! function() {
  try {
    var e = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {},
      n = (new Error).stack;
    n && (e._sentryDebugIds = e._sentryDebugIds || {}, e._sentryDebugIds[n] = "68c3aa7a-a503-5fe3-b256-4537170f3e7b")
  } catch (e) {}
}();
var r6 = Object.defineProperty;
var o6 = (t, e, n) => e in t ? r6(t, e, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: n
}) : t[e] = n;
var P = (t, e, n) => (o6(t, typeof e != "symbol" ? e + "" : e, n), n);

function J$(t, e) {
  for (var n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in t)) {
          const s = Object.getOwnPropertyDescriptor(r, o);
          s && Object.defineProperty(t, o, s.get ? s : {
            enumerable: !0,
            get: () => r[o]
          })
        }
    }
  }
  return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
    value: "Module"
  }))
}(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
  new MutationObserver(o => {
    for (const s of o)
      if (s.type === "childList")
        for (const i of s.addedNodes) i.tagName === "LINK" && i.rel === "modulepreload" && r(i)
  }).observe(document, {
    childList: !0,
    subtree: !0
  });

  function n(o) {
    const s = {};
    return o.integrity && (s.integrity = o.integrity), o.referrerPolicy && (s.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? s.credentials = "include" : o.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
  }

  function r(o) {
    if (o.ep) return;
    o.ep = !0;
    const s = n(o);
    fetch(o.href, s)
  }
})();
const s6 = "modulepreload",
  i6 = function(t) {
    return "/" + t
  },
  ok = {},
  Ie = function(e, n, r) {
    if (!n || n.length === 0) return e();
    const o = document.getElementsByTagName("link");
    return Promise.all(n.map(s => {
      if (s = i6(s), s in ok) return;
      ok[s] = !0;
      const i = s.endsWith(".css"),
        a = i ? '[rel="stylesheet"]' : "";
      if (!!r)
        for (let u = o.length - 1; u >= 0; u--) {
          const d = o[u];
          if (d.href === s && (!i || d.rel === "stylesheet")) return
        } else if (document.querySelector(`link[href="${s}"]${a}`)) return;
      const l = document.createElement("link");
      if (l.rel = i ? "stylesheet" : s6, i || (l.as = "script", l.crossOrigin = ""), l.href = s, document.head.appendChild(l), i) return new Promise((u, d) => {
        l.addEventListener("load", u), l.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${s}`)))
      })
    })).then(() => e()).catch(s => {
      const i = new Event("vite:preloadError", {
        cancelable: !0
      });
      if (i.payload = s, window.dispatchEvent(i), !i.defaultPrevented) throw s
    })
  };
var hn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function co(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function a6(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
    };
    n.prototype = e.prototype
  } else n = {};
  return Object.defineProperty(n, "__esModule", {
    value: !0
  }), Object.keys(t).forEach(function(r) {
    var o = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, o.get ? o : {
      enumerable: !0,
      get: function() {
        return t[r]
      }
    })
  }), n
}
var Q$ = {
    exports: {}
  },
  dy = {},
  eI = {
    exports: {}
  },
  Qe = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uh = Symbol.for("react.element"),
  c6 = Symbol.for("react.portal"),
  l6 = Symbol.for("react.fragment"),
  u6 = Symbol.for("react.strict_mode"),
  d6 = Symbol.for("react.profiler"),
  f6 = Symbol.for("react.provider"),
  h6 = Symbol.for("react.context"),
  p6 = Symbol.for("react.forward_ref"),
  g6 = Symbol.for("react.suspense"),
  m6 = Symbol.for("react.memo"),
  y6 = Symbol.for("react.lazy"),
  sk = Symbol.iterator;

function v6(t) {
  return t === null || typeof t != "object" ? null : (t = sk && t[sk] || t["@@iterator"], typeof t == "function" ? t : null)
}
var tI = {
    isMounted: function() {
      return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
  },
  nI = Object.assign,
  rI = {};

function du(t, e, n) {
  this.props = t, this.context = e, this.refs = rI, this.updater = n || tI
}
du.prototype.isReactComponent = {};
du.prototype.setState = function(t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, t, e, "setState")
};
du.prototype.forceUpdate = function(t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate")
};

function oI() {}
oI.prototype = du.prototype;

function K_(t, e, n) {
  this.props = t, this.context = e, this.refs = rI, this.updater = n || tI
}
var G_ = K_.prototype = new oI;
G_.constructor = K_;
nI(G_, du.prototype);
G_.isPureReactComponent = !0;
var ik = Array.isArray,
  sI = Object.prototype.hasOwnProperty,
  Y_ = {
    current: null
  },
  iI = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function aI(t, e, n) {
  var r, o = {},
    s = null,
    i = null;
  if (e != null)
    for (r in e.ref !== void 0 && (i = e.ref), e.key !== void 0 && (s = "" + e.key), e) sI.call(e, r) && !iI.hasOwnProperty(r) && (o[r] = e[r]);
  var a = arguments.length - 2;
  if (a === 1) o.children = n;
  else if (1 < a) {
    for (var c = Array(a), l = 0; l < a; l++) c[l] = arguments[l + 2];
    o.children = c
  }
  if (t && t.defaultProps)
    for (r in a = t.defaultProps, a) o[r] === void 0 && (o[r] = a[r]);
  return {
    $$typeof: uh,
    type: t,
    key: s,
    ref: i,
    props: o,
    _owner: Y_.current
  }
}

function b6(t, e) {
  return {
    $$typeof: uh,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner
  }
}

function q_(t) {
  return typeof t == "object" && t !== null && t.$$typeof === uh
}

function w6(t) {
  var e = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + t.replace(/[=:]/g, function(n) {
    return e[n]
  })
}
var ak = /\/+/g;

function qv(t, e) {
  return typeof t == "object" && t !== null && t.key != null ? w6("" + t.key) : e.toString(36)
}

function hg(t, e, n, r, o) {
  var s = typeof t;
  (s === "undefined" || s === "boolean") && (t = null);
  var i = !1;
  if (t === null) i = !0;
  else switch (s) {
    case "string":
    case "number":
      i = !0;
      break;
    case "object":
      switch (t.$$typeof) {
        case uh:
        case c6:
          i = !0
      }
  }
  if (i) return i = t, o = o(i), t = r === "" ? "." + qv(i, 0) : r, ik(o) ? (n = "", t != null && (n = t.replace(ak, "$&/") + "/"), hg(o, e, n, "", function(l) {
    return l
  })) : o != null && (q_(o) && (o = b6(o, n + (!o.key || i && i.key === o.key ? "" : ("" + o.key).replace(ak, "$&/") + "/") + t)), e.push(o)), 1;
  if (i = 0, r = r === "" ? "." : r + ":", ik(t))
    for (var a = 0; a < t.length; a++) {
      s = t[a];
      var c = r + qv(s, a);
      i += hg(s, e, n, c, o)
    } else if (c = v6(t), typeof c == "function")
      for (t = c.call(t), a = 0; !(s = t.next()).done;) s = s.value, c = r + qv(s, a++), i += hg(s, e, n, c, o);
    else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
  return i
}

function sp(t, e, n) {
  if (t == null) return t;
  var r = [],
    o = 0;
  return hg(t, r, "", "", function(s) {
    return e.call(n, s, o++)
  }), r
}

function S6(t) {
  if (t._status === -1) {
    var e = t._result;
    e = e(), e.then(function(n) {
      (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n)
    }, function(n) {
      (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n)
    }), t._status === -1 && (t._status = 0, t._result = e)
  }
  if (t._status === 1) return t._result.default;
  throw t._result
}
var ir = {
    current: null
  },
  pg = {
    transition: null
  },
  _6 = {
    ReactCurrentDispatcher: ir,
    ReactCurrentBatchConfig: pg,
    ReactCurrentOwner: Y_
  };
Qe.Children = {
  map: sp,
  forEach: function(t, e, n) {
    sp(t, function() {
      e.apply(this, arguments)
    }, n)
  },
  count: function(t) {
    var e = 0;
    return sp(t, function() {
      e++
    }), e
  },
  toArray: function(t) {
    return sp(t, function(e) {
      return e
    }) || []
  },
  only: function(t) {
    if (!q_(t)) throw Error("React.Children.only expected to receive a single React element child.");
    return t
  }
};
Qe.Component = du;
Qe.Fragment = l6;
Qe.Profiler = d6;
Qe.PureComponent = K_;
Qe.StrictMode = u6;
Qe.Suspense = g6;
Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _6;
Qe.cloneElement = function(t, e, n) {
  if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
  var r = nI({}, t.props),
    o = t.key,
    s = t.ref,
    i = t._owner;
  if (e != null) {
    if (e.ref !== void 0 && (s = e.ref, i = Y_.current), e.key !== void 0 && (o = "" + e.key), t.type && t.type.defaultProps) var a = t.type.defaultProps;
    for (c in e) sI.call(e, c) && !iI.hasOwnProperty(c) && (r[c] = e[c] === void 0 && a !== void 0 ? a[c] : e[c])
  }
  var c = arguments.length - 2;
  if (c === 1) r.children = n;
  else if (1 < c) {
    a = Array(c);
    for (var l = 0; l < c; l++) a[l] = arguments[l + 2];
    r.children = a
  }
  return {
    $$typeof: uh,
    type: t.type,
    key: o,
    ref: s,
    props: r,
    _owner: i
  }
};
Qe.createContext = function(t) {
  return t = {
    $$typeof: h6,
    _currentValue: t,
    _currentValue2: t,
    _threadCount: 0,
    Provider: null,
    Consumer: null,
    _defaultValue: null,
    _globalName: null
  }, t.Provider = {
    $$typeof: f6,
    _context: t
  }, t.Consumer = t
};
Qe.createElement = aI;
Qe.createFactory = function(t) {
  var e = aI.bind(null, t);
  return e.type = t, e
};
Qe.createRef = function() {
  return {
    current: null
  }
};
Qe.forwardRef = function(t) {
  return {
    $$typeof: p6,
    render: t
  }
};
Qe.isValidElement = q_;
Qe.lazy = function(t) {
  return {
    $$typeof: y6,
    _payload: {
      _status: -1,
      _result: t
    },
    _init: S6
  }
};
Qe.memo = function(t, e) {
  return {
    $$typeof: m6,
    type: t,
    compare: e === void 0 ? null : e
  }
};
Qe.startTransition = function(t) {
  var e = pg.transition;
  pg.transition = {};
  try {
    t()
  } finally {
    pg.transition = e
  }
};
Qe.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.")
};
Qe.useCallback = function(t, e) {
  return ir.current.useCallback(t, e)
};
Qe.useContext = function(t) {
  return ir.current.useContext(t)
};
Qe.useDebugValue = function() {};
Qe.useDeferredValue = function(t) {
  return ir.current.useDeferredValue(t)
};
Qe.useEffect = function(t, e) {
  return ir.current.useEffect(t, e)
};
Qe.useId = function() {
  return ir.current.useId()
};
Qe.useImperativeHandle = function(t, e, n) {
  return ir.current.useImperativeHandle(t, e, n)
};
Qe.useInsertionEffect = function(t, e) {
  return ir.current.useInsertionEffect(t, e)
};
Qe.useLayoutEffect = function(t, e) {
  return ir.current.useLayoutEffect(t, e)
};
Qe.useMemo = function(t, e) {
  return ir.current.useMemo(t, e)
};
Qe.useReducer = function(t, e, n) {
  return ir.current.useReducer(t, e, n)
};
Qe.useRef = function(t) {
  return ir.current.useRef(t)
};
Qe.useState = function(t) {
  return ir.current.useState(t)
};
Qe.useSyncExternalStore = function(t, e, n) {
  return ir.current.useSyncExternalStore(t, e, n)
};
Qe.useTransition = function() {
  return ir.current.useTransition()
};
Qe.version = "18.2.0";
eI.exports = Qe;
var g = eI.exports;
const se = co(g),
  cI = J$({
    __proto__: null,
    default: se
  }, [g]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var x6 = g,
  E6 = Symbol.for("react.element"),
  k6 = Symbol.for("react.fragment"),
  C6 = Object.prototype.hasOwnProperty,
  P6 = x6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  T6 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

function lI(t, e, n) {
  var r, o = {},
    s = null,
    i = null;
  n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (i = e.ref);
  for (r in e) C6.call(e, r) && !T6.hasOwnProperty(r) && (o[r] = e[r]);
  if (t && t.defaultProps)
    for (r in e = t.defaultProps, e) o[r] === void 0 && (o[r] = e[r]);
  return {
    $$typeof: E6,
    type: t,
    key: s,
    ref: i,
    props: o,
    _owner: P6.current
  }
}
dy.Fragment = k6;
dy.jsx = lI;
dy.jsxs = lI;
Q$.exports = dy;
var y = Q$.exports;
const uI = Object.prototype.toString;

function dI(t) {
  switch (uI.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Ba(t, Error)
  }
}

function fu(t, e) {
  return uI.call(t) === `[object ${e}]`
}

function X_(t) {
  return fu(t, "ErrorEvent")
}

function ck(t) {
  return fu(t, "DOMError")
}

function $6(t) {
  return fu(t, "DOMException")
}

function Fa(t) {
  return fu(t, "String")
}

function fI(t) {
  return t === null || typeof t != "object" && typeof t != "function"
}

function Vl(t) {
  return fu(t, "Object")
}

function fy(t) {
  return typeof Event < "u" && Ba(t, Event)
}

function I6(t) {
  return typeof Element < "u" && Ba(t, Element)
}

function O6(t) {
  return fu(t, "RegExp")
}

function Z_(t) {
  return !!(t && t.then && typeof t.then == "function")
}

function R6(t) {
  return Vl(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}

function A6(t) {
  return typeof t == "number" && t !== t
}

function Ba(t, e) {
  try {
    return t instanceof e
  } catch {
    return !1
  }
}

function hI(t) {
  return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue))
}

function Cl(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0,e)}...`
}

function lk(t, e) {
  if (!Array.isArray(t)) return "";
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    try {
      hI(o) ? n.push("[VueViewModel]") : n.push(String(o))
    } catch {
      n.push("[value cannot be serialized]")
    }
  }
  return n.join(e)
}

function M6(t, e, n = !1) {
  return Fa(t) ? O6(e) ? e.test(t) : Fa(e) ? n ? t === e : t.includes(e) : !1 : !1
}

function hy(t, e = [], n = !1) {
  return e.some(r => M6(t, r, n))
}

function j6(t, e, n = 250, r, o, s, i) {
  if (!s.exception || !s.exception.values || !i || !Ba(i.originalException, Error)) return;
  const a = s.exception.values.length > 0 ? s.exception.values[s.exception.values.length - 1] : void 0;
  a && (s.exception.values = D6(cw(t, e, o, i.originalException, r, s.exception.values, a, 0), n))
}

function cw(t, e, n, r, o, s, i, a) {
  if (s.length >= n + 1) return s;
  let c = [...s];
  if (Ba(r[o], Error)) {
    uk(i, a);
    const l = t(e, r[o]),
      u = c.length;
    dk(l, o, u, a), c = cw(t, e, n, r[o], o, [l, ...c], l, u)
  }
  return Array.isArray(r.errors) && r.errors.forEach((l, u) => {
    if (Ba(l, Error)) {
      uk(i, a);
      const d = t(e, l),
        f = c.length;
      dk(d, `errors[${u}]`, f, a), c = cw(t, e, n, l, o, [d, ...c], d, f)
    }
  }), c
}

function uk(t, e) {
  t.mechanism = t.mechanism || {
    type: "generic",
    handled: !0
  }, t.mechanism = {
    ...t.mechanism,
    is_exception_group: !0,
    exception_id: e
  }
}

function dk(t, e, n, r) {
  t.mechanism = t.mechanism || {
    type: "generic",
    handled: !0
  }, t.mechanism = {
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  }
}

function D6(t, e) {
  return t.map(n => (n.value && (n.value = Cl(n.value, e)), n))
}

function ip(t) {
  return t && t.Math == Math ? t : void 0
}
const pn = typeof globalThis == "object" && ip(globalThis) || typeof window == "object" && ip(window) || typeof self == "object" && ip(self) || typeof global == "object" && ip(global) || function() {
  return this
}() || {};

function dh() {
  return pn
}

function pI(t, e, n) {
  const r = n || pn,
    o = r.__SENTRY__ = r.__SENTRY__ || {};
  return o[t] || (o[t] = e())
}
const N6 = dh(),
  L6 = 80;

function lw(t, e = {}) {
  if (!t) return "<unknown>";
  try {
    let n = t;
    const r = 5,
      o = [];
    let s = 0,
      i = 0;
    const a = " > ",
      c = a.length;
    let l;
    const u = Array.isArray(e) ? e : e.keyAttrs,
      d = !Array.isArray(e) && e.maxStringLength || L6;
    for (; n && s++ < r && (l = F6(n, u), !(l === "html" || s > 1 && i + o.length * c + l.length >= d));) o.push(l), i += l.length, n = n.parentNode;
    return o.reverse().join(a)
  } catch {
    return "<unknown>"
  }
}

function F6(t, e) {
  const n = t,
    r = [];
  let o, s, i, a, c;
  if (!n || !n.tagName) return "";
  r.push(n.tagName.toLowerCase());
  const l = e && e.length ? e.filter(d => n.getAttribute(d)).map(d => [d, n.getAttribute(d)]) : null;
  if (l && l.length) l.forEach(d => {
    r.push(`[${d[0]}="${d[1]}"]`)
  });
  else if (n.id && r.push(`#${n.id}`), o = n.className, o && Fa(o))
    for (s = o.split(/\s+/), c = 0; c < s.length; c++) r.push(`.${s[c]}`);
  const u = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < u.length; c++) i = u[c], a = n.getAttribute(i), a && r.push(`[${i}="${a}"]`);
  return r.join("")
}

function B6() {
  try {
    return N6.document.location.href
  } catch {
    return ""
  }
}
const U6 = "Sentry Logger ",
  uw = ["debug", "info", "warn", "error", "log", "assert", "trace"],
  Vg = {};

function gI(t) {
  if (!("console" in pn)) return t();
  const e = pn.console,
    n = {},
    r = Object.keys(Vg);
  r.forEach(o => {
    const s = Vg[o];
    n[o] = e[o], e[o] = s
  });
  try {
    return t()
  } finally {
    r.forEach(o => {
      e[o] = n[o]
    })
  }
}

function z6() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0
    },
    disable: () => {
      t = !1
    },
    isEnabled: () => t
  };
  return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? uw.forEach(n => {
    e[n] = (...r) => {
      t && gI(() => {
        pn.console[n](`${U6}[${n}]:`, ...r)
      })
    }
  }) : uw.forEach(n => {
    e[n] = () => {}
  }), e
}
const Ve = z6(),
  H6 = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;

function V6(t) {
  return t === "http" || t === "https"
}

function py(t, e = !1) {
  const {
    host: n,
    path: r,
    pass: o,
    port: s,
    projectId: i,
    protocol: a,
    publicKey: c
  } = t;
  return `${a}://${c}${e&&o?`:${o}`:""}@${n}${s?`:${s}`:""}/${r&&`${r}/`}${i}`
}

function W6(t) {
  const e = H6.exec(t);
  if (!e) {
    console.error(`Invalid Sentry Dsn: ${t}`);
    return
  }
  const [n, r, o = "", s, i = "", a] = e.slice(1);
  let c = "",
    l = a;
  const u = l.split("/");
  if (u.length > 1 && (c = u.slice(0, -1).join("/"), l = u.pop()), l) {
    const d = l.match(/^\d+/);
    d && (l = d[0])
  }
  return mI({
    host: s,
    pass: o,
    path: c,
    projectId: l,
    port: i,
    protocol: n,
    publicKey: r
  })
}

function mI(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId
  }
}

function K6(t) {
  if (!(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__)) return !0;
  const {
    port: e,
    projectId: n,
    protocol: r
  } = t;
  return ["protocol", "publicKey", "host", "projectId"].find(i => t[i] ? !1 : (Ve.error(`Invalid Sentry Dsn: ${i} missing`), !0)) ? !1 : n.match(/^\d+$/) ? V6(r) ? e && isNaN(parseInt(e, 10)) ? (Ve.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1) : !0 : (Ve.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (Ve.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1)
}

function G6(t) {
  const e = typeof t == "string" ? W6(t) : mI(t);
  if (!(!e || !K6(e))) return e
}
class rs extends Error {
  constructor(e, n = "warn") {
    super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n
  }
}

function Tn(t, e, n) {
  if (!(e in t)) return;
  const r = t[e],
    o = n(r);
  typeof o == "function" && yI(o, r), t[e] = o
}

function rf(t, e, n) {
  try {
    Object.defineProperty(t, e, {
      value: n,
      writable: !0,
      configurable: !0
    })
  } catch {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(`Failed to add non-enumerable property "${e}" to object`, t)
  }
}

function yI(t, e) {
  try {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, rf(t, "__sentry_original__", e)
  } catch {}
}

function J_(t) {
  return t.__sentry_original__
}

function Y6(t) {
  return Object.keys(t).map(e => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&")
}

function vI(t) {
  if (dI(t)) return {
    message: t.message,
    name: t.name,
    stack: t.stack,
    ...hk(t)
  };
  if (fy(t)) {
    const e = {
      type: t.type,
      target: fk(t.target),
      currentTarget: fk(t.currentTarget),
      ...hk(t)
    };
    return typeof CustomEvent < "u" && Ba(t, CustomEvent) && (e.detail = t.detail), e
  } else return t
}

function fk(t) {
  try {
    return I6(t) ? lw(t) : Object.prototype.toString.call(t)
  } catch {
    return "<unknown>"
  }
}

function hk(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e
  } else return {}
}

function q6(t, e = 40) {
  const n = Object.keys(vI(t));
  if (n.sort(), !n.length) return "[object has no keys]";
  if (n[0].length >= e) return Cl(n[0], e);
  for (let r = n.length; r > 0; r--) {
    const o = n.slice(0, r).join(", ");
    if (!(o.length > e)) return r === n.length ? o : Cl(o, e)
  }
  return ""
}

function gy(t) {
  return dw(t, new Map)
}

function dw(t, e) {
  if (Vl(t)) {
    const n = e.get(t);
    if (n !== void 0) return n;
    const r = {};
    e.set(t, r);
    for (const o of Object.keys(t)) typeof t[o] < "u" && (r[o] = dw(t[o], e));
    return r
  }
  if (Array.isArray(t)) {
    const n = e.get(t);
    if (n !== void 0) return n;
    const r = [];
    return e.set(t, r), t.forEach(o => {
      r.push(dw(o, e))
    }), r
  }
  return t
}

function Ms() {
  const t = pn,
    e = t.crypto || t.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (e && e.randomUUID) return e.randomUUID().replace(/-/g, "");
    e && e.getRandomValues && (n = () => e.getRandomValues(new Uint8Array(1))[0])
  } catch {}
  return ([1e7] + 1e3 + 4e3 + 8e3 + 1e11).replace(/[018]/g, r => (r ^ (n() & 15) >> r / 4).toString(16))
}

function bI(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0
}

function bi(t) {
  const {
    message: e,
    event_id: n
  } = t;
  if (e) return e;
  const r = bI(t);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>"
}

function fw(t, e, n) {
  const r = t.exception = t.exception || {},
    o = r.values = r.values || [],
    s = o[0] = o[0] || {};
  s.value || (s.value = e || ""), s.type || (s.type = n || "Error")
}

function of(t, e) {
  const n = bI(t);
  if (!n) return;
  const r = {
      type: "generic",
      handled: !0
    },
    o = n.mechanism;
  if (n.mechanism = {
      ...r,
      ...o,
      ...e
    }, e && "data" in e) {
    const s = {
      ...o && o.data,
      ...e.data
    };
    n.mechanism.data = s
  }
}

function pk(t) {
  if (t && t.__sentry_captured__) return !0;
  try {
    rf(t, "__sentry_captured__", !0)
  } catch {}
  return !1
}

function wI(t) {
  return Array.isArray(t) ? t : [t]
}
const SI = 50,
  gk = /\(error: (.*)\)/,
  mk = /captureMessage|captureException/;

function _I(...t) {
  const e = t.sort((n, r) => n[0] - r[0]).map(n => n[1]);
  return (n, r = 0) => {
    const o = [],
      s = n.split(`
`);
    for (let i = r; i < s.length; i++) {
      const a = s[i];
      if (a.length > 1024) continue;
      const c = gk.test(a) ? a.replace(gk, "$1") : a;
      if (!c.match(/\S*Error: /)) {
        for (const l of e) {
          const u = l(c);
          if (u) {
            o.push(u);
            break
          }
        }
        if (o.length >= SI) break
      }
    }
    return Z6(o)
  }
}

function X6(t) {
  return Array.isArray(t) ? _I(...t) : t
}

function Z6(t) {
  if (!t.length) return [];
  const e = Array.from(t);
  return /sentryWrapped/.test(e[e.length - 1].function || "") && e.pop(), e.reverse(), mk.test(e[e.length - 1].function || "") && (e.pop(), mk.test(e[e.length - 1].function || "") && e.pop()), e.slice(0, SI).map(n => ({
    ...n,
    filename: n.filename || e[e.length - 1].filename,
    function: n.function || "?"
  }))
}
const Xv = "<anonymous>";

function Bi(t) {
  try {
    return !t || typeof t != "function" ? Xv : t.name || Xv
  } catch {
    return Xv
  }
}
const hw = dh();

function xI() {
  if (!("fetch" in hw)) return !1;
  try {
    return new Headers, new Request("http://www.example.com"), new Response, !0
  } catch {
    return !1
  }
}

function pw(t) {
  return t && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString())
}

function J6() {
  if (!xI()) return !1;
  if (pw(hw.fetch)) return !0;
  let t = !1;
  const e = hw.document;
  if (e && typeof e.createElement == "function") try {
    const n = e.createElement("iframe");
    n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = pw(n.contentWindow.fetch)), e.head.removeChild(n)
  } catch (n) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
  }
  return t
}
const ap = dh();

function Q6() {
  const t = ap.chrome,
    e = t && t.app && t.app.runtime,
    n = "history" in ap && !!ap.history.pushState && !!ap.history.replaceState;
  return !e && n
}
const fn = dh(),
  _d = "__sentry_xhr_v2__",
  jd = {},
  yk = {};

function eL(t) {
  if (!yk[t]) switch (yk[t] = !0, t) {
    case "console":
      tL();
      break;
    case "dom":
      uL();
      break;
    case "xhr":
      oL();
      break;
    case "fetch":
      nL();
      break;
    case "history":
      sL();
      break;
    case "error":
      dL();
      break;
    case "unhandledrejection":
      fL();
      break;
    default:
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("unknown instrumentation type:", t);
      return
  }
}

function wi(t, e) {
  jd[t] = jd[t] || [], jd[t].push(e), eL(t)
}

function Io(t, e) {
  if (!(!t || !jd[t]))
    for (const n of jd[t] || []) try {
      n(e)
    } catch (r) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.error(`Error while triggering instrumentation handler.
Type: ${t}
Name: ${Bi(n)}
Error:`, r)
    }
}

function tL() {
  "console" in pn && uw.forEach(function(t) {
    t in pn.console && Tn(pn.console, t, function(e) {
      return Vg[t] = e,
        function(...n) {
          Io("console", {
            args: n,
            level: t
          });
          const r = Vg[t];
          r && r.apply(pn.console, n)
        }
    })
  })
}

function nL() {
  J6() && Tn(pn, "fetch", function(t) {
    return function(...e) {
      const {
        method: n,
        url: r
      } = rL(e), o = {
        args: e,
        fetchData: {
          method: n,
          url: r
        },
        startTimestamp: Date.now()
      };
      return Io("fetch", {
        ...o
      }), t.apply(pn, e).then(s => (Io("fetch", {
        ...o,
        endTimestamp: Date.now(),
        response: s
      }), s), s => {
        throw Io("fetch", {
          ...o,
          endTimestamp: Date.now(),
          error: s
        }), s
      })
    }
  })
}

function gw(t, e) {
  return !!t && typeof t == "object" && !!t[e]
}

function vk(t) {
  return typeof t == "string" ? t : t ? gw(t, "url") ? t.url : t.toString ? t.toString() : "" : ""
}

function rL(t) {
  if (t.length === 0) return {
    method: "GET",
    url: ""
  };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: vk(n),
      method: gw(r, "method") ? String(r.method).toUpperCase() : "GET"
    }
  }
  const e = t[0];
  return {
    url: vk(e),
    method: gw(e, "method") ? String(e.method).toUpperCase() : "GET"
  }
}

function oL() {
  if (!fn.XMLHttpRequest) return;
  const t = XMLHttpRequest.prototype;
  Tn(t, "open", function(e) {
    return function(...n) {
      const r = Date.now(),
        o = n[1],
        s = this[_d] = {
          method: Fa(n[0]) ? n[0].toUpperCase() : n[0],
          url: n[1],
          request_headers: {}
        };
      Fa(o) && s.method === "POST" && o.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const i = () => {
        const a = this[_d];
        if (a && this.readyState === 4) {
          try {
            a.status_code = this.status
          } catch {}
          Io("xhr", {
            args: n,
            endTimestamp: Date.now(),
            startTimestamp: r,
            xhr: this
          })
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Tn(this, "onreadystatechange", function(a) {
        return function(...c) {
          return i(), a.apply(this, c)
        }
      }) : this.addEventListener("readystatechange", i), Tn(this, "setRequestHeader", function(a) {
        return function(...c) {
          const [l, u] = c, d = this[_d];
          return d && (d.request_headers[l.toLowerCase()] = u), a.apply(this, c)
        }
      }), e.apply(this, n)
    }
  }), Tn(t, "send", function(e) {
    return function(...n) {
      const r = this[_d];
      return r && n[0] !== void 0 && (r.body = n[0]), Io("xhr", {
        args: n,
        startTimestamp: Date.now(),
        xhr: this
      }), e.apply(this, n)
    }
  })
}
let cp;

function sL() {
  if (!Q6()) return;
  const t = fn.onpopstate;
  fn.onpopstate = function(...n) {
    const r = fn.location.href,
      o = cp;
    if (cp = r, Io("history", {
        from: o,
        to: r
      }), t) try {
      return t.apply(this, n)
    } catch {}
  };

  function e(n) {
    return function(...r) {
      const o = r.length > 2 ? r[2] : void 0;
      if (o) {
        const s = cp,
          i = String(o);
        cp = i, Io("history", {
          from: s,
          to: i
        })
      }
      return n.apply(this, r)
    }
  }
  Tn(fn.history, "pushState", e), Tn(fn.history, "replaceState", e)
}
const iL = 1e3;
let bk, mw, yw;

function aL(t) {
  if (t.type !== mw) return !1;
  try {
    if (!t.target || t.target._sentryId !== yw) return !1
  } catch {}
  return !0
}

function cL(t, e) {
  return t !== "keypress" ? !1 : !e || !e.tagName ? !0 : !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable)
}

function lL(t) {
  try {
    return t.target
  } catch {
    return null
  }
}

function wk(t, e = !1) {
  return n => {
    if (!n || n._sentryCaptured) return;
    const r = lL(n);
    if (cL(n.type, r)) return;
    rf(n, "_sentryCaptured", !0), r && !r._sentryId && rf(r, "_sentryId", Ms());
    const o = n.type === "keypress" ? "input" : n.type;
    aL(n) || (t({
      event: n,
      name: o,
      global: e
    }), mw = n.type, yw = r ? r._sentryId : void 0), clearTimeout(bk), bk = fn.setTimeout(() => {
      yw = void 0, mw = void 0
    }, iL)
  }
}

function uL() {
  if (!fn.document) return;
  const t = Io.bind(null, "dom"),
    e = wk(t, !0);
  fn.document.addEventListener("click", e, !1), fn.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach(n => {
    const r = fn[n] && fn[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Tn(r, "addEventListener", function(o) {
      return function(s, i, a) {
        if (s === "click" || s == "keypress") try {
          const c = this,
            l = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {},
            u = l[s] = l[s] || {
              refCount: 0
            };
          if (!u.handler) {
            const d = wk(t);
            u.handler = d, o.call(this, s, d, a)
          }
          u.refCount++
        } catch {}
        return o.call(this, s, i, a)
      }
    }), Tn(r, "removeEventListener", function(o) {
      return function(s, i, a) {
        if (s === "click" || s == "keypress") try {
          const c = this,
            l = c.__sentry_instrumentation_handlers__ || {},
            u = l[s];
          u && (u.refCount--, u.refCount <= 0 && (o.call(this, s, u.handler, a), u.handler = void 0, delete l[s]), Object.keys(l).length === 0 && delete c.__sentry_instrumentation_handlers__)
        } catch {}
        return o.call(this, s, i, a)
      }
    }))
  })
}
let lp = null;

function dL() {
  lp = fn.onerror, fn.onerror = function(t, e, n, r, o) {
    return Io("error", {
      column: r,
      error: o,
      line: n,
      msg: t,
      url: e
    }), lp && !lp.__SENTRY_LOADER__ ? lp.apply(this, arguments) : !1
  }, fn.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let up = null;

function fL() {
  up = fn.onunhandledrejection, fn.onunhandledrejection = function(t) {
    return Io("unhandledrejection", t), up && !up.__SENTRY_LOADER__ ? up.apply(this, arguments) : !0
  }, fn.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}

function hL() {
  return typeof __SENTRY_BROWSER_BUNDLE__ < "u" && !!__SENTRY_BROWSER_BUNDLE__
}

function pL() {
  return "npm"
}

function gL() {
  return !hL() && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]"
}

function mL(t, e) {
  return t.require(e)
}

function yL() {
  const t = typeof WeakSet == "function",
    e = t ? new WeakSet : [];

  function n(o) {
    if (t) return e.has(o) ? !0 : (e.add(o), !1);
    for (let s = 0; s < e.length; s++)
      if (e[s] === o) return !0;
    return e.push(o), !1
  }

  function r(o) {
    if (t) e.delete(o);
    else
      for (let s = 0; s < e.length; s++)
        if (e[s] === o) {
          e.splice(s, 1);
          break
        }
  }
  return [n, r]
}

function pi(t, e = 100, n = 1 / 0) {
  try {
    return vw("", t, e, n)
  } catch (r) {
    return {
      ERROR: `**non-serializable** (${r})`
    }
  }
}

function EI(t, e = 3, n = 100 * 1024) {
  const r = pi(t, e);
  return SL(r) > n ? EI(t, e - 1, n) : r
}

function vw(t, e, n = 1 / 0, r = 1 / 0, o = yL()) {
  const [s, i] = o;
  if (e == null || ["number", "boolean", "string"].includes(typeof e) && !A6(e)) return e;
  const a = vL(t, e);
  if (!a.startsWith("[object ")) return a;
  if (e.__sentry_skip_normalization__) return e;
  const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
  if (c === 0) return a.replace("object ", "");
  if (s(e)) return "[Circular ~]";
  const l = e;
  if (l && typeof l.toJSON == "function") try {
    const h = l.toJSON();
    return vw("", h, c - 1, r, o)
  } catch {}
  const u = Array.isArray(e) ? [] : {};
  let d = 0;
  const f = vI(e);
  for (const h in f) {
    if (!Object.prototype.hasOwnProperty.call(f, h)) continue;
    if (d >= r) {
      u[h] = "[MaxProperties ~]";
      break
    }
    const m = f[h];
    u[h] = vw(h, m, c - 1, r, o), d++
  }
  return i(e), u
}

function vL(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events) return "[Domain]";
    if (t === "domainEmitter") return "[DomainEmitter]";
    if (typeof global < "u" && e === global) return "[Global]";
    if (typeof window < "u" && e === window) return "[Window]";
    if (typeof document < "u" && e === document) return "[Document]";
    if (hI(e)) return "[VueViewModel]";
    if (R6(e)) return "[SyntheticEvent]";
    if (typeof e == "number" && e !== e) return "[NaN]";
    if (typeof e == "function") return `[Function: ${Bi(e)}]`;
    if (typeof e == "symbol") return `[${String(e)}]`;
    if (typeof e == "bigint") return `[BigInt: ${String(e)}]`;
    const n = bL(e);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`
  } catch (n) {
    return `**non-serializable** (${n})`
  }
}

function bL(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype"
}

function wL(t) {
  return ~-encodeURI(t).split(/%..|./).length
}

function SL(t) {
  return wL(JSON.stringify(t))
}
var Ps;
(function(t) {
  t[t.PENDING = 0] = "PENDING";
  const n = 1;
  t[t.RESOLVED = n] = "RESOLVED";
  const r = 2;
  t[t.REJECTED = r] = "REJECTED"
})(Ps || (Ps = {}));

function Ua(t) {
  return new Mr(e => {
    e(t)
  })
}

function Q_(t) {
  return new Mr((e, n) => {
    n(t)
  })
}
class Mr {
  constructor(e) {
    Mr.prototype.__init.call(this), Mr.prototype.__init2.call(this), Mr.prototype.__init3.call(this), Mr.prototype.__init4.call(this), this._state = Ps.PENDING, this._handlers = [];
    try {
      e(this._resolve, this._reject)
    } catch (n) {
      this._reject(n)
    }
  }
  then(e, n) {
    return new Mr((r, o) => {
      this._handlers.push([!1, s => {
        if (!e) r(s);
        else try {
          r(e(s))
        } catch (i) {
          o(i)
        }
      }, s => {
        if (!n) o(s);
        else try {
          r(n(s))
        } catch (i) {
          o(i)
        }
      }]), this._executeHandlers()
    })
  } catch (e) {
    return this.then(n => n, e)
  } finally(e) {
    return new Mr((n, r) => {
      let o, s;
      return this.then(i => {
        s = !1, o = i, e && e()
      }, i => {
        s = !0, o = i, e && e()
      }).then(() => {
        if (s) {
          r(o);
          return
        }
        n(o)
      })
    })
  }
  __init() {
    this._resolve = e => {
      this._setResult(Ps.RESOLVED, e)
    }
  }
  __init2() {
    this._reject = e => {
      this._setResult(Ps.REJECTED, e)
    }
  }
  __init3() {
    this._setResult = (e, n) => {
      if (this._state === Ps.PENDING) {
        if (Z_(n)) {
          n.then(this._resolve, this._reject);
          return
        }
        this._state = e, this._value = n, this._executeHandlers()
      }
    }
  }
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Ps.PENDING) return;
      const e = this._handlers.slice();
      this._handlers = [], e.forEach(n => {
        n[0] || (this._state === Ps.RESOLVED && n[1](this._value), this._state === Ps.REJECTED && n[2](this._value), n[0] = !0)
      })
    }
  }
}

function _L(t) {
  const e = [];

  function n() {
    return t === void 0 || e.length < t
  }

  function r(i) {
    return e.splice(e.indexOf(i), 1)[0]
  }

  function o(i) {
    if (!n()) return Q_(new rs("Not adding Promise because buffer limit was reached."));
    const a = i();
    return e.indexOf(a) === -1 && e.push(a), a.then(() => r(a)).then(null, () => r(a).then(null, () => {})), a
  }

  function s(i) {
    return new Mr((a, c) => {
      let l = e.length;
      if (!l) return a(!0);
      const u = setTimeout(() => {
        i && i > 0 && a(!1)
      }, i);
      e.forEach(d => {
        Ua(d).then(() => {
          --l || (clearTimeout(u), a(!0))
        }, c)
      })
    })
  }
  return {
    $: e,
    add: o,
    drain: s
  }
}

function Zv(t) {
  if (!t) return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e) return {};
  const n = e[6] || "",
    r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
  }
}
const xL = ["fatal", "error", "warning", "log", "info", "debug"];

function EL(t) {
  return t === "warn" ? "warning" : xL.includes(t) ? t : "log"
}
const kI = dh(),
  bw = {
    nowSeconds: () => Date.now() / 1e3
  };

function kL() {
  const {
    performance: t
  } = kI;
  if (!t || !t.now) return;
  const e = Date.now() - t.now();
  return {
    now: () => t.now(),
    timeOrigin: e
  }
}

function CL() {
  try {
    return mL(module, "perf_hooks").performance
  } catch {
    return
  }
}
const Jv = gL() ? CL() : kL(),
  Sk = Jv === void 0 ? bw : {
    nowSeconds: () => (Jv.timeOrigin + Jv.now()) / 1e3
  },
  my = bw.nowSeconds.bind(bw),
  CI = Sk.nowSeconds.bind(Sk);
(() => {
  const {
    performance: t
  } = kI;
  if (!t || !t.now) return;
  const e = 3600 * 1e3,
    n = t.now(),
    r = Date.now(),
    o = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e,
    s = o < e,
    i = t.timing && t.timing.navigationStart,
    c = typeof i == "number" ? Math.abs(i + n - r) : e,
    l = c < e;
  return s || l ? o <= c ? t.timeOrigin : i : r
})();

function fh(t, e = []) {
  return [t, e]
}

function PL(t, e) {
  const [n, r] = t;
  return [n, [...r, e]]
}

function _k(t, e) {
  const n = t[1];
  for (const r of n) {
    const o = r[0].type;
    if (e(r, o)) return !0
  }
  return !1
}

function ww(t, e) {
  return (e || new TextEncoder).encode(t)
}

function TL(t, e) {
  const [n, r] = t;
  let o = JSON.stringify(n);

  function s(i) {
    typeof o == "string" ? o = typeof i == "string" ? o + i : [ww(o, e), i] : o.push(typeof i == "string" ? ww(i, e) : i)
  }
  for (const i of r) {
    const [a, c] = i;
    if (s(`
${JSON.stringify(a)}
`), typeof c == "string" || c instanceof Uint8Array) s(c);
    else {
      let l;
      try {
        l = JSON.stringify(c)
      } catch {
        l = JSON.stringify(pi(c))
      }
      s(l)
    }
  }
  return typeof o == "string" ? o : $L(o)
}

function $L(t) {
  const e = t.reduce((o, s) => o + s.length, 0),
    n = new Uint8Array(e);
  let r = 0;
  for (const o of t) n.set(o, r), r += o.length;
  return n
}

function IL(t, e) {
  const n = typeof t.data == "string" ? ww(t.data, e) : t.data;
  return [gy({
    type: "attachment",
    length: n.length,
    filename: t.filename,
    content_type: t.contentType,
    attachment_type: t.attachmentType
  }), n]
}
const OL = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  statsd: "unknown"
};

function xk(t) {
  return OL[t]
}

function PI(t) {
  if (!t || !t.sdk) return;
  const {
    name: e,
    version: n
  } = t.sdk;
  return {
    name: e,
    version: n
  }
}

function RL(t, e, n, r) {
  const o = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: new Date().toISOString(),
    ...e && {
      sdk: e
    },
    ...!!n && r && {
      dsn: py(r)
    },
    ...o && {
      trace: gy({
        ...o
      })
    }
  }
}

function AL(t, e, n) {
  const r = [{
    type: "client_report"
  }, {
    timestamp: n || my(),
    discarded_events: t
  }];
  return fh(e ? {
    dsn: e
  } : {}, [r])
}
const ML = 60 * 1e3;

function jL(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n)) return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? ML : r - e
}

function DL(t, e) {
  return t[e] || t.all || 0
}

function NL(t, e, n = Date.now()) {
  return DL(t, e) > n
}

function LL(t, {
  statusCode: e,
  headers: n
}, r = Date.now()) {
  const o = {
      ...t
    },
    s = n && n["x-sentry-rate-limits"],
    i = n && n["retry-after"];
  if (s)
    for (const a of s.trim().split(",")) {
      const [c, l] = a.split(":", 2), u = parseInt(c, 10), d = (isNaN(u) ? 60 : u) * 1e3;
      if (!l) o.all = r + d;
      else
        for (const f of l.split(";")) o[f] = r + d
    } else i ? o.all = r + jL(i, r) : e === 429 && (o.all = r + 60 * 1e3);
  return o
}
const ex = "production";

function tx() {
  return pI("globalEventProcessors", () => [])
}

function FL(t) {
  tx().push(t)
}

function Wg(t, e, n, r = 0) {
  return new Mr((o, s) => {
    const i = t[r];
    if (e === null || typeof i != "function") o(e);
    else {
      const a = i({
        ...e
      }, n);
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && i.id && a === null && Ve.log(`Event processor "${i.id}" dropped event`), Z_(a) ? a.then(c => Wg(t, c, n, r + 1).then(o)).then(null, s) : Wg(t, a, n, r + 1).then(o).then(null, s)
    }
  })
}

function BL(t) {
  const e = CI(),
    n = {
      sid: Ms(),
      init: !0,
      timestamp: e,
      started: e,
      duration: 0,
      status: "ok",
      errors: 0,
      ignoreDuration: !1,
      toJSON: () => zL(n)
    };
  return t && Wl(n, t), n
}

function Wl(t, e = {}) {
  if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || CI(), e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : Ms()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration) t.duration = void 0;
  else if (typeof e.duration == "number") t.duration = e.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0
  }
  e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status)
}

function UL(t, e) {
  let n = {};
  e ? n = {
    status: e
  } : t.status === "ok" && (n = {
    status: "exited"
  }), Wl(t, n)
}

function zL(t) {
  return gy({
    sid: `${t.sid}`,
    init: t.init,
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
    duration: t.duration,
    abnormal_mechanism: t.abnormal_mechanism,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent
    }
  })
}
const HL = 100;
class Ra {
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Ek()
  }
  static clone(e) {
    const n = new Ra;
    return e && (n._breadcrumbs = [...e._breadcrumbs], n._tags = {
      ...e._tags
    }, n._extra = {
      ...e._extra
    }, n._contexts = {
      ...e._contexts
    }, n._user = e._user, n._level = e._level, n._span = e._span, n._session = e._session, n._transactionName = e._transactionName, n._fingerprint = e._fingerprint, n._eventProcessors = [...e._eventProcessors], n._requestSession = e._requestSession, n._attachments = [...e._attachments], n._sdkProcessingMetadata = {
      ...e._sdkProcessingMetadata
    }, n._propagationContext = {
      ...e._propagationContext
    }), n
  }
  addScopeListener(e) {
    this._scopeListeners.push(e)
  }
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this
  }
  setUser(e) {
    return this._user = e || {}, this._session && Wl(this._session, {
      user: e
    }), this._notifyScopeListeners(), this
  }
  getUser() {
    return this._user
  }
  getRequestSession() {
    return this._requestSession
  }
  setRequestSession(e) {
    return this._requestSession = e, this
  }
  setTags(e) {
    return this._tags = {
      ...this._tags,
      ...e
    }, this._notifyScopeListeners(), this
  }
  setTag(e, n) {
    return this._tags = {
      ...this._tags,
      [e]: n
    }, this._notifyScopeListeners(), this
  }
  setExtras(e) {
    return this._extra = {
      ...this._extra,
      ...e
    }, this._notifyScopeListeners(), this
  }
  setExtra(e, n) {
    return this._extra = {
      ...this._extra,
      [e]: n
    }, this._notifyScopeListeners(), this
  }
  setFingerprint(e) {
    return this._fingerprint = e, this._notifyScopeListeners(), this
  }
  setLevel(e) {
    return this._level = e, this._notifyScopeListeners(), this
  }
  setTransactionName(e) {
    return this._transactionName = e, this._notifyScopeListeners(), this
  }
  setContext(e, n) {
    return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this
  }
  setSpan(e) {
    return this._span = e, this._notifyScopeListeners(), this
  }
  getSpan() {
    return this._span
  }
  getTransaction() {
    const e = this.getSpan();
    return e && e.transaction
  }
  setSession(e) {
    return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this
  }
  getSession() {
    return this._session
  }
  update(e) {
    if (!e) return this;
    if (typeof e == "function") {
      const n = e(this);
      return n instanceof Ra ? n : this
    }
    return e instanceof Ra ? (this._tags = {
      ...this._tags,
      ...e._tags
    }, this._extra = {
      ...this._extra,
      ...e._extra
    }, this._contexts = {
      ...this._contexts,
      ...e._contexts
    }, e._user && Object.keys(e._user).length && (this._user = e._user), e._level && (this._level = e._level), e._fingerprint && (this._fingerprint = e._fingerprint), e._requestSession && (this._requestSession = e._requestSession), e._propagationContext && (this._propagationContext = e._propagationContext)) : Vl(e) && (e = e, this._tags = {
      ...this._tags,
      ...e.tags
    }, this._extra = {
      ...this._extra,
      ...e.extra
    }, this._contexts = {
      ...this._contexts,
      ...e.contexts
    }, e.user && (this._user = e.user), e.level && (this._level = e.level), e.fingerprint && (this._fingerprint = e.fingerprint), e.requestSession && (this._requestSession = e.requestSession), e.propagationContext && (this._propagationContext = e.propagationContext)), this
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = Ek(), this
  }
  addBreadcrumb(e, n) {
    const r = typeof n == "number" ? n : HL;
    if (r <= 0) return this;
    const o = {
        timestamp: my(),
        ...e
      },
      s = this._breadcrumbs;
    return s.push(o), this._breadcrumbs = s.length > r ? s.slice(-r) : s, this._notifyScopeListeners(), this
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1]
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this
  }
  addAttachment(e) {
    return this._attachments.push(e), this
  }
  getAttachments() {
    return this._attachments
  }
  clearAttachments() {
    return this._attachments = [], this
  }
  applyToEvent(e, n = {}, r) {
    if (this._extra && Object.keys(this._extra).length && (e.extra = {
        ...this._extra,
        ...e.extra
      }), this._tags && Object.keys(this._tags).length && (e.tags = {
        ...this._tags,
        ...e.tags
      }), this._user && Object.keys(this._user).length && (e.user = {
        ...this._user,
        ...e.user
      }), this._contexts && Object.keys(this._contexts).length && (e.contexts = {
        ...this._contexts,
        ...e.contexts
      }), this._level && (e.level = this._level), this._transactionName && (e.transaction = this._transactionName), this._span) {
      e.contexts = {
        trace: this._span.getTraceContext(),
        ...e.contexts
      };
      const i = this._span.transaction;
      if (i) {
        e.sdkProcessingMetadata = {
          dynamicSamplingContext: i.getDynamicSamplingContext(),
          ...e.sdkProcessingMetadata
        };
        const a = i.name;
        a && (e.tags = {
          transaction: a,
          ...e.tags
        })
      }
    }
    this._applyFingerprint(e);
    const o = this._getBreadcrumbs(),
      s = [...e.breadcrumbs || [], ...o];
    return e.breadcrumbs = s.length > 0 ? s : void 0, e.sdkProcessingMetadata = {
      ...e.sdkProcessingMetadata,
      ...this._sdkProcessingMetadata,
      propagationContext: this._propagationContext
    }, Wg([...r || [], ...tx(), ...this._eventProcessors], e, n)
  }
  setSDKProcessingMetadata(e) {
    return this._sdkProcessingMetadata = {
      ...this._sdkProcessingMetadata,
      ...e
    }, this
  }
  setPropagationContext(e) {
    return this._propagationContext = e, this
  }
  getPropagationContext() {
    return this._propagationContext
  }
  _getBreadcrumbs() {
    return this._breadcrumbs
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach(e => {
      e(this)
    }), this._notifyingListeners = !1)
  }
  _applyFingerprint(e) {
    e.fingerprint = e.fingerprint ? wI(e.fingerprint) : [], this._fingerprint && (e.fingerprint = e.fingerprint.concat(this._fingerprint)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint
  }
}

function Ek() {
  return {
    traceId: Ms(),
    spanId: Ms().substring(16)
  }
}
const TI = 4,
  VL = 100;
class $I {
  constructor(e, n = new Ra, r = TI) {
    this._version = r, this._stack = [{
      scope: n
    }], e && this.bindClient(e)
  }
  isOlderThan(e) {
    return this._version < e
  }
  bindClient(e) {
    const n = this.getStackTop();
    n.client = e, e && e.setupIntegrations && e.setupIntegrations()
  }
  pushScope() {
    const e = Ra.clone(this.getScope());
    return this.getStack().push({
      client: this.getClient(),
      scope: e
    }), e
  }
  popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop()
  }
  withScope(e) {
    const n = this.pushScope();
    try {
      e(n)
    } finally {
      this.popScope()
    }
  }
  getClient() {
    return this.getStackTop().client
  }
  getScope() {
    return this.getStackTop().scope
  }
  getStack() {
    return this._stack
  }
  getStackTop() {
    return this._stack[this._stack.length - 1]
  }
  captureException(e, n) {
    const r = this._lastEventId = n && n.event_id ? n.event_id : Ms(),
      o = new Error("Sentry syntheticException");
    return this._withClient((s, i) => {
      s.captureException(e, {
        originalException: e,
        syntheticException: o,
        ...n,
        event_id: r
      }, i)
    }), r
  }
  captureMessage(e, n, r) {
    const o = this._lastEventId = r && r.event_id ? r.event_id : Ms(),
      s = new Error(e);
    return this._withClient((i, a) => {
      i.captureMessage(e, n, {
        originalException: e,
        syntheticException: s,
        ...r,
        event_id: o
      }, a)
    }), o
  }
  captureEvent(e, n) {
    const r = n && n.event_id ? n.event_id : Ms();
    return e.type || (this._lastEventId = r), this._withClient((o, s) => {
      o.captureEvent(e, {
        ...n,
        event_id: r
      }, s)
    }), r
  }
  lastEventId() {
    return this._lastEventId
  }
  addBreadcrumb(e, n) {
    const {
      scope: r,
      client: o
    } = this.getStackTop();
    if (!o) return;
    const {
      beforeBreadcrumb: s = null,
      maxBreadcrumbs: i = VL
    } = o.getOptions && o.getOptions() || {};
    if (i <= 0) return;
    const c = {
        timestamp: my(),
        ...e
      },
      l = s ? gI(() => s(c, n)) : c;
    l !== null && (o.emit && o.emit("beforeAddBreadcrumb", l, n), r.addBreadcrumb(l, i))
  }
  setUser(e) {
    this.getScope().setUser(e)
  }
  setTags(e) {
    this.getScope().setTags(e)
  }
  setExtras(e) {
    this.getScope().setExtras(e)
  }
  setTag(e, n) {
    this.getScope().setTag(e, n)
  }
  setExtra(e, n) {
    this.getScope().setExtra(e, n)
  }
  setContext(e, n) {
    this.getScope().setContext(e, n)
  }
  configureScope(e) {
    const {
      scope: n,
      client: r
    } = this.getStackTop();
    r && e(n)
  }
  run(e) {
    const n = kk(this);
    try {
      e(this)
    } finally {
      kk(n)
    }
  }
  getIntegration(e) {
    const n = this.getClient();
    if (!n) return null;
    try {
      return n.getIntegration(e)
    } catch {
      return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Cannot retrieve integration ${e.id} from the current Hub`), null
    }
  }
  startTransaction(e, n) {
    const r = this._callExtensionMethod("startTransaction", e, n);
    if ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && !r) {
      const o = this.getClient();
      console.warn(o ? `Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':
Sentry.addTracingExtensions();
Sentry.init({...});
` : "Tracing extension 'startTransaction' is missing. You should 'init' the SDK before calling 'startTransaction'")
    }
    return r
  }
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders")
  }
  captureSession(e = !1) {
    if (e) return this.endSession();
    this._sendSessionUpdate()
  }
  endSession() {
    const n = this.getStackTop().scope,
      r = n.getSession();
    r && UL(r), this._sendSessionUpdate(), n.setSession()
  }
  startSession(e) {
    const {
      scope: n,
      client: r
    } = this.getStackTop(), {
      release: o,
      environment: s = ex
    } = r && r.getOptions() || {}, {
      userAgent: i
    } = pn.navigator || {}, a = BL({
      release: o,
      environment: s,
      user: n.getUser(),
      ...i && {
        userAgent: i
      },
      ...e
    }), c = n.getSession && n.getSession();
    return c && c.status === "ok" && Wl(c, {
      status: "exited"
    }), this.endSession(), n.setSession(a), a
  }
  shouldSendDefaultPii() {
    const e = this.getClient(),
      n = e && e.getOptions();
    return !!(n && n.sendDefaultPii)
  }
  _sendSessionUpdate() {
    const {
      scope: e,
      client: n
    } = this.getStackTop(), r = e.getSession();
    r && n && n.captureSession && n.captureSession(r)
  }
  _withClient(e) {
    const {
      scope: n,
      client: r
    } = this.getStackTop();
    r && e(r, n)
  }
  _callExtensionMethod(e, ...n) {
    const o = yy().__SENTRY__;
    if (o && o.extensions && typeof o.extensions[e] == "function") return o.extensions[e].apply(this, n);
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Extension method ${e} couldn't be found, doing nothing.`)
  }
}

function yy() {
  return pn.__SENTRY__ = pn.__SENTRY__ || {
    extensions: {},
    hub: void 0
  }, pn
}

function kk(t) {
  const e = yy(),
    n = Sw(e);
  return II(e, t), n
}

function Kn() {
  const t = yy();
  if (t.__SENTRY__ && t.__SENTRY__.acs) {
    const e = t.__SENTRY__.acs.getCurrentHub();
    if (e) return e
  }
  return WL(t)
}

function WL(t = yy()) {
  return (!KL(t) || Sw(t).isOlderThan(TI)) && II(t, new $I), Sw(t)
}

function KL(t) {
  return !!(t && t.__SENTRY__ && t.__SENTRY__.hub)
}

function Sw(t) {
  return pI("hub", () => new $I, t)
}

function II(t, e) {
  if (!t) return !1;
  const n = t.__SENTRY__ = t.__SENTRY__ || {};
  return n.hub = e, !0
}

function GL(t, e, n) {
  const r = e.getOptions(),
    {
      publicKey: o
    } = e.getDsn() || {},
    {
      segment: s
    } = n && n.getUser() || {},
    i = gy({
      environment: r.environment || ex,
      release: r.release,
      user_segment: s,
      public_key: o,
      trace_id: t
    });
  return e.emit && e.emit("createDsc", i), i
}

function nx(t, e) {
  return Kn().captureException(t, {
    captureContext: e
  })
}

function YL(t) {
  Kn().withScope(t)
}
const qL = "7";

function XL(t) {
  const e = t.protocol ? `${t.protocol}:` : "",
    n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path?`/${t.path}`:""}/api/`
}

function ZL(t) {
  return `${XL(t)}${t.projectId}/envelope/`
}

function JL(t, e) {
  return Y6({
    sentry_key: t.publicKey,
    sentry_version: qL,
    ...e && {
      sentry_client: `${e.name}/${e.version}`
    }
  })
}

function QL(t, e = {}) {
  const n = typeof e == "string" ? e : e.tunnel,
    r = typeof e == "string" || !e._metadata ? void 0 : e._metadata.sdk;
  return n || `${ZL(t)}?${JL(t,r)}`
}

function e8(t, e) {
  return e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]), t
}

function t8(t, e, n, r) {
  const o = PI(n),
    s = {
      sent_at: new Date().toISOString(),
      ...o && {
        sdk: o
      },
      ...!!r && e && {
        dsn: py(e)
      }
    },
    i = "aggregates" in t ? [{
      type: "sessions"
    }, t] : [{
      type: "session"
    }, t.toJSON()];
  return fh(s, [i])
}

function n8(t, e, n, r) {
  const o = PI(n),
    s = t.type && t.type !== "replay_event" ? t.type : "event";
  e8(t, n && n.sdk);
  const i = RL(t, o, r, e);
  return delete t.sdkProcessingMetadata, fh(i, [
    [{
      type: s
    }, t]
  ])
}
const Ck = [];

function r8(t) {
  const e = {};
  return t.forEach(n => {
    const {
      name: r
    } = n, o = e[r];
    o && !o.isDefaultInstance && n.isDefaultInstance || (e[r] = n)
  }), Object.keys(e).map(n => e[n])
}

function o8(t) {
  const e = t.defaultIntegrations || [],
    n = t.integrations;
  e.forEach(i => {
    i.isDefaultInstance = !0
  });
  let r;
  Array.isArray(n) ? r = [...e, ...n] : typeof n == "function" ? r = wI(n(e)) : r = e;
  const o = r8(r),
    s = i8(o, i => i.name === "Debug");
  if (s !== -1) {
    const [i] = o.splice(s, 1);
    o.push(i)
  }
  return o
}

function s8(t, e) {
  const n = {};
  return e.forEach(r => {
    r && OI(t, r, n)
  }), n
}

function OI(t, e, n) {
  if (n[e.name] = e, Ck.indexOf(e.name) === -1 && (e.setupOnce(FL, Kn), Ck.push(e.name)), t.on && typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (o, s) => r(o, s, t))
  }
  if (t.addEventProcessor && typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e),
      o = Object.assign((s, i) => r(s, i, t), {
        id: e.name
      });
    t.addEventProcessor(o)
  }(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(`Integration installed: ${e.name}`)
}

function i8(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]) === !0) return n;
  return -1
}

function a8(t, e, n, r, o) {
  const {
    normalizeDepth: s = 3,
    normalizeMaxBreadth: i = 1e3
  } = t, a = {
    ...e,
    event_id: e.event_id || n.event_id || Ms(),
    timestamp: e.timestamp || my()
  }, c = n.integrations || t.integrations.map(f => f.name);
  c8(a, t), d8(a, c), e.type === void 0 && l8(a, t.stackParser);
  let l = r;
  n.captureContext && (l = Ra.clone(l).update(n.captureContext));
  let u = Ua(a);
  const d = o && o.getEventProcessors ? o.getEventProcessors() : [];
  if (l) {
    if (l.getAttachments) {
      const f = [...n.attachments || [], ...l.getAttachments()];
      f.length && (n.attachments = f)
    }
    u = l.applyToEvent(a, n, d)
  } else u = Wg([...d, ...tx()], a, n);
  return u.then(f => (f && u8(f), typeof s == "number" && s > 0 ? f8(f, s, i) : f))
}

function c8(t, e) {
  const {
    environment: n,
    release: r,
    dist: o,
    maxValueLength: s = 250
  } = e;
  "environment" in t || (t.environment = "environment" in e ? n : ex), t.release === void 0 && r !== void 0 && (t.release = r), t.dist === void 0 && o !== void 0 && (t.dist = o), t.message && (t.message = Cl(t.message, s));
  const i = t.exception && t.exception.values && t.exception.values[0];
  i && i.value && (i.value = Cl(i.value, s));
  const a = t.request;
  a && a.url && (a.url = Cl(a.url, s))
}
const Pk = new WeakMap;

function l8(t, e) {
  const n = pn._sentryDebugIds;
  if (!n) return;
  let r;
  const o = Pk.get(e);
  o ? r = o : (r = new Map, Pk.set(e, r));
  const s = Object.keys(n).reduce((i, a) => {
    let c;
    const l = r.get(a);
    l ? c = l : (c = e(a), r.set(a, c));
    for (let u = c.length - 1; u >= 0; u--) {
      const d = c[u];
      if (d.filename) {
        i[d.filename] = n[a];
        break
      }
    }
    return i
  }, {});
  try {
    t.exception.values.forEach(i => {
      i.stacktrace.frames.forEach(a => {
        a.filename && (a.debug_id = s[a.filename])
      })
    })
  } catch {}
}

function u8(t) {
  const e = {};
  try {
    t.exception.values.forEach(r => {
      r.stacktrace.frames.forEach(o => {
        o.debug_id && (o.abs_path ? e[o.abs_path] = o.debug_id : o.filename && (e[o.filename] = o.debug_id), delete o.debug_id)
      })
    })
  } catch {}
  if (Object.keys(e).length === 0) return;
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const n = t.debug_meta.images;
  Object.keys(e).forEach(r => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: e[r]
    })
  })
}

function d8(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e])
}

function f8(t, e, n) {
  if (!t) return null;
  const r = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map(o => ({
        ...o,
        ...o.data && {
          data: pi(o.data, e, n)
        }
      }))
    },
    ...t.user && {
      user: pi(t.user, e, n)
    },
    ...t.contexts && {
      contexts: pi(t.contexts, e, n)
    },
    ...t.extra && {
      extra: pi(t.extra, e, n)
    }
  };
  return t.contexts && t.contexts.trace && r.contexts && (r.contexts.trace = t.contexts.trace, t.contexts.trace.data && (r.contexts.trace.data = pi(t.contexts.trace.data, e, n))), t.spans && (r.spans = t.spans.map(o => (o.data && (o.data = pi(o.data, e, n)), o))), r
}
const Tk = "Not capturing exception because it's already been captured.";
class h8 {
  constructor(e) {
    if (this._options = e, this._integrations = {}, this._integrationsInitialized = !1, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = G6(e.dsn) : (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = QL(this._dsn, e);
      this._transport = e.transport({
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n
      })
    }
  }
  captureException(e, n, r) {
    if (pk(e)) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(Tk);
      return
    }
    let o = n && n.event_id;
    return this._process(this.eventFromException(e, n).then(s => this._captureEvent(s, n, r)).then(s => {
      o = s
    })), o
  }
  captureMessage(e, n, r, o) {
    let s = r && r.event_id;
    const i = fI(e) ? this.eventFromMessage(String(e), n, r) : this.eventFromException(e, r);
    return this._process(i.then(a => this._captureEvent(a, r, o)).then(a => {
      s = a
    })), s
  }
  captureEvent(e, n, r) {
    if (n && n.originalException && pk(n.originalException)) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(Tk);
      return
    }
    let o = n && n.event_id;
    return this._process(this._captureEvent(e, n, r).then(s => {
      o = s
    })), o
  }
  captureSession(e) {
    typeof e.release != "string" ? (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), Wl(e, {
      init: !1
    }))
  }
  getDsn() {
    return this._dsn
  }
  getOptions() {
    return this._options
  }
  getSdkMetadata() {
    return this._options._metadata
  }
  getTransport() {
    return this._transport
  }
  flush(e) {
    const n = this._transport;
    return n ? this._isClientDoneProcessing(e).then(r => n.flush(e).then(o => r && o)) : Ua(!0)
  }
  close(e) {
    return this.flush(e).then(n => (this.getOptions().enabled = !1, n))
  }
  getEventProcessors() {
    return this._eventProcessors
  }
  addEventProcessor(e) {
    this._eventProcessors.push(e)
  }
  setupIntegrations(e) {
    (e && !this._integrationsInitialized || this._isEnabled() && !this._integrationsInitialized) && (this._integrations = s8(this, this._options.integrations), this._integrationsInitialized = !0)
  }
  getIntegrationById(e) {
    return this._integrations[e]
  }
  getIntegration(e) {
    try {
      return this._integrations[e.id] || null
    } catch {
      return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Cannot retrieve integration ${e.id} from the current Client`), null
    }
  }
  addIntegration(e) {
    OI(this, e, this._integrations)
  }
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = n8(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const s of n.attachments || []) r = PL(r, IL(s, this._options.transportOptions && this._options.transportOptions.textEncoder));
    const o = this._sendEnvelope(r);
    o && o.then(s => this.emit("afterSendEvent", e, s), null)
  }
  sendSession(e) {
    const n = t8(e, this._dsn, this._options._metadata, this._options.tunnel);
    this._sendEnvelope(n)
  }
  recordDroppedEvent(e, n, r) {
    if (this._options.sendClientReports) {
      const o = `${e}:${n}`;
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(`Adding outcome: "${o}"`), this._outcomes[o] = this._outcomes[o] + 1 || 1
    }
  }
  on(e, n) {
    this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(n)
  }
  emit(e, ...n) {
    this._hooks[e] && this._hooks[e].forEach(r => r(...n))
  }
  _updateSessionFromEvent(e, n) {
    let r = !1,
      o = !1;
    const s = n.exception && n.exception.values;
    if (s) {
      o = !0;
      for (const c of s) {
        const l = c.mechanism;
        if (l && l.handled === !1) {
          r = !0;
          break
        }
      }
    }
    const i = e.status === "ok";
    (i && e.errors === 0 || i && r) && (Wl(e, {
      ...r && {
        status: "crashed"
      },
      errors: e.errors || Number(o || r)
    }), this.captureSession(e))
  }
  _isClientDoneProcessing(e) {
    return new Mr(n => {
      let r = 0;
      const o = 1,
        s = setInterval(() => {
          this._numProcessing == 0 ? (clearInterval(s), n(!0)) : (r += o, e && r >= e && (clearInterval(s), n(!1)))
        }, o)
    })
  }
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0
  }
  _prepareEvent(e, n, r) {
    const o = this.getOptions(),
      s = Object.keys(this._integrations);
    return !n.integrations && s.length > 0 && (n.integrations = s), this.emit("preprocessEvent", e, n), a8(o, e, n, r, this).then(i => {
      if (i === null) return i;
      const {
        propagationContext: a
      } = i.sdkProcessingMetadata || {};
      if (!(i.contexts && i.contexts.trace) && a) {
        const {
          traceId: l,
          spanId: u,
          parentSpanId: d,
          dsc: f
        } = a;
        i.contexts = {
          trace: {
            trace_id: l,
            span_id: u,
            parent_span_id: d
          },
          ...i.contexts
        };
        const h = f || GL(l, this, r);
        i.sdkProcessingMetadata = {
          dynamicSamplingContext: h,
          ...i.sdkProcessingMetadata
        }
      }
      return i
    })
  }
  _captureEvent(e, n = {}, r) {
    return this._processEvent(e, n, r).then(o => o.event_id, o => {
      if (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) {
        const s = o;
        s.logLevel === "log" ? Ve.log(s.message) : Ve.warn(s)
      }
    })
  }
  _processEvent(e, n, r) {
    const o = this.getOptions(),
      {
        sampleRate: s
      } = o,
      i = AI(e),
      a = RI(e),
      c = e.type || "error",
      l = `before send for type \`${c}\``;
    if (a && typeof s == "number" && Math.random() > s) return this.recordDroppedEvent("sample_rate", "error", e), Q_(new rs(`Discarding event because it's not included in the random sample (sampling rate = ${s})`, "log"));
    const u = c === "replay_event" ? "replay" : c;
    return this._prepareEvent(e, n, r).then(d => {
      if (d === null) throw this.recordDroppedEvent("event_processor", u, e), new rs("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0) return d;
      const h = g8(o, d, n);
      return p8(h, l)
    }).then(d => {
      if (d === null) throw this.recordDroppedEvent("before_send", u, e), new rs(`${l} returned \`null\`, will not send event.`, "log");
      const f = r && r.getSession();
      !i && f && this._updateSessionFromEvent(f, d);
      const h = d.transaction_info;
      if (i && h && d.transaction !== e.transaction) {
        const m = "custom";
        d.transaction_info = {
          ...h,
          source: m
        }
      }
      return this.sendEvent(d, n), d
    }).then(null, d => {
      throw d instanceof rs ? d : (this.captureException(d, {
        data: {
          __sentry__: !0
        },
        originalException: d
      }), new rs(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${d}`))
    })
  }
  _process(e) {
    this._numProcessing++, e.then(n => (this._numProcessing--, n), n => (this._numProcessing--, n))
  }
  _sendEnvelope(e) {
    if (this.emit("beforeEnvelope", e), this._isEnabled() && this._transport) return this._transport.send(e).then(null, n => {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.error("Error while sending event:", n)
    });
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.error("Transport disabled")
  }
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.keys(e).map(n => {
      const [r, o] = n.split(":");
      return {
        reason: r,
        category: o,
        quantity: e[n]
      }
    })
  }
}

function p8(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (Z_(t)) return t.then(r => {
    if (!Vl(r) && r !== null) throw new rs(n);
    return r
  }, r => {
    throw new rs(`${e} rejected with ${r}`)
  });
  if (!Vl(t) && t !== null) throw new rs(n);
  return t
}

function g8(t, e, n) {
  const {
    beforeSend: r,
    beforeSendTransaction: o
  } = t;
  return RI(e) && r ? r(e, n) : AI(e) && o ? o(e, n) : e
}

function RI(t) {
  return t.type === void 0
}

function AI(t) {
  return t.type === "transaction"
}

function m8(t, e) {
  e.debug === !0 && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? Ve.enable() : console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle."));
  const n = Kn();
  n.getScope().update(e.initialScope);
  const o = new t(e);
  n.bindClient(o)
}
const y8 = 30;

function MI(t, e, n = _L(t.bufferSize || y8)) {
  let r = {};
  const o = i => n.drain(i);

  function s(i) {
    const a = [];
    if (_k(i, (d, f) => {
        const h = xk(f);
        if (NL(r, h)) {
          const m = $k(d, f);
          t.recordDroppedEvent("ratelimit_backoff", h, m)
        } else a.push(d)
      }), a.length === 0) return Ua();
    const c = fh(i[0], a),
      l = d => {
        _k(c, (f, h) => {
          const m = $k(f, h);
          t.recordDroppedEvent(d, xk(h), m)
        })
      },
      u = () => e({
        body: TL(c, t.textEncoder)
      }).then(d => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = LL(r, d), d), d => {
        throw l("network_error"), d
      });
    return n.add(u).then(d => d, d => {
      if (d instanceof rs) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.error("Skipped sending event because buffer is full."), l("queue_overflow"), Ua();
      throw d
    })
  }
  return s.__sentry__baseTransport__ = !0, {
    send: s,
    flush: o
  }
}

function $k(t, e) {
  if (!(e !== "event" && e !== "transaction")) return Array.isArray(t) ? t[1] : void 0
}
const Kg = "7.77.0";
let Ik;
class vy {
  static __initStatic() {
    this.id = "FunctionToString"
  }
  constructor() {
    this.name = vy.id
  }
  setupOnce() {
    Ik = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...e) {
        const n = J_(this) || this;
        return Ik.apply(n, e)
      }
    } catch {}
  }
}
vy.__initStatic();
const v8 = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/],
  b8 = [/^.*\/healthcheck$/, /^.*\/healthy$/, /^.*\/live$/, /^.*\/ready$/, /^.*\/heartbeat$/, /^.*\/health$/, /^.*\/healthz$/];
class by {
  static __initStatic() {
    this.id = "InboundFilters"
  }
  constructor(e = {}) {
    this.name = by.id, this._options = e
  }
  setupOnce(e, n) {}
  processEvent(e, n, r) {
    const o = r.getOptions(),
      s = w8(this._options, o);
    return S8(e, s) ? null : e
  }
}
by.__initStatic();

function w8(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [...t.ignoreErrors || [], ...e.ignoreErrors || [], ...t.disableErrorDefaults ? [] : v8],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || [], ...t.disableTransactionDefaults ? [] : b8],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
  }
}

function S8(t, e) {
  return e.ignoreInternal && P8(t) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Event dropped due to being internal Sentry Error.
Event: ${bi(t)}`), !0) : _8(t, e.ignoreErrors) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${bi(t)}`), !0) : x8(t, e.ignoreTransactions) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${bi(t)}`), !0) : E8(t, e.denyUrls) ? ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${bi(t)}.
Url: ${Gg(t)}`), !0) : k8(t, e.allowUrls) ? !1 : ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${bi(t)}.
Url: ${Gg(t)}`), !0)
}

function _8(t, e) {
  return t.type || !e || !e.length ? !1 : C8(t).some(n => hy(n, e))
}

function x8(t, e) {
  if (t.type !== "transaction" || !e || !e.length) return !1;
  const n = t.transaction;
  return n ? hy(n, e) : !1
}

function E8(t, e) {
  if (!e || !e.length) return !1;
  const n = Gg(t);
  return n ? hy(n, e) : !1
}

function k8(t, e) {
  if (!e || !e.length) return !0;
  const n = Gg(t);
  return n ? hy(n, e) : !0
}

function C8(t) {
  const e = [];
  t.message && e.push(t.message);
  let n;
  try {
    n = t.exception.values[t.exception.values.length - 1]
  } catch {}
  return n && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`)), (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && e.length === 0 && Ve.error(`Could not extract message for event ${bi(t)}`), e
}

function P8(t) {
  try {
    return t.exception.values[0].type === "SentryError"
  } catch {}
  return !1
}

function T8(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]") return n.filename || null
  }
  return null
}

function Gg(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames
    } catch {}
    return e ? T8(e) : null
  } catch {
    return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.error(`Cannot extract url for event ${bi(t)}`), null
  }
}
const _t = pn;
let _w = 0;

function jI() {
  return _w > 0
}

function $8() {
  _w++, setTimeout(() => {
    _w--
  })
}

function Kl(t, e = {}, n) {
  if (typeof t != "function") return t;
  try {
    const o = t.__sentry_wrapped__;
    if (o) return o;
    if (J_(t)) return t
  } catch {
    return t
  }
  const r = function() {
    const o = Array.prototype.slice.call(arguments);
    try {
      n && typeof n == "function" && n.apply(this, arguments);
      const s = o.map(i => Kl(i, e));
      return t.apply(this, s)
    } catch (s) {
      throw $8(), YL(i => {
        i.addEventProcessor(a => (e.mechanism && (fw(a, void 0, void 0), of(a, e.mechanism)), a.extra = {
          ...a.extra,
          arguments: o
        }, a)), nx(s)
      }), s
    }
  };
  try {
    for (const o in t) Object.prototype.hasOwnProperty.call(t, o) && (r[o] = t[o])
  } catch {}
  yI(r, t), rf(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name
      }
    })
  } catch {}
  return r
}

function DI(t, e) {
  const n = rx(t, e),
    r = {
      type: e && e.name,
      value: A8(e)
    };
  return n.length && (r.stacktrace = {
    frames: n
  }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r
}

function I8(t, e, n, r) {
  const s = Kn().getClient(),
    i = s && s.getOptions().normalizeDepth,
    a = {
      exception: {
        values: [{
          type: fy(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
          value: D8(e, {
            isUnhandledRejection: r
          })
        }]
      },
      extra: {
        __serialized__: EI(e, i)
      }
    };
  if (n) {
    const c = rx(t, n);
    c.length && (a.exception.values[0].stacktrace = {
      frames: c
    })
  }
  return a
}

function Qv(t, e) {
  return {
    exception: {
      values: [DI(t, e)]
    }
  }
}

function rx(t, e) {
  const n = e.stacktrace || e.stack || "",
    r = R8(e);
  try {
    return t(n, r)
  } catch {}
  return []
}
const O8 = /Minified React error #\d+;/i;

function R8(t) {
  if (t) {
    if (typeof t.framesToPop == "number") return t.framesToPop;
    if (O8.test(t.message)) return 1
  }
  return 0
}

function A8(t) {
  const e = t && t.message;
  return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message"
}

function M8(t, e, n, r) {
  const o = n && n.syntheticException || void 0,
    s = ox(t, e, o, r);
  return of(s), s.level = "error", n && n.event_id && (s.event_id = n.event_id), Ua(s)
}

function j8(t, e, n = "info", r, o) {
  const s = r && r.syntheticException || void 0,
    i = xw(t, e, s, o);
  return i.level = n, r && r.event_id && (i.event_id = r.event_id), Ua(i)
}

function ox(t, e, n, r, o) {
  let s;
  if (X_(e) && e.error) return Qv(t, e.error);
  if (ck(e) || $6(e)) {
    const i = e;
    if ("stack" in e) s = Qv(t, e);
    else {
      const a = i.name || (ck(i) ? "DOMError" : "DOMException"),
        c = i.message ? `${a}: ${i.message}` : a;
      s = xw(t, c, n, r), fw(s, c)
    }
    return "code" in i && (s.tags = {
      ...s.tags,
      "DOMException.code": `${i.code}`
    }), s
  }
  return dI(e) ? Qv(t, e) : Vl(e) || fy(e) ? (s = I8(t, e, n, o), of(s, {
    synthetic: !0
  }), s) : (s = xw(t, e, n, r), fw(s, `${e}`, void 0), of(s, {
    synthetic: !0
  }), s)
}

function xw(t, e, n, r) {
  const o = {
    message: e
  };
  if (r && n) {
    const s = rx(t, n);
    s.length && (o.exception = {
      values: [{
        value: e,
        stacktrace: {
          frames: s
        }
      }]
    })
  }
  return o
}

function D8(t, {
  isUnhandledRejection: e
}) {
  const n = q6(t),
    r = e ? "promise rejection" : "exception";
  return X_(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : fy(t) ? `Event \`${N8(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`
}

function N8(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0
  } catch {}
}

function L8(t, {
  metadata: e,
  tunnel: n,
  dsn: r
}) {
  const o = {
      event_id: t.event_id,
      sent_at: new Date().toISOString(),
      ...e && e.sdk && {
        sdk: {
          name: e.sdk.name,
          version: e.sdk.version
        }
      },
      ...!!n && !!r && {
        dsn: py(r)
      }
    },
    s = F8(t);
  return fh(o, [s])
}

function F8(t) {
  return [{
    type: "user_report"
  }, t]
}
class B8 extends h8 {
  constructor(e) {
    const n = _t.SENTRY_SDK_SOURCE || pL();
    e._metadata = e._metadata || {}, e._metadata.sdk = e._metadata.sdk || {
      name: "sentry.javascript.browser",
      packages: [{
        name: `${n}:@sentry/browser`,
        version: Kg
      }],
      version: Kg
    }, super(e), e.sendClientReports && _t.document && _t.document.addEventListener("visibilitychange", () => {
      _t.document.visibilityState === "hidden" && this._flushOutcomes()
    })
  }
  eventFromException(e, n) {
    return M8(this._options.stackParser, e, n, this._options.attachStacktrace)
  }
  eventFromMessage(e, n = "info", r) {
    return j8(this._options.stackParser, e, n, r, this._options.attachStacktrace)
  }
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("SDK not enabled, will not capture user feedback.");
      return
    }
    const n = L8(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this._sendEnvelope(n)
  }
  _prepareEvent(e, n, r) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r)
  }
  _flushOutcomes() {
    const e = this._clearOutcomes();
    if (e.length === 0) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log("No outcomes to send");
      return
    }
    if (!this._dsn) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log("No dsn provided, will not send outcomes");
      return
    }(typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log("Sending outcomes:", e);
    const n = AL(e, this._options.tunnel && py(this._dsn));
    this._sendEnvelope(n)
  }
}
let xd;

function U8() {
  if (xd) return xd;
  if (pw(_t.fetch)) return xd = _t.fetch.bind(_t);
  const t = _t.document;
  let e = _t.fetch;
  if (t && typeof t.createElement == "function") try {
    const n = t.createElement("iframe");
    n.hidden = !0, t.head.appendChild(n);
    const r = n.contentWindow;
    r && r.fetch && (e = r.fetch), t.head.removeChild(n)
  } catch (n) {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n)
  }
  return xd = e.bind(_t)
}

function z8() {
  xd = void 0
}

function H8(t, e = U8()) {
  let n = 0,
    r = 0;

  function o(s) {
    const i = s.body.length;
    n += i, r++;
    const a = {
      body: s.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    try {
      return e(t.url, a).then(c => (n -= i, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }))
    } catch (c) {
      return z8(), n -= i, r--, Q_(c)
    }
  }
  return MI(t, o)
}
const V8 = 4;

function W8(t) {
  function e(n) {
    return new Mr((r, o) => {
      const s = new XMLHttpRequest;
      s.onerror = o, s.onreadystatechange = () => {
        s.readyState === V8 && r({
          statusCode: s.status,
          headers: {
            "x-sentry-rate-limits": s.getResponseHeader("X-Sentry-Rate-Limits"),
            "retry-after": s.getResponseHeader("Retry-After")
          }
        })
      }, s.open("POST", t.url);
      for (const i in t.headers) Object.prototype.hasOwnProperty.call(t.headers, i) && s.setRequestHeader(i, t.headers[i]);
      s.send(n.body)
    })
  }
  return MI(t, e)
}
const wy = "?",
  K8 = 30,
  G8 = 40,
  Y8 = 50;

function sx(t, e, n, r) {
  const o = {
    filename: t,
    function: e,
    in_app: !0
  };
  return n !== void 0 && (o.lineno = n), r !== void 0 && (o.colno = r), o
}
const q8 = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i,
  X8 = /\((\S*)(?::(\d+))(?::(\d+))\)/,
  Z8 = t => {
    const e = q8.exec(t);
    if (e) {
      if (e[2] && e[2].indexOf("eval") === 0) {
        const s = X8.exec(e[2]);
        s && (e[2] = s[1], e[3] = s[2], e[4] = s[3])
      }
      const [r, o] = NI(e[1] || wy, e[2]);
      return sx(o, r, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0)
    }
  },
  J8 = [K8, Z8],
  Q8 = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i,
  e7 = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i,
  t7 = t => {
    const e = Q8.exec(t);
    if (e) {
      if (e[3] && e[3].indexOf(" > eval") > -1) {
        const s = e7.exec(e[3]);
        s && (e[1] = e[1] || "eval", e[3] = s[1], e[4] = s[2], e[5] = "")
      }
      let r = e[3],
        o = e[1] || wy;
      return [o, r] = NI(o, r), sx(r, o, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0)
    }
  },
  n7 = [Y8, t7],
  r7 = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:[-a-z]+):.*?):(\d+)(?::(\d+))?\)?\s*$/i,
  o7 = t => {
    const e = r7.exec(t);
    return e ? sx(e[2], e[1] || wy, +e[3], e[4] ? +e[4] : void 0) : void 0
  },
  s7 = [G8, o7],
  i7 = [J8, n7, s7],
  a7 = _I(...i7),
  NI = (t, e) => {
    const n = t.indexOf("safari-extension") !== -1,
      r = t.indexOf("safari-web-extension") !== -1;
    return n || r ? [t.indexOf("@") !== -1 ? t.split("@")[0] : wy, n ? `safari-extension:${e}` : `safari-web-extension:${e}`] : [t, e]
  };
class hu {
  static __initStatic() {
    this.id = "GlobalHandlers"
  }
  constructor(e) {
    this.name = hu.id, this._options = {
      onerror: !0,
      onunhandledrejection: !0,
      ...e
    }, this._installFunc = {
      onerror: c7,
      onunhandledrejection: l7
    }
  }
  setupOnce() {
    Error.stackTraceLimit = 50;
    const e = this._options;
    for (const n in e) {
      const r = this._installFunc[n];
      r && e[n] && (f7(n), r(), this._installFunc[n] = void 0)
    }
  }
}
hu.__initStatic();

function c7() {
  wi("error", t => {
    const [e, n, r] = BI();
    if (!e.getIntegration(hu)) return;
    const {
      msg: o,
      url: s,
      line: i,
      column: a,
      error: c
    } = t;
    if (jI() || c && c.__sentry_own_request__) return;
    const l = c === void 0 && Fa(o) ? d7(o, s, i, a) : LI(ox(n, c || o, void 0, r, !1), s, i, a);
    l.level = "error", FI(e, c, l, "onerror")
  })
}

function l7() {
  wi("unhandledrejection", t => {
    const [e, n, r] = BI();
    if (!e.getIntegration(hu)) return;
    let o = t;
    try {
      "reason" in t ? o = t.reason : "detail" in t && "reason" in t.detail && (o = t.detail.reason)
    } catch {}
    if (jI() || o && o.__sentry_own_request__) return !0;
    const s = fI(o) ? u7(o) : ox(n, o, void 0, r, !0);
    s.level = "error", FI(e, o, s, "onunhandledrejection")
  })
}

function u7(t) {
  return {
    exception: {
      values: [{
        type: "UnhandledRejection",
        value: `Non-Error promise rejection captured with value: ${String(t)}`
      }]
    }
  }
}

function d7(t, e, n, r) {
  const o = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
  let s = X_(t) ? t.message : t,
    i = "Error";
  const a = s.match(o);
  return a && (i = a[1], s = a[2]), LI({
    exception: {
      values: [{
        type: i,
        value: s
      }]
    }
  }, e, n, r)
}

function LI(t, e, n, r) {
  const o = t.exception = t.exception || {},
    s = o.values = o.values || [],
    i = s[0] = s[0] || {},
    a = i.stacktrace = i.stacktrace || {},
    c = a.frames = a.frames || [],
    l = isNaN(parseInt(r, 10)) ? void 0 : r,
    u = isNaN(parseInt(n, 10)) ? void 0 : n,
    d = Fa(e) && e.length > 0 ? e : B6();
  return c.length === 0 && c.push({
    colno: l,
    filename: d,
    function: "?",
    in_app: !0,
    lineno: u
  }), t
}

function f7(t) {
  (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.log(`Global Handler attached: ${t}`)
}

function FI(t, e, n, r) {
  of(n, {
    handled: !1,
    type: r
  }), t.captureEvent(n, {
    originalException: e
  })
}

function BI() {
  const t = Kn(),
    e = t.getClient(),
    n = e && e.getOptions() || {
      stackParser: () => [],
      attachStacktrace: !1
    };
  return [t, n.stackParser, n.attachStacktrace]
}
const h7 = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
class Sy {
  static __initStatic() {
    this.id = "TryCatch"
  }
  constructor(e) {
    this.name = Sy.id, this._options = {
      XMLHttpRequest: !0,
      eventTarget: !0,
      requestAnimationFrame: !0,
      setInterval: !0,
      setTimeout: !0,
      ...e
    }
  }
  setupOnce() {
    this._options.setTimeout && Tn(_t, "setTimeout", Ok), this._options.setInterval && Tn(_t, "setInterval", Ok), this._options.requestAnimationFrame && Tn(_t, "requestAnimationFrame", p7), this._options.XMLHttpRequest && "XMLHttpRequest" in _t && Tn(XMLHttpRequest.prototype, "send", g7);
    const e = this._options.eventTarget;
    e && (Array.isArray(e) ? e : h7).forEach(m7)
  }
}
Sy.__initStatic();

function Ok(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = Kl(n, {
      mechanism: {
        data: {
          function: Bi(t)
        },
        handled: !1,
        type: "instrument"
      }
    }), t.apply(this, e)
  }
}

function p7(t) {
  return function(e) {
    return t.apply(this, [Kl(e, {
      mechanism: {
        data: {
          function: "requestAnimationFrame",
          handler: Bi(t)
        },
        handled: !1,
        type: "instrument"
      }
    })])
  }
}

function g7(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(o => {
      o in n && typeof n[o] == "function" && Tn(n, o, function(s) {
        const i = {
            mechanism: {
              data: {
                function: o,
                handler: Bi(s)
              },
              handled: !1,
              type: "instrument"
            }
          },
          a = J_(s);
        return a && (i.mechanism.data.handler = Bi(a)), Kl(s, i)
      })
    }), t.apply(this, e)
  }
}

function m7(t) {
  const e = _t,
    n = e[t] && e[t].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Tn(n, "addEventListener", function(r) {
    return function(o, s, i) {
      try {
        typeof s.handleEvent == "function" && (s.handleEvent = Kl(s.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Bi(s),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }))
      } catch {}
      return r.apply(this, [o, Kl(s, {
        mechanism: {
          data: {
            function: "addEventListener",
            handler: Bi(s),
            target: t
          },
          handled: !1,
          type: "instrument"
        }
      }), i])
    }
  }), Tn(n, "removeEventListener", function(r) {
    return function(o, s, i) {
      const a = s;
      try {
        const c = a && a.__sentry_wrapped__;
        c && r.call(this, o, c, i)
      } catch {}
      return r.call(this, o, a, i)
    }
  }))
}
const dp = 1024;
class _y {
  static __initStatic() {
    this.id = "Breadcrumbs"
  }
  constructor(e) {
    this.name = _y.id, this.options = {
      console: !0,
      dom: !0,
      fetch: !0,
      history: !0,
      sentry: !0,
      xhr: !0,
      ...e
    }
  }
  setupOnce() {
    if (this.options.console && wi("console", b7), this.options.dom && wi("dom", v7(this.options.dom)), this.options.xhr && wi("xhr", w7), this.options.fetch && wi("fetch", S7), this.options.history && wi("history", _7), this.options.sentry) {
      const e = Kn().getClient();
      e && e.on && e.on("beforeSendEvent", y7)
    }
  }
}
_y.__initStatic();

function y7(t) {
  Kn().addBreadcrumb({
    category: `sentry.${t.type==="transaction"?"transaction":"event"}`,
    event_id: t.event_id,
    level: t.level,
    message: bi(t)
  }, {
    event: t
  })
}

function v7(t) {
  function e(n) {
    let r, o = typeof t == "object" ? t.serializeAttribute : void 0,
      s = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    s && s > dp && ((typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn(`\`dom.maxStringLength\` cannot exceed ${dp}, but a value of ${s} was configured. Sentry will use ${dp} instead.`), s = dp), typeof o == "string" && (o = [o]);
    try {
      const i = n.event;
      r = x7(i) ? lw(i.target, {
        keyAttrs: o,
        maxStringLength: s
      }) : lw(i, {
        keyAttrs: o,
        maxStringLength: s
      })
    } catch {
      r = "<unknown>"
    }
    r.length !== 0 && Kn().addBreadcrumb({
      category: `ui.${n.name}`,
      message: r
    }, {
      event: n.event,
      name: n.name,
      global: n.global
    })
  }
  return e
}

function b7(t) {
  const e = {
    category: "console",
    data: {
      arguments: t.args,
      logger: "console"
    },
    level: EL(t.level),
    message: lk(t.args, " ")
  };
  if (t.level === "assert")
    if (t.args[0] === !1) e.message = `Assertion failed: ${lk(t.args.slice(1)," ")||"console.assert"}`, e.data.arguments = t.args.slice(1);
    else return;
  Kn().addBreadcrumb(e, {
    input: t.args,
    level: t.level
  })
}

function w7(t) {
  const {
    startTimestamp: e,
    endTimestamp: n
  } = t, r = t.xhr[_d];
  if (!e || !n || !r) return;
  const {
    method: o,
    url: s,
    status_code: i,
    body: a
  } = r, c = {
    method: o,
    url: s,
    status_code: i
  }, l = {
    xhr: t.xhr,
    input: a,
    startTimestamp: e,
    endTimestamp: n
  };
  Kn().addBreadcrumb({
    category: "xhr",
    data: c,
    type: "http"
  }, l)
}

function S7(t) {
  const {
    startTimestamp: e,
    endTimestamp: n
  } = t;
  if (n && !(t.fetchData.url.match(/sentry_key/) && t.fetchData.method === "POST"))
    if (t.error) {
      const r = t.fetchData,
        o = {
          data: t.error,
          input: t.args,
          startTimestamp: e,
          endTimestamp: n
        };
      Kn().addBreadcrumb({
        category: "fetch",
        data: r,
        level: "error",
        type: "http"
      }, o)
    } else {
      const r = {
          ...t.fetchData,
          status_code: t.response && t.response.status
        },
        o = {
          input: t.args,
          response: t.response,
          startTimestamp: e,
          endTimestamp: n
        };
      Kn().addBreadcrumb({
        category: "fetch",
        data: r,
        type: "http"
      }, o)
    }
}

function _7(t) {
  let e = t.from,
    n = t.to;
  const r = Zv(_t.location.href);
  let o = Zv(e);
  const s = Zv(n);
  o.path || (o = r), r.protocol === s.protocol && r.host === s.host && (n = s.relative), r.protocol === o.protocol && r.host === o.host && (e = o.relative), Kn().addBreadcrumb({
    category: "navigation",
    data: {
      from: e,
      to: n
    }
  })
}

function x7(t) {
  return !!t && !!t.target
}
const E7 = "cause",
  k7 = 5;
class xy {
  static __initStatic() {
    this.id = "LinkedErrors"
  }
  constructor(e = {}) {
    this.name = xy.id, this._key = e.key || E7, this._limit = e.limit || k7
  }
  setupOnce() {}
  preprocessEvent(e, n, r) {
    const o = r.getOptions();
    j6(DI, o.stackParser, o.maxValueLength, this._key, this._limit, e, n)
  }
}
xy.__initStatic();
class Ey {
  static __initStatic() {
    this.id = "HttpContext"
  }
  constructor() {
    this.name = Ey.id
  }
  setupOnce() {}
  preprocessEvent(e) {
    if (!_t.navigator && !_t.location && !_t.document) return;
    const n = e.request && e.request.url || _t.location && _t.location.href,
      {
        referrer: r
      } = _t.document || {},
      {
        userAgent: o
      } = _t.navigator || {},
      s = {
        ...e.request && e.request.headers,
        ...r && {
          Referer: r
        },
        ...o && {
          "User-Agent": o
        }
      },
      i = {
        ...e.request,
        ...n && {
          url: n
        },
        headers: s
      };
    e.request = i
  }
}
Ey.__initStatic();
class ky {
  static __initStatic() {
    this.id = "Dedupe"
  }
  constructor() {
    this.name = ky.id
  }
  setupOnce(e, n) {}
  processEvent(e) {
    if (e.type) return e;
    try {
      if (C7(e, this._previousEvent)) return (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("Event dropped due to being a duplicate of previously captured event."), null
    } catch {}
    return this._previousEvent = e
  }
}
ky.__initStatic();

function C7(t, e) {
  return e ? !!(P7(t, e) || T7(t, e)) : !1
}

function P7(t, e) {
  const n = t.message,
    r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !zI(t, e) || !UI(t, e))
}

function T7(t, e) {
  const n = Rk(e),
    r = Rk(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !zI(t, e) || !UI(t, e))
}

function UI(t, e) {
  let n = Ak(t),
    r = Ak(e);
  if (!n && !r) return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length)) return !1;
  for (let o = 0; o < r.length; o++) {
    const s = r[o],
      i = n[o];
    if (s.filename !== i.filename || s.lineno !== i.lineno || s.colno !== i.colno || s.function !== i.function) return !1
  }
  return !0
}

function zI(t, e) {
  let n = t.fingerprint,
    r = e.fingerprint;
  if (!n && !r) return !0;
  if (n && !r || !n && r) return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("")
  } catch {
    return !1
  }
}

function Rk(t) {
  return t.exception && t.exception.values && t.exception.values[0]
}

function Ak(t) {
  const e = t.exception;
  if (e) try {
    return e.values[0].stacktrace.frames
  } catch {
    return
  }
}
const $7 = [new by, new vy, new Sy, new _y, new hu, new xy, new ky, new Ey];

function I7(t = {}) {
  t.defaultIntegrations === void 0 && (t.defaultIntegrations = $7), t.release === void 0 && (typeof __SENTRY_RELEASE__ == "string" && (t.release = __SENTRY_RELEASE__), _t.SENTRY_RELEASE && _t.SENTRY_RELEASE.id && (t.release = _t.SENTRY_RELEASE.id)), t.autoSessionTracking === void 0 && (t.autoSessionTracking = !0), t.sendClientReports === void 0 && (t.sendClientReports = !0);
  const e = {
    ...t,
    stackParser: X6(t.stackParser || a7),
    integrations: o8(t),
    transport: t.transport || (xI() ? H8 : W8)
  };
  m8(B8, e), t.autoSessionTracking && O7()
}

function Mk(t) {
  t.startSession({
    ignoreDuration: !0
  }), t.captureSession()
}

function O7() {
  if (typeof _t.document > "u") {
    (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && Ve.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return
  }
  const t = Kn();
  t.captureSession && (Mk(t), wi("history", ({
    from: e,
    to: n
  }) => {
    e === void 0 || e === n || Mk(Kn())
  }))
}

function R7(t) {
  const e = {
    _metadata: {},
    ...t
  };
  e._metadata.sdk = e._metadata.sdk || {
    name: "sentry.javascript.react",
    packages: [{
      name: "npm:@sentry/react",
      version: Kg
    }],
    version: Kg
  }, I7(e)
}
var A7 = "@vercel/analytics",
  M7 = "1.0.1",
  j7 = () => {
    window.va || (window.va = function(...e) {
      (window.vaq = window.vaq || []).push(e)
    })
  };

function D7() {
  return typeof window < "u"
}

function N7() {
  try {
    const t = "production"
  } catch {}
  return "production"
}

function L7(t = "auto") {
  if (t === "auto") {
    window.vam = N7();
    return
  }
  window.vam = t
}

function F7() {
  return window.vam || "production"
}

function jk() {
  return F7() === "development"
}

function B7(t = {
  debug: !0
}) {
  var e;
  if (!D7()) return;
  L7(t.mode), j7(), t.beforeSend && ((e = window.va) == null || e.call(window, "beforeSend", t.beforeSend));
  const n = jk() ? "https://va.vercel-scripts.com/v1/script.debug.js" : "/_vercel/insights/script.js";
  if (document.head.querySelector(`script[src*="${n}"]`)) return;
  const r = document.createElement("script");
  r.src = n, r.defer = !0, r.setAttribute("data-sdkn", A7), r.setAttribute("data-sdkv", M7), jk() && t.debug === !1 && r.setAttribute("data-debug", "false"), document.head.appendChild(r)
}

function U7({
  beforeSend: t,
  debug: e = !0,
  mode: n = "auto"
}) {
  return g.useEffect(() => {
    B7({
      beforeSend: t,
      debug: e,
      mode: n
    })
  }, [t, e, n]), null
}
let Ui = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, n) => (n &= 63, n < 36 ? e += n.toString(36) : n < 62 ? e += (n - 26).toString(36).toUpperCase() : n > 62 ? e += "-" : e += "_", e), "");
var HI = {
    exports: {}
  },
  Ur = {},
  VI = {
    exports: {}
  },
  WI = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
  function e(F, B) {
    var V = F.length;
    F.push(B);
    e: for (; 0 < V;) {
      var J = V - 1 >>> 1,
        ee = F[J];
      if (0 < o(ee, B)) F[J] = B, F[V] = ee, V = J;
      else break e
    }
  }

  function n(F) {
    return F.length === 0 ? null : F[0]
  }

  function r(F) {
    if (F.length === 0) return null;
    var B = F[0],
      V = F.pop();
    if (V !== B) {
      F[0] = V;
      e: for (var J = 0, ee = F.length, ye = ee >>> 1; J < ye;) {
        var ge = 2 * (J + 1) - 1,
          ce = F[ge],
          Ce = ge + 1,
          oe = F[Ce];
        if (0 > o(ce, V)) Ce < ee && 0 > o(oe, ce) ? (F[J] = oe, F[Ce] = V, J = Ce) : (F[J] = ce, F[ge] = V, J = ge);
        else if (Ce < ee && 0 > o(oe, V)) F[J] = oe, F[Ce] = V, J = Ce;
        else break e
      }
    }
    return B
  }

  function o(F, B) {
    var V = F.sortIndex - B.sortIndex;
    return V !== 0 ? V : F.id - B.id
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function() {
      return s.now()
    }
  } else {
    var i = Date,
      a = i.now();
    t.unstable_now = function() {
      return i.now() - a
    }
  }
  var c = [],
    l = [],
    u = 1,
    d = null,
    f = 3,
    h = !1,
    m = !1,
    p = !1,
    b = typeof setTimeout == "function" ? setTimeout : null,
    w = typeof clearTimeout == "function" ? clearTimeout : null,
    v = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

  function _(F) {
    for (var B = n(l); B !== null;) {
      if (B.callback === null) r(l);
      else if (B.startTime <= F) r(l), B.sortIndex = B.expirationTime, e(c, B);
      else break;
      B = n(l)
    }
  }

  function S(F) {
    if (p = !1, _(F), !m)
      if (n(c) !== null) m = !0, N(x);
      else {
        var B = n(l);
        B !== null && q(S, B.startTime - F)
      }
  }

  function x(F, B) {
    m = !1, p && (p = !1, w(C), C = -1), h = !0;
    var V = f;
    try {
      for (_(B), d = n(c); d !== null && (!(d.expirationTime > B) || F && !R());) {
        var J = d.callback;
        if (typeof J == "function") {
          d.callback = null, f = d.priorityLevel;
          var ee = J(d.expirationTime <= B);
          B = t.unstable_now(), typeof ee == "function" ? d.callback = ee : d === n(c) && r(c), _(B)
        } else r(c);
        d = n(c)
      }
      if (d !== null) var ye = !0;
      else {
        var ge = n(l);
        ge !== null && q(S, ge.startTime - B), ye = !1
      }
      return ye
    } finally {
      d = null, f = V, h = !1
    }
  }
  var E = !1,
    k = null,
    C = -1,
    $ = 5,
    I = -1;

  function R() {
    return !(t.unstable_now() - I < $)
  }

  function M() {
    if (k !== null) {
      var F = t.unstable_now();
      I = F;
      var B = !0;
      try {
        B = k(!0, F)
      } finally {
        B ? j() : (E = !1, k = null)
      }
    } else E = !1
  }
  var j;
  if (typeof v == "function") j = function() {
    v(M)
  };
  else if (typeof MessageChannel < "u") {
    var A = new MessageChannel,
      D = A.port2;
    A.port1.onmessage = M, j = function() {
      D.postMessage(null)
    }
  } else j = function() {
    b(M, 0)
  };

  function N(F) {
    k = F, E || (E = !0, j())
  }

  function q(F, B) {
    C = b(function() {
      F(t.unstable_now())
    }, B)
  }
  t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(F) {
    F.callback = null
  }, t.unstable_continueExecution = function() {
    m || h || (m = !0, N(x))
  }, t.unstable_forceFrameRate = function(F) {
    0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : $ = 0 < F ? Math.floor(1e3 / F) : 5
  }, t.unstable_getCurrentPriorityLevel = function() {
    return f
  }, t.unstable_getFirstCallbackNode = function() {
    return n(c)
  }, t.unstable_next = function(F) {
    switch (f) {
      case 1:
      case 2:
      case 3:
        var B = 3;
        break;
      default:
        B = f
    }
    var V = f;
    f = B;
    try {
      return F()
    } finally {
      f = V
    }
  }, t.unstable_pauseExecution = function() {}, t.unstable_requestPaint = function() {}, t.unstable_runWithPriority = function(F, B) {
    switch (F) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        F = 3
    }
    var V = f;
    f = F;
    try {
      return B()
    } finally {
      f = V
    }
  }, t.unstable_scheduleCallback = function(F, B, V) {
    var J = t.unstable_now();
    switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? J + V : J) : V = J, F) {
      case 1:
        var ee = -1;
        break;
      case 2:
        ee = 250;
        break;
      case 5:
        ee = 1073741823;
        break;
      case 4:
        ee = 1e4;
        break;
      default:
        ee = 5e3
    }
    return ee = V + ee, F = {
      id: u++,
      callback: B,
      priorityLevel: F,
      startTime: V,
      expirationTime: ee,
      sortIndex: -1
    }, V > J ? (F.sortIndex = V, e(l, F), n(c) === null && F === n(l) && (p ? (w(C), C = -1) : p = !0, q(S, V - J))) : (F.sortIndex = ee, e(c, F), m || h || (m = !0, N(x))), F
  }, t.unstable_shouldYield = R, t.unstable_wrapCallback = function(F) {
    var B = f;
    return function() {
      var V = f;
      f = B;
      try {
        return F.apply(this, arguments)
      } finally {
        f = V
      }
    }
  }
})(WI);
VI.exports = WI;
var z7 = VI.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var KI = g,
  Br = z7;

function ne(t) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++) e += "&args[]=" + encodeURIComponent(arguments[n]);
  return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var GI = new Set,
  sf = {};

function cc(t, e) {
  Gl(t, e), Gl(t + "Capture", e)
}

function Gl(t, e) {
  for (sf[t] = e, t = 0; t < e.length; t++) GI.add(e[t])
}
var Vs = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
  Ew = Object.prototype.hasOwnProperty,
  H7 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Dk = {},
  Nk = {};

function V7(t) {
  return Ew.call(Nk, t) ? !0 : Ew.call(Dk, t) ? !1 : H7.test(t) ? Nk[t] = !0 : (Dk[t] = !0, !1)
}

function W7(t, e, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
    default:
      return !1
  }
}

function K7(t, e, n, r) {
  if (e === null || typeof e > "u" || W7(t, e, n, r)) return !0;
  if (r) return !1;
  if (n !== null) switch (n.type) {
    case 3:
      return !e;
    case 4:
      return e === !1;
    case 5:
      return isNaN(e);
    case 6:
      return isNaN(e) || 1 > e
  }
  return !1
}

function ar(t, e, n, r, o, s, i) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = i
}
var On = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
  On[t] = new ar(t, 0, !1, t, null, !1, !1)
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(function(t) {
  var e = t[0];
  On[e] = new ar(e, 1, !1, t[1], null, !1, !1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
  On[t] = new ar(t, 2, !1, t.toLowerCase(), null, !1, !1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
  On[t] = new ar(t, 2, !1, t, null, !1, !1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
  On[t] = new ar(t, 3, !1, t.toLowerCase(), null, !1, !1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
  On[t] = new ar(t, 3, !0, t, null, !1, !1)
});
["capture", "download"].forEach(function(t) {
  On[t] = new ar(t, 4, !1, t, null, !1, !1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
  On[t] = new ar(t, 6, !1, t, null, !1, !1)
});
["rowSpan", "start"].forEach(function(t) {
  On[t] = new ar(t, 5, !1, t.toLowerCase(), null, !1, !1)
});
var ix = /[\-:]([a-z])/g;

function ax(t) {
  return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
  var e = t.replace(ix, ax);
  On[e] = new ar(e, 1, !1, t, null, !1, !1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
  var e = t.replace(ix, ax);
  On[e] = new ar(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
  var e = t.replace(ix, ax);
  On[e] = new ar(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
  On[t] = new ar(t, 1, !1, t.toLowerCase(), null, !1, !1)
});
On.xlinkHref = new ar("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
  On[t] = new ar(t, 1, !1, t.toLowerCase(), null, !0, !0)
});

function cx(t, e, n, r) {
  var o = On.hasOwnProperty(e) ? On[e] : null;
  (o !== null ? o.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (K7(e, n, o, r) && (n = null), r || o === null ? V7(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : o.mustUseProperty ? t[o.propertyName] = n === null ? o.type === 3 ? !1 : "" : n : (e = o.attributeName, r = o.attributeNamespace, n === null ? t.removeAttribute(e) : (o = o.type, n = o === 3 || o === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n))))
}
var ti = KI.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  fp = Symbol.for("react.element"),
  el = Symbol.for("react.portal"),
  tl = Symbol.for("react.fragment"),
  lx = Symbol.for("react.strict_mode"),
  kw = Symbol.for("react.profiler"),
  YI = Symbol.for("react.provider"),
  qI = Symbol.for("react.context"),
  ux = Symbol.for("react.forward_ref"),
  Cw = Symbol.for("react.suspense"),
  Pw = Symbol.for("react.suspense_list"),
  dx = Symbol.for("react.memo"),
  gi = Symbol.for("react.lazy"),
  XI = Symbol.for("react.offscreen"),
  Lk = Symbol.iterator;

function Hu(t) {
  return t === null || typeof t != "object" ? null : (t = Lk && t[Lk] || t["@@iterator"], typeof t == "function" ? t : null)
}
var Wt = Object.assign,
  e0;

function Ed(t) {
  if (e0 === void 0) try {
    throw Error()
  } catch (n) {
    var e = n.stack.trim().match(/\n( *(at )?)/);
    e0 = e && e[1] || ""
  }
  return `
` + e0 + t
}
var t0 = !1;

function n0(t, e) {
  if (!t || t0) return "";
  t0 = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (e = function() {
          throw Error()
        }, Object.defineProperty(e.prototype, "props", {
          set: function() {
            throw Error()
          }
        }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(e, [])
        } catch (l) {
          var r = l
        }
        Reflect.construct(t, [], e)
      } else {
        try {
          e.call()
        } catch (l) {
          r = l
        }
        t.call(e.prototype)
      }
    else {
      try {
        throw Error()
      } catch (l) {
        r = l
      }
      t()
    }
  } catch (l) {
    if (l && r && typeof l.stack == "string") {
      for (var o = l.stack.split(`
`), s = r.stack.split(`
`), i = o.length - 1, a = s.length - 1; 1 <= i && 0 <= a && o[i] !== s[a];) a--;
      for (; 1 <= i && 0 <= a; i--, a--)
        if (o[i] !== s[a]) {
          if (i !== 1 || a !== 1)
            do
              if (i--, a--, 0 > a || o[i] !== s[a]) {
                var c = `
` + o[i].replace(" at new ", " at ");
                return t.displayName && c.includes("<anonymous>") && (c = c.replace("<anonymous>", t.displayName)), c
              } while (1 <= i && 0 <= a);
          break
        }
    }
  } finally {
    t0 = !1, Error.prepareStackTrace = n
  }
  return (t = t ? t.displayName || t.name : "") ? Ed(t) : ""
}

function G7(t) {
  switch (t.tag) {
    case 5:
      return Ed(t.type);
    case 16:
      return Ed("Lazy");
    case 13:
      return Ed("Suspense");
    case 19:
      return Ed("SuspenseList");
    case 0:
    case 2:
    case 15:
      return t = n0(t.type, !1), t;
    case 11:
      return t = n0(t.type.render, !1), t;
    case 1:
      return t = n0(t.type, !0), t;
    default:
      return ""
  }
}

function Tw(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case tl:
      return "Fragment";
    case el:
      return "Portal";
    case kw:
      return "Profiler";
    case lx:
      return "StrictMode";
    case Cw:
      return "Suspense";
    case Pw:
      return "SuspenseList"
  }
  if (typeof t == "object") switch (t.$$typeof) {
    case qI:
      return (t.displayName || "Context") + ".Consumer";
    case YI:
      return (t._context.displayName || "Context") + ".Provider";
    case ux:
      var e = t.render;
      return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
    case dx:
      return e = t.displayName || null, e !== null ? e : Tw(t.type) || "Memo";
    case gi:
      e = t._payload, t = t._init;
      try {
        return Tw(t(e))
      } catch {}
  }
  return null
}

function Y7(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Tw(e);
    case 8:
      return e === lx ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e
  }
  return null
}

function zi(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return ""
  }
}

function ZI(t) {
  var e = t.type;
  return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}

function q7(t) {
  var e = ZI(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    r = "" + t[e];
  if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") {
    var o = n.get,
      s = n.set;
    return Object.defineProperty(t, e, {
      configurable: !0,
      get: function() {
        return o.call(this)
      },
      set: function(i) {
        r = "" + i, s.call(this, i)
      }
    }), Object.defineProperty(t, e, {
      enumerable: n.enumerable
    }), {
      getValue: function() {
        return r
      },
      setValue: function(i) {
        r = "" + i
      },
      stopTracking: function() {
        t._valueTracker = null, delete t[e]
      }
    }
  }
}

function hp(t) {
  t._valueTracker || (t._valueTracker = q7(t))
}

function JI(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    r = "";
  return t && (r = ZI(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1
}

function Yg(t) {
  if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null;
  try {
    return t.activeElement || t.body
  } catch {
    return t.body
  }
}

function $w(t, e) {
  var n = e.checked;
  return Wt({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked
  })
}

function Fk(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    r = e.checked != null ? e.checked : e.defaultChecked;
  n = zi(e.value != null ? e.value : n), t._wrapperState = {
    initialChecked: r,
    initialValue: n,
    controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
  }
}

function QI(t, e) {
  e = e.checked, e != null && cx(t, "checked", e, !1)
}

function Iw(t, e) {
  QI(t, e);
  var n = zi(e.value),
    r = e.type;
  if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n);
  else if (r === "submit" || r === "reset") {
    t.removeAttribute("value");
    return
  }
  e.hasOwnProperty("value") ? Ow(t, e.type, n) : e.hasOwnProperty("defaultValue") && Ow(t, e.type, zi(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}

function Bk(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var r = e.type;
    if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return;
    e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e
  }
  n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n)
}

function Ow(t, e, n) {
  (e !== "number" || Yg(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n))
}
var kd = Array.isArray;

function Pl(t, e, n, r) {
  if (t = t.options, e) {
    e = {};
    for (var o = 0; o < n.length; o++) e["$" + n[o]] = !0;
    for (n = 0; n < t.length; n++) o = e.hasOwnProperty("$" + t[n].value), t[n].selected !== o && (t[n].selected = o), o && r && (t[n].defaultSelected = !0)
  } else {
    for (n = "" + zi(n), e = null, o = 0; o < t.length; o++) {
      if (t[o].value === n) {
        t[o].selected = !0, r && (t[o].defaultSelected = !0);
        return
      }
      e !== null || t[o].disabled || (e = t[o])
    }
    e !== null && (e.selected = !0)
  }
}

function Rw(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(ne(91));
  return Wt({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue
  })
}

function Uk(t, e) {
  var n = e.value;
  if (n == null) {
    if (n = e.children, e = e.defaultValue, n != null) {
      if (e != null) throw Error(ne(92));
      if (kd(n)) {
        if (1 < n.length) throw Error(ne(93));
        n = n[0]
      }
      e = n
    }
    e == null && (e = ""), n = e
  }
  t._wrapperState = {
    initialValue: zi(n)
  }
}

function eO(t, e) {
  var n = zi(e.value),
    r = zi(e.defaultValue);
  n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r)
}

function zk(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}

function tO(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml"
  }
}

function Aw(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml" ? tO(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var pp, nO = function(t) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, n, r, o) {
    MSApp.execUnsafeLocalFunction(function() {
      return t(e, n, r, o)
    })
  } : t
}(function(t, e) {
  if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
  else {
    for (pp = pp || document.createElement("div"), pp.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = pp.firstChild; t.firstChild;) t.removeChild(t.firstChild);
    for (; e.firstChild;) t.appendChild(e.firstChild)
  }
});

function af(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return
    }
  }
  t.textContent = e
}
var Dd = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
  X7 = ["Webkit", "ms", "Moz", "O"];
Object.keys(Dd).forEach(function(t) {
  X7.forEach(function(e) {
    e = e + t.charAt(0).toUpperCase() + t.substring(1), Dd[e] = Dd[t]
  })
});

function rO(t, e, n) {
  return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || Dd.hasOwnProperty(t) && Dd[t] ? ("" + e).trim() : e + "px"
}

function oO(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        o = rO(n, e[n], r);
      n === "float" && (n = "cssFloat"), r ? t.setProperty(n, o) : t[n] = o
    }
}
var Z7 = Wt({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function Mw(t, e) {
  if (e) {
    if (Z7[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(ne(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(ne(60));
      if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(ne(61))
    }
    if (e.style != null && typeof e.style != "object") throw Error(ne(62))
  }
}

function jw(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0
  }
}
var Dw = null;

function fx(t) {
  return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t
}
var Nw = null,
  Tl = null,
  $l = null;

function Hk(t) {
  if (t = gh(t)) {
    if (typeof Nw != "function") throw Error(ne(280));
    var e = t.stateNode;
    e && (e = Iy(e), Nw(t.stateNode, t.type, e))
  }
}

function sO(t) {
  Tl ? $l ? $l.push(t) : $l = [t] : Tl = t
}

function iO() {
  if (Tl) {
    var t = Tl,
      e = $l;
    if ($l = Tl = null, Hk(t), e)
      for (t = 0; t < e.length; t++) Hk(e[t])
  }
}

function aO(t, e) {
  return t(e)
}

function cO() {}
var r0 = !1;

function lO(t, e, n) {
  if (r0) return t(e, n);
  r0 = !0;
  try {
    return aO(t, e, n)
  } finally {
    r0 = !1, (Tl !== null || $l !== null) && (cO(), iO())
  }
}

function cf(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var r = Iy(n);
  if (r === null) return null;
  n = r[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r;
      break e;
    default:
      t = !1
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(ne(231, e, typeof n));
  return n
}
var Lw = !1;
if (Vs) try {
  var Vu = {};
  Object.defineProperty(Vu, "passive", {
    get: function() {
      Lw = !0
    }
  }), window.addEventListener("test", Vu, Vu), window.removeEventListener("test", Vu, Vu)
} catch {
  Lw = !1
}

function J7(t, e, n, r, o, s, i, a, c) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, l)
  } catch (u) {
    this.onError(u)
  }
}
var Nd = !1,
  qg = null,
  Xg = !1,
  Fw = null,
  Q7 = {
    onError: function(t) {
      Nd = !0, qg = t
    }
  };

function e9(t, e, n, r, o, s, i, a, c) {
  Nd = !1, qg = null, J7.apply(Q7, arguments)
}

function t9(t, e, n, r, o, s, i, a, c) {
  if (e9.apply(this, arguments), Nd) {
    if (Nd) {
      var l = qg;
      Nd = !1, qg = null
    } else throw Error(ne(198));
    Xg || (Xg = !0, Fw = l)
  }
}

function lc(t) {
  var e = t,
    n = t;
  if (t.alternate)
    for (; e.return;) e = e.return;
  else {
    t = e;
    do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t)
  }
  return e.tag === 3 ? n : null
}

function uO(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated
  }
  return null
}

function Vk(t) {
  if (lc(t) !== t) throw Error(ne(188))
}

function n9(t) {
  var e = t.alternate;
  if (!e) {
    if (e = lc(t), e === null) throw Error(ne(188));
    return e !== t ? null : t
  }
  for (var n = t, r = e;;) {
    var o = n.return;
    if (o === null) break;
    var s = o.alternate;
    if (s === null) {
      if (r = o.return, r !== null) {
        n = r;
        continue
      }
      break
    }
    if (o.child === s.child) {
      for (s = o.child; s;) {
        if (s === n) return Vk(o), t;
        if (s === r) return Vk(o), e;
        s = s.sibling
      }
      throw Error(ne(188))
    }
    if (n.return !== r.return) n = o, r = s;
    else {
      for (var i = !1, a = o.child; a;) {
        if (a === n) {
          i = !0, n = o, r = s;
          break
        }
        if (a === r) {
          i = !0, r = o, n = s;
          break
        }
        a = a.sibling
      }
      if (!i) {
        for (a = s.child; a;) {
          if (a === n) {
            i = !0, n = s, r = o;
            break
          }
          if (a === r) {
            i = !0, r = s, n = o;
            break
          }
          a = a.sibling
        }
        if (!i) throw Error(ne(189))
      }
    }
    if (n.alternate !== r) throw Error(ne(190))
  }
  if (n.tag !== 3) throw Error(ne(188));
  return n.stateNode.current === n ? t : e
}

function dO(t) {
  return t = n9(t), t !== null ? fO(t) : null
}

function fO(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null;) {
    var e = fO(t);
    if (e !== null) return e;
    t = t.sibling
  }
  return null
}
var hO = Br.unstable_scheduleCallback,
  Wk = Br.unstable_cancelCallback,
  r9 = Br.unstable_shouldYield,
  o9 = Br.unstable_requestPaint,
  nn = Br.unstable_now,
  s9 = Br.unstable_getCurrentPriorityLevel,
  hx = Br.unstable_ImmediatePriority,
  pO = Br.unstable_UserBlockingPriority,
  Zg = Br.unstable_NormalPriority,
  i9 = Br.unstable_LowPriority,
  gO = Br.unstable_IdlePriority,
  Cy = null,
  as = null;

function a9(t) {
  if (as && typeof as.onCommitFiberRoot == "function") try {
    as.onCommitFiberRoot(Cy, t, void 0, (t.current.flags & 128) === 128)
  } catch {}
}
var Oo = Math.clz32 ? Math.clz32 : u9,
  c9 = Math.log,
  l9 = Math.LN2;

function u9(t) {
  return t >>>= 0, t === 0 ? 32 : 31 - (c9(t) / l9 | 0) | 0
}
var gp = 64,
  mp = 4194304;

function Cd(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t
  }
}

function Jg(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    o = t.suspendedLanes,
    s = t.pingedLanes,
    i = n & 268435455;
  if (i !== 0) {
    var a = i & ~o;
    a !== 0 ? r = Cd(a) : (s &= i, s !== 0 && (r = Cd(s)))
  } else i = n & ~o, i !== 0 ? r = Cd(i) : s !== 0 && (r = Cd(s));
  if (r === 0) return 0;
  if (e !== 0 && e !== r && !(e & o) && (o = r & -r, s = e & -e, o >= s || o === 16 && (s & 4194240) !== 0)) return e;
  if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0)
    for (t = t.entanglements, e &= r; 0 < e;) n = 31 - Oo(e), o = 1 << n, r |= t[n], e &= ~o;
  return r
}

function d9(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1
  }
}

function f9(t, e) {
  for (var n = t.suspendedLanes, r = t.pingedLanes, o = t.expirationTimes, s = t.pendingLanes; 0 < s;) {
    var i = 31 - Oo(s),
      a = 1 << i,
      c = o[i];
    c === -1 ? (!(a & n) || a & r) && (o[i] = d9(a, e)) : c <= e && (t.expiredLanes |= a), s &= ~a
  }
}

function Bw(t) {
  return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}

function mO() {
  var t = gp;
  return gp <<= 1, !(gp & 4194240) && (gp = 64), t
}

function o0(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e
}

function hh(t, e, n) {
  t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - Oo(e), t[e] = n
}

function h9(t, e) {
  var n = t.pendingLanes & ~e;
  t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
  var r = t.eventTimes;
  for (t = t.expirationTimes; 0 < n;) {
    var o = 31 - Oo(n),
      s = 1 << o;
    e[o] = 0, r[o] = -1, t[o] = -1, n &= ~s
  }
}

function px(t, e) {
  var n = t.entangledLanes |= e;
  for (t = t.entanglements; n;) {
    var r = 31 - Oo(n),
      o = 1 << r;
    o & e | t[r] & e && (t[r] |= e), n &= ~o
  }
}
var vt = 0;

function yO(t) {
  return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var vO, gx, bO, wO, SO, Uw = !1,
  yp = [],
  $i = null,
  Ii = null,
  Oi = null,
  lf = new Map,
  uf = new Map,
  Si = [],
  p9 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function Kk(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      $i = null;
      break;
    case "dragenter":
    case "dragleave":
      Ii = null;
      break;
    case "mouseover":
    case "mouseout":
      Oi = null;
      break;
    case "pointerover":
    case "pointerout":
      lf.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      uf.delete(e.pointerId)
  }
}

function Wu(t, e, n, r, o, s) {
  return t === null || t.nativeEvent !== s ? (t = {
    blockedOn: e,
    domEventName: n,
    eventSystemFlags: r,
    nativeEvent: s,
    targetContainers: [o]
  }, e !== null && (e = gh(e), e !== null && gx(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, o !== null && e.indexOf(o) === -1 && e.push(o), t)
}

function g9(t, e, n, r, o) {
  switch (e) {
    case "focusin":
      return $i = Wu($i, t, e, n, r, o), !0;
    case "dragenter":
      return Ii = Wu(Ii, t, e, n, r, o), !0;
    case "mouseover":
      return Oi = Wu(Oi, t, e, n, r, o), !0;
    case "pointerover":
      var s = o.pointerId;
      return lf.set(s, Wu(lf.get(s) || null, t, e, n, r, o)), !0;
    case "gotpointercapture":
      return s = o.pointerId, uf.set(s, Wu(uf.get(s) || null, t, e, n, r, o)), !0
  }
  return !1
}

function _O(t) {
  var e = ka(t.target);
  if (e !== null) {
    var n = lc(e);
    if (n !== null) {
      if (e = n.tag, e === 13) {
        if (e = uO(n), e !== null) {
          t.blockedOn = e, SO(t.priority, function() {
            bO(n)
          });
          return
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return
      }
    }
  }
  t.blockedOn = null
}

function gg(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length;) {
    var n = zw(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var r = new n.constructor(n.type, n);
      Dw = r, n.target.dispatchEvent(r), Dw = null
    } else return e = gh(n), e !== null && gx(e), t.blockedOn = n, !1;
    e.shift()
  }
  return !0
}

function Gk(t, e, n) {
  gg(t) && n.delete(e)
}

function m9() {
  Uw = !1, $i !== null && gg($i) && ($i = null), Ii !== null && gg(Ii) && (Ii = null), Oi !== null && gg(Oi) && (Oi = null), lf.forEach(Gk), uf.forEach(Gk)
}

function Ku(t, e) {
  t.blockedOn === e && (t.blockedOn = null, Uw || (Uw = !0, Br.unstable_scheduleCallback(Br.unstable_NormalPriority, m9)))
}

function df(t) {
  function e(o) {
    return Ku(o, t)
  }
  if (0 < yp.length) {
    Ku(yp[0], t);
    for (var n = 1; n < yp.length; n++) {
      var r = yp[n];
      r.blockedOn === t && (r.blockedOn = null)
    }
  }
  for ($i !== null && Ku($i, t), Ii !== null && Ku(Ii, t), Oi !== null && Ku(Oi, t), lf.forEach(e), uf.forEach(e), n = 0; n < Si.length; n++) r = Si[n], r.blockedOn === t && (r.blockedOn = null);
  for (; 0 < Si.length && (n = Si[0], n.blockedOn === null);) _O(n), n.blockedOn === null && Si.shift()
}
var Il = ti.ReactCurrentBatchConfig,
  Qg = !0;

function y9(t, e, n, r) {
  var o = vt,
    s = Il.transition;
  Il.transition = null;
  try {
    vt = 1, mx(t, e, n, r)
  } finally {
    vt = o, Il.transition = s
  }
}

function v9(t, e, n, r) {
  var o = vt,
    s = Il.transition;
  Il.transition = null;
  try {
    vt = 4, mx(t, e, n, r)
  } finally {
    vt = o, Il.transition = s
  }
}

function mx(t, e, n, r) {
  if (Qg) {
    var o = zw(t, e, n, r);
    if (o === null) p0(t, e, r, em, n), Kk(t, r);
    else if (g9(o, t, e, n, r)) r.stopPropagation();
    else if (Kk(t, r), e & 4 && -1 < p9.indexOf(t)) {
      for (; o !== null;) {
        var s = gh(o);
        if (s !== null && vO(s), s = zw(t, e, n, r), s === null && p0(t, e, r, em, n), s === o) break;
        o = s
      }
      o !== null && r.stopPropagation()
    } else p0(t, e, r, null, n)
  }
}
var em = null;

function zw(t, e, n, r) {
  if (em = null, t = fx(r), t = ka(t), t !== null)
    if (e = lc(t), e === null) t = null;
    else if (n = e.tag, n === 13) {
    if (t = uO(e), t !== null) return t;
    t = null
  } else if (n === 3) {
    if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
    t = null
  } else e !== t && (t = null);
  return em = t, null
}

function xO(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (s9()) {
        case hx:
          return 1;
        case pO:
          return 4;
        case Zg:
        case i9:
          return 16;
        case gO:
          return 536870912;
        default:
          return 16
      }
    default:
      return 16
  }
}
var ki = null,
  yx = null,
  mg = null;

function EO() {
  if (mg) return mg;
  var t, e = yx,
    n = e.length,
    r, o = "value" in ki ? ki.value : ki.textContent,
    s = o.length;
  for (t = 0; t < n && e[t] === o[t]; t++);
  var i = n - t;
  for (r = 1; r <= i && e[n - r] === o[s - r]; r++);
  return mg = o.slice(t, 1 < r ? 1 - r : void 0)
}

function yg(t) {
  var e = t.keyCode;
  return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0
}

function vp() {
  return !0
}

function Yk() {
  return !1
}

function zr(t) {
  function e(n, r, o, s, i) {
    this._reactName = n, this._targetInst = o, this.type = r, this.nativeEvent = s, this.target = i, this.currentTarget = null;
    for (var a in t) t.hasOwnProperty(a) && (n = t[a], this[a] = n ? n(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? vp : Yk, this.isPropagationStopped = Yk, this
  }
  return Wt(e.prototype, {
    preventDefault: function() {
      this.defaultPrevented = !0;
      var n = this.nativeEvent;
      n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = vp)
    },
    stopPropagation: function() {
      var n = this.nativeEvent;
      n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = vp)
    },
    persist: function() {},
    isPersistent: vp
  }), e
}
var pu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
      return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
  vx = zr(pu),
  ph = Wt({}, pu, {
    view: 0,
    detail: 0
  }),
  b9 = zr(ph),
  s0, i0, Gu, Py = Wt({}, ph, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: bx,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
      return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
      return "movementX" in t ? t.movementX : (t !== Gu && (Gu && t.type === "mousemove" ? (s0 = t.screenX - Gu.screenX, i0 = t.screenY - Gu.screenY) : i0 = s0 = 0, Gu = t), s0)
    },
    movementY: function(t) {
      return "movementY" in t ? t.movementY : i0
    }
  }),
  qk = zr(Py),
  w9 = Wt({}, Py, {
    dataTransfer: 0
  }),
  S9 = zr(w9),
  _9 = Wt({}, ph, {
    relatedTarget: 0
  }),
  a0 = zr(_9),
  x9 = Wt({}, pu, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  E9 = zr(x9),
  k9 = Wt({}, pu, {
    clipboardData: function(t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData
    }
  }),
  C9 = zr(k9),
  P9 = Wt({}, pu, {
    data: 0
  }),
  Xk = zr(P9),
  T9 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
  $9 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
  I9 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };

function O9(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = I9[t]) ? !!e[t] : !1
}

function bx() {
  return O9
}
var R9 = Wt({}, ph, {
    key: function(t) {
      if (t.key) {
        var e = T9[t.key] || t.key;
        if (e !== "Unidentified") return e
      }
      return t.type === "keypress" ? (t = yg(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? $9[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: bx,
    charCode: function(t) {
      return t.type === "keypress" ? yg(t) : 0
    },
    keyCode: function(t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
      return t.type === "keypress" ? yg(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
  }),
  A9 = zr(R9),
  M9 = Wt({}, Py, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
  Zk = zr(M9),
  j9 = Wt({}, ph, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: bx
  }),
  D9 = zr(j9),
  N9 = Wt({}, pu, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
  L9 = zr(N9),
  F9 = Wt({}, Py, {
    deltaX: function(t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
      return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
  }),
  B9 = zr(F9),
  U9 = [9, 13, 27, 32],
  wx = Vs && "CompositionEvent" in window,
  Ld = null;
Vs && "documentMode" in document && (Ld = document.documentMode);
var z9 = Vs && "TextEvent" in window && !Ld,
  kO = Vs && (!wx || Ld && 8 < Ld && 11 >= Ld),
  Jk = String.fromCharCode(32),
  Qk = !1;

function CO(t, e) {
  switch (t) {
    case "keyup":
      return U9.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1
  }
}

function PO(t) {
  return t = t.detail, typeof t == "object" && "data" in t ? t.data : null
}
var nl = !1;

function H9(t, e) {
  switch (t) {
    case "compositionend":
      return PO(e);
    case "keypress":
      return e.which !== 32 ? null : (Qk = !0, Jk);
    case "textInput":
      return t = e.data, t === Jk && Qk ? null : t;
    default:
      return null
  }
}

function V9(t, e) {
  if (nl) return t === "compositionend" || !wx && CO(t, e) ? (t = EO(), mg = yx = ki = null, nl = !1, t) : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which)
      }
      return null;
    case "compositionend":
      return kO && e.locale !== "ko" ? null : e.data;
    default:
      return null
  }
}
var W9 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function eC(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!W9[t.type] : e === "textarea"
}

function TO(t, e, n, r) {
  sO(r), e = tm(e, "onChange"), 0 < e.length && (n = new vx("onChange", "change", null, n, r), t.push({
    event: n,
    listeners: e
  }))
}
var Fd = null,
  ff = null;

function K9(t) {
  FO(t, 0)
}

function Ty(t) {
  var e = sl(t);
  if (JI(e)) return t
}

function G9(t, e) {
  if (t === "change") return e
}
var $O = !1;
if (Vs) {
  var c0;
  if (Vs) {
    var l0 = "oninput" in document;
    if (!l0) {
      var tC = document.createElement("div");
      tC.setAttribute("oninput", "return;"), l0 = typeof tC.oninput == "function"
    }
    c0 = l0
  } else c0 = !1;
  $O = c0 && (!document.documentMode || 9 < document.documentMode)
}

function nC() {
  Fd && (Fd.detachEvent("onpropertychange", IO), ff = Fd = null)
}

function IO(t) {
  if (t.propertyName === "value" && Ty(ff)) {
    var e = [];
    TO(e, ff, t, fx(t)), lO(K9, e)
  }
}

function Y9(t, e, n) {
  t === "focusin" ? (nC(), Fd = e, ff = n, Fd.attachEvent("onpropertychange", IO)) : t === "focusout" && nC()
}

function q9(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown") return Ty(ff)
}

function X9(t, e) {
  if (t === "click") return Ty(e)
}

function Z9(t, e) {
  if (t === "input" || t === "change") return Ty(e)
}

function J9(t, e) {
  return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var Lo = typeof Object.is == "function" ? Object.is : J9;

function hf(t, e) {
  if (Lo(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
  var n = Object.keys(t),
    r = Object.keys(e);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var o = n[r];
    if (!Ew.call(e, o) || !Lo(t[o], e[o])) return !1
  }
  return !0
}

function rC(t) {
  for (; t && t.firstChild;) t = t.firstChild;
  return t
}

function oC(t, e) {
  var n = rC(t);
  t = 0;
  for (var r; n;) {
    if (n.nodeType === 3) {
      if (r = t + n.textContent.length, t <= e && r >= e) return {
        node: n,
        offset: e - t
      };
      t = r
    }
    e: {
      for (; n;) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e
        }
        n = n.parentNode
      }
      n = void 0
    }
    n = rC(n)
  }
}

function OO(t, e) {
  return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? OO(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}

function RO() {
  for (var t = window, e = Yg(); e instanceof t.HTMLIFrameElement;) {
    try {
      var n = typeof e.contentWindow.location.href == "string"
    } catch {
      n = !1
    }
    if (n) t = e.contentWindow;
    else break;
    e = Yg(t.document)
  }
  return e
}

function Sx(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}

function Q9(t) {
  var e = RO(),
    n = t.focusedElem,
    r = t.selectionRange;
  if (e !== n && n && n.ownerDocument && OO(n.ownerDocument.documentElement, n)) {
    if (r !== null && Sx(n)) {
      if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length);
      else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) {
        t = t.getSelection();
        var o = n.textContent.length,
          s = Math.min(r.start, o);
        r = r.end === void 0 ? s : Math.min(r.end, o), !t.extend && s > r && (o = r, r = s, s = o), o = oC(n, s);
        var i = oC(n, r);
        o && i && (t.rangeCount !== 1 || t.anchorNode !== o.node || t.anchorOffset !== o.offset || t.focusNode !== i.node || t.focusOffset !== i.offset) && (e = e.createRange(), e.setStart(o.node, o.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(i.node, i.offset)) : (e.setEnd(i.node, i.offset), t.addRange(e)))
      }
    }
    for (e = [], t = n; t = t.parentNode;) t.nodeType === 1 && e.push({
      element: t,
      left: t.scrollLeft,
      top: t.scrollTop
    });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++) t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top
  }
}
var eF = Vs && "documentMode" in document && 11 >= document.documentMode,
  rl = null,
  Hw = null,
  Bd = null,
  Vw = !1;

function sC(t, e, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  Vw || rl == null || rl !== Yg(r) || (r = rl, "selectionStart" in r && Sx(r) ? r = {
    start: r.selectionStart,
    end: r.selectionEnd
  } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = {
    anchorNode: r.anchorNode,
    anchorOffset: r.anchorOffset,
    focusNode: r.focusNode,
    focusOffset: r.focusOffset
  }), Bd && hf(Bd, r) || (Bd = r, r = tm(Hw, "onSelect"), 0 < r.length && (e = new vx("onSelect", "select", null, e, n), t.push({
    event: e,
    listeners: r
  }), e.target = rl)))
}

function bp(t, e) {
  var n = {};
  return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n
}
var ol = {
    animationend: bp("Animation", "AnimationEnd"),
    animationiteration: bp("Animation", "AnimationIteration"),
    animationstart: bp("Animation", "AnimationStart"),
    transitionend: bp("Transition", "TransitionEnd")
  },
  u0 = {},
  AO = {};
Vs && (AO = document.createElement("div").style, "AnimationEvent" in window || (delete ol.animationend.animation, delete ol.animationiteration.animation, delete ol.animationstart.animation), "TransitionEvent" in window || delete ol.transitionend.transition);

function $y(t) {
  if (u0[t]) return u0[t];
  if (!ol[t]) return t;
  var e = ol[t],
    n;
  for (n in e)
    if (e.hasOwnProperty(n) && n in AO) return u0[t] = e[n];
  return t
}
var MO = $y("animationend"),
  jO = $y("animationiteration"),
  DO = $y("animationstart"),
  NO = $y("transitionend"),
  LO = new Map,
  iC = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");

function Ji(t, e) {
  LO.set(t, e), cc(e, [t])
}
for (var d0 = 0; d0 < iC.length; d0++) {
  var f0 = iC[d0],
    tF = f0.toLowerCase(),
    nF = f0[0].toUpperCase() + f0.slice(1);
  Ji(tF, "on" + nF)
}
Ji(MO, "onAnimationEnd");
Ji(jO, "onAnimationIteration");
Ji(DO, "onAnimationStart");
Ji("dblclick", "onDoubleClick");
Ji("focusin", "onFocus");
Ji("focusout", "onBlur");
Ji(NO, "onTransitionEnd");
Gl("onMouseEnter", ["mouseout", "mouseover"]);
Gl("onMouseLeave", ["mouseout", "mouseover"]);
Gl("onPointerEnter", ["pointerout", "pointerover"]);
Gl("onPointerLeave", ["pointerout", "pointerover"]);
cc("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
cc("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
cc("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
cc("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
cc("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
cc("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Pd = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
  rF = new Set("cancel close invalid load scroll toggle".split(" ").concat(Pd));

function aC(t, e, n) {
  var r = t.type || "unknown-event";
  t.currentTarget = n, t9(r, e, void 0, t), t.currentTarget = null
}

function FO(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var r = t[n],
      o = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var i = r.length - 1; 0 <= i; i--) {
          var a = r[i],
            c = a.instance,
            l = a.currentTarget;
          if (a = a.listener, c !== s && o.isPropagationStopped()) break e;
          aC(o, a, l), s = c
        } else
          for (i = 0; i < r.length; i++) {
            if (a = r[i], c = a.instance, l = a.currentTarget, a = a.listener, c !== s && o.isPropagationStopped()) break e;
            aC(o, a, l), s = c
          }
    }
  }
  if (Xg) throw t = Fw, Xg = !1, Fw = null, t
}

function $t(t, e) {
  var n = e[qw];
  n === void 0 && (n = e[qw] = new Set);
  var r = t + "__bubble";
  n.has(r) || (BO(e, t, 2, !1), n.add(r))
}

function h0(t, e, n) {
  var r = 0;
  e && (r |= 4), BO(n, t, r, e)
}
var wp = "_reactListening" + Math.random().toString(36).slice(2);

function pf(t) {
  if (!t[wp]) {
    t[wp] = !0, GI.forEach(function(n) {
      n !== "selectionchange" && (rF.has(n) || h0(n, !1, t), h0(n, !0, t))
    });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[wp] || (e[wp] = !0, h0("selectionchange", !1, e))
  }
}

function BO(t, e, n, r) {
  switch (xO(e)) {
    case 1:
      var o = y9;
      break;
    case 4:
      o = v9;
      break;
    default:
      o = mx
  }
  n = o.bind(null, e, n, t), o = void 0, !Lw || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (o = !0), r ? o !== void 0 ? t.addEventListener(e, n, {
    capture: !0,
    passive: o
  }) : t.addEventListener(e, n, !0) : o !== void 0 ? t.addEventListener(e, n, {
    passive: o
  }) : t.addEventListener(e, n, !1)
}

function p0(t, e, n, r, o) {
  var s = r;
  if (!(e & 1) && !(e & 2) && r !== null) e: for (;;) {
    if (r === null) return;
    var i = r.tag;
    if (i === 3 || i === 4) {
      var a = r.stateNode.containerInfo;
      if (a === o || a.nodeType === 8 && a.parentNode === o) break;
      if (i === 4)
        for (i = r.return; i !== null;) {
          var c = i.tag;
          if ((c === 3 || c === 4) && (c = i.stateNode.containerInfo, c === o || c.nodeType === 8 && c.parentNode === o)) return;
          i = i.return
        }
      for (; a !== null;) {
        if (i = ka(a), i === null) return;
        if (c = i.tag, c === 5 || c === 6) {
          r = s = i;
          continue e
        }
        a = a.parentNode
      }
    }
    r = r.return
  }
  lO(function() {
    var l = s,
      u = fx(n),
      d = [];
    e: {
      var f = LO.get(t);
      if (f !== void 0) {
        var h = vx,
          m = t;
        switch (t) {
          case "keypress":
            if (yg(n) === 0) break e;
          case "keydown":
          case "keyup":
            h = A9;
            break;
          case "focusin":
            m = "focus", h = a0;
            break;
          case "focusout":
            m = "blur", h = a0;
            break;
          case "beforeblur":
          case "afterblur":
            h = a0;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            h = qk;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            h = S9;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            h = D9;
            break;
          case MO:
          case jO:
          case DO:
            h = E9;
            break;
          case NO:
            h = L9;
            break;
          case "scroll":
            h = b9;
            break;
          case "wheel":
            h = B9;
            break;
          case "copy":
          case "cut":
          case "paste":
            h = C9;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            h = Zk
        }
        var p = (e & 4) !== 0,
          b = !p && t === "scroll",
          w = p ? f !== null ? f + "Capture" : null : f;
        p = [];
        for (var v = l, _; v !== null;) {
          _ = v;
          var S = _.stateNode;
          if (_.tag === 5 && S !== null && (_ = S, w !== null && (S = cf(v, w), S != null && p.push(gf(v, S, _)))), b) break;
          v = v.return
        }
        0 < p.length && (f = new h(f, m, null, n, u), d.push({
          event: f,
          listeners: p
        }))
      }
    }
    if (!(e & 7)) {
      e: {
        if (f = t === "mouseover" || t === "pointerover", h = t === "mouseout" || t === "pointerout", f && n !== Dw && (m = n.relatedTarget || n.fromElement) && (ka(m) || m[Ws])) break e;
        if ((h || f) && (f = u.window === u ? u : (f = u.ownerDocument) ? f.defaultView || f.parentWindow : window, h ? (m = n.relatedTarget || n.toElement, h = l, m = m ? ka(m) : null, m !== null && (b = lc(m), m !== b || m.tag !== 5 && m.tag !== 6) && (m = null)) : (h = null, m = l), h !== m)) {
          if (p = qk, S = "onMouseLeave", w = "onMouseEnter", v = "mouse", (t === "pointerout" || t === "pointerover") && (p = Zk, S = "onPointerLeave", w = "onPointerEnter", v = "pointer"), b = h == null ? f : sl(h), _ = m == null ? f : sl(m), f = new p(S, v + "leave", h, n, u), f.target = b, f.relatedTarget = _, S = null, ka(u) === l && (p = new p(w, v + "enter", m, n, u), p.target = _, p.relatedTarget = b, S = p), b = S, h && m) t: {
            for (p = h, w = m, v = 0, _ = p; _; _ = Cc(_)) v++;
            for (_ = 0, S = w; S; S = Cc(S)) _++;
            for (; 0 < v - _;) p = Cc(p),
            v--;
            for (; 0 < _ - v;) w = Cc(w),
            _--;
            for (; v--;) {
              if (p === w || w !== null && p === w.alternate) break t;
              p = Cc(p), w = Cc(w)
            }
            p = null
          }
          else p = null;
          h !== null && cC(d, f, h, p, !1), m !== null && b !== null && cC(d, b, m, p, !0)
        }
      }
      e: {
        if (f = l ? sl(l) : window, h = f.nodeName && f.nodeName.toLowerCase(), h === "select" || h === "input" && f.type === "file") var x = G9;
        else if (eC(f))
          if ($O) x = Z9;
          else {
            x = q9;
            var E = Y9
          }
        else(h = f.nodeName) && h.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (x = X9);
        if (x && (x = x(t, l))) {
          TO(d, x, n, u);
          break e
        }
        E && E(t, f, l),
        t === "focusout" && (E = f._wrapperState) && E.controlled && f.type === "number" && Ow(f, "number", f.value)
      }
      switch (E = l ? sl(l) : window, t) {
        case "focusin":
          (eC(E) || E.contentEditable === "true") && (rl = E, Hw = l, Bd = null);
          break;
        case "focusout":
          Bd = Hw = rl = null;
          break;
        case "mousedown":
          Vw = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Vw = !1, sC(d, n, u);
          break;
        case "selectionchange":
          if (eF) break;
        case "keydown":
        case "keyup":
          sC(d, n, u)
      }
      var k;
      if (wx) e: {
        switch (t) {
          case "compositionstart":
            var C = "onCompositionStart";
            break e;
          case "compositionend":
            C = "onCompositionEnd";
            break e;
          case "compositionupdate":
            C = "onCompositionUpdate";
            break e
        }
        C = void 0
      }
      else nl ? CO(t, n) && (C = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (C = "onCompositionStart");C && (kO && n.locale !== "ko" && (nl || C !== "onCompositionStart" ? C === "onCompositionEnd" && nl && (k = EO()) : (ki = u, yx = "value" in ki ? ki.value : ki.textContent, nl = !0)), E = tm(l, C), 0 < E.length && (C = new Xk(C, t, null, n, u), d.push({
        event: C,
        listeners: E
      }), k ? C.data = k : (k = PO(n), k !== null && (C.data = k)))),
      (k = z9 ? H9(t, n) : V9(t, n)) && (l = tm(l, "onBeforeInput"), 0 < l.length && (u = new Xk("onBeforeInput", "beforeinput", null, n, u), d.push({
        event: u,
        listeners: l
      }), u.data = k))
    }
    FO(d, e)
  })
}

function gf(t, e, n) {
  return {
    instance: t,
    listener: e,
    currentTarget: n
  }
}

function tm(t, e) {
  for (var n = e + "Capture", r = []; t !== null;) {
    var o = t,
      s = o.stateNode;
    o.tag === 5 && s !== null && (o = s, s = cf(t, n), s != null && r.unshift(gf(t, s, o)), s = cf(t, e), s != null && r.push(gf(t, s, o))), t = t.return
  }
  return r
}

function Cc(t) {
  if (t === null) return null;
  do t = t.return; while (t && t.tag !== 5);
  return t || null
}

function cC(t, e, n, r, o) {
  for (var s = e._reactName, i = []; n !== null && n !== r;) {
    var a = n,
      c = a.alternate,
      l = a.stateNode;
    if (c !== null && c === r) break;
    a.tag === 5 && l !== null && (a = l, o ? (c = cf(n, s), c != null && i.unshift(gf(n, c, a))) : o || (c = cf(n, s), c != null && i.push(gf(n, c, a)))), n = n.return
  }
  i.length !== 0 && t.push({
    event: e,
    listeners: i
  })
}
var oF = /\r\n?/g,
  sF = /\u0000|\uFFFD/g;

function lC(t) {
  return (typeof t == "string" ? t : "" + t).replace(oF, `
`).replace(sF, "")
}

function Sp(t, e, n) {
  if (e = lC(e), lC(t) !== e && n) throw Error(ne(425))
}

function nm() {}
var Ww = null,
  Kw = null;

function Gw(t, e) {
  return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Yw = typeof setTimeout == "function" ? setTimeout : void 0,
  iF = typeof clearTimeout == "function" ? clearTimeout : void 0,
  uC = typeof Promise == "function" ? Promise : void 0,
  aF = typeof queueMicrotask == "function" ? queueMicrotask : typeof uC < "u" ? function(t) {
    return uC.resolve(null).then(t).catch(cF)
  } : Yw;

function cF(t) {
  setTimeout(function() {
    throw t
  })
}

function g0(t, e) {
  var n = e,
    r = 0;
  do {
    var o = n.nextSibling;
    if (t.removeChild(n), o && o.nodeType === 8)
      if (n = o.data, n === "/$") {
        if (r === 0) {
          t.removeChild(o), df(e);
          return
        }
        r--
      } else n !== "$" && n !== "$?" && n !== "$!" || r++;
    n = o
  } while (n);
  df(e)
}

function Ri(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
      if (e === "/$") return null
    }
  }
  return t
}

function dC(t) {
  t = t.previousSibling;
  for (var e = 0; t;) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--
      } else n === "/$" && e++
    }
    t = t.previousSibling
  }
  return null
}
var gu = Math.random().toString(36).slice(2),
  os = "__reactFiber$" + gu,
  mf = "__reactProps$" + gu,
  Ws = "__reactContainer$" + gu,
  qw = "__reactEvents$" + gu,
  lF = "__reactListeners$" + gu,
  uF = "__reactHandles$" + gu;

function ka(t) {
  var e = t[os];
  if (e) return e;
  for (var n = t.parentNode; n;) {
    if (e = n[Ws] || n[os]) {
      if (n = e.alternate, e.child !== null || n !== null && n.child !== null)
        for (t = dC(t); t !== null;) {
          if (n = t[os]) return n;
          t = dC(t)
        }
      return e
    }
    t = n, n = t.parentNode
  }
  return null
}

function gh(t) {
  return t = t[os] || t[Ws], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}

function sl(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(ne(33))
}

function Iy(t) {
  return t[mf] || null
}
var Xw = [],
  il = -1;

function Qi(t) {
  return {
    current: t
  }
}

function Ot(t) {
  0 > il || (t.current = Xw[il], Xw[il] = null, il--)
}

function Ct(t, e) {
  il++, Xw[il] = t.current, t.current = e
}
var Hi = {},
  Gn = Qi(Hi),
  mr = Qi(!1),
  za = Hi;

function Yl(t, e) {
  var n = t.type.contextTypes;
  if (!n) return Hi;
  var r = t.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext;
  var o = {},
    s;
  for (s in n) o[s] = e[s];
  return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = o), o
}

function yr(t) {
  return t = t.childContextTypes, t != null
}

function rm() {
  Ot(mr), Ot(Gn)
}

function fC(t, e, n) {
  if (Gn.current !== Hi) throw Error(ne(168));
  Ct(Gn, e), Ct(mr, n)
}

function UO(t, e, n) {
  var r = t.stateNode;
  if (e = e.childContextTypes, typeof r.getChildContext != "function") return n;
  r = r.getChildContext();
  for (var o in r)
    if (!(o in e)) throw Error(ne(108, Y7(t) || "Unknown", o));
  return Wt({}, n, r)
}

function om(t) {
  return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Hi, za = Gn.current, Ct(Gn, t), Ct(mr, mr.current), !0
}

function hC(t, e, n) {
  var r = t.stateNode;
  if (!r) throw Error(ne(169));
  n ? (t = UO(t, e, za), r.__reactInternalMemoizedMergedChildContext = t, Ot(mr), Ot(Gn), Ct(Gn, t)) : Ot(mr), Ct(mr, n)
}
var Is = null,
  Oy = !1,
  m0 = !1;

function zO(t) {
  Is === null ? Is = [t] : Is.push(t)
}

function dF(t) {
  Oy = !0, zO(t)
}

function ea() {
  if (!m0 && Is !== null) {
    m0 = !0;
    var t = 0,
      e = vt;
    try {
      var n = Is;
      for (vt = 1; t < n.length; t++) {
        var r = n[t];
        do r = r(!0); while (r !== null)
      }
      Is = null, Oy = !1
    } catch (o) {
      throw Is !== null && (Is = Is.slice(t + 1)), hO(hx, ea), o
    } finally {
      vt = e, m0 = !1
    }
  }
  return null
}
var al = [],
  cl = 0,
  sm = null,
  im = 0,
  qr = [],
  Xr = 0,
  Ha = null,
  Rs = 1,
  As = "";

function va(t, e) {
  al[cl++] = im, al[cl++] = sm, sm = t, im = e
}

function HO(t, e, n) {
  qr[Xr++] = Rs, qr[Xr++] = As, qr[Xr++] = Ha, Ha = t;
  var r = Rs;
  t = As;
  var o = 32 - Oo(r) - 1;
  r &= ~(1 << o), n += 1;
  var s = 32 - Oo(e) + o;
  if (30 < s) {
    var i = o - o % 5;
    s = (r & (1 << i) - 1).toString(32), r >>= i, o -= i, Rs = 1 << 32 - Oo(e) + o | n << o | r, As = s + t
  } else Rs = 1 << s | n << o | r, As = t
}

function _x(t) {
  t.return !== null && (va(t, 1), HO(t, 1, 0))
}

function xx(t) {
  for (; t === sm;) sm = al[--cl], al[cl] = null, im = al[--cl], al[cl] = null;
  for (; t === Ha;) Ha = qr[--Xr], qr[Xr] = null, As = qr[--Xr], qr[Xr] = null, Rs = qr[--Xr], qr[Xr] = null
}
var Lr = null,
  Dr = null,
  Dt = !1,
  Eo = null;

function VO(t, e) {
  var n = no(5, null, null, 0);
  n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n)
}

function pC(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Lr = t, Dr = Ri(e.firstChild), !0) : !1;
    case 6:
      return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Lr = t, Dr = null, !0) : !1;
    case 13:
      return e = e.nodeType !== 8 ? null : e, e !== null ? (n = Ha !== null ? {
        id: Rs,
        overflow: As
      } : null, t.memoizedState = {
        dehydrated: e,
        treeContext: n,
        retryLane: 1073741824
      }, n = no(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Lr = t, Dr = null, !0) : !1;
    default:
      return !1
  }
}

function Zw(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}

function Jw(t) {
  if (Dt) {
    var e = Dr;
    if (e) {
      var n = e;
      if (!pC(t, e)) {
        if (Zw(t)) throw Error(ne(418));
        e = Ri(n.nextSibling);
        var r = Lr;
        e && pC(t, e) ? VO(r, n) : (t.flags = t.flags & -4097 | 2, Dt = !1, Lr = t)
      }
    } else {
      if (Zw(t)) throw Error(ne(418));
      t.flags = t.flags & -4097 | 2, Dt = !1, Lr = t
    }
  }
}

function gC(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;) t = t.return;
  Lr = t
}

function _p(t) {
  if (t !== Lr) return !1;
  if (!Dt) return gC(t), Dt = !0, !1;
  var e;
  if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Gw(t.type, t.memoizedProps)), e && (e = Dr)) {
    if (Zw(t)) throw WO(), Error(ne(418));
    for (; e;) VO(t, e), e = Ri(e.nextSibling)
  }
  if (gC(t), t.tag === 13) {
    if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(ne(317));
    e: {
      for (t = t.nextSibling, e = 0; t;) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              Dr = Ri(t.nextSibling);
              break e
            }
            e--
          } else n !== "$" && n !== "$!" && n !== "$?" || e++
        }
        t = t.nextSibling
      }
      Dr = null
    }
  } else Dr = Lr ? Ri(t.stateNode.nextSibling) : null;
  return !0
}

function WO() {
  for (var t = Dr; t;) t = Ri(t.nextSibling)
}

function ql() {
  Dr = Lr = null, Dt = !1
}

function Ex(t) {
  Eo === null ? Eo = [t] : Eo.push(t)
}
var fF = ti.ReactCurrentBatchConfig;

function mo(t, e) {
  if (t && t.defaultProps) {
    e = Wt({}, e), t = t.defaultProps;
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e
  }
  return e
}
var am = Qi(null),
  cm = null,
  ll = null,
  kx = null;

function Cx() {
  kx = ll = cm = null
}

function Px(t) {
  var e = am.current;
  Ot(am), t._currentValue = e
}

function Qw(t, e, n) {
  for (; t !== null;) {
    var r = t.alternate;
    if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break;
    t = t.return
  }
}

function Ol(t, e) {
  cm = t, kx = ll = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (pr = !0), t.firstContext = null)
}

function oo(t) {
  var e = t._currentValue;
  if (kx !== t)
    if (t = {
        context: t,
        memoizedValue: e,
        next: null
      }, ll === null) {
      if (cm === null) throw Error(ne(308));
      ll = t, cm.dependencies = {
        lanes: 0,
        firstContext: t
      }
    } else ll = ll.next = t;
  return e
}
var Ca = null;

function Tx(t) {
  Ca === null ? Ca = [t] : Ca.push(t)
}

function KO(t, e, n, r) {
  var o = e.interleaved;
  return o === null ? (n.next = n, Tx(e)) : (n.next = o.next, o.next = n), e.interleaved = n, Ks(t, r)
}

function Ks(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;) t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return;
  return n.tag === 3 ? n.stateNode : null
}
var mi = !1;

function $x(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0
    },
    effects: null
  }
}

function GO(t, e) {
  t = t.updateQueue, e.updateQueue === t && (e.updateQueue = {
    baseState: t.baseState,
    firstBaseUpdate: t.firstBaseUpdate,
    lastBaseUpdate: t.lastBaseUpdate,
    shared: t.shared,
    effects: t.effects
  })
}

function js(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  }
}

function Ai(t, e, n) {
  var r = t.updateQueue;
  if (r === null) return null;
  if (r = r.shared, st & 2) {
    var o = r.pending;
    return o === null ? e.next = e : (e.next = o.next, o.next = e), r.pending = e, Ks(t, n)
  }
  return o = r.interleaved, o === null ? (e.next = e, Tx(r)) : (e.next = o.next, o.next = e), r.interleaved = e, Ks(t, n)
}

function vg(t, e, n) {
  if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) {
    var r = e.lanes;
    r &= t.pendingLanes, n |= r, e.lanes = n, px(t, n)
  }
}

function mC(t, e) {
  var n = t.updateQueue,
    r = t.alternate;
  if (r !== null && (r = r.updateQueue, n === r)) {
    var o = null,
      s = null;
    if (n = n.firstBaseUpdate, n !== null) {
      do {
        var i = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null
        };
        s === null ? o = s = i : s = s.next = i, n = n.next
      } while (n !== null);
      s === null ? o = s = e : s = s.next = e
    } else o = s = e;
    n = {
      baseState: r.baseState,
      firstBaseUpdate: o,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects
    }, t.updateQueue = n;
    return
  }
  t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e
}

function lm(t, e, n, r) {
  var o = t.updateQueue;
  mi = !1;
  var s = o.firstBaseUpdate,
    i = o.lastBaseUpdate,
    a = o.shared.pending;
  if (a !== null) {
    o.shared.pending = null;
    var c = a,
      l = c.next;
    c.next = null, i === null ? s = l : i.next = l, i = c;
    var u = t.alternate;
    u !== null && (u = u.updateQueue, a = u.lastBaseUpdate, a !== i && (a === null ? u.firstBaseUpdate = l : a.next = l, u.lastBaseUpdate = c))
  }
  if (s !== null) {
    var d = o.baseState;
    i = 0, u = l = c = null, a = s;
    do {
      var f = a.lane,
        h = a.eventTime;
      if ((r & f) === f) {
        u !== null && (u = u.next = {
          eventTime: h,
          lane: 0,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null
        });
        e: {
          var m = t,
            p = a;
          switch (f = e, h = n, p.tag) {
            case 1:
              if (m = p.payload, typeof m == "function") {
                d = m.call(h, d, f);
                break e
              }
              d = m;
              break e;
            case 3:
              m.flags = m.flags & -65537 | 128;
            case 0:
              if (m = p.payload, f = typeof m == "function" ? m.call(h, d, f) : m, f == null) break e;
              d = Wt({}, d, f);
              break e;
            case 2:
              mi = !0
          }
        }
        a.callback !== null && a.lane !== 0 && (t.flags |= 64, f = o.effects, f === null ? o.effects = [a] : f.push(a))
      } else h = {
        eventTime: h,
        lane: f,
        tag: a.tag,
        payload: a.payload,
        callback: a.callback,
        next: null
      }, u === null ? (l = u = h, c = d) : u = u.next = h, i |= f;
      if (a = a.next, a === null) {
        if (a = o.shared.pending, a === null) break;
        f = a, a = f.next, f.next = null, o.lastBaseUpdate = f, o.shared.pending = null
      }
    } while (1);
    if (u === null && (c = d), o.baseState = c, o.firstBaseUpdate = l, o.lastBaseUpdate = u, e = o.shared.interleaved, e !== null) {
      o = e;
      do i |= o.lane, o = o.next; while (o !== e)
    } else s === null && (o.shared.lanes = 0);
    Wa |= i, t.lanes = i, t.memoizedState = d
  }
}

function yC(t, e, n) {
  if (t = e.effects, e.effects = null, t !== null)
    for (e = 0; e < t.length; e++) {
      var r = t[e],
        o = r.callback;
      if (o !== null) {
        if (r.callback = null, r = n, typeof o != "function") throw Error(ne(191, o));
        o.call(r)
      }
    }
}
var YO = new KI.Component().refs;

function eS(t, e, n, r) {
  e = t.memoizedState, n = n(r, e), n = n == null ? e : Wt({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n)
}
var Ry = {
  isMounted: function(t) {
    return (t = t._reactInternals) ? lc(t) === t : !1
  },
  enqueueSetState: function(t, e, n) {
    t = t._reactInternals;
    var r = nr(),
      o = ji(t),
      s = js(r, o);
    s.payload = e, n != null && (s.callback = n), e = Ai(t, s, o), e !== null && (Ro(e, t, o, r), vg(e, t, o))
  },
  enqueueReplaceState: function(t, e, n) {
    t = t._reactInternals;
    var r = nr(),
      o = ji(t),
      s = js(r, o);
    s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Ai(t, s, o), e !== null && (Ro(e, t, o, r), vg(e, t, o))
  },
  enqueueForceUpdate: function(t, e) {
    t = t._reactInternals;
    var n = nr(),
      r = ji(t),
      o = js(n, r);
    o.tag = 2, e != null && (o.callback = e), e = Ai(t, o, r), e !== null && (Ro(e, t, r, n), vg(e, t, r))
  }
};

function vC(t, e, n, r, o, s, i) {
  return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, i) : e.prototype && e.prototype.isPureReactComponent ? !hf(n, r) || !hf(o, s) : !0
}

function qO(t, e, n) {
  var r = !1,
    o = Hi,
    s = e.contextType;
  return typeof s == "object" && s !== null ? s = oo(s) : (o = yr(e) ? za : Gn.current, r = e.contextTypes, s = (r = r != null) ? Yl(t, o) : Hi), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = Ry, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = o, t.__reactInternalMemoizedMaskedChildContext = s), e
}

function bC(t, e, n, r) {
  t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && Ry.enqueueReplaceState(e, e.state, null)
}

function tS(t, e, n, r) {
  var o = t.stateNode;
  o.props = n, o.state = t.memoizedState, o.refs = YO, $x(t);
  var s = e.contextType;
  typeof s == "object" && s !== null ? o.context = oo(s) : (s = yr(e) ? za : Gn.current, o.context = Yl(t, s)), o.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (eS(t, e, s, n), o.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof o.getSnapshotBeforeUpdate == "function" || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (e = o.state, typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount(), e !== o.state && Ry.enqueueReplaceState(o, o.state, null), lm(t, n, o, r), o.state = t.memoizedState), typeof o.componentDidMount == "function" && (t.flags |= 4194308)
}

function Yu(t, e, n) {
  if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") {
    if (n._owner) {
      if (n = n._owner, n) {
        if (n.tag !== 1) throw Error(ne(309));
        var r = n.stateNode
      }
      if (!r) throw Error(ne(147, t));
      var o = r,
        s = "" + t;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(i) {
        var a = o.refs;
        a === YO && (a = o.refs = {}), i === null ? delete a[s] : a[s] = i
      }, e._stringRef = s, e)
    }
    if (typeof t != "string") throw Error(ne(284));
    if (!n._owner) throw Error(ne(290, t))
  }
  return t
}

function xp(t, e) {
  throw t = Object.prototype.toString.call(e), Error(ne(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}

function wC(t) {
  var e = t._init;
  return e(t._payload)
}

function XO(t) {
  function e(w, v) {
    if (t) {
      var _ = w.deletions;
      _ === null ? (w.deletions = [v], w.flags |= 16) : _.push(v)
    }
  }

  function n(w, v) {
    if (!t) return null;
    for (; v !== null;) e(w, v), v = v.sibling;
    return null
  }

  function r(w, v) {
    for (w = new Map; v !== null;) v.key !== null ? w.set(v.key, v) : w.set(v.index, v), v = v.sibling;
    return w
  }

  function o(w, v) {
    return w = Di(w, v), w.index = 0, w.sibling = null, w
  }

  function s(w, v, _) {
    return w.index = _, t ? (_ = w.alternate, _ !== null ? (_ = _.index, _ < v ? (w.flags |= 2, v) : _) : (w.flags |= 2, v)) : (w.flags |= 1048576, v)
  }

  function i(w) {
    return t && w.alternate === null && (w.flags |= 2), w
  }

  function a(w, v, _, S) {
    return v === null || v.tag !== 6 ? (v = x0(_, w.mode, S), v.return = w, v) : (v = o(v, _), v.return = w, v)
  }

  function c(w, v, _, S) {
    var x = _.type;
    return x === tl ? u(w, v, _.props.children, S, _.key) : v !== null && (v.elementType === x || typeof x == "object" && x !== null && x.$$typeof === gi && wC(x) === v.type) ? (S = o(v, _.props), S.ref = Yu(w, v, _), S.return = w, S) : (S = Eg(_.type, _.key, _.props, null, w.mode, S), S.ref = Yu(w, v, _), S.return = w, S)
  }

  function l(w, v, _, S) {
    return v === null || v.tag !== 4 || v.stateNode.containerInfo !== _.containerInfo || v.stateNode.implementation !== _.implementation ? (v = E0(_, w.mode, S), v.return = w, v) : (v = o(v, _.children || []), v.return = w, v)
  }

  function u(w, v, _, S, x) {
    return v === null || v.tag !== 7 ? (v = Ma(_, w.mode, S, x), v.return = w, v) : (v = o(v, _), v.return = w, v)
  }

  function d(w, v, _) {
    if (typeof v == "string" && v !== "" || typeof v == "number") return v = x0("" + v, w.mode, _), v.return = w, v;
    if (typeof v == "object" && v !== null) {
      switch (v.$$typeof) {
        case fp:
          return _ = Eg(v.type, v.key, v.props, null, w.mode, _), _.ref = Yu(w, null, v), _.return = w, _;
        case el:
          return v = E0(v, w.mode, _), v.return = w, v;
        case gi:
          var S = v._init;
          return d(w, S(v._payload), _)
      }
      if (kd(v) || Hu(v)) return v = Ma(v, w.mode, _, null), v.return = w, v;
      xp(w, v)
    }
    return null
  }

  function f(w, v, _, S) {
    var x = v !== null ? v.key : null;
    if (typeof _ == "string" && _ !== "" || typeof _ == "number") return x !== null ? null : a(w, v, "" + _, S);
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case fp:
          return _.key === x ? c(w, v, _, S) : null;
        case el:
          return _.key === x ? l(w, v, _, S) : null;
        case gi:
          return x = _._init, f(w, v, x(_._payload), S)
      }
      if (kd(_) || Hu(_)) return x !== null ? null : u(w, v, _, S, null);
      xp(w, _)
    }
    return null
  }

  function h(w, v, _, S, x) {
    if (typeof S == "string" && S !== "" || typeof S == "number") return w = w.get(_) || null, a(v, w, "" + S, x);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case fp:
          return w = w.get(S.key === null ? _ : S.key) || null, c(v, w, S, x);
        case el:
          return w = w.get(S.key === null ? _ : S.key) || null, l(v, w, S, x);
        case gi:
          var E = S._init;
          return h(w, v, _, E(S._payload), x)
      }
      if (kd(S) || Hu(S)) return w = w.get(_) || null, u(v, w, S, x, null);
      xp(v, S)
    }
    return null
  }

  function m(w, v, _, S) {
    for (var x = null, E = null, k = v, C = v = 0, $ = null; k !== null && C < _.length; C++) {
      k.index > C ? ($ = k, k = null) : $ = k.sibling;
      var I = f(w, k, _[C], S);
      if (I === null) {
        k === null && (k = $);
        break
      }
      t && k && I.alternate === null && e(w, k), v = s(I, v, C), E === null ? x = I : E.sibling = I, E = I, k = $
    }
    if (C === _.length) return n(w, k), Dt && va(w, C), x;
    if (k === null) {
      for (; C < _.length; C++) k = d(w, _[C], S), k !== null && (v = s(k, v, C), E === null ? x = k : E.sibling = k, E = k);
      return Dt && va(w, C), x
    }
    for (k = r(w, k); C < _.length; C++) $ = h(k, w, C, _[C], S), $ !== null && (t && $.alternate !== null && k.delete($.key === null ? C : $.key), v = s($, v, C), E === null ? x = $ : E.sibling = $, E = $);
    return t && k.forEach(function(R) {
      return e(w, R)
    }), Dt && va(w, C), x
  }

  function p(w, v, _, S) {
    var x = Hu(_);
    if (typeof x != "function") throw Error(ne(150));
    if (_ = x.call(_), _ == null) throw Error(ne(151));
    for (var E = x = null, k = v, C = v = 0, $ = null, I = _.next(); k !== null && !I.done; C++, I = _.next()) {
      k.index > C ? ($ = k, k = null) : $ = k.sibling;
      var R = f(w, k, I.value, S);
      if (R === null) {
        k === null && (k = $);
        break
      }
      t && k && R.alternate === null && e(w, k), v = s(R, v, C), E === null ? x = R : E.sibling = R, E = R, k = $
    }
    if (I.done) return n(w, k), Dt && va(w, C), x;
    if (k === null) {
      for (; !I.done; C++, I = _.next()) I = d(w, I.value, S), I !== null && (v = s(I, v, C), E === null ? x = I : E.sibling = I, E = I);
      return Dt && va(w, C), x
    }
    for (k = r(w, k); !I.done; C++, I = _.next()) I = h(k, w, C, I.value, S), I !== null && (t && I.alternate !== null && k.delete(I.key === null ? C : I.key), v = s(I, v, C), E === null ? x = I : E.sibling = I, E = I);
    return t && k.forEach(function(M) {
      return e(w, M)
    }), Dt && va(w, C), x
  }

  function b(w, v, _, S) {
    if (typeof _ == "object" && _ !== null && _.type === tl && _.key === null && (_ = _.props.children), typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case fp:
          e: {
            for (var x = _.key, E = v; E !== null;) {
              if (E.key === x) {
                if (x = _.type, x === tl) {
                  if (E.tag === 7) {
                    n(w, E.sibling), v = o(E, _.props.children), v.return = w, w = v;
                    break e
                  }
                } else if (E.elementType === x || typeof x == "object" && x !== null && x.$$typeof === gi && wC(x) === E.type) {
                  n(w, E.sibling), v = o(E, _.props), v.ref = Yu(w, E, _), v.return = w, w = v;
                  break e
                }
                n(w, E);
                break
              } else e(w, E);
              E = E.sibling
            }
            _.type === tl ? (v = Ma(_.props.children, w.mode, S, _.key), v.return = w, w = v) : (S = Eg(_.type, _.key, _.props, null, w.mode, S), S.ref = Yu(w, v, _), S.return = w, w = S)
          }
          return i(w);
        case el:
          e: {
            for (E = _.key; v !== null;) {
              if (v.key === E)
                if (v.tag === 4 && v.stateNode.containerInfo === _.containerInfo && v.stateNode.implementation === _.implementation) {
                  n(w, v.sibling), v = o(v, _.children || []), v.return = w, w = v;
                  break e
                } else {
                  n(w, v);
                  break
                }
              else e(w, v);
              v = v.sibling
            }
            v = E0(_, w.mode, S),
            v.return = w,
            w = v
          }
          return i(w);
        case gi:
          return E = _._init, b(w, v, E(_._payload), S)
      }
      if (kd(_)) return m(w, v, _, S);
      if (Hu(_)) return p(w, v, _, S);
      xp(w, _)
    }
    return typeof _ == "string" && _ !== "" || typeof _ == "number" ? (_ = "" + _, v !== null && v.tag === 6 ? (n(w, v.sibling), v = o(v, _), v.return = w, w = v) : (n(w, v), v = x0(_, w.mode, S), v.return = w, w = v), i(w)) : n(w, v)
  }
  return b
}
var Xl = XO(!0),
  ZO = XO(!1),
  mh = {},
  cs = Qi(mh),
  yf = Qi(mh),
  vf = Qi(mh);

function Pa(t) {
  if (t === mh) throw Error(ne(174));
  return t
}

function Ix(t, e) {
  switch (Ct(vf, e), Ct(yf, t), Ct(cs, mh), t = e.nodeType, t) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : Aw(null, "");
      break;
    default:
      t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = Aw(e, t)
  }
  Ot(cs), Ct(cs, e)
}

function Zl() {
  Ot(cs), Ot(yf), Ot(vf)
}

function JO(t) {
  Pa(vf.current);
  var e = Pa(cs.current),
    n = Aw(e, t.type);
  e !== n && (Ct(yf, t), Ct(cs, n))
}

function Ox(t) {
  yf.current === t && (Ot(cs), Ot(yf))
}
var zt = Qi(0);

function um(t) {
  for (var e = t; e !== null;) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue
    }
    if (e === t) break;
    for (; e.sibling === null;) {
      if (e.return === null || e.return === t) return null;
      e = e.return
    }
    e.sibling.return = e.return, e = e.sibling
  }
  return null
}
var y0 = [];

function Rx() {
  for (var t = 0; t < y0.length; t++) y0[t]._workInProgressVersionPrimary = null;
  y0.length = 0
}
var bg = ti.ReactCurrentDispatcher,
  v0 = ti.ReactCurrentBatchConfig,
  Va = 0,
  Vt = null,
  an = null,
  dn = null,
  dm = !1,
  Ud = !1,
  bf = 0,
  hF = 0;

function jn() {
  throw Error(ne(321))
}

function Ax(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!Lo(t[n], e[n])) return !1;
  return !0
}

function Mx(t, e, n, r, o, s) {
  if (Va = s, Vt = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, bg.current = t === null || t.memoizedState === null ? yF : vF, t = n(r, o), Ud) {
    s = 0;
    do {
      if (Ud = !1, bf = 0, 25 <= s) throw Error(ne(301));
      s += 1, dn = an = null, e.updateQueue = null, bg.current = bF, t = n(r, o)
    } while (Ud)
  }
  if (bg.current = fm, e = an !== null && an.next !== null, Va = 0, dn = an = Vt = null, dm = !1, e) throw Error(ne(300));
  return t
}

function jx() {
  var t = bf !== 0;
  return bf = 0, t
}

function Jo() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  return dn === null ? Vt.memoizedState = dn = t : dn = dn.next = t, dn
}

function so() {
  if (an === null) {
    var t = Vt.alternate;
    t = t !== null ? t.memoizedState : null
  } else t = an.next;
  var e = dn === null ? Vt.memoizedState : dn.next;
  if (e !== null) dn = e, an = t;
  else {
    if (t === null) throw Error(ne(310));
    an = t, t = {
      memoizedState: an.memoizedState,
      baseState: an.baseState,
      baseQueue: an.baseQueue,
      queue: an.queue,
      next: null
    }, dn === null ? Vt.memoizedState = dn = t : dn = dn.next = t
  }
  return dn
}

function wf(t, e) {
  return typeof e == "function" ? e(t) : e
}

function b0(t) {
  var e = so(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var r = an,
    o = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (o !== null) {
      var i = o.next;
      o.next = s.next, s.next = i
    }
    r.baseQueue = o = s, n.pending = null
  }
  if (o !== null) {
    s = o.next, r = r.baseState;
    var a = i = null,
      c = null,
      l = s;
    do {
      var u = l.lane;
      if ((Va & u) === u) c !== null && (c = c.next = {
        lane: 0,
        action: l.action,
        hasEagerState: l.hasEagerState,
        eagerState: l.eagerState,
        next: null
      }), r = l.hasEagerState ? l.eagerState : t(r, l.action);
      else {
        var d = {
          lane: u,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null
        };
        c === null ? (a = c = d, i = r) : c = c.next = d, Vt.lanes |= u, Wa |= u
      }
      l = l.next
    } while (l !== null && l !== s);
    c === null ? i = r : c.next = a, Lo(r, e.memoizedState) || (pr = !0), e.memoizedState = r, e.baseState = i, e.baseQueue = c, n.lastRenderedState = r
  }
  if (t = n.interleaved, t !== null) {
    o = t;
    do s = o.lane, Vt.lanes |= s, Wa |= s, o = o.next; while (o !== t)
  } else o === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch]
}

function w0(t) {
  var e = so(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var r = n.dispatch,
    o = n.pending,
    s = e.memoizedState;
  if (o !== null) {
    n.pending = null;
    var i = o = o.next;
    do s = t(s, i.action), i = i.next; while (i !== o);
    Lo(s, e.memoizedState) || (pr = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s
  }
  return [s, r]
}

function QO() {}

function eR(t, e) {
  var n = Vt,
    r = so(),
    o = e(),
    s = !Lo(r.memoizedState, o);
  if (s && (r.memoizedState = o, pr = !0), r = r.queue, Dx(rR.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || dn !== null && dn.memoizedState.tag & 1) {
    if (n.flags |= 2048, Sf(9, nR.bind(null, n, r, o, e), void 0, null), gn === null) throw Error(ne(349));
    Va & 30 || tR(n, e, o)
  }
  return o
}

function tR(t, e, n) {
  t.flags |= 16384, t = {
    getSnapshot: e,
    value: n
  }, e = Vt.updateQueue, e === null ? (e = {
    lastEffect: null,
    stores: null
  }, Vt.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t))
}

function nR(t, e, n, r) {
  e.value = n, e.getSnapshot = r, oR(e) && sR(t)
}

function rR(t, e, n) {
  return n(function() {
    oR(e) && sR(t)
  })
}

function oR(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !Lo(t, n)
  } catch {
    return !0
  }
}

function sR(t) {
  var e = Ks(t, 1);
  e !== null && Ro(e, t, 1, -1)
}

function SC(t) {
  var e = Jo();
  return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = {
    pending: null,
    interleaved: null,
    lanes: 0,
    dispatch: null,
    lastRenderedReducer: wf,
    lastRenderedState: t
  }, e.queue = t, t = t.dispatch = mF.bind(null, Vt, t), [e.memoizedState, t]
}

function Sf(t, e, n, r) {
  return t = {
    tag: t,
    create: e,
    destroy: n,
    deps: r,
    next: null
  }, e = Vt.updateQueue, e === null ? (e = {
    lastEffect: null,
    stores: null
  }, Vt.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t
}

function iR() {
  return so().memoizedState
}

function wg(t, e, n, r) {
  var o = Jo();
  Vt.flags |= t, o.memoizedState = Sf(1 | e, n, void 0, r === void 0 ? null : r)
}

function Ay(t, e, n, r) {
  var o = so();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (an !== null) {
    var i = an.memoizedState;
    if (s = i.destroy, r !== null && Ax(r, i.deps)) {
      o.memoizedState = Sf(e, n, s, r);
      return
    }
  }
  Vt.flags |= t, o.memoizedState = Sf(1 | e, n, s, r)
}

function _C(t, e) {
  return wg(8390656, 8, t, e)
}

function Dx(t, e) {
  return Ay(2048, 8, t, e)
}

function aR(t, e) {
  return Ay(4, 2, t, e)
}

function cR(t, e) {
  return Ay(4, 4, t, e)
}

function lR(t, e) {
  if (typeof e == "function") return t = t(), e(t),
    function() {
      e(null)
    };
  if (e != null) return t = t(), e.current = t,
    function() {
      e.current = null
    }
}

function uR(t, e, n) {
  return n = n != null ? n.concat([t]) : null, Ay(4, 4, lR.bind(null, e, t), n)
}

function Nx() {}

function dR(t, e) {
  var n = so();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Ax(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t)
}

function fR(t, e) {
  var n = so();
  e = e === void 0 ? null : e;
  var r = n.memoizedState;
  return r !== null && e !== null && Ax(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t)
}

function hR(t, e, n) {
  return Va & 21 ? (Lo(n, e) || (n = mO(), Vt.lanes |= n, Wa |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, pr = !0), t.memoizedState = n)
}

function pF(t, e) {
  var n = vt;
  vt = n !== 0 && 4 > n ? n : 4, t(!0);
  var r = v0.transition;
  v0.transition = {};
  try {
    t(!1), e()
  } finally {
    vt = n, v0.transition = r
  }
}

function pR() {
  return so().memoizedState
}

function gF(t, e, n) {
  var r = ji(t);
  if (n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, gR(t)) mR(e, n);
  else if (n = KO(t, e, n, r), n !== null) {
    var o = nr();
    Ro(n, t, r, o), yR(n, e, r)
  }
}

function mF(t, e, n) {
  var r = ji(t),
    o = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
  if (gR(t)) mR(e, o);
  else {
    var s = t.alternate;
    if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
      var i = e.lastRenderedState,
        a = s(i, n);
      if (o.hasEagerState = !0, o.eagerState = a, Lo(a, i)) {
        var c = e.interleaved;
        c === null ? (o.next = o, Tx(e)) : (o.next = c.next, c.next = o), e.interleaved = o;
        return
      }
    } catch {} finally {}
    n = KO(t, e, o, r), n !== null && (o = nr(), Ro(n, t, r, o), yR(n, e, r))
  }
}

function gR(t) {
  var e = t.alternate;
  return t === Vt || e !== null && e === Vt
}

function mR(t, e) {
  Ud = dm = !0;
  var n = t.pending;
  n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e
}

function yR(t, e, n) {
  if (n & 4194240) {
    var r = e.lanes;
    r &= t.pendingLanes, n |= r, e.lanes = n, px(t, n)
  }
}
var fm = {
    readContext: oo,
    useCallback: jn,
    useContext: jn,
    useEffect: jn,
    useImperativeHandle: jn,
    useInsertionEffect: jn,
    useLayoutEffect: jn,
    useMemo: jn,
    useReducer: jn,
    useRef: jn,
    useState: jn,
    useDebugValue: jn,
    useDeferredValue: jn,
    useTransition: jn,
    useMutableSource: jn,
    useSyncExternalStore: jn,
    useId: jn,
    unstable_isNewReconciler: !1
  },
  yF = {
    readContext: oo,
    useCallback: function(t, e) {
      return Jo().memoizedState = [t, e === void 0 ? null : e], t
    },
    useContext: oo,
    useEffect: _C,
    useImperativeHandle: function(t, e, n) {
      return n = n != null ? n.concat([t]) : null, wg(4194308, 4, lR.bind(null, e, t), n)
    },
    useLayoutEffect: function(t, e) {
      return wg(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
      return wg(4, 2, t, e)
    },
    useMemo: function(t, e) {
      var n = Jo();
      return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t
    },
    useReducer: function(t, e, n) {
      var r = Jo();
      return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: t,
        lastRenderedState: e
      }, r.queue = t, t = t.dispatch = gF.bind(null, Vt, t), [r.memoizedState, t]
    },
    useRef: function(t) {
      var e = Jo();
      return t = {
        current: t
      }, e.memoizedState = t
    },
    useState: SC,
    useDebugValue: Nx,
    useDeferredValue: function(t) {
      return Jo().memoizedState = t
    },
    useTransition: function() {
      var t = SC(!1),
        e = t[0];
      return t = pF.bind(null, t[1]), Jo().memoizedState = t, [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, n) {
      var r = Vt,
        o = Jo();
      if (Dt) {
        if (n === void 0) throw Error(ne(407));
        n = n()
      } else {
        if (n = e(), gn === null) throw Error(ne(349));
        Va & 30 || tR(r, e, n)
      }
      o.memoizedState = n;
      var s = {
        value: n,
        getSnapshot: e
      };
      return o.queue = s, _C(rR.bind(null, r, s, t), [t]), r.flags |= 2048, Sf(9, nR.bind(null, r, s, n, e), void 0, null), n
    },
    useId: function() {
      var t = Jo(),
        e = gn.identifierPrefix;
      if (Dt) {
        var n = As,
          r = Rs;
        n = (r & ~(1 << 32 - Oo(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = bf++, 0 < n && (e += "H" + n.toString(32)), e += ":"
      } else n = hF++, e = ":" + e + "r" + n.toString(32) + ":";
      return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
  },
  vF = {
    readContext: oo,
    useCallback: dR,
    useContext: oo,
    useEffect: Dx,
    useImperativeHandle: uR,
    useInsertionEffect: aR,
    useLayoutEffect: cR,
    useMemo: fR,
    useReducer: b0,
    useRef: iR,
    useState: function() {
      return b0(wf)
    },
    useDebugValue: Nx,
    useDeferredValue: function(t) {
      var e = so();
      return hR(e, an.memoizedState, t)
    },
    useTransition: function() {
      var t = b0(wf)[0],
        e = so().memoizedState;
      return [t, e]
    },
    useMutableSource: QO,
    useSyncExternalStore: eR,
    useId: pR,
    unstable_isNewReconciler: !1
  },
  bF = {
    readContext: oo,
    useCallback: dR,
    useContext: oo,
    useEffect: Dx,
    useImperativeHandle: uR,
    useInsertionEffect: aR,
    useLayoutEffect: cR,
    useMemo: fR,
    useReducer: w0,
    useRef: iR,
    useState: function() {
      return w0(wf)
    },
    useDebugValue: Nx,
    useDeferredValue: function(t) {
      var e = so();
      return an === null ? e.memoizedState = t : hR(e, an.memoizedState, t)
    },
    useTransition: function() {
      var t = w0(wf)[0],
        e = so().memoizedState;
      return [t, e]
    },
    useMutableSource: QO,
    useSyncExternalStore: eR,
    useId: pR,
    unstable_isNewReconciler: !1
  };

function Jl(t, e) {
  try {
    var n = "",
      r = e;
    do n += G7(r), r = r.return; while (r);
    var o = n
  } catch (s) {
    o = `
Error generating stack: ` + s.message + `
` + s.stack
  }
  return {
    value: t,
    source: e,
    stack: o,
    digest: null
  }
}

function S0(t, e, n) {
  return {
    value: t,
    source: null,
    stack: n ?? null,
    digest: e ?? null
  }
}

function nS(t, e) {
  try {
    console.error(e.value)
  } catch (n) {
    setTimeout(function() {
      throw n
    })
  }
}
var wF = typeof WeakMap == "function" ? WeakMap : Map;

function vR(t, e, n) {
  n = js(-1, n), n.tag = 3, n.payload = {
    element: null
  };
  var r = e.value;
  return n.callback = function() {
    pm || (pm = !0, fS = r), nS(t, e)
  }, n
}

function bR(t, e, n) {
  n = js(-1, n), n.tag = 3;
  var r = t.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var o = e.value;
    n.payload = function() {
      return r(o)
    }, n.callback = function() {
      nS(t, e)
    }
  }
  var s = t.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function() {
    nS(t, e), typeof r != "function" && (Mi === null ? Mi = new Set([this]) : Mi.add(this));
    var i = e.stack;
    this.componentDidCatch(e.value, {
      componentStack: i !== null ? i : ""
    })
  }), n
}

function xC(t, e, n) {
  var r = t.pingCache;
  if (r === null) {
    r = t.pingCache = new wF;
    var o = new Set;
    r.set(e, o)
  } else o = r.get(e), o === void 0 && (o = new Set, r.set(e, o));
  o.has(n) || (o.add(n), t = MF.bind(null, t, e, n), e.then(t, t))
}

function EC(t) {
  do {
    var e;
    if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
    t = t.return
  } while (t !== null);
  return null
}

function kC(t, e, n, r, o) {
  return t.mode & 1 ? (t.flags |= 65536, t.lanes = o, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = js(-1, 1), e.tag = 2, Ai(n, e, 1))), n.lanes |= 1), t)
}
var SF = ti.ReactCurrentOwner,
  pr = !1;

function Qn(t, e, n, r) {
  e.child = t === null ? ZO(e, null, n, r) : Xl(e, t.child, n, r)
}

function CC(t, e, n, r, o) {
  n = n.render;
  var s = e.ref;
  return Ol(e, o), r = Mx(t, e, n, r, s, o), n = jx(), t !== null && !pr ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~o, Gs(t, e, o)) : (Dt && n && _x(e), e.flags |= 1, Qn(t, e, r, o), e.child)
}

function PC(t, e, n, r, o) {
  if (t === null) {
    var s = n.type;
    return typeof s == "function" && !Wx(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, wR(t, e, s, r, o)) : (t = Eg(n.type, null, r, e, e.mode, o), t.ref = e.ref, t.return = e, e.child = t)
  }
  if (s = t.child, !(t.lanes & o)) {
    var i = s.memoizedProps;
    if (n = n.compare, n = n !== null ? n : hf, n(i, r) && t.ref === e.ref) return Gs(t, e, o)
  }
  return e.flags |= 1, t = Di(s, r), t.ref = e.ref, t.return = e, e.child = t
}

function wR(t, e, n, r, o) {
  if (t !== null) {
    var s = t.memoizedProps;
    if (hf(s, r) && t.ref === e.ref)
      if (pr = !1, e.pendingProps = r = s, (t.lanes & o) !== 0) t.flags & 131072 && (pr = !0);
      else return e.lanes = t.lanes, Gs(t, e, o)
  }
  return rS(t, e, n, r, o)
}

function SR(t, e, n) {
  var r = e.pendingProps,
    o = r.children,
    s = t !== null ? t.memoizedState : null;
  if (r.mode === "hidden")
    if (!(e.mode & 1)) e.memoizedState = {
      baseLanes: 0,
      cachePool: null,
      transitions: null
    }, Ct(dl, Ar), Ar |= n;
    else {
      if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = {
        baseLanes: t,
        cachePool: null,
        transitions: null
      }, e.updateQueue = null, Ct(dl, Ar), Ar |= t, null;
      e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null
      }, r = s !== null ? s.baseLanes : n, Ct(dl, Ar), Ar |= r
    }
  else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, Ct(dl, Ar), Ar |= r;
  return Qn(t, e, o, n), e.child
}

function _R(t, e) {
  var n = e.ref;
  (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152)
}

function rS(t, e, n, r, o) {
  var s = yr(n) ? za : Gn.current;
  return s = Yl(e, s), Ol(e, o), n = Mx(t, e, n, r, s, o), r = jx(), t !== null && !pr ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~o, Gs(t, e, o)) : (Dt && r && _x(e), e.flags |= 1, Qn(t, e, n, o), e.child)
}

function TC(t, e, n, r, o) {
  if (yr(n)) {
    var s = !0;
    om(e)
  } else s = !1;
  if (Ol(e, o), e.stateNode === null) Sg(t, e), qO(e, n, r), tS(e, n, r, o), r = !0;
  else if (t === null) {
    var i = e.stateNode,
      a = e.memoizedProps;
    i.props = a;
    var c = i.context,
      l = n.contextType;
    typeof l == "object" && l !== null ? l = oo(l) : (l = yr(n) ? za : Gn.current, l = Yl(e, l));
    var u = n.getDerivedStateFromProps,
      d = typeof u == "function" || typeof i.getSnapshotBeforeUpdate == "function";
    d || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (a !== r || c !== l) && bC(e, i, r, l), mi = !1;
    var f = e.memoizedState;
    i.state = f, lm(e, r, i, o), c = e.memoizedState, a !== r || f !== c || mr.current || mi ? (typeof u == "function" && (eS(e, n, u, r), c = e.memoizedState), (a = mi || vC(e, n, a, r, f, c, l)) ? (d || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount()), typeof i.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof i.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = c), i.props = r, i.state = c, i.context = l, r = a) : (typeof i.componentDidMount == "function" && (e.flags |= 4194308), r = !1)
  } else {
    i = e.stateNode, GO(t, e), a = e.memoizedProps, l = e.type === e.elementType ? a : mo(e.type, a), i.props = l, d = e.pendingProps, f = i.context, c = n.contextType, typeof c == "object" && c !== null ? c = oo(c) : (c = yr(n) ? za : Gn.current, c = Yl(e, c));
    var h = n.getDerivedStateFromProps;
    (u = typeof h == "function" || typeof i.getSnapshotBeforeUpdate == "function") || typeof i.UNSAFE_componentWillReceiveProps != "function" && typeof i.componentWillReceiveProps != "function" || (a !== d || f !== c) && bC(e, i, r, c), mi = !1, f = e.memoizedState, i.state = f, lm(e, r, i, o);
    var m = e.memoizedState;
    a !== d || f !== m || mr.current || mi ? (typeof h == "function" && (eS(e, n, h, r), m = e.memoizedState), (l = mi || vC(e, n, l, r, f, m, c) || !1) ? (u || typeof i.UNSAFE_componentWillUpdate != "function" && typeof i.componentWillUpdate != "function" || (typeof i.componentWillUpdate == "function" && i.componentWillUpdate(r, m, c), typeof i.UNSAFE_componentWillUpdate == "function" && i.UNSAFE_componentWillUpdate(r, m, c)), typeof i.componentDidUpdate == "function" && (e.flags |= 4), typeof i.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof i.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = m), i.props = r, i.state = m, i.context = c, r = l) : (typeof i.componentDidUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof i.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), r = !1)
  }
  return oS(t, e, n, r, s, o)
}

function oS(t, e, n, r, o, s) {
  _R(t, e);
  var i = (e.flags & 128) !== 0;
  if (!r && !i) return o && hC(e, n, !1), Gs(t, e, s);
  r = e.stateNode, SF.current = e;
  var a = i && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return e.flags |= 1, t !== null && i ? (e.child = Xl(e, t.child, null, s), e.child = Xl(e, null, a, s)) : Qn(t, e, a, s), e.memoizedState = r.state, o && hC(e, n, !0), e.child
}

function xR(t) {
  var e = t.stateNode;
  e.pendingContext ? fC(t, e.pendingContext, e.pendingContext !== e.context) : e.context && fC(t, e.context, !1), Ix(t, e.containerInfo)
}

function $C(t, e, n, r, o) {
  return ql(), Ex(o), e.flags |= 256, Qn(t, e, n, r), e.child
}
var sS = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0
};

function iS(t) {
  return {
    baseLanes: t,
    cachePool: null,
    transitions: null
  }
}

function ER(t, e, n) {
  var r = e.pendingProps,
    o = zt.current,
    s = !1,
    i = (e.flags & 128) !== 0,
    a;
  if ((a = i) || (a = t !== null && t.memoizedState === null ? !1 : (o & 2) !== 0), a ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (o |= 1), Ct(zt, o & 1), t === null) return Jw(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (i = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, i = {
    mode: "hidden",
    children: i
  }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = i) : s = Dy(i, r, 0, null), t = Ma(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = iS(n), e.memoizedState = sS, t) : Lx(e, i));
  if (o = t.memoizedState, o !== null && (a = o.dehydrated, a !== null)) return _F(t, e, i, r, a, o, n);
  if (s) {
    s = r.fallback, i = e.mode, o = t.child, a = o.sibling;
    var c = {
      mode: "hidden",
      children: r.children
    };
    return !(i & 1) && e.child !== o ? (r = e.child, r.childLanes = 0, r.pendingProps = c, e.deletions = null) : (r = Di(o, c), r.subtreeFlags = o.subtreeFlags & 14680064), a !== null ? s = Di(a, s) : (s = Ma(s, i, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, i = t.child.memoizedState, i = i === null ? iS(n) : {
      baseLanes: i.baseLanes | n,
      cachePool: null,
      transitions: i.transitions
    }, s.memoizedState = i, s.childLanes = t.childLanes & ~n, e.memoizedState = sS, r
  }
  return s = t.child, t = s.sibling, r = Di(s, {
    mode: "visible",
    children: r.children
  }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r
}

function Lx(t, e) {
  return e = Dy({
    mode: "visible",
    children: e
  }, t.mode, 0, null), e.return = t, t.child = e
}

function Ep(t, e, n, r) {
  return r !== null && Ex(r), Xl(e, t.child, null, n), t = Lx(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t
}

function _F(t, e, n, r, o, s, i) {
  if (n) return e.flags & 256 ? (e.flags &= -257, r = S0(Error(ne(422))), Ep(t, e, i, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, o = e.mode, r = Dy({
    mode: "visible",
    children: r.children
  }, o, 0, null), s = Ma(s, o, i, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && Xl(e, t.child, null, i), e.child.memoizedState = iS(i), e.memoizedState = sS, s);
  if (!(e.mode & 1)) return Ep(t, e, i, null);
  if (o.data === "$!") {
    if (r = o.nextSibling && o.nextSibling.dataset, r) var a = r.dgst;
    return r = a, s = Error(ne(419)), r = S0(s, r, void 0), Ep(t, e, i, r)
  }
  if (a = (i & t.childLanes) !== 0, pr || a) {
    if (r = gn, r !== null) {
      switch (i & -i) {
        case 4:
          o = 2;
          break;
        case 16:
          o = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          o = 32;
          break;
        case 536870912:
          o = 268435456;
          break;
        default:
          o = 0
      }
      o = o & (r.suspendedLanes | i) ? 0 : o, o !== 0 && o !== s.retryLane && (s.retryLane = o, Ks(t, o), Ro(r, t, o, -1))
    }
    return Vx(), r = S0(Error(ne(421))), Ep(t, e, i, r)
  }
  return o.data === "$?" ? (e.flags |= 128, e.child = t.child, e = jF.bind(null, t), o._reactRetry = e, null) : (t = s.treeContext, Dr = Ri(o.nextSibling), Lr = e, Dt = !0, Eo = null, t !== null && (qr[Xr++] = Rs, qr[Xr++] = As, qr[Xr++] = Ha, Rs = t.id, As = t.overflow, Ha = e), e = Lx(e, r.children), e.flags |= 4096, e)
}

function IC(t, e, n) {
  t.lanes |= e;
  var r = t.alternate;
  r !== null && (r.lanes |= e), Qw(t.return, e, n)
}

function _0(t, e, n, r, o) {
  var s = t.memoizedState;
  s === null ? t.memoizedState = {
    isBackwards: e,
    rendering: null,
    renderingStartTime: 0,
    last: r,
    tail: n,
    tailMode: o
  } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = o)
}

function kR(t, e, n) {
  var r = e.pendingProps,
    o = r.revealOrder,
    s = r.tail;
  if (Qn(t, e, r.children, n), r = zt.current, r & 2) r = r & 1 | 2, e.flags |= 128;
  else {
    if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) {
      if (t.tag === 13) t.memoizedState !== null && IC(t, n, e);
      else if (t.tag === 19) IC(t, n, e);
      else if (t.child !== null) {
        t.child.return = t, t = t.child;
        continue
      }
      if (t === e) break e;
      for (; t.sibling === null;) {
        if (t.return === null || t.return === e) break e;
        t = t.return
      }
      t.sibling.return = t.return, t = t.sibling
    }
    r &= 1
  }
  if (Ct(zt, r), !(e.mode & 1)) e.memoizedState = null;
  else switch (o) {
    case "forwards":
      for (n = e.child, o = null; n !== null;) t = n.alternate, t !== null && um(t) === null && (o = n), n = n.sibling;
      n = o, n === null ? (o = e.child, e.child = null) : (o = n.sibling, n.sibling = null), _0(e, !1, o, n, s);
      break;
    case "backwards":
      for (n = null, o = e.child, e.child = null; o !== null;) {
        if (t = o.alternate, t !== null && um(t) === null) {
          e.child = o;
          break
        }
        t = o.sibling, o.sibling = n, n = o, o = t
      }
      _0(e, !0, n, null, s);
      break;
    case "together":
      _0(e, !1, null, null, void 0);
      break;
    default:
      e.memoizedState = null
  }
  return e.child
}

function Sg(t, e) {
  !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2)
}

function Gs(t, e, n) {
  if (t !== null && (e.dependencies = t.dependencies), Wa |= e.lanes, !(n & e.childLanes)) return null;
  if (t !== null && e.child !== t.child) throw Error(ne(153));
  if (e.child !== null) {
    for (t = e.child, n = Di(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;) t = t.sibling, n = n.sibling = Di(t, t.pendingProps), n.return = e;
    n.sibling = null
  }
  return e.child
}

function xF(t, e, n) {
  switch (e.tag) {
    case 3:
      xR(e), ql();
      break;
    case 5:
      JO(e);
      break;
    case 1:
      yr(e.type) && om(e);
      break;
    case 4:
      Ix(e, e.stateNode.containerInfo);
      break;
    case 10:
      var r = e.type._context,
        o = e.memoizedProps.value;
      Ct(am, r._currentValue), r._currentValue = o;
      break;
    case 13:
      if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (Ct(zt, zt.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? ER(t, e, n) : (Ct(zt, zt.current & 1), t = Gs(t, e, n), t !== null ? t.sibling : null);
      Ct(zt, zt.current & 1);
      break;
    case 19:
      if (r = (n & e.childLanes) !== 0, t.flags & 128) {
        if (r) return kR(t, e, n);
        e.flags |= 128
      }
      if (o = e.memoizedState, o !== null && (o.rendering = null, o.tail = null, o.lastEffect = null), Ct(zt, zt.current), r) break;
      return null;
    case 22:
    case 23:
      return e.lanes = 0, SR(t, e, n)
  }
  return Gs(t, e, n)
}
var CR, aS, PR, TR;
CR = function(t, e) {
  for (var n = e.child; n !== null;) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      n.child.return = n, n = n.child;
      continue
    }
    if (n === e) break;
    for (; n.sibling === null;) {
      if (n.return === null || n.return === e) return;
      n = n.return
    }
    n.sibling.return = n.return, n = n.sibling
  }
};
aS = function() {};
PR = function(t, e, n, r) {
  var o = t.memoizedProps;
  if (o !== r) {
    t = e.stateNode, Pa(cs.current);
    var s = null;
    switch (n) {
      case "input":
        o = $w(t, o), r = $w(t, r), s = [];
        break;
      case "select":
        o = Wt({}, o, {
          value: void 0
        }), r = Wt({}, r, {
          value: void 0
        }), s = [];
        break;
      case "textarea":
        o = Rw(t, o), r = Rw(t, r), s = [];
        break;
      default:
        typeof o.onClick != "function" && typeof r.onClick == "function" && (t.onclick = nm)
    }
    Mw(n, r);
    var i;
    n = null;
    for (l in o)
      if (!r.hasOwnProperty(l) && o.hasOwnProperty(l) && o[l] != null)
        if (l === "style") {
          var a = o[l];
          for (i in a) a.hasOwnProperty(i) && (n || (n = {}), n[i] = "")
        } else l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (sf.hasOwnProperty(l) ? s || (s = []) : (s = s || []).push(l, null));
    for (l in r) {
      var c = r[l];
      if (a = o != null ? o[l] : void 0, r.hasOwnProperty(l) && c !== a && (c != null || a != null))
        if (l === "style")
          if (a) {
            for (i in a) !a.hasOwnProperty(i) || c && c.hasOwnProperty(i) || (n || (n = {}), n[i] = "");
            for (i in c) c.hasOwnProperty(i) && a[i] !== c[i] && (n || (n = {}), n[i] = c[i])
          } else n || (s || (s = []), s.push(l, n)), n = c;
      else l === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, a = a ? a.__html : void 0, c != null && a !== c && (s = s || []).push(l, c)) : l === "children" ? typeof c != "string" && typeof c != "number" || (s = s || []).push(l, "" + c) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (sf.hasOwnProperty(l) ? (c != null && l === "onScroll" && $t("scroll", t), s || a === c || (s = [])) : (s = s || []).push(l, c))
    }
    n && (s = s || []).push("style", n);
    var l = s;
    (e.updateQueue = l) && (e.flags |= 4)
  }
};
TR = function(t, e, n, r) {
  n !== r && (e.flags |= 4)
};

function qu(t, e) {
  if (!Dt) switch (t.tailMode) {
    case "hidden":
      e = t.tail;
      for (var n = null; e !== null;) e.alternate !== null && (n = e), e = e.sibling;
      n === null ? t.tail = null : n.sibling = null;
      break;
    case "collapsed":
      n = t.tail;
      for (var r = null; n !== null;) n.alternate !== null && (r = n), n = n.sibling;
      r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null
  }
}

function Dn(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    r = 0;
  if (e)
    for (var o = t.child; o !== null;) n |= o.lanes | o.childLanes, r |= o.subtreeFlags & 14680064, r |= o.flags & 14680064, o.return = t, o = o.sibling;
  else
    for (o = t.child; o !== null;) n |= o.lanes | o.childLanes, r |= o.subtreeFlags, r |= o.flags, o.return = t, o = o.sibling;
  return t.subtreeFlags |= r, t.childLanes = n, e
}

function EF(t, e, n) {
  var r = e.pendingProps;
  switch (xx(e), e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Dn(e), null;
    case 1:
      return yr(e.type) && rm(), Dn(e), null;
    case 3:
      return r = e.stateNode, Zl(), Ot(mr), Ot(Gn), Rx(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (_p(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Eo !== null && (gS(Eo), Eo = null))), aS(t, e), Dn(e), null;
    case 5:
      Ox(e);
      var o = Pa(vf.current);
      if (n = e.type, t !== null && e.stateNode != null) PR(t, e, n, r, o), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
      else {
        if (!r) {
          if (e.stateNode === null) throw Error(ne(166));
          return Dn(e), null
        }
        if (t = Pa(cs.current), _p(e)) {
          r = e.stateNode, n = e.type;
          var s = e.memoizedProps;
          switch (r[os] = e, r[mf] = s, t = (e.mode & 1) !== 0, n) {
            case "dialog":
              $t("cancel", r), $t("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              $t("load", r);
              break;
            case "video":
            case "audio":
              for (o = 0; o < Pd.length; o++) $t(Pd[o], r);
              break;
            case "source":
              $t("error", r);
              break;
            case "img":
            case "image":
            case "link":
              $t("error", r), $t("load", r);
              break;
            case "details":
              $t("toggle", r);
              break;
            case "input":
              Fk(r, s), $t("invalid", r);
              break;
            case "select":
              r._wrapperState = {
                wasMultiple: !!s.multiple
              }, $t("invalid", r);
              break;
            case "textarea":
              Uk(r, s), $t("invalid", r)
          }
          Mw(n, s), o = null;
          for (var i in s)
            if (s.hasOwnProperty(i)) {
              var a = s[i];
              i === "children" ? typeof a == "string" ? r.textContent !== a && (s.suppressHydrationWarning !== !0 && Sp(r.textContent, a, t), o = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (s.suppressHydrationWarning !== !0 && Sp(r.textContent, a, t), o = ["children", "" + a]) : sf.hasOwnProperty(i) && a != null && i === "onScroll" && $t("scroll", r)
            } switch (n) {
            case "input":
              hp(r), Bk(r, s, !0);
              break;
            case "textarea":
              hp(r), zk(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = nm)
          }
          r = o, e.updateQueue = r, r !== null && (e.flags |= 4)
        } else {
          i = o.nodeType === 9 ? o : o.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = tO(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = i.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = i.createElement(n, {
            is: r.is
          }) : (t = i.createElement(n), n === "select" && (i = t, r.multiple ? i.multiple = !0 : r.size && (i.size = r.size))) : t = i.createElementNS(t, n), t[os] = e, t[mf] = r, CR(t, e, !1, !1), e.stateNode = t;
          e: {
            switch (i = jw(n, r), n) {
              case "dialog":
                $t("cancel", t), $t("close", t), o = r;
                break;
              case "iframe":
              case "object":
              case "embed":
                $t("load", t), o = r;
                break;
              case "video":
              case "audio":
                for (o = 0; o < Pd.length; o++) $t(Pd[o], t);
                o = r;
                break;
              case "source":
                $t("error", t), o = r;
                break;
              case "img":
              case "image":
              case "link":
                $t("error", t), $t("load", t), o = r;
                break;
              case "details":
                $t("toggle", t), o = r;
                break;
              case "input":
                Fk(t, r), o = $w(t, r), $t("invalid", t);
                break;
              case "option":
                o = r;
                break;
              case "select":
                t._wrapperState = {
                  wasMultiple: !!r.multiple
                }, o = Wt({}, r, {
                  value: void 0
                }), $t("invalid", t);
                break;
              case "textarea":
                Uk(t, r), o = Rw(t, r), $t("invalid", t);
                break;
              default:
                o = r
            }
            Mw(n, o),
            a = o;
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var c = a[s];
                s === "style" ? oO(t, c) : s === "dangerouslySetInnerHTML" ? (c = c ? c.__html : void 0, c != null && nO(t, c)) : s === "children" ? typeof c == "string" ? (n !== "textarea" || c !== "") && af(t, c) : typeof c == "number" && af(t, "" + c) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (sf.hasOwnProperty(s) ? c != null && s === "onScroll" && $t("scroll", t) : c != null && cx(t, s, c, i))
              } switch (n) {
              case "input":
                hp(t), Bk(t, r, !1);
                break;
              case "textarea":
                hp(t), zk(t);
                break;
              case "option":
                r.value != null && t.setAttribute("value", "" + zi(r.value));
                break;
              case "select":
                t.multiple = !!r.multiple, s = r.value, s != null ? Pl(t, !!r.multiple, s, !1) : r.defaultValue != null && Pl(t, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof o.onClick == "function" && (t.onclick = nm)
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1
            }
          }
          r && (e.flags |= 4)
        }
        e.ref !== null && (e.flags |= 512, e.flags |= 2097152)
      }
      return Dn(e), null;
    case 6:
      if (t && e.stateNode != null) TR(t, e, t.memoizedProps, r);
      else {
        if (typeof r != "string" && e.stateNode === null) throw Error(ne(166));
        if (n = Pa(vf.current), Pa(cs.current), _p(e)) {
          if (r = e.stateNode, n = e.memoizedProps, r[os] = e, (s = r.nodeValue !== n) && (t = Lr, t !== null)) switch (t.tag) {
            case 3:
              Sp(r.nodeValue, n, (t.mode & 1) !== 0);
              break;
            case 5:
              t.memoizedProps.suppressHydrationWarning !== !0 && Sp(r.nodeValue, n, (t.mode & 1) !== 0)
          }
          s && (e.flags |= 4)
        } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[os] = e, e.stateNode = r
      }
      return Dn(e), null;
    case 13:
      if (Ot(zt), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
        if (Dt && Dr !== null && e.mode & 1 && !(e.flags & 128)) WO(), ql(), e.flags |= 98560, s = !1;
        else if (s = _p(e), r !== null && r.dehydrated !== null) {
          if (t === null) {
            if (!s) throw Error(ne(318));
            if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(ne(317));
            s[os] = e
          } else ql(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
          Dn(e), s = !1
        } else Eo !== null && (gS(Eo), Eo = null), s = !0;
        if (!s) return e.flags & 65536 ? e : null
      }
      return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || zt.current & 1 ? cn === 0 && (cn = 3) : Vx())), e.updateQueue !== null && (e.flags |= 4), Dn(e), null);
    case 4:
      return Zl(), aS(t, e), t === null && pf(e.stateNode.containerInfo), Dn(e), null;
    case 10:
      return Px(e.type._context), Dn(e), null;
    case 17:
      return yr(e.type) && rm(), Dn(e), null;
    case 19:
      if (Ot(zt), s = e.memoizedState, s === null) return Dn(e), null;
      if (r = (e.flags & 128) !== 0, i = s.rendering, i === null)
        if (r) qu(s, !1);
        else {
          if (cn !== 0 || t !== null && t.flags & 128)
            for (t = e.child; t !== null;) {
              if (i = um(t), i !== null) {
                for (e.flags |= 128, qu(s, !1), r = i.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;) s = n, t = r, s.flags &= 14680066, i = s.alternate, i === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = i.childLanes, s.lanes = i.lanes, s.child = i.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = i.memoizedProps, s.memoizedState = i.memoizedState, s.updateQueue = i.updateQueue, s.type = i.type, t = i.dependencies, s.dependencies = t === null ? null : {
                  lanes: t.lanes,
                  firstContext: t.firstContext
                }), n = n.sibling;
                return Ct(zt, zt.current & 1 | 2), e.child
              }
              t = t.sibling
            }
          s.tail !== null && nn() > Ql && (e.flags |= 128, r = !0, qu(s, !1), e.lanes = 4194304)
        }
      else {
        if (!r)
          if (t = um(i), t !== null) {
            if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), qu(s, !0), s.tail === null && s.tailMode === "hidden" && !i.alternate && !Dt) return Dn(e), null
          } else 2 * nn() - s.renderingStartTime > Ql && n !== 1073741824 && (e.flags |= 128, r = !0, qu(s, !1), e.lanes = 4194304);
        s.isBackwards ? (i.sibling = e.child, e.child = i) : (n = s.last, n !== null ? n.sibling = i : e.child = i, s.last = i)
      }
      return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = nn(), e.sibling = null, n = zt.current, Ct(zt, r ? n & 1 | 2 : n & 1), e) : (Dn(e), null);
    case 22:
    case 23:
      return Hx(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Ar & 1073741824 && (Dn(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : Dn(e), null;
    case 24:
      return null;
    case 25:
      return null
  }
  throw Error(ne(156, e.tag))
}

function kF(t, e) {
  switch (xx(e), e.tag) {
    case 1:
      return yr(e.type) && rm(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
    case 3:
      return Zl(), Ot(mr), Ot(Gn), Rx(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
    case 5:
      return Ox(e), null;
    case 13:
      if (Ot(zt), t = e.memoizedState, t !== null && t.dehydrated !== null) {
        if (e.alternate === null) throw Error(ne(340));
        ql()
      }
      return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
    case 19:
      return Ot(zt), null;
    case 4:
      return Zl(), null;
    case 10:
      return Px(e.type._context), null;
    case 22:
    case 23:
      return Hx(), null;
    case 24:
      return null;
    default:
      return null
  }
}
var kp = !1,
  zn = !1,
  CF = typeof WeakSet == "function" ? WeakSet : Set,
  he = null;

function ul(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function") try {
      n(null)
    } catch (r) {
      Yt(t, e, r)
    } else n.current = null
}

function cS(t, e, n) {
  try {
    n()
  } catch (r) {
    Yt(t, e, r)
  }
}
var OC = !1;

function PF(t, e) {
  if (Ww = Qg, t = RO(), Sx(t)) {
    if ("selectionStart" in t) var n = {
      start: t.selectionStart,
      end: t.selectionEnd
    };
    else e: {
      n = (n = t.ownerDocument) && n.defaultView || window;
      var r = n.getSelection && n.getSelection();
      if (r && r.rangeCount !== 0) {
        n = r.anchorNode;
        var o = r.anchorOffset,
          s = r.focusNode;
        r = r.focusOffset;
        try {
          n.nodeType, s.nodeType
        } catch {
          n = null;
          break e
        }
        var i = 0,
          a = -1,
          c = -1,
          l = 0,
          u = 0,
          d = t,
          f = null;
        t: for (;;) {
          for (var h; d !== n || o !== 0 && d.nodeType !== 3 || (a = i + o), d !== s || r !== 0 && d.nodeType !== 3 || (c = i + r), d.nodeType === 3 && (i += d.nodeValue.length), (h = d.firstChild) !== null;) f = d, d = h;
          for (;;) {
            if (d === t) break t;
            if (f === n && ++l === o && (a = i), f === s && ++u === r && (c = i), (h = d.nextSibling) !== null) break;
            d = f, f = d.parentNode
          }
          d = h
        }
        n = a === -1 || c === -1 ? null : {
          start: a,
          end: c
        }
      } else n = null
    }
    n = n || {
      start: 0,
      end: 0
    }
  } else n = null;
  for (Kw = {
      focusedElem: t,
      selectionRange: n
    }, Qg = !1, he = e; he !== null;)
    if (e = he, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, he = t;
    else
      for (; he !== null;) {
        e = he;
        try {
          var m = e.alternate;
          if (e.flags & 1024) switch (e.tag) {
            case 0:
            case 11:
            case 15:
              break;
            case 1:
              if (m !== null) {
                var p = m.memoizedProps,
                  b = m.memoizedState,
                  w = e.stateNode,
                  v = w.getSnapshotBeforeUpdate(e.elementType === e.type ? p : mo(e.type, p), b);
                w.__reactInternalSnapshotBeforeUpdate = v
              }
              break;
            case 3:
              var _ = e.stateNode.containerInfo;
              _.nodeType === 1 ? _.textContent = "" : _.nodeType === 9 && _.documentElement && _.removeChild(_.documentElement);
              break;
            case 5:
            case 6:
            case 4:
            case 17:
              break;
            default:
              throw Error(ne(163))
          }
        } catch (S) {
          Yt(e, e.return, S)
        }
        if (t = e.sibling, t !== null) {
          t.return = e.return, he = t;
          break
        }
        he = e.return
      }
  return m = OC, OC = !1, m
}

function zd(t, e, n) {
  var r = e.updateQueue;
  if (r = r !== null ? r.lastEffect : null, r !== null) {
    var o = r = r.next;
    do {
      if ((o.tag & t) === t) {
        var s = o.destroy;
        o.destroy = void 0, s !== void 0 && cS(e, n, s)
      }
      o = o.next
    } while (o !== r)
  }
}

function My(t, e) {
  if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
    var n = e = e.next;
    do {
      if ((n.tag & t) === t) {
        var r = n.create;
        n.destroy = r()
      }
      n = n.next
    } while (n !== e)
  }
}

function lS(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n
    }
    typeof e == "function" ? e(t) : e.current = t
  }
}

function $R(t) {
  var e = t.alternate;
  e !== null && (t.alternate = null, $R(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[os], delete e[mf], delete e[qw], delete e[lF], delete e[uF])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null
}

function IR(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4
}

function RC(t) {
  e: for (;;) {
    for (; t.sibling === null;) {
      if (t.return === null || IR(t.return)) return null;
      t = t.return
    }
    for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      t.child.return = t, t = t.child
    }
    if (!(t.flags & 2)) return t.stateNode
  }
}

function uS(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = nm));
  else if (r !== 4 && (t = t.child, t !== null))
    for (uS(t, e, n), t = t.sibling; t !== null;) uS(t, e, n), t = t.sibling
}

function dS(t, e, n) {
  var r = t.tag;
  if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (r !== 4 && (t = t.child, t !== null))
    for (dS(t, e, n), t = t.sibling; t !== null;) dS(t, e, n), t = t.sibling
}
var xn = null,
  vo = !1;

function ci(t, e, n) {
  for (n = n.child; n !== null;) OR(t, e, n), n = n.sibling
}

function OR(t, e, n) {
  if (as && typeof as.onCommitFiberUnmount == "function") try {
    as.onCommitFiberUnmount(Cy, n)
  } catch {}
  switch (n.tag) {
    case 5:
      zn || ul(n, e);
    case 6:
      var r = xn,
        o = vo;
      xn = null, ci(t, e, n), xn = r, vo = o, xn !== null && (vo ? (t = xn, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : xn.removeChild(n.stateNode));
      break;
    case 18:
      xn !== null && (vo ? (t = xn, n = n.stateNode, t.nodeType === 8 ? g0(t.parentNode, n) : t.nodeType === 1 && g0(t, n), df(t)) : g0(xn, n.stateNode));
      break;
    case 4:
      r = xn, o = vo, xn = n.stateNode.containerInfo, vo = !0, ci(t, e, n), xn = r, vo = o;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!zn && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) {
        o = r = r.next;
        do {
          var s = o,
            i = s.destroy;
          s = s.tag, i !== void 0 && (s & 2 || s & 4) && cS(n, e, i), o = o.next
        } while (o !== r)
      }
      ci(t, e, n);
      break;
    case 1:
      if (!zn && (ul(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try {
        r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount()
      } catch (a) {
        Yt(n, e, a)
      }
      ci(t, e, n);
      break;
    case 21:
      ci(t, e, n);
      break;
    case 22:
      n.mode & 1 ? (zn = (r = zn) || n.memoizedState !== null, ci(t, e, n), zn = r) : ci(t, e, n);
      break;
    default:
      ci(t, e, n)
  }
}

function AC(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new CF), e.forEach(function(r) {
      var o = DF.bind(null, t, r);
      n.has(r) || (n.add(r), r.then(o, o))
    })
  }
}

function po(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      try {
        var s = t,
          i = e,
          a = i;
        e: for (; a !== null;) {
          switch (a.tag) {
            case 5:
              xn = a.stateNode, vo = !1;
              break e;
            case 3:
              xn = a.stateNode.containerInfo, vo = !0;
              break e;
            case 4:
              xn = a.stateNode.containerInfo, vo = !0;
              break e
          }
          a = a.return
        }
        if (xn === null) throw Error(ne(160));
        OR(s, i, o), xn = null, vo = !1;
        var c = o.alternate;
        c !== null && (c.return = null), o.return = null
      } catch (l) {
        Yt(o, e, l)
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null;) RR(e, t), e = e.sibling
}

function RR(t, e) {
  var n = t.alternate,
    r = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (po(e, t), Xo(t), r & 4) {
        try {
          zd(3, t, t.return), My(3, t)
        } catch (p) {
          Yt(t, t.return, p)
        }
        try {
          zd(5, t, t.return)
        } catch (p) {
          Yt(t, t.return, p)
        }
      }
      break;
    case 1:
      po(e, t), Xo(t), r & 512 && n !== null && ul(n, n.return);
      break;
    case 5:
      if (po(e, t), Xo(t), r & 512 && n !== null && ul(n, n.return), t.flags & 32) {
        var o = t.stateNode;
        try {
          af(o, "")
        } catch (p) {
          Yt(t, t.return, p)
        }
      }
      if (r & 4 && (o = t.stateNode, o != null)) {
        var s = t.memoizedProps,
          i = n !== null ? n.memoizedProps : s,
          a = t.type,
          c = t.updateQueue;
        if (t.updateQueue = null, c !== null) try {
          a === "input" && s.type === "radio" && s.name != null && QI(o, s), jw(a, i);
          var l = jw(a, s);
          for (i = 0; i < c.length; i += 2) {
            var u = c[i],
              d = c[i + 1];
            u === "style" ? oO(o, d) : u === "dangerouslySetInnerHTML" ? nO(o, d) : u === "children" ? af(o, d) : cx(o, u, d, l)
          }
          switch (a) {
            case "input":
              Iw(o, s);
              break;
            case "textarea":
              eO(o, s);
              break;
            case "select":
              var f = o._wrapperState.wasMultiple;
              o._wrapperState.wasMultiple = !!s.multiple;
              var h = s.value;
              h != null ? Pl(o, !!s.multiple, h, !1) : f !== !!s.multiple && (s.defaultValue != null ? Pl(o, !!s.multiple, s.defaultValue, !0) : Pl(o, !!s.multiple, s.multiple ? [] : "", !1))
          }
          o[mf] = s
        } catch (p) {
          Yt(t, t.return, p)
        }
      }
      break;
    case 6:
      if (po(e, t), Xo(t), r & 4) {
        if (t.stateNode === null) throw Error(ne(162));
        o = t.stateNode, s = t.memoizedProps;
        try {
          o.nodeValue = s
        } catch (p) {
          Yt(t, t.return, p)
        }
      }
      break;
    case 3:
      if (po(e, t), Xo(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try {
        df(e.containerInfo)
      } catch (p) {
        Yt(t, t.return, p)
      }
      break;
    case 4:
      po(e, t), Xo(t);
      break;
    case 13:
      po(e, t), Xo(t), o = t.child, o.flags & 8192 && (s = o.memoizedState !== null, o.stateNode.isHidden = s, !s || o.alternate !== null && o.alternate.memoizedState !== null || (Ux = nn())), r & 4 && AC(t);
      break;
    case 22:
      if (u = n !== null && n.memoizedState !== null, t.mode & 1 ? (zn = (l = zn) || u, po(e, t), zn = l) : po(e, t), Xo(t), r & 8192) {
        if (l = t.memoizedState !== null, (t.stateNode.isHidden = l) && !u && t.mode & 1)
          for (he = t, u = t.child; u !== null;) {
            for (d = he = u; he !== null;) {
              switch (f = he, h = f.child, f.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  zd(4, f, f.return);
                  break;
                case 1:
                  ul(f, f.return);
                  var m = f.stateNode;
                  if (typeof m.componentWillUnmount == "function") {
                    r = f, n = f.return;
                    try {
                      e = r, m.props = e.memoizedProps, m.state = e.memoizedState, m.componentWillUnmount()
                    } catch (p) {
                      Yt(r, n, p)
                    }
                  }
                  break;
                case 5:
                  ul(f, f.return);
                  break;
                case 22:
                  if (f.memoizedState !== null) {
                    jC(d);
                    continue
                  }
              }
              h !== null ? (h.return = f, he = h) : jC(d)
            }
            u = u.sibling
          }
        e: for (u = null, d = t;;) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                o = d.stateNode, l ? (s = o.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, c = d.memoizedProps.style, i = c != null && c.hasOwnProperty("display") ? c.display : null, a.style.display = rO("display", i))
              } catch (p) {
                Yt(t, t.return, p)
              }
            }
          } else if (d.tag === 6) {
            if (u === null) try {
              d.stateNode.nodeValue = l ? "" : d.memoizedProps
            } catch (p) {
              Yt(t, t.return, p)
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue
          }
          if (d === t) break e;
          for (; d.sibling === null;) {
            if (d.return === null || d.return === t) break e;
            u === d && (u = null), d = d.return
          }
          u === d && (u = null), d.sibling.return = d.return, d = d.sibling
        }
      }
      break;
    case 19:
      po(e, t), Xo(t), r & 4 && AC(t);
      break;
    case 21:
      break;
    default:
      po(e, t), Xo(t)
  }
}

function Xo(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null;) {
          if (IR(n)) {
            var r = n;
            break e
          }
          n = n.return
        }
        throw Error(ne(160))
      }
      switch (r.tag) {
        case 5:
          var o = r.stateNode;
          r.flags & 32 && (af(o, ""), r.flags &= -33);
          var s = RC(t);
          dS(t, s, o);
          break;
        case 3:
        case 4:
          var i = r.stateNode.containerInfo,
            a = RC(t);
          uS(t, a, i);
          break;
        default:
          throw Error(ne(161))
      }
    }
    catch (c) {
      Yt(t, t.return, c)
    }
    t.flags &= -3
  }
  e & 4096 && (t.flags &= -4097)
}

function TF(t, e, n) {
  he = t, AR(t)
}

function AR(t, e, n) {
  for (var r = (t.mode & 1) !== 0; he !== null;) {
    var o = he,
      s = o.child;
    if (o.tag === 22 && r) {
      var i = o.memoizedState !== null || kp;
      if (!i) {
        var a = o.alternate,
          c = a !== null && a.memoizedState !== null || zn;
        a = kp;
        var l = zn;
        if (kp = i, (zn = c) && !l)
          for (he = o; he !== null;) i = he, c = i.child, i.tag === 22 && i.memoizedState !== null ? DC(o) : c !== null ? (c.return = i, he = c) : DC(o);
        for (; s !== null;) he = s, AR(s), s = s.sibling;
        he = o, kp = a, zn = l
      }
      MC(t)
    } else o.subtreeFlags & 8772 && s !== null ? (s.return = o, he = s) : MC(t)
  }
}

function MC(t) {
  for (; he !== null;) {
    var e = he;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772) switch (e.tag) {
          case 0:
          case 11:
          case 15:
            zn || My(5, e);
            break;
          case 1:
            var r = e.stateNode;
            if (e.flags & 4 && !zn)
              if (n === null) r.componentDidMount();
              else {
                var o = e.elementType === e.type ? n.memoizedProps : mo(e.type, n.memoizedProps);
                r.componentDidUpdate(o, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate)
              } var s = e.updateQueue;
            s !== null && yC(e, s, r);
            break;
          case 3:
            var i = e.updateQueue;
            if (i !== null) {
              if (n = null, e.child !== null) switch (e.child.tag) {
                case 5:
                  n = e.child.stateNode;
                  break;
                case 1:
                  n = e.child.stateNode
              }
              yC(e, i, n)
            }
            break;
          case 5:
            var a = e.stateNode;
            if (n === null && e.flags & 4) {
              n = a;
              var c = e.memoizedProps;
              switch (e.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  c.autoFocus && n.focus();
                  break;
                case "img":
                  c.src && (n.src = c.src)
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (e.memoizedState === null) {
              var l = e.alternate;
              if (l !== null) {
                var u = l.memoizedState;
                if (u !== null) {
                  var d = u.dehydrated;
                  d !== null && df(d)
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(ne(163))
        }
        zn || e.flags & 512 && lS(e)
      } catch (f) {
        Yt(e, e.return, f)
      }
    }
    if (e === t) {
      he = null;
      break
    }
    if (n = e.sibling, n !== null) {
      n.return = e.return, he = n;
      break
    }
    he = e.return
  }
}

function jC(t) {
  for (; he !== null;) {
    var e = he;
    if (e === t) {
      he = null;
      break
    }
    var n = e.sibling;
    if (n !== null) {
      n.return = e.return, he = n;
      break
    }
    he = e.return
  }
}

function DC(t) {
  for (; he !== null;) {
    var e = he;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            My(4, e)
          } catch (c) {
            Yt(e, n, c)
          }
          break;
        case 1:
          var r = e.stateNode;
          if (typeof r.componentDidMount == "function") {
            var o = e.return;
            try {
              r.componentDidMount()
            } catch (c) {
              Yt(e, o, c)
            }
          }
          var s = e.return;
          try {
            lS(e)
          } catch (c) {
            Yt(e, s, c)
          }
          break;
        case 5:
          var i = e.return;
          try {
            lS(e)
          } catch (c) {
            Yt(e, i, c)
          }
      }
    } catch (c) {
      Yt(e, e.return, c)
    }
    if (e === t) {
      he = null;
      break
    }
    var a = e.sibling;
    if (a !== null) {
      a.return = e.return, he = a;
      break
    }
    he = e.return
  }
}
var $F = Math.ceil,
  hm = ti.ReactCurrentDispatcher,
  Fx = ti.ReactCurrentOwner,
  ro = ti.ReactCurrentBatchConfig,
  st = 0,
  gn = null,
  sn = null,
  In = 0,
  Ar = 0,
  dl = Qi(0),
  cn = 0,
  _f = null,
  Wa = 0,
  jy = 0,
  Bx = 0,
  Hd = null,
  dr = null,
  Ux = 0,
  Ql = 1 / 0,
  Ts = null,
  pm = !1,
  fS = null,
  Mi = null,
  Cp = !1,
  Ci = null,
  gm = 0,
  Vd = 0,
  hS = null,
  _g = -1,
  xg = 0;

function nr() {
  return st & 6 ? nn() : _g !== -1 ? _g : _g = nn()
}

function ji(t) {
  return t.mode & 1 ? st & 2 && In !== 0 ? In & -In : fF.transition !== null ? (xg === 0 && (xg = mO()), xg) : (t = vt, t !== 0 || (t = window.event, t = t === void 0 ? 16 : xO(t.type)), t) : 1
}

function Ro(t, e, n, r) {
  if (50 < Vd) throw Vd = 0, hS = null, Error(ne(185));
  hh(t, n, r), (!(st & 2) || t !== gn) && (t === gn && (!(st & 2) && (jy |= n), cn === 4 && _i(t, In)), vr(t, r), n === 1 && st === 0 && !(e.mode & 1) && (Ql = nn() + 500, Oy && ea()))
}

function vr(t, e) {
  var n = t.callbackNode;
  f9(t, e);
  var r = Jg(t, t === gn ? In : 0);
  if (r === 0) n !== null && Wk(n), t.callbackNode = null, t.callbackPriority = 0;
  else if (e = r & -r, t.callbackPriority !== e) {
    if (n != null && Wk(n), e === 1) t.tag === 0 ? dF(NC.bind(null, t)) : zO(NC.bind(null, t)), aF(function() {
      !(st & 6) && ea()
    }), n = null;
    else {
      switch (yO(r)) {
        case 1:
          n = hx;
          break;
        case 4:
          n = pO;
          break;
        case 16:
          n = Zg;
          break;
        case 536870912:
          n = gO;
          break;
        default:
          n = Zg
      }
      n = UR(n, MR.bind(null, t))
    }
    t.callbackPriority = e, t.callbackNode = n
  }
}

function MR(t, e) {
  if (_g = -1, xg = 0, st & 6) throw Error(ne(327));
  var n = t.callbackNode;
  if (Rl() && t.callbackNode !== n) return null;
  var r = Jg(t, t === gn ? In : 0);
  if (r === 0) return null;
  if (r & 30 || r & t.expiredLanes || e) e = mm(t, r);
  else {
    e = r;
    var o = st;
    st |= 2;
    var s = DR();
    (gn !== t || In !== e) && (Ts = null, Ql = nn() + 500, Aa(t, e));
    do try {
      RF();
      break
    } catch (a) {
      jR(t, a)
    }
    while (1);
    Cx(), hm.current = s, st = o, sn !== null ? e = 0 : (gn = null, In = 0, e = cn)
  }
  if (e !== 0) {
    if (e === 2 && (o = Bw(t), o !== 0 && (r = o, e = pS(t, o))), e === 1) throw n = _f, Aa(t, 0), _i(t, r), vr(t, nn()), n;
    if (e === 6) _i(t, r);
    else {
      if (o = t.current.alternate, !(r & 30) && !IF(o) && (e = mm(t, r), e === 2 && (s = Bw(t), s !== 0 && (r = s, e = pS(t, s))), e === 1)) throw n = _f, Aa(t, 0), _i(t, r), vr(t, nn()), n;
      switch (t.finishedWork = o, t.finishedLanes = r, e) {
        case 0:
        case 1:
          throw Error(ne(345));
        case 2:
          ba(t, dr, Ts);
          break;
        case 3:
          if (_i(t, r), (r & 130023424) === r && (e = Ux + 500 - nn(), 10 < e)) {
            if (Jg(t, 0) !== 0) break;
            if (o = t.suspendedLanes, (o & r) !== r) {
              nr(), t.pingedLanes |= t.suspendedLanes & o;
              break
            }
            t.timeoutHandle = Yw(ba.bind(null, t, dr, Ts), e);
            break
          }
          ba(t, dr, Ts);
          break;
        case 4:
          if (_i(t, r), (r & 4194240) === r) break;
          for (e = t.eventTimes, o = -1; 0 < r;) {
            var i = 31 - Oo(r);
            s = 1 << i, i = e[i], i > o && (o = i), r &= ~s
          }
          if (r = o, r = nn() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * $F(r / 1960)) - r, 10 < r) {
            t.timeoutHandle = Yw(ba.bind(null, t, dr, Ts), r);
            break
          }
          ba(t, dr, Ts);
          break;
        case 5:
          ba(t, dr, Ts);
          break;
        default:
          throw Error(ne(329))
      }
    }
  }
  return vr(t, nn()), t.callbackNode === n ? MR.bind(null, t) : null
}

function pS(t, e) {
  var n = Hd;
  return t.current.memoizedState.isDehydrated && (Aa(t, e).flags |= 256), t = mm(t, e), t !== 2 && (e = dr, dr = n, e !== null && gS(e)), t
}

function gS(t) {
  dr === null ? dr = t : dr.push.apply(dr, t)
}

function IF(t) {
  for (var e = t;;) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && (n = n.stores, n !== null))
        for (var r = 0; r < n.length; r++) {
          var o = n[r],
            s = o.getSnapshot;
          o = o.value;
          try {
            if (!Lo(s(), o)) return !1
          } catch {
            return !1
          }
        }
    }
    if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n;
    else {
      if (e === t) break;
      for (; e.sibling === null;) {
        if (e.return === null || e.return === t) return !0;
        e = e.return
      }
      e.sibling.return = e.return, e = e.sibling
    }
  }
  return !0
}

function _i(t, e) {
  for (e &= ~Bx, e &= ~jy, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) {
    var n = 31 - Oo(e),
      r = 1 << n;
    t[n] = -1, e &= ~r
  }
}

function NC(t) {
  if (st & 6) throw Error(ne(327));
  Rl();
  var e = Jg(t, 0);
  if (!(e & 1)) return vr(t, nn()), null;
  var n = mm(t, e);
  if (t.tag !== 0 && n === 2) {
    var r = Bw(t);
    r !== 0 && (e = r, n = pS(t, r))
  }
  if (n === 1) throw n = _f, Aa(t, 0), _i(t, e), vr(t, nn()), n;
  if (n === 6) throw Error(ne(345));
  return t.finishedWork = t.current.alternate, t.finishedLanes = e, ba(t, dr, Ts), vr(t, nn()), null
}

function zx(t, e) {
  var n = st;
  st |= 1;
  try {
    return t(e)
  } finally {
    st = n, st === 0 && (Ql = nn() + 500, Oy && ea())
  }
}

function Ka(t) {
  Ci !== null && Ci.tag === 0 && !(st & 6) && Rl();
  var e = st;
  st |= 1;
  var n = ro.transition,
    r = vt;
  try {
    if (ro.transition = null, vt = 1, t) return t()
  } finally {
    vt = r, ro.transition = n, st = e, !(st & 6) && ea()
  }
}

function Hx() {
  Ar = dl.current, Ot(dl)
}

function Aa(t, e) {
  t.finishedWork = null, t.finishedLanes = 0;
  var n = t.timeoutHandle;
  if (n !== -1 && (t.timeoutHandle = -1, iF(n)), sn !== null)
    for (n = sn.return; n !== null;) {
      var r = n;
      switch (xx(r), r.tag) {
        case 1:
          r = r.type.childContextTypes, r != null && rm();
          break;
        case 3:
          Zl(), Ot(mr), Ot(Gn), Rx();
          break;
        case 5:
          Ox(r);
          break;
        case 4:
          Zl();
          break;
        case 13:
          Ot(zt);
          break;
        case 19:
          Ot(zt);
          break;
        case 10:
          Px(r.type._context);
          break;
        case 22:
        case 23:
          Hx()
      }
      n = n.return
    }
  if (gn = t, sn = t = Di(t.current, null), In = Ar = e, cn = 0, _f = null, Bx = jy = Wa = 0, dr = Hd = null, Ca !== null) {
    for (e = 0; e < Ca.length; e++)
      if (n = Ca[e], r = n.interleaved, r !== null) {
        n.interleaved = null;
        var o = r.next,
          s = n.pending;
        if (s !== null) {
          var i = s.next;
          s.next = o, r.next = i
        }
        n.pending = r
      } Ca = null
  }
  return t
}

function jR(t, e) {
  do {
    var n = sn;
    try {
      if (Cx(), bg.current = fm, dm) {
        for (var r = Vt.memoizedState; r !== null;) {
          var o = r.queue;
          o !== null && (o.pending = null), r = r.next
        }
        dm = !1
      }
      if (Va = 0, dn = an = Vt = null, Ud = !1, bf = 0, Fx.current = null, n === null || n.return === null) {
        cn = 1, _f = e, sn = null;
        break
      }
      e: {
        var s = t,
          i = n.return,
          a = n,
          c = e;
        if (e = In, a.flags |= 32768, c !== null && typeof c == "object" && typeof c.then == "function") {
          var l = c,
            u = a,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var f = u.alternate;
            f ? (u.updateQueue = f.updateQueue, u.memoizedState = f.memoizedState, u.lanes = f.lanes) : (u.updateQueue = null, u.memoizedState = null)
          }
          var h = EC(i);
          if (h !== null) {
            h.flags &= -257, kC(h, i, a, s, e), h.mode & 1 && xC(s, l, e), e = h, c = l;
            var m = e.updateQueue;
            if (m === null) {
              var p = new Set;
              p.add(c), e.updateQueue = p
            } else m.add(c);
            break e
          } else {
            if (!(e & 1)) {
              xC(s, l, e), Vx();
              break e
            }
            c = Error(ne(426))
          }
        } else if (Dt && a.mode & 1) {
          var b = EC(i);
          if (b !== null) {
            !(b.flags & 65536) && (b.flags |= 256), kC(b, i, a, s, e), Ex(Jl(c, a));
            break e
          }
        }
        s = c = Jl(c, a),
        cn !== 4 && (cn = 2),
        Hd === null ? Hd = [s] : Hd.push(s),
        s = i;do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, e &= -e, s.lanes |= e;
              var w = vR(s, c, e);
              mC(s, w);
              break e;
            case 1:
              a = c;
              var v = s.type,
                _ = s.stateNode;
              if (!(s.flags & 128) && (typeof v.getDerivedStateFromError == "function" || _ !== null && typeof _.componentDidCatch == "function" && (Mi === null || !Mi.has(_)))) {
                s.flags |= 65536, e &= -e, s.lanes |= e;
                var S = bR(s, a, e);
                mC(s, S);
                break e
              }
          }
          s = s.return
        } while (s !== null)
      }
      LR(n)
    } catch (x) {
      e = x, sn === n && n !== null && (sn = n = n.return);
      continue
    }
    break
  } while (1)
}

function DR() {
  var t = hm.current;
  return hm.current = fm, t === null ? fm : t
}

function Vx() {
  (cn === 0 || cn === 3 || cn === 2) && (cn = 4), gn === null || !(Wa & 268435455) && !(jy & 268435455) || _i(gn, In)
}

function mm(t, e) {
  var n = st;
  st |= 2;
  var r = DR();
  (gn !== t || In !== e) && (Ts = null, Aa(t, e));
  do try {
    OF();
    break
  } catch (o) {
    jR(t, o)
  }
  while (1);
  if (Cx(), st = n, hm.current = r, sn !== null) throw Error(ne(261));
  return gn = null, In = 0, cn
}

function OF() {
  for (; sn !== null;) NR(sn)
}

function RF() {
  for (; sn !== null && !r9();) NR(sn)
}

function NR(t) {
  var e = BR(t.alternate, t, Ar);
  t.memoizedProps = t.pendingProps, e === null ? LR(t) : sn = e, Fx.current = null
}

function LR(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (t = e.return, e.flags & 32768) {
      if (n = kF(n, e), n !== null) {
        n.flags &= 32767, sn = n;
        return
      }
      if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
      else {
        cn = 6, sn = null;
        return
      }
    } else if (n = EF(n, e, Ar), n !== null) {
      sn = n;
      return
    }
    if (e = e.sibling, e !== null) {
      sn = e;
      return
    }
    sn = e = t
  } while (e !== null);
  cn === 0 && (cn = 5)
}

function ba(t, e, n) {
  var r = vt,
    o = ro.transition;
  try {
    ro.transition = null, vt = 1, AF(t, e, n, r)
  } finally {
    ro.transition = o, vt = r
  }
  return null
}

function AF(t, e, n, r) {
  do Rl(); while (Ci !== null);
  if (st & 6) throw Error(ne(327));
  n = t.finishedWork;
  var o = t.finishedLanes;
  if (n === null) return null;
  if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(ne(177));
  t.callbackNode = null, t.callbackPriority = 0;
  var s = n.lanes | n.childLanes;
  if (h9(t, s), t === gn && (sn = gn = null, In = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || Cp || (Cp = !0, UR(Zg, function() {
      return Rl(), null
    })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) {
    s = ro.transition, ro.transition = null;
    var i = vt;
    vt = 1;
    var a = st;
    st |= 4, Fx.current = null, PF(t, n), RR(n, t), Q9(Kw), Qg = !!Ww, Kw = Ww = null, t.current = n, TF(n), o9(), st = a, vt = i, ro.transition = s
  } else t.current = n;
  if (Cp && (Cp = !1, Ci = t, gm = o), s = t.pendingLanes, s === 0 && (Mi = null), a9(n.stateNode), vr(t, nn()), e !== null)
    for (r = t.onRecoverableError, n = 0; n < e.length; n++) o = e[n], r(o.value, {
      componentStack: o.stack,
      digest: o.digest
    });
  if (pm) throw pm = !1, t = fS, fS = null, t;
  return gm & 1 && t.tag !== 0 && Rl(), s = t.pendingLanes, s & 1 ? t === hS ? Vd++ : (Vd = 0, hS = t) : Vd = 0, ea(), null
}

function Rl() {
  if (Ci !== null) {
    var t = yO(gm),
      e = ro.transition,
      n = vt;
    try {
      if (ro.transition = null, vt = 16 > t ? 16 : t, Ci === null) var r = !1;
      else {
        if (t = Ci, Ci = null, gm = 0, st & 6) throw Error(ne(331));
        var o = st;
        for (st |= 4, he = t.current; he !== null;) {
          var s = he,
            i = s.child;
          if (he.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var c = 0; c < a.length; c++) {
                var l = a[c];
                for (he = l; he !== null;) {
                  var u = he;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      zd(8, u, s)
                  }
                  var d = u.child;
                  if (d !== null) d.return = u, he = d;
                  else
                    for (; he !== null;) {
                      u = he;
                      var f = u.sibling,
                        h = u.return;
                      if ($R(u), u === l) {
                        he = null;
                        break
                      }
                      if (f !== null) {
                        f.return = h, he = f;
                        break
                      }
                      he = h
                    }
                }
              }
              var m = s.alternate;
              if (m !== null) {
                var p = m.child;
                if (p !== null) {
                  m.child = null;
                  do {
                    var b = p.sibling;
                    p.sibling = null, p = b
                  } while (p !== null)
                }
              }
              he = s
            }
          }
          if (s.subtreeFlags & 2064 && i !== null) i.return = s, he = i;
          else e: for (; he !== null;) {
            if (s = he, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                zd(9, s, s.return)
            }
            var w = s.sibling;
            if (w !== null) {
              w.return = s.return, he = w;
              break e
            }
            he = s.return
          }
        }
        var v = t.current;
        for (he = v; he !== null;) {
          i = he;
          var _ = i.child;
          if (i.subtreeFlags & 2064 && _ !== null) _.return = i, he = _;
          else e: for (i = v; he !== null;) {
            if (a = he, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  My(9, a)
              }
            } catch (x) {
              Yt(a, a.return, x)
            }
            if (a === i) {
              he = null;
              break e
            }
            var S = a.sibling;
            if (S !== null) {
              S.return = a.return, he = S;
              break e
            }
            he = a.return
          }
        }
        if (st = o, ea(), as && typeof as.onPostCommitFiberRoot == "function") try {
          as.onPostCommitFiberRoot(Cy, t)
        } catch {}
        r = !0
      }
      return r
    } finally {
      vt = n, ro.transition = e
    }
  }
  return !1
}

function LC(t, e, n) {
  e = Jl(n, e), e = vR(t, e, 1), t = Ai(t, e, 1), e = nr(), t !== null && (hh(t, 1, e), vr(t, e))
}

function Yt(t, e, n) {
  if (t.tag === 3) LC(t, t, n);
  else
    for (; e !== null;) {
      if (e.tag === 3) {
        LC(e, t, n);
        break
      } else if (e.tag === 1) {
        var r = e.stateNode;
        if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Mi === null || !Mi.has(r))) {
          t = Jl(n, t), t = bR(e, t, 1), e = Ai(e, t, 1), t = nr(), e !== null && (hh(e, 1, t), vr(e, t));
          break
        }
      }
      e = e.return
    }
}

function MF(t, e, n) {
  var r = t.pingCache;
  r !== null && r.delete(e), e = nr(), t.pingedLanes |= t.suspendedLanes & n, gn === t && (In & n) === n && (cn === 4 || cn === 3 && (In & 130023424) === In && 500 > nn() - Ux ? Aa(t, 0) : Bx |= n), vr(t, e)
}

function FR(t, e) {
  e === 0 && (t.mode & 1 ? (e = mp, mp <<= 1, !(mp & 130023424) && (mp = 4194304)) : e = 1);
  var n = nr();
  t = Ks(t, e), t !== null && (hh(t, e, n), vr(t, n))
}

function jF(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), FR(t, n)
}

function DF(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var r = t.stateNode,
        o = t.memoizedState;
      o !== null && (n = o.retryLane);
      break;
    case 19:
      r = t.stateNode;
      break;
    default:
      throw Error(ne(314))
  }
  r !== null && r.delete(e), FR(t, n)
}
var BR;
BR = function(t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || mr.current) pr = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return pr = !1, xF(t, e, n);
      pr = !!(t.flags & 131072)
    }
  else pr = !1, Dt && e.flags & 1048576 && HO(e, im, e.index);
  switch (e.lanes = 0, e.tag) {
    case 2:
      var r = e.type;
      Sg(t, e), t = e.pendingProps;
      var o = Yl(e, Gn.current);
      Ol(e, n), o = Mx(null, e, r, t, o, n);
      var s = jx();
      return e.flags |= 1, typeof o == "object" && o !== null && typeof o.render == "function" && o.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, yr(r) ? (s = !0, om(e)) : s = !1, e.memoizedState = o.state !== null && o.state !== void 0 ? o.state : null, $x(e), o.updater = Ry, e.stateNode = o, o._reactInternals = e, tS(e, r, t, n), e = oS(null, e, r, !0, s, n)) : (e.tag = 0, Dt && s && _x(e), Qn(null, e, o, n), e = e.child), e;
    case 16:
      r = e.elementType;
      e: {
        switch (Sg(t, e), t = e.pendingProps, o = r._init, r = o(r._payload), e.type = r, o = e.tag = LF(r), t = mo(r, t), o) {
          case 0:
            e = rS(null, e, r, t, n);
            break e;
          case 1:
            e = TC(null, e, r, t, n);
            break e;
          case 11:
            e = CC(null, e, r, t, n);
            break e;
          case 14:
            e = PC(null, e, r, mo(r.type, t), n);
            break e
        }
        throw Error(ne(306, r, ""))
      }
      return e;
    case 0:
      return r = e.type, o = e.pendingProps, o = e.elementType === r ? o : mo(r, o), rS(t, e, r, o, n);
    case 1:
      return r = e.type, o = e.pendingProps, o = e.elementType === r ? o : mo(r, o), TC(t, e, r, o, n);
    case 3:
      e: {
        if (xR(e), t === null) throw Error(ne(387));r = e.pendingProps,
        s = e.memoizedState,
        o = s.element,
        GO(t, e),
        lm(e, r, null, n);
        var i = e.memoizedState;
        if (r = i.element, s.isDehydrated)
          if (s = {
              element: r,
              isDehydrated: !1,
              cache: i.cache,
              pendingSuspenseBoundaries: i.pendingSuspenseBoundaries,
              transitions: i.transitions
            }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
            o = Jl(Error(ne(423)), e), e = $C(t, e, r, n, o);
            break e
          } else if (r !== o) {
          o = Jl(Error(ne(424)), e), e = $C(t, e, r, n, o);
          break e
        } else
          for (Dr = Ri(e.stateNode.containerInfo.firstChild), Lr = e, Dt = !0, Eo = null, n = ZO(e, null, r, n), e.child = n; n;) n.flags = n.flags & -3 | 4096, n = n.sibling;
        else {
          if (ql(), r === o) {
            e = Gs(t, e, n);
            break e
          }
          Qn(t, e, r, n)
        }
        e = e.child
      }
      return e;
    case 5:
      return JO(e), t === null && Jw(e), r = e.type, o = e.pendingProps, s = t !== null ? t.memoizedProps : null, i = o.children, Gw(r, o) ? i = null : s !== null && Gw(r, s) && (e.flags |= 32), _R(t, e), Qn(t, e, i, n), e.child;
    case 6:
      return t === null && Jw(e), null;
    case 13:
      return ER(t, e, n);
    case 4:
      return Ix(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = Xl(e, null, r, n) : Qn(t, e, r, n), e.child;
    case 11:
      return r = e.type, o = e.pendingProps, o = e.elementType === r ? o : mo(r, o), CC(t, e, r, o, n);
    case 7:
      return Qn(t, e, e.pendingProps, n), e.child;
    case 8:
      return Qn(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return Qn(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (r = e.type._context, o = e.pendingProps, s = e.memoizedProps, i = o.value, Ct(am, r._currentValue), r._currentValue = i, s !== null)
          if (Lo(s.value, i)) {
            if (s.children === o.children && !mr.current) {
              e = Gs(t, e, n);
              break e
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null;) {
              var a = s.dependencies;
              if (a !== null) {
                i = s.child;
                for (var c = a.firstContext; c !== null;) {
                  if (c.context === r) {
                    if (s.tag === 1) {
                      c = js(-1, n & -n), c.tag = 2;
                      var l = s.updateQueue;
                      if (l !== null) {
                        l = l.shared;
                        var u = l.pending;
                        u === null ? c.next = c : (c.next = u.next, u.next = c), l.pending = c
                      }
                    }
                    s.lanes |= n, c = s.alternate, c !== null && (c.lanes |= n), Qw(s.return, n, e), a.lanes |= n;
                    break
                  }
                  c = c.next
                }
              } else if (s.tag === 10) i = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (i = s.return, i === null) throw Error(ne(341));
                i.lanes |= n, a = i.alternate, a !== null && (a.lanes |= n), Qw(i, n, e), i = s.sibling
              } else i = s.child;
              if (i !== null) i.return = s;
              else
                for (i = s; i !== null;) {
                  if (i === e) {
                    i = null;
                    break
                  }
                  if (s = i.sibling, s !== null) {
                    s.return = i.return, i = s;
                    break
                  }
                  i = i.return
                }
              s = i
            }
        Qn(t, e, o.children, n),
        e = e.child
      }
      return e;
    case 9:
      return o = e.type, r = e.pendingProps.children, Ol(e, n), o = oo(o), r = r(o), e.flags |= 1, Qn(t, e, r, n), e.child;
    case 14:
      return r = e.type, o = mo(r, e.pendingProps), o = mo(r.type, o), PC(t, e, r, o, n);
    case 15:
      return wR(t, e, e.type, e.pendingProps, n);
    case 17:
      return r = e.type, o = e.pendingProps, o = e.elementType === r ? o : mo(r, o), Sg(t, e), e.tag = 1, yr(r) ? (t = !0, om(e)) : t = !1, Ol(e, n), qO(e, r, o), tS(e, r, o, n), oS(null, e, r, !0, t, n);
    case 19:
      return kR(t, e, n);
    case 22:
      return SR(t, e, n)
  }
  throw Error(ne(156, e.tag))
};

function UR(t, e) {
  return hO(t, e)
}

function NF(t, e, n, r) {
  this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
}

function no(t, e, n, r) {
  return new NF(t, e, n, r)
}

function Wx(t) {
  return t = t.prototype, !(!t || !t.isReactComponent)
}

function LF(t) {
  if (typeof t == "function") return Wx(t) ? 1 : 0;
  if (t != null) {
    if (t = t.$$typeof, t === ux) return 11;
    if (t === dx) return 14
  }
  return 2
}

function Di(t, e) {
  var n = t.alternate;
  return n === null ? (n = no(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : {
    lanes: e.lanes,
    firstContext: e.firstContext
  }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n
}

function Eg(t, e, n, r, o, s) {
  var i = 2;
  if (r = t, typeof t == "function") Wx(t) && (i = 1);
  else if (typeof t == "string") i = 5;
  else e: switch (t) {
    case tl:
      return Ma(n.children, o, s, e);
    case lx:
      i = 8, o |= 8;
      break;
    case kw:
      return t = no(12, n, e, o | 2), t.elementType = kw, t.lanes = s, t;
    case Cw:
      return t = no(13, n, e, o), t.elementType = Cw, t.lanes = s, t;
    case Pw:
      return t = no(19, n, e, o), t.elementType = Pw, t.lanes = s, t;
    case XI:
      return Dy(n, o, s, e);
    default:
      if (typeof t == "object" && t !== null) switch (t.$$typeof) {
        case YI:
          i = 10;
          break e;
        case qI:
          i = 9;
          break e;
        case ux:
          i = 11;
          break e;
        case dx:
          i = 14;
          break e;
        case gi:
          i = 16, r = null;
          break e
      }
      throw Error(ne(130, t == null ? t : typeof t, ""))
  }
  return e = no(i, n, e, o), e.elementType = t, e.type = r, e.lanes = s, e
}

function Ma(t, e, n, r) {
  return t = no(7, t, r, e), t.lanes = n, t
}

function Dy(t, e, n, r) {
  return t = no(22, t, r, e), t.elementType = XI, t.lanes = n, t.stateNode = {
    isHidden: !1
  }, t
}

function x0(t, e, n) {
  return t = no(6, t, null, e), t.lanes = n, t
}

function E0(t, e, n) {
  return e = no(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = {
    containerInfo: t.containerInfo,
    pendingChildren: null,
    implementation: t.implementation
  }, e
}

function FF(t, e, n, r, o) {
  this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = o0(0), this.expirationTimes = o0(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = o0(0), this.identifierPrefix = r, this.onRecoverableError = o, this.mutableSourceEagerHydrationData = null
}

function Kx(t, e, n, r, o, s, i, a, c) {
  return t = new FF(t, e, n, a, c), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = no(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = {
    element: r,
    isDehydrated: n,
    cache: null,
    transitions: null,
    pendingSuspenseBoundaries: null
  }, $x(s), t
}

function BF(t, e, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: el,
    key: r == null ? null : "" + r,
    children: t,
    containerInfo: e,
    implementation: n
  }
}

function zR(t) {
  if (!t) return Hi;
  t = t._reactInternals;
  e: {
    if (lc(t) !== t || t.tag !== 1) throw Error(ne(170));
    var e = t;do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (yr(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e
          }
      }
      e = e.return
    } while (e !== null);
    throw Error(ne(171))
  }
  if (t.tag === 1) {
    var n = t.type;
    if (yr(n)) return UO(t, n, e)
  }
  return e
}

function HR(t, e, n, r, o, s, i, a, c) {
  return t = Kx(n, r, !0, t, o, s, i, a, c), t.context = zR(null), n = t.current, r = nr(), o = ji(n), s = js(r, o), s.callback = e ?? null, Ai(n, s, o), t.current.lanes = o, hh(t, o, r), vr(t, r), t
}

function Ny(t, e, n, r) {
  var o = e.current,
    s = nr(),
    i = ji(o);
  return n = zR(n), e.context === null ? e.context = n : e.pendingContext = n, e = js(s, i), e.payload = {
    element: t
  }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Ai(o, e, i), t !== null && (Ro(t, o, i, s), vg(t, o, i)), i
}

function ym(t) {
  if (t = t.current, !t.child) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode
  }
}

function FC(t, e) {
  if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e
  }
}

function Gx(t, e) {
  FC(t, e), (t = t.alternate) && FC(t, e)
}

function UF() {
  return null
}
var VR = typeof reportError == "function" ? reportError : function(t) {
  console.error(t)
};

function Yx(t) {
  this._internalRoot = t
}
Ly.prototype.render = Yx.prototype.render = function(t) {
  var e = this._internalRoot;
  if (e === null) throw Error(ne(409));
  Ny(t, e, null, null)
};
Ly.prototype.unmount = Yx.prototype.unmount = function() {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    Ka(function() {
      Ny(null, t, null, null)
    }), e[Ws] = null
  }
};

function Ly(t) {
  this._internalRoot = t
}
Ly.prototype.unstable_scheduleHydration = function(t) {
  if (t) {
    var e = wO();
    t = {
      blockedOn: null,
      target: t,
      priority: e
    };
    for (var n = 0; n < Si.length && e !== 0 && e < Si[n].priority; n++);
    Si.splice(n, 0, t), n === 0 && _O(t)
  }
};

function qx(t) {
  return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}

function Fy(t) {
  return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}

function BC() {}

function zF(t, e, n, r, o) {
  if (o) {
    if (typeof r == "function") {
      var s = r;
      r = function() {
        var l = ym(i);
        s.call(l)
      }
    }
    var i = HR(e, r, t, 0, null, !1, !1, "", BC);
    return t._reactRootContainer = i, t[Ws] = i.current, pf(t.nodeType === 8 ? t.parentNode : t), Ka(), i
  }
  for (; o = t.lastChild;) t.removeChild(o);
  if (typeof r == "function") {
    var a = r;
    r = function() {
      var l = ym(c);
      a.call(l)
    }
  }
  var c = Kx(t, 0, !1, null, null, !1, !1, "", BC);
  return t._reactRootContainer = c, t[Ws] = c.current, pf(t.nodeType === 8 ? t.parentNode : t), Ka(function() {
    Ny(e, c, n, r)
  }), c
}

function By(t, e, n, r, o) {
  var s = n._reactRootContainer;
  if (s) {
    var i = s;
    if (typeof o == "function") {
      var a = o;
      o = function() {
        var c = ym(i);
        a.call(c)
      }
    }
    Ny(e, i, t, o)
  } else i = zF(n, e, t, o, r);
  return ym(i)
}
vO = function(t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = Cd(e.pendingLanes);
        n !== 0 && (px(e, n | 1), vr(e, nn()), !(st & 6) && (Ql = nn() + 500, ea()))
      }
      break;
    case 13:
      Ka(function() {
        var r = Ks(t, 1);
        if (r !== null) {
          var o = nr();
          Ro(r, t, 1, o)
        }
      }), Gx(t, 1)
  }
};
gx = function(t) {
  if (t.tag === 13) {
    var e = Ks(t, 134217728);
    if (e !== null) {
      var n = nr();
      Ro(e, t, 134217728, n)
    }
    Gx(t, 134217728)
  }
};
bO = function(t) {
  if (t.tag === 13) {
    var e = ji(t),
      n = Ks(t, e);
    if (n !== null) {
      var r = nr();
      Ro(n, t, e, r)
    }
    Gx(t, e)
  }
};
wO = function() {
  return vt
};
SO = function(t, e) {
  var n = vt;
  try {
    return vt = t, e()
  } finally {
    vt = n
  }
};
Nw = function(t, e, n) {
  switch (e) {
    case "input":
      if (Iw(t, n), e = n.name, n.type === "radio" && e != null) {
        for (n = t; n.parentNode;) n = n.parentNode;
        for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) {
          var r = n[e];
          if (r !== t && r.form === t.form) {
            var o = Iy(r);
            if (!o) throw Error(ne(90));
            JI(r), Iw(r, o)
          }
        }
      }
      break;
    case "textarea":
      eO(t, n);
      break;
    case "select":
      e = n.value, e != null && Pl(t, !!n.multiple, e, !1)
  }
};
aO = zx;
cO = Ka;
var HF = {
    usingClientEntryPoint: !1,
    Events: [gh, sl, Iy, sO, iO, zx]
  },
  Xu = {
    findFiberByHostInstance: ka,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
  },
  VF = {
    bundleType: Xu.bundleType,
    version: Xu.version,
    rendererPackageName: Xu.rendererPackageName,
    rendererConfig: Xu.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ti.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
      return t = dO(t), t === null ? null : t.stateNode
    },
    findFiberByHostInstance: Xu.findFiberByHostInstance || UF,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Pp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Pp.isDisabled && Pp.supportsFiber) try {
    Cy = Pp.inject(VF), as = Pp
  } catch {}
}
Ur.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = HF;
Ur.createPortal = function(t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!qx(e)) throw Error(ne(200));
  return BF(t, e, null, n)
};
Ur.createRoot = function(t, e) {
  if (!qx(t)) throw Error(ne(299));
  var n = !1,
    r = "",
    o = VR;
  return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (o = e.onRecoverableError)), e = Kx(t, 1, !1, null, null, n, !1, r, o), t[Ws] = e.current, pf(t.nodeType === 8 ? t.parentNode : t), new Yx(e)
};
Ur.findDOMNode = function(t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0) throw typeof t.render == "function" ? Error(ne(188)) : (t = Object.keys(t).join(","), Error(ne(268, t)));
  return t = dO(e), t = t === null ? null : t.stateNode, t
};
Ur.flushSync = function(t) {
  return Ka(t)
};
Ur.hydrate = function(t, e, n) {
  if (!Fy(e)) throw Error(ne(200));
  return By(null, t, e, !0, n)
};
Ur.hydrateRoot = function(t, e, n) {
  if (!qx(t)) throw Error(ne(405));
  var r = n != null && n.hydratedSources || null,
    o = !1,
    s = "",
    i = VR;
  if (n != null && (n.unstable_strictMode === !0 && (o = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (i = n.onRecoverableError)), e = HR(e, null, t, 1, n ?? null, o, !1, s, i), t[Ws] = e.current, pf(t), r)
    for (t = 0; t < r.length; t++) n = r[t], o = n._getVersion, o = o(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, o] : e.mutableSourceEagerHydrationData.push(n, o);
  return new Ly(e)
};
Ur.render = function(t, e, n) {
  if (!Fy(e)) throw Error(ne(200));
  return By(null, t, e, !1, n)
};
Ur.unmountComponentAtNode = function(t) {
  if (!Fy(t)) throw Error(ne(40));
  return t._reactRootContainer ? (Ka(function() {
    By(null, null, t, !1, function() {
      t._reactRootContainer = null, t[Ws] = null
    })
  }), !0) : !1
};
Ur.unstable_batchedUpdates = zx;
Ur.unstable_renderSubtreeIntoContainer = function(t, e, n, r) {
  if (!Fy(n)) throw Error(ne(200));
  if (t == null || t._reactInternals === void 0) throw Error(ne(38));
  return By(t, e, n, !1, r)
};
Ur.version = "18.2.0-next-9e3b772b8-20220608";

function WR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(WR)
  } catch (t) {
    console.error(t)
  }
}
WR(), HI.exports = Ur;
var ta = HI.exports;
const KR = co(ta);
var GR, UC = ta;
GR = UC.createRoot, UC.hydrateRoot;
var YR = {
    exports: {}
  },
  WF = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  KF = WF,
  GF = KF;

function qR() {}

function XR() {}
XR.resetWarningCache = qR;
var YF = function() {
  function t(r, o, s, i, a, c) {
    if (c !== GF) {
      var l = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
      throw l.name = "Invariant Violation", l
    }
  }
  t.isRequired = t;

  function e() {
    return t
  }
  var n = {
    array: t,
    bigint: t,
    bool: t,
    func: t,
    number: t,
    object: t,
    string: t,
    symbol: t,
    any: t,
    arrayOf: e,
    element: t,
    elementType: t,
    instanceOf: e,
    node: t,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: XR,
    resetWarningCache: qR
  };
  return n.PropTypes = n, n
};
YR.exports = YF();
var qF = YR.exports;
const et = co(qF);
var XF = typeof Element < "u",
  ZF = typeof Map == "function",
  JF = typeof Set == "function",
  QF = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView;

function kg(t, e) {
  if (t === e) return !0;
  if (t && e && typeof t == "object" && typeof e == "object") {
    if (t.constructor !== e.constructor) return !1;
    var n, r, o;
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length) return !1;
      for (r = n; r-- !== 0;)
        if (!kg(t[r], e[r])) return !1;
      return !0
    }
    var s;
    if (ZF && t instanceof Map && e instanceof Map) {
      if (t.size !== e.size) return !1;
      for (s = t.entries(); !(r = s.next()).done;)
        if (!e.has(r.value[0])) return !1;
      for (s = t.entries(); !(r = s.next()).done;)
        if (!kg(r.value[1], e.get(r.value[0]))) return !1;
      return !0
    }
    if (JF && t instanceof Set && e instanceof Set) {
      if (t.size !== e.size) return !1;
      for (s = t.entries(); !(r = s.next()).done;)
        if (!e.has(r.value[0])) return !1;
      return !0
    }
    if (QF && ArrayBuffer.isView(t) && ArrayBuffer.isView(e)) {
      if (n = t.length, n != e.length) return !1;
      for (r = n; r-- !== 0;)
        if (t[r] !== e[r]) return !1;
      return !0
    }
    if (t.constructor === RegExp) return t.source === e.source && t.flags === e.flags;
    if (t.valueOf !== Object.prototype.valueOf && typeof t.valueOf == "function" && typeof e.valueOf == "function") return t.valueOf() === e.valueOf();
    if (t.toString !== Object.prototype.toString && typeof t.toString == "function" && typeof e.toString == "function") return t.toString() === e.toString();
    if (o = Object.keys(t), n = o.length, n !== Object.keys(e).length) return !1;
    for (r = n; r-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(e, o[r])) return !1;
    if (XF && t instanceof Element) return !1;
    for (r = n; r-- !== 0;)
      if (!((o[r] === "_owner" || o[r] === "__v" || o[r] === "__o") && t.$$typeof) && !kg(t[o[r]], e[o[r]])) return !1;
    return !0
  }
  return t !== t && e !== e
}
var eB = function(e, n) {
  try {
    return kg(e, n)
  } catch (r) {
    if ((r.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1;
    throw r
  }
};
const tB = co(eB);
var nB = function(t, e, n, r, o, s, i, a) {
    if (!t) {
      var c;
      if (e === void 0) c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var l = [n, r, o, s, i, a],
          u = 0;
        c = new Error(e.replace(/%s/g, function() {
          return l[u++]
        })), c.name = "Invariant Violation"
      }
      throw c.framesToPop = 1, c
    }
  },
  rB = nB;
const zC = co(rB);
var oB = function(e, n, r, o) {
  var s = r ? r.call(o, e, n) : void 0;
  if (s !== void 0) return !!s;
  if (e === n) return !0;
  if (typeof e != "object" || !e || typeof n != "object" || !n) return !1;
  var i = Object.keys(e),
    a = Object.keys(n);
  if (i.length !== a.length) return !1;
  for (var c = Object.prototype.hasOwnProperty.bind(n), l = 0; l < i.length; l++) {
    var u = i[l];
    if (!c(u)) return !1;
    var d = e[u],
      f = n[u];
    if (s = r ? r.call(o, d, f, u) : void 0, s === !1 || s === void 0 && d !== f) return !1
  }
  return !0
};
const sB = co(oB);

function Qt() {
  return Qt = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
    return t
  }, Qt.apply(this, arguments)
}

function Xx(t, e) {
  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, mS(t, e)
}

function mS(t, e) {
  return mS = Object.setPrototypeOf || function(n, r) {
    return n.__proto__ = r, n
  }, mS(t, e)
}

function HC(t, e) {
  if (t == null) return {};
  var n, r, o = {},
    s = Object.keys(t);
  for (r = 0; r < s.length; r++) e.indexOf(n = s[r]) >= 0 || (o[n] = t[n]);
  return o
}
var $e = {
    BASE: "base",
    BODY: "body",
    HEAD: "head",
    HTML: "html",
    LINK: "link",
    META: "meta",
    NOSCRIPT: "noscript",
    SCRIPT: "script",
    STYLE: "style",
    TITLE: "title",
    FRAGMENT: "Symbol(react.fragment)"
  },
  iB = {
    rel: ["amphtml", "canonical", "alternate"]
  },
  aB = {
    type: ["application/ld+json"]
  },
  cB = {
    charset: "",
    name: ["robots", "description"],
    property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"]
  },
  VC = Object.keys($e).map(function(t) {
    return $e[t]
  }),
  vm = {
    accesskey: "accessKey",
    charset: "charSet",
    class: "className",
    contenteditable: "contentEditable",
    contextmenu: "contextMenu",
    "http-equiv": "httpEquiv",
    itemprop: "itemProp",
    tabindex: "tabIndex"
  },
  lB = Object.keys(vm).reduce(function(t, e) {
    return t[vm[e]] = e, t
  }, {}),
  Al = function(t, e) {
    for (var n = t.length - 1; n >= 0; n -= 1) {
      var r = t[n];
      if (Object.prototype.hasOwnProperty.call(r, e)) return r[e]
    }
    return null
  },
  uB = function(t) {
    var e = Al(t, $e.TITLE),
      n = Al(t, "titleTemplate");
    if (Array.isArray(e) && (e = e.join("")), n && e) return n.replace(/%s/g, function() {
      return e
    });
    var r = Al(t, "defaultTitle");
    return e || r || void 0
  },
  dB = function(t) {
    return Al(t, "onChangeClientState") || function() {}
  },
  k0 = function(t, e) {
    return e.filter(function(n) {
      return n[t] !== void 0
    }).map(function(n) {
      return n[t]
    }).reduce(function(n, r) {
      return Qt({}, n, r)
    }, {})
  },
  fB = function(t, e) {
    return e.filter(function(n) {
      return n[$e.BASE] !== void 0
    }).map(function(n) {
      return n[$e.BASE]
    }).reverse().reduce(function(n, r) {
      if (!n.length)
        for (var o = Object.keys(r), s = 0; s < o.length; s += 1) {
          var i = o[s].toLowerCase();
          if (t.indexOf(i) !== -1 && r[i]) return n.concat(r)
        }
      return n
    }, [])
  },
  Zu = function(t, e, n) {
    var r = {};
    return n.filter(function(o) {
      return !!Array.isArray(o[t]) || (o[t] !== void 0 && console && typeof console.warn == "function" && console.warn("Helmet: " + t + ' should be of type "Array". Instead found type "' + typeof o[t] + '"'), !1)
    }).map(function(o) {
      return o[t]
    }).reverse().reduce(function(o, s) {
      var i = {};
      s.filter(function(d) {
        for (var f, h = Object.keys(d), m = 0; m < h.length; m += 1) {
          var p = h[m],
            b = p.toLowerCase();
          e.indexOf(b) === -1 || f === "rel" && d[f].toLowerCase() === "canonical" || b === "rel" && d[b].toLowerCase() === "stylesheet" || (f = b), e.indexOf(p) === -1 || p !== "innerHTML" && p !== "cssText" && p !== "itemprop" || (f = p)
        }
        if (!f || !d[f]) return !1;
        var w = d[f].toLowerCase();
        return r[f] || (r[f] = {}), i[f] || (i[f] = {}), !r[f][w] && (i[f][w] = !0, !0)
      }).reverse().forEach(function(d) {
        return o.push(d)
      });
      for (var a = Object.keys(i), c = 0; c < a.length; c += 1) {
        var l = a[c],
          u = Qt({}, r[l], i[l]);
        r[l] = u
      }
      return o
    }, []).reverse()
  },
  hB = function(t, e) {
    if (Array.isArray(t) && t.length) {
      for (var n = 0; n < t.length; n += 1)
        if (t[n][e]) return !0
    }
    return !1
  },
  ZR = function(t) {
    return Array.isArray(t) ? t.join("") : t
  },
  C0 = function(t, e) {
    return Array.isArray(t) ? t.reduce(function(n, r) {
      return function(o, s) {
        for (var i = Object.keys(o), a = 0; a < i.length; a += 1)
          if (s[i[a]] && s[i[a]].includes(o[i[a]])) return !0;
        return !1
      }(r, e) ? n.priority.push(r) : n.default.push(r), n
    }, {
      priority: [],
      default: []
    }) : {
      default: t
    }
  },
  WC = function(t, e) {
    var n;
    return Qt({}, t, ((n = {})[e] = void 0, n))
  },
  pB = [$e.NOSCRIPT, $e.SCRIPT, $e.STYLE],
  P0 = function(t, e) {
    return e === void 0 && (e = !0), e === !1 ? String(t) : String(t).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;")
  },
  KC = function(t) {
    return Object.keys(t).reduce(function(e, n) {
      var r = t[n] !== void 0 ? n + '="' + t[n] + '"' : "" + n;
      return e ? e + " " + r : r
    }, "")
  },
  GC = function(t, e) {
    return e === void 0 && (e = {}), Object.keys(t).reduce(function(n, r) {
      return n[vm[r] || r] = t[r], n
    }, e)
  },
  Cg = function(t, e) {
    return e.map(function(n, r) {
      var o, s = ((o = {
        key: r
      })["data-rh"] = !0, o);
      return Object.keys(n).forEach(function(i) {
        var a = vm[i] || i;
        a === "innerHTML" || a === "cssText" ? s.dangerouslySetInnerHTML = {
          __html: n.innerHTML || n.cssText
        } : s[a] = n[i]
      }), se.createElement(t, s)
    })
  },
  Kr = function(t, e, n) {
    switch (t) {
      case $e.TITLE:
        return {
          toComponent: function() {
            return o = e.titleAttributes, (s = {
              key: r = e.title
            })["data-rh"] = !0, i = GC(o, s), [se.createElement($e.TITLE, i, r)];
            var r, o, s, i
          }, toString: function() {
            return function(r, o, s, i) {
              var a = KC(s),
                c = ZR(o);
              return a ? "<" + r + ' data-rh="true" ' + a + ">" + P0(c, i) + "</" + r + ">" : "<" + r + ' data-rh="true">' + P0(c, i) + "</" + r + ">"
            }(t, e.title, e.titleAttributes, n)
          }
        };
      case "bodyAttributes":
      case "htmlAttributes":
        return {
          toComponent: function() {
            return GC(e)
          }, toString: function() {
            return KC(e)
          }
        };
      default:
        return {
          toComponent: function() {
            return Cg(t, e)
          }, toString: function() {
            return function(r, o, s) {
              return o.reduce(function(i, a) {
                var c = Object.keys(a).filter(function(d) {
                    return !(d === "innerHTML" || d === "cssText")
                  }).reduce(function(d, f) {
                    var h = a[f] === void 0 ? f : f + '="' + P0(a[f], s) + '"';
                    return d ? d + " " + h : h
                  }, ""),
                  l = a.innerHTML || a.cssText || "",
                  u = pB.indexOf(r) === -1;
                return i + "<" + r + ' data-rh="true" ' + c + (u ? "/>" : ">" + l + "</" + r + ">")
              }, "")
            }(t, e, n)
          }
        }
    }
  },
  yS = function(t) {
    var e = t.baseTag,
      n = t.bodyAttributes,
      r = t.encode,
      o = t.htmlAttributes,
      s = t.noscriptTags,
      i = t.styleTags,
      a = t.title,
      c = a === void 0 ? "" : a,
      l = t.titleAttributes,
      u = t.linkTags,
      d = t.metaTags,
      f = t.scriptTags,
      h = {
        toComponent: function() {},
        toString: function() {
          return ""
        }
      };
    if (t.prioritizeSeoTags) {
      var m = function(p) {
        var b = p.linkTags,
          w = p.scriptTags,
          v = p.encode,
          _ = C0(p.metaTags, cB),
          S = C0(b, iB),
          x = C0(w, aB);
        return {
          priorityMethods: {
            toComponent: function() {
              return [].concat(Cg($e.META, _.priority), Cg($e.LINK, S.priority), Cg($e.SCRIPT, x.priority))
            },
            toString: function() {
              return Kr($e.META, _.priority, v) + " " + Kr($e.LINK, S.priority, v) + " " + Kr($e.SCRIPT, x.priority, v)
            }
          },
          metaTags: _.default,
          linkTags: S.default,
          scriptTags: x.default
        }
      }(t);
      h = m.priorityMethods, u = m.linkTags, d = m.metaTags, f = m.scriptTags
    }
    return {
      priority: h,
      base: Kr($e.BASE, e, r),
      bodyAttributes: Kr("bodyAttributes", n, r),
      htmlAttributes: Kr("htmlAttributes", o, r),
      link: Kr($e.LINK, u, r),
      meta: Kr($e.META, d, r),
      noscript: Kr($e.NOSCRIPT, s, r),
      script: Kr($e.SCRIPT, f, r),
      style: Kr($e.STYLE, i, r),
      title: Kr($e.TITLE, {
        title: c,
        titleAttributes: l
      }, r)
    }
  },
  Tp = [],
  vS = function(t, e) {
    var n = this;
    e === void 0 && (e = typeof document < "u"), this.instances = [], this.value = {
      setHelmet: function(r) {
        n.context.helmet = r
      },
      helmetInstances: {
        get: function() {
          return n.canUseDOM ? Tp : n.instances
        },
        add: function(r) {
          (n.canUseDOM ? Tp : n.instances).push(r)
        },
        remove: function(r) {
          var o = (n.canUseDOM ? Tp : n.instances).indexOf(r);
          (n.canUseDOM ? Tp : n.instances).splice(o, 1)
        }
      }
    }, this.context = t, this.canUseDOM = e, e || (t.helmet = yS({
      baseTag: [],
      bodyAttributes: {},
      encodeSpecialCharacters: !0,
      htmlAttributes: {},
      linkTags: [],
      metaTags: [],
      noscriptTags: [],
      scriptTags: [],
      styleTags: [],
      title: "",
      titleAttributes: {}
    }))
  },
  JR = se.createContext({}),
  gB = et.shape({
    setHelmet: et.func,
    helmetInstances: et.shape({
      get: et.func,
      add: et.func,
      remove: et.func
    })
  }),
  mB = typeof document < "u",
  fl = function(t) {
    function e(n) {
      var r;
      return (r = t.call(this, n) || this).helmetData = new vS(r.props.context, e.canUseDOM), r
    }
    return Xx(e, t), e.prototype.render = function() {
      return se.createElement(JR.Provider, {
        value: this.helmetData.value
      }, this.props.children)
    }, e
  }(g.Component);
fl.canUseDOM = mB, fl.propTypes = {
  context: et.shape({
    helmet: et.shape()
  }),
  children: et.node.isRequired
}, fl.defaultProps = {
  context: {}
}, fl.displayName = "HelmetProvider";
var Pc = function(t, e) {
    var n, r = document.head || document.querySelector($e.HEAD),
      o = r.querySelectorAll(t + "[data-rh]"),
      s = [].slice.call(o),
      i = [];
    return e && e.length && e.forEach(function(a) {
      var c = document.createElement(t);
      for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (l === "innerHTML" ? c.innerHTML = a.innerHTML : l === "cssText" ? c.styleSheet ? c.styleSheet.cssText = a.cssText : c.appendChild(document.createTextNode(a.cssText)) : c.setAttribute(l, a[l] === void 0 ? "" : a[l]));
      c.setAttribute("data-rh", "true"), s.some(function(u, d) {
        return n = d, c.isEqualNode(u)
      }) ? s.splice(n, 1) : i.push(c)
    }), s.forEach(function(a) {
      return a.parentNode.removeChild(a)
    }), i.forEach(function(a) {
      return r.appendChild(a)
    }), {
      oldTags: s,
      newTags: i
    }
  },
  T0 = function(t, e) {
    var n = document.getElementsByTagName(t)[0];
    if (n) {
      for (var r = n.getAttribute("data-rh"), o = r ? r.split(",") : [], s = [].concat(o), i = Object.keys(e), a = 0; a < i.length; a += 1) {
        var c = i[a],
          l = e[c] || "";
        n.getAttribute(c) !== l && n.setAttribute(c, l), o.indexOf(c) === -1 && o.push(c);
        var u = s.indexOf(c);
        u !== -1 && s.splice(u, 1)
      }
      for (var d = s.length - 1; d >= 0; d -= 1) n.removeAttribute(s[d]);
      o.length === s.length ? n.removeAttribute("data-rh") : n.getAttribute("data-rh") !== i.join(",") && n.setAttribute("data-rh", i.join(","))
    }
  },
  YC = function(t, e) {
    var n = t.baseTag,
      r = t.htmlAttributes,
      o = t.linkTags,
      s = t.metaTags,
      i = t.noscriptTags,
      a = t.onChangeClientState,
      c = t.scriptTags,
      l = t.styleTags,
      u = t.title,
      d = t.titleAttributes;
    T0($e.BODY, t.bodyAttributes), T0($e.HTML, r),
      function(p, b) {
        p !== void 0 && document.title !== p && (document.title = ZR(p)), T0($e.TITLE, b)
      }(u, d);
    var f = {
        baseTag: Pc($e.BASE, n),
        linkTags: Pc($e.LINK, o),
        metaTags: Pc($e.META, s),
        noscriptTags: Pc($e.NOSCRIPT, i),
        scriptTags: Pc($e.SCRIPT, c),
        styleTags: Pc($e.STYLE, l)
      },
      h = {},
      m = {};
    Object.keys(f).forEach(function(p) {
      var b = f[p],
        w = b.newTags,
        v = b.oldTags;
      w.length && (h[p] = w), v.length && (m[p] = f[p].oldTags)
    }), e && e(), a(t, h, m)
  },
  Ju = null,
  bm = function(t) {
    function e() {
      for (var r, o = arguments.length, s = new Array(o), i = 0; i < o; i++) s[i] = arguments[i];
      return (r = t.call.apply(t, [this].concat(s)) || this).rendered = !1, r
    }
    Xx(e, t);
    var n = e.prototype;
    return n.shouldComponentUpdate = function(r) {
      return !sB(r, this.props)
    }, n.componentDidUpdate = function() {
      this.emitChange()
    }, n.componentWillUnmount = function() {
      this.props.context.helmetInstances.remove(this), this.emitChange()
    }, n.emitChange = function() {
      var r, o, s = this.props.context,
        i = s.setHelmet,
        a = null,
        c = (r = s.helmetInstances.get().map(function(l) {
          var u = Qt({}, l.props);
          return delete u.context, u
        }), {
          baseTag: fB(["href"], r),
          bodyAttributes: k0("bodyAttributes", r),
          defer: Al(r, "defer"),
          encode: Al(r, "encodeSpecialCharacters"),
          htmlAttributes: k0("htmlAttributes", r),
          linkTags: Zu($e.LINK, ["rel", "href"], r),
          metaTags: Zu($e.META, ["name", "charset", "http-equiv", "property", "itemprop"], r),
          noscriptTags: Zu($e.NOSCRIPT, ["innerHTML"], r),
          onChangeClientState: dB(r),
          scriptTags: Zu($e.SCRIPT, ["src", "innerHTML"], r),
          styleTags: Zu($e.STYLE, ["cssText"], r),
          title: uB(r),
          titleAttributes: k0("titleAttributes", r),
          prioritizeSeoTags: hB(r, "prioritizeSeoTags")
        });
      fl.canUseDOM ? (o = c, Ju && cancelAnimationFrame(Ju), o.defer ? Ju = requestAnimationFrame(function() {
        YC(o, function() {
          Ju = null
        })
      }) : (YC(o), Ju = null)) : yS && (a = yS(c)), i(a)
    }, n.init = function() {
      this.rendered || (this.rendered = !0, this.props.context.helmetInstances.add(this), this.emitChange())
    }, n.render = function() {
      return this.init(), null
    }, e
  }(g.Component);
bm.propTypes = {
  context: gB.isRequired
}, bm.displayName = "HelmetDispatcher";
var yB = ["children"],
  vB = ["children"],
  Pg = function(t) {
    function e() {
      return t.apply(this, arguments) || this
    }
    Xx(e, t);
    var n = e.prototype;
    return n.shouldComponentUpdate = function(r) {
      return !tB(WC(this.props, "helmetData"), WC(r, "helmetData"))
    }, n.mapNestedChildrenToProps = function(r, o) {
      if (!o) return null;
      switch (r.type) {
        case $e.SCRIPT:
        case $e.NOSCRIPT:
          return {
            innerHTML: o
          };
        case $e.STYLE:
          return {
            cssText: o
          };
        default:
          throw new Error("<" + r.type + " /> elements are self-closing and can not contain children. Refer to our API for more information.")
      }
    }, n.flattenArrayTypeChildren = function(r) {
      var o, s = r.child,
        i = r.arrayTypeChildren;
      return Qt({}, i, ((o = {})[s.type] = [].concat(i[s.type] || [], [Qt({}, r.newChildProps, this.mapNestedChildrenToProps(s, r.nestedChildren))]), o))
    }, n.mapObjectTypeChildren = function(r) {
      var o, s, i = r.child,
        a = r.newProps,
        c = r.newChildProps,
        l = r.nestedChildren;
      switch (i.type) {
        case $e.TITLE:
          return Qt({}, a, ((o = {})[i.type] = l, o.titleAttributes = Qt({}, c), o));
        case $e.BODY:
          return Qt({}, a, {
            bodyAttributes: Qt({}, c)
          });
        case $e.HTML:
          return Qt({}, a, {
            htmlAttributes: Qt({}, c)
          });
        default:
          return Qt({}, a, ((s = {})[i.type] = Qt({}, c), s))
      }
    }, n.mapArrayTypeChildrenToProps = function(r, o) {
      var s = Qt({}, o);
      return Object.keys(r).forEach(function(i) {
        var a;
        s = Qt({}, s, ((a = {})[i] = r[i], a))
      }), s
    }, n.warnOnInvalidChildren = function(r, o) {
      return zC(VC.some(function(s) {
        return r.type === s
      }), typeof r.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : "Only elements types " + VC.join(", ") + " are allowed. Helmet does not support rendering <" + r.type + "> elements. Refer to our API for more information."), zC(!o || typeof o == "string" || Array.isArray(o) && !o.some(function(s) {
        return typeof s != "string"
      }), "Helmet expects a string as a child of <" + r.type + ">. Did you forget to wrap your children in braces? ( <" + r.type + ">{``}</" + r.type + "> ) Refer to our API for more information."), !0
    }, n.mapChildrenToProps = function(r, o) {
      var s = this,
        i = {};
      return se.Children.forEach(r, function(a) {
        if (a && a.props) {
          var c = a.props,
            l = c.children,
            u = HC(c, yB),
            d = Object.keys(u).reduce(function(h, m) {
              return h[lB[m] || m] = u[m], h
            }, {}),
            f = a.type;
          switch (typeof f == "symbol" ? f = f.toString() : s.warnOnInvalidChildren(a, l), f) {
            case $e.FRAGMENT:
              o = s.mapChildrenToProps(l, o);
              break;
            case $e.LINK:
            case $e.META:
            case $e.NOSCRIPT:
            case $e.SCRIPT:
            case $e.STYLE:
              i = s.flattenArrayTypeChildren({
                child: a,
                arrayTypeChildren: i,
                newChildProps: d,
                nestedChildren: l
              });
              break;
            default:
              o = s.mapObjectTypeChildren({
                child: a,
                newProps: o,
                newChildProps: d,
                nestedChildren: l
              })
          }
        }
      }), this.mapArrayTypeChildrenToProps(i, o)
    }, n.render = function() {
      var r = this.props,
        o = r.children,
        s = HC(r, vB),
        i = Qt({}, s),
        a = s.helmetData;
      return o && (i = this.mapChildrenToProps(o, i)), !a || a instanceof vS || (a = new vS(a.context, a.instances)), a ? se.createElement(bm, Qt({}, i, {
        context: a.value,
        helmetData: void 0
      })) : se.createElement(JR.Consumer, null, function(c) {
        return se.createElement(bm, Qt({}, i, {
          context: c
        }))
      })
    }, e
  }(g.Component);
Pg.propTypes = {
  base: et.object,
  bodyAttributes: et.object,
  children: et.oneOfType([et.arrayOf(et.node), et.node]),
  defaultTitle: et.string,
  defer: et.bool,
  encodeSpecialCharacters: et.bool,
  htmlAttributes: et.object,
  link: et.arrayOf(et.object),
  meta: et.arrayOf(et.object),
  noscript: et.arrayOf(et.object),
  onChangeClientState: et.func,
  script: et.arrayOf(et.object),
  style: et.arrayOf(et.object),
  title: et.string,
  titleAttributes: et.object,
  titleTemplate: et.string,
  prioritizeSeoTags: et.bool,
  helmetData: et.object
}, Pg.defaultProps = {
  defer: !0,
  encodeSpecialCharacters: !0,
  prioritizeSeoTags: !1
}, Pg.displayName = "Helmet";
/**
 * @remix-run/router v1.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function jt() {
  return jt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
    return t
  }, jt.apply(this, arguments)
}
var en;
(function(t) {
  t.Pop = "POP", t.Push = "PUSH", t.Replace = "REPLACE"
})(en || (en = {}));
const qC = "popstate";

function bB(t) {
  t === void 0 && (t = {});

  function e(r, o) {
    let {
      pathname: s,
      search: i,
      hash: a
    } = r.location;
    return xf("", {
      pathname: s,
      search: i,
      hash: a
    }, o.state && o.state.usr || null, o.state && o.state.key || "default")
  }

  function n(r, o) {
    return typeof o == "string" ? o : Ya(o)
  }
  return SB(e, n, null, t)
}

function We(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e)
}

function Ga(t, e) {
  if (!t) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e)
    } catch {}
  }
}

function wB() {
  return Math.random().toString(36).substr(2, 8)
}

function XC(t, e) {
  return {
    usr: t.state,
    key: t.key,
    idx: e
  }
}

function xf(t, e, n, r) {
  return n === void 0 && (n = null), jt({
    pathname: typeof t == "string" ? t : t.pathname,
    search: "",
    hash: ""
  }, typeof e == "string" ? ni(e) : e, {
    state: n,
    key: e && e.key || r || wB()
  })
}

function Ya(t) {
  let {
    pathname: e = "/",
    search: n = "",
    hash: r = ""
  } = t;
  return n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e
}

function ni(t) {
  let e = {};
  if (t) {
    let n = t.indexOf("#");
    n >= 0 && (e.hash = t.substr(n), t = t.substr(0, n));
    let r = t.indexOf("?");
    r >= 0 && (e.search = t.substr(r), t = t.substr(0, r)), t && (e.pathname = t)
  }
  return e
}

function SB(t, e, n, r) {
  r === void 0 && (r = {});
  let {
    window: o = document.defaultView,
    v5Compat: s = !1
  } = r, i = o.history, a = en.Pop, c = null, l = u();
  l == null && (l = 0, i.replaceState(jt({}, i.state, {
    idx: l
  }), ""));

  function u() {
    return (i.state || {
      idx: null
    }).idx
  }

  function d() {
    a = en.Pop;
    let b = u(),
      w = b == null ? null : b - l;
    l = b, c && c({
      action: a,
      location: p.location,
      delta: w
    })
  }

  function f(b, w) {
    a = en.Push;
    let v = xf(p.location, b, w);
    n && n(v, b), l = u() + 1;
    let _ = XC(v, l),
      S = p.createHref(v);
    try {
      i.pushState(_, "", S)
    } catch (x) {
      if (x instanceof DOMException && x.name === "DataCloneError") throw x;
      o.location.assign(S)
    }
    s && c && c({
      action: a,
      location: p.location,
      delta: 1
    })
  }

  function h(b, w) {
    a = en.Replace;
    let v = xf(p.location, b, w);
    n && n(v, b), l = u();
    let _ = XC(v, l),
      S = p.createHref(v);
    i.replaceState(_, "", S), s && c && c({
      action: a,
      location: p.location,
      delta: 0
    })
  }

  function m(b) {
    let w = o.location.origin !== "null" ? o.location.origin : o.location.href,
      v = typeof b == "string" ? b : Ya(b);
    return We(w, "No window.location.(origin|href) available to create URL for href: " + v), new URL(v, w)
  }
  let p = {
    get action() {
      return a
    },
    get location() {
      return t(o, i)
    },
    listen(b) {
      if (c) throw new Error("A history only accepts one active listener");
      return o.addEventListener(qC, d), c = b, () => {
        o.removeEventListener(qC, d), c = null
      }
    },
    createHref(b) {
      return e(o, b)
    },
    createURL: m,
    encodeLocation(b) {
      let w = m(b);
      return {
        pathname: w.pathname,
        search: w.search,
        hash: w.hash
      }
    },
    push: f,
    replace: h,
    go(b) {
      return i.go(b)
    }
  };
  return p
}
var tn;
(function(t) {
  t.data = "data", t.deferred = "deferred", t.redirect = "redirect", t.error = "error"
})(tn || (tn = {}));
const _B = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);

function xB(t) {
  return t.index === !0
}

function bS(t, e, n, r) {
  return n === void 0 && (n = []), r === void 0 && (r = {}), t.map((o, s) => {
    let i = [...n, s],
      a = typeof o.id == "string" ? o.id : i.join("-");
    if (We(o.index !== !0 || !o.children, "Cannot specify children on an index route"), We(!r[a], 'Found a route id collision on id "' + a + `".  Route id's must be globally unique within Data Router usages`), xB(o)) {
      let c = jt({}, o, e(o), {
        id: a
      });
      return r[a] = c, c
    } else {
      let c = jt({}, o, e(o), {
        id: a,
        children: void 0
      });
      return r[a] = c, o.children && (c.children = bS(o.children, e, i, r)), c
    }
  })
}

function hl(t, e, n) {
  n === void 0 && (n = "/");
  let r = typeof e == "string" ? ni(e) : e,
    o = mu(r.pathname || "/", n);
  if (o == null) return null;
  let s = QR(t);
  kB(s);
  let i = null;
  for (let a = 0; i == null && a < s.length; ++a) i = MB(s[a], NB(o));
  return i
}

function EB(t, e) {
  let {
    route: n,
    pathname: r,
    params: o
  } = t;
  return {
    id: n.id,
    pathname: r,
    params: o,
    data: e[n.id],
    handle: n.handle
  }
}

function QR(t, e, n, r) {
  e === void 0 && (e = []), n === void 0 && (n = []), r === void 0 && (r = "");
  let o = (s, i, a) => {
    let c = {
      relativePath: a === void 0 ? s.path || "" : a,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: i,
      route: s
    };
    c.relativePath.startsWith("/") && (We(c.relativePath.startsWith(r), 'Absolute route path "' + c.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), c.relativePath = c.relativePath.slice(r.length));
    let l = Ds([r, c.relativePath]),
      u = n.concat(c);
    s.children && s.children.length > 0 && (We(s.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + l + '".')), QR(s.children, e, u, l)), !(s.path == null && !s.index) && e.push({
      path: l,
      score: RB(l, s.index),
      routesMeta: u
    })
  };
  return t.forEach((s, i) => {
    var a;
    if (s.path === "" || !((a = s.path) != null && a.includes("?"))) o(s, i);
    else
      for (let c of eA(s.path)) o(s, i, c)
  }), e
}

function eA(t) {
  let e = t.split("/");
  if (e.length === 0) return [];
  let [n, ...r] = e, o = n.endsWith("?"), s = n.replace(/\?$/, "");
  if (r.length === 0) return o ? [s, ""] : [s];
  let i = eA(r.join("/")),
    a = [];
  return a.push(...i.map(c => c === "" ? s : [s, c].join("/"))), o && a.push(...i), a.map(c => t.startsWith("/") && c === "" ? "/" : c)
}

function kB(t) {
  t.sort((e, n) => e.score !== n.score ? n.score - e.score : AB(e.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex)))
}
const CB = /^:\w+$/,
  PB = 3,
  TB = 2,
  $B = 1,
  IB = 10,
  OB = -2,
  ZC = t => t === "*";

function RB(t, e) {
  let n = t.split("/"),
    r = n.length;
  return n.some(ZC) && (r += OB), e && (r += TB), n.filter(o => !ZC(o)).reduce((o, s) => o + (CB.test(s) ? PB : s === "" ? $B : IB), r)
}

function AB(t, e) {
  return t.length === e.length && t.slice(0, -1).every((r, o) => r === e[o]) ? t[t.length - 1] - e[e.length - 1] : 0
}

function MB(t, e) {
  let {
    routesMeta: n
  } = t, r = {}, o = "/", s = [];
  for (let i = 0; i < n.length; ++i) {
    let a = n[i],
      c = i === n.length - 1,
      l = o === "/" ? e : e.slice(o.length) || "/",
      u = jB({
        path: a.relativePath,
        caseSensitive: a.caseSensitive,
        end: c
      }, l);
    if (!u) return null;
    Object.assign(r, u.params);
    let d = a.route;
    s.push({
      params: r,
      pathname: Ds([o, u.pathname]),
      pathnameBase: UB(Ds([o, u.pathnameBase])),
      route: d
    }), u.pathnameBase !== "/" && (o = Ds([o, u.pathnameBase]))
  }
  return s
}

function jB(t, e) {
  typeof t == "string" && (t = {
    path: t,
    caseSensitive: !1,
    end: !0
  });
  let [n, r] = DB(t.path, t.caseSensitive, t.end), o = e.match(n);
  if (!o) return null;
  let s = o[0],
    i = s.replace(/(.)\/+$/, "$1"),
    a = o.slice(1);
  return {
    params: r.reduce((l, u, d) => {
      if (u === "*") {
        let f = a[d] || "";
        i = s.slice(0, s.length - f.length).replace(/(.)\/+$/, "$1")
      }
      return l[u] = LB(a[d] || "", u), l
    }, {}),
    pathname: s,
    pathnameBase: i,
    pattern: t
  }
}

function DB(t, e, n) {
  e === void 0 && (e = !1), n === void 0 && (n = !0), Ga(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".'));
  let r = [],
    o = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (i, a) => (r.push(a), "/([^\\/]+)"));
  return t.endsWith("*") ? (r.push("*"), o += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? o += "\\/*$" : t !== "" && t !== "/" && (o += "(?:(?=\\/|$))"), [new RegExp(o, e ? void 0 : "i"), r]
}

function NB(t) {
  try {
    return decodeURI(t)
  } catch (e) {
    return Ga(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")), t
  }
}

function LB(t, e) {
  try {
    return decodeURIComponent(t)
  } catch (n) {
    return Ga(!1, 'The value for the URL param "' + e + '" will not be decoded because' + (' the string "' + t + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + n + ").")), t
  }
}

function mu(t, e) {
  if (e === "/") return t;
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
  let n = e.endsWith("/") ? e.length - 1 : e.length,
    r = t.charAt(n);
  return r && r !== "/" ? null : t.slice(n) || "/"
}

function FB(t, e) {
  e === void 0 && (e = "/");
  let {
    pathname: n,
    search: r = "",
    hash: o = ""
  } = typeof t == "string" ? ni(t) : t;
  return {
    pathname: n ? n.startsWith("/") ? n : BB(n, e) : e,
    search: zB(r),
    hash: HB(o)
  }
}

function BB(t, e) {
  let n = e.replace(/\/+$/, "").split("/");
  return t.split("/").forEach(o => {
    o === ".." ? n.length > 1 && n.pop() : o !== "." && n.push(o)
  }), n.length > 1 ? n.join("/") : "/"
}

function $0(t, e, n, r) {
  return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}

function yh(t) {
  return t.filter((e, n) => n === 0 || e.route.path && e.route.path.length > 0)
}

function Uy(t, e, n, r) {
  r === void 0 && (r = !1);
  let o;
  typeof t == "string" ? o = ni(t) : (o = jt({}, t), We(!o.pathname || !o.pathname.includes("?"), $0("?", "pathname", "search", o)), We(!o.pathname || !o.pathname.includes("#"), $0("#", "pathname", "hash", o)), We(!o.search || !o.search.includes("#"), $0("#", "search", "hash", o)));
  let s = t === "" || o.pathname === "",
    i = s ? "/" : o.pathname,
    a;
  if (r || i == null) a = n;
  else {
    let d = e.length - 1;
    if (i.startsWith("..")) {
      let f = i.split("/");
      for (; f[0] === "..";) f.shift(), d -= 1;
      o.pathname = f.join("/")
    }
    a = d >= 0 ? e[d] : "/"
  }
  let c = FB(o, a),
    l = i && i !== "/" && i.endsWith("/"),
    u = (s || i === ".") && n.endsWith("/");
  return !c.pathname.endsWith("/") && (l || u) && (c.pathname += "/"), c
}
const Ds = t => t.join("/").replace(/\/\/+/g, "/"),
  UB = t => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
  zB = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t,
  HB = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t,
  VB = function(e, n) {
    n === void 0 && (n = 302);
    let r = n;
    typeof r == "number" ? r = {
      status: r
    } : typeof r.status > "u" && (r.status = 302);
    let o = new Headers(r.headers);
    return o.set("Location", e), new Response(null, jt({}, r, {
      headers: o
    }))
  };
class Zx {
  constructor(e, n, r, o) {
    o === void 0 && (o = !1), this.status = e, this.statusText = n || "", this.internal = o, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r
  }
}

function tA(t) {
  return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data" in t
}
const nA = ["post", "put", "patch", "delete"],
  WB = new Set(nA),
  KB = ["get", ...nA],
  GB = new Set(KB),
  YB = new Set([301, 302, 303, 307, 308]),
  qB = new Set([307, 308]),
  I0 = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  },
  XB = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  },
  Qu = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
  },
  rA = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  ZB = t => ({
    hasErrorBoundary: !!t.hasErrorBoundary
  }),
  oA = "remix-router-transitions";

function JB(t) {
  const e = t.window ? t.window : typeof window < "u" ? window : void 0,
    n = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u",
    r = !n;
  We(t.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let o;
  if (t.mapRouteProperties) o = t.mapRouteProperties;
  else if (t.detectErrorBoundary) {
    let z = t.detectErrorBoundary;
    o = W => ({
      hasErrorBoundary: z(W)
    })
  } else o = ZB;
  let s = {},
    i = bS(t.routes, o, void 0, s),
    a, c = t.basename || "/",
    l = jt({
      v7_normalizeFormMethod: !1,
      v7_prependBasename: !1
    }, t.future),
    u = null,
    d = new Set,
    f = null,
    h = null,
    m = null,
    p = t.hydrationData != null,
    b = hl(i, t.history.location, c),
    w = null;
  if (b == null) {
    let z = Yr(404, {
        pathname: t.history.location.pathname
      }),
      {
        matches: W,
        route: X
      } = sP(i);
    b = W, w = {
      [X.id]: z
    }
  }
  let v = !b.some(z => z.route.lazy) && (!b.some(z => z.route.loader) || t.hydrationData != null),
    _, S = {
      historyAction: t.history.action,
      location: t.history.location,
      matches: b,
      initialized: v,
      navigation: I0,
      restoreScrollPosition: t.hydrationData != null ? !1 : null,
      preventScrollReset: !1,
      revalidation: "idle",
      loaderData: t.hydrationData && t.hydrationData.loaderData || {},
      actionData: t.hydrationData && t.hydrationData.actionData || null,
      errors: t.hydrationData && t.hydrationData.errors || w,
      fetchers: new Map,
      blockers: new Map
    },
    x = en.Pop,
    E = !1,
    k, C = !1,
    $ = new Map,
    I = null,
    R = !1,
    M = !1,
    j = [],
    A = [],
    D = new Map,
    N = 0,
    q = -1,
    F = new Map,
    B = new Set,
    V = new Map,
    J = new Map,
    ee = new Map,
    ye = !1;

  function ge() {
    if (u = t.history.listen(z => {
        let {
          action: W,
          location: X,
          delta: le
        } = z;
        if (ye) {
          ye = !1;
          return
        }
        Ga(ee.size === 0 || le != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
        let De = kr({
          currentLocation: S.location,
          nextLocation: X,
          historyAction: W
        });
        if (De && le != null) {
          ye = !0, t.history.go(le * -1), ca(De, {
            state: "blocked",
            location: X,
            proceed() {
              ca(De, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: X
              }), t.history.go(le)
            },
            reset() {
              let je = new Map(S.blockers);
              je.set(De, Qu), oe({
                blockers: je
              })
            }
          });
          return
        }
        return Me(W, X)
      }), n) {
      lU(e, $);
      let z = () => uU(e, $);
      e.addEventListener("pagehide", z), I = () => e.removeEventListener("pagehide", z)
    }
    return S.initialized || Me(en.Pop, S.location), _
  }

  function ce() {
    u && u(), I && I(), d.clear(), k && k.abort(), S.fetchers.forEach((z, W) => Du(W)), S.blockers.forEach((z, W) => Sc(W))
  }

  function Ce(z) {
    return d.add(z), () => d.delete(z)
  }

  function oe(z, W) {
    S = jt({}, S, z), d.forEach(X => X(S, {
      unstable_viewTransitionOpts: W
    }))
  }

  function pe(z, W) {
    var X, le;
    let De = S.actionData != null && S.navigation.formMethod != null && bo(S.navigation.formMethod) && S.navigation.state === "loading" && ((X = z.state) == null ? void 0 : X._isRedirect) !== !0,
      je;
    W.actionData ? Object.keys(W.actionData).length > 0 ? je = W.actionData : je = null : De ? je = S.actionData : je = null;
    let Ne = W.loaderData ? oP(S.loaderData, W.loaderData, W.matches || [], W.errors) : S.loaderData,
      Se = S.blockers;
    Se.size > 0 && (Se = new Map(Se), Se.forEach((St, Ge) => Se.set(Ge, Qu)));
    let be = E === !0 || S.navigation.formMethod != null && bo(S.navigation.formMethod) && ((le = z.state) == null ? void 0 : le._isRedirect) !== !0;
    a && (i = a, a = void 0), R || x === en.Pop || (x === en.Push ? t.history.push(z, z.state) : x === en.Replace && t.history.replace(z, z.state));
    let lt;
    if (x === en.Pop) {
      let St = $.get(S.location.pathname);
      St && St.has(z.pathname) ? lt = {
        currentLocation: S.location,
        nextLocation: z
      } : $.has(z.pathname) && (lt = {
        currentLocation: z,
        nextLocation: S.location
      })
    } else if (C) {
      let St = $.get(S.location.pathname);
      St ? St.add(z.pathname) : (St = new Set([z.pathname]), $.set(S.location.pathname, St)), lt = {
        currentLocation: S.location,
        nextLocation: z
      }
    }
    oe(jt({}, W, {
      actionData: je,
      loaderData: Ne,
      historyAction: x,
      location: z,
      initialized: !0,
      navigation: I0,
      revalidation: "idle",
      restoreScrollPosition: la(z, W.matches || S.matches),
      preventScrollReset: be,
      blockers: Se
    }), lt), x = en.Pop, E = !1, C = !1, R = !1, M = !1, j = [], A = []
  }
  async function _e(z, W) {
    if (typeof z == "number") {
      t.history.go(z);
      return
    }
    let X = wS(S.location, S.matches, c, l.v7_prependBasename, z, W == null ? void 0 : W.fromRouteId, W == null ? void 0 : W.relative),
      {
        path: le,
        submission: De,
        error: je
      } = JC(l.v7_normalizeFormMethod, !1, X, W),
      Ne = S.location,
      Se = xf(S.location, le, W && W.state);
    Se = jt({}, Se, t.history.encodeLocation(Se));
    let be = W && W.replace != null ? W.replace : void 0,
      lt = en.Push;
    be === !0 ? lt = en.Replace : be === !1 || De != null && bo(De.formMethod) && De.formAction === S.location.pathname + S.location.search && (lt = en.Replace);
    let St = W && "preventScrollReset" in W ? W.preventScrollReset === !0 : void 0,
      Ge = kr({
        currentLocation: Ne,
        nextLocation: Se,
        historyAction: lt
      });
    if (Ge) {
      ca(Ge, {
        state: "blocked",
        location: Se,
        proceed() {
          ca(Ge, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: Se
          }), _e(z, W)
        },
        reset() {
          let mt = new Map(S.blockers);
          mt.set(Ge, Qu), oe({
            blockers: mt
          })
        }
      });
      return
    }
    return await Me(lt, Se, {
      submission: De,
      pendingError: je,
      preventScrollReset: St,
      replace: W && W.replace,
      enableViewTransition: W && W.unstable_viewTransition
    })
  }

  function xe() {
    if (Zn(), oe({
        revalidation: "loading"
      }), S.navigation.state !== "submitting") {
      if (S.navigation.state === "idle") {
        Me(S.historyAction, S.location, {
          startUninterruptedRevalidation: !0
        });
        return
      }
      Me(x || S.historyAction, S.navigation.location, {
        overrideNavigation: S.navigation
      })
    }
  }
  async function Me(z, W, X) {
    k && k.abort(), k = null, x = z, R = (X && X.startUninterruptedRevalidation) === !0, Xh(S.location, S.matches), E = (X && X.preventScrollReset) === !0, C = (X && X.enableViewTransition) === !0;
    let le = a || i,
      De = X && X.overrideNavigation,
      je = hl(le, W, c);
    if (!je) {
      let mt = Yr(404, {
          pathname: W.pathname
        }),
        {
          matches: Lt,
          route: Ss
        } = sP(le);
      _c(), pe(W, {
        matches: Lt,
        loaderData: {},
        errors: {
          [Ss.id]: mt
        }
      });
      return
    }
    if (S.initialized && !M && rU(S.location, W) && !(X && X.submission && bo(X.submission.formMethod))) {
      pe(W, {
        matches: je
      });
      return
    }
    k = new AbortController;
    let Ne = td(t.history, W, k.signal, X && X.submission),
      Se, be;
    if (X && X.pendingError) be = {
      [pl(je).route.id]: X.pendingError
    };
    else if (X && X.submission && bo(X.submission.formMethod)) {
      let mt = await Le(Ne, W, X.submission, je, {
        replace: X.replace
      });
      if (mt.shortCircuited) return;
      Se = mt.pendingActionData, be = mt.pendingActionError, De = O0(W, X.submission), Ne = new Request(Ne.url, {
        signal: Ne.signal
      })
    }
    let {
      shortCircuited: lt,
      loaderData: St,
      errors: Ge
    } = await gt(Ne, W, je, De, X && X.submission, X && X.fetcherSubmission, X && X.replace, Se, be);
    lt || (k = null, pe(W, jt({
      matches: je
    }, Se ? {
      actionData: Se
    } : {}, {
      loaderData: St,
      errors: Ge
    })))
  }
  async function Le(z, W, X, le, De) {
    De === void 0 && (De = {}), Zn();
    let je = aU(W, X);
    oe({
      navigation: je
    });
    let Ne, Se = _S(le, W);
    if (!Se.route.action && !Se.route.lazy) Ne = {
      type: tn.error,
      error: Yr(405, {
        method: z.method,
        pathname: W.pathname,
        routeId: Se.route.id
      })
    };
    else if (Ne = await ed("action", z, Se, le, s, o, c), z.signal.aborted) return {
      shortCircuited: !0
    };
    if (Ml(Ne)) {
      let be;
      return De && De.replace != null ? be = De.replace : be = Ne.location === S.location.pathname + S.location.search, await bn(S, Ne, {
        submission: X,
        replace: be
      }), {
        shortCircuited: !0
      }
    }
    if (Wd(Ne)) {
      let be = pl(le, Se.route.id);
      return (De && De.replace) !== !0 && (x = en.Push), {
        pendingActionData: {},
        pendingActionError: {
          [be.route.id]: Ne.error
        }
      }
    }
    if (Ta(Ne)) throw Yr(400, {
      type: "defer-action"
    });
    return {
      pendingActionData: {
        [Se.route.id]: Ne.data
      }
    }
  }
  async function gt(z, W, X, le, De, je, Ne, Se, be) {
    let lt = le || O0(W, De),
      St = De || je || cP(lt),
      Ge = a || i,
      [mt, Lt] = QC(t.history, S, X, St, W, M, j, A, V, B, Ge, c, Se, be);
    if (_c(ut => !(X && X.some(Xt => Xt.route.id === ut)) || mt && mt.some(Xt => Xt.route.id === ut)), q = ++N, mt.length === 0 && Lt.length === 0) {
      let ut = Kh();
      return pe(W, jt({
        matches: X,
        loaderData: {},
        errors: be || null
      }, Se ? {
        actionData: Se
      } : {}, ut ? {
        fetchers: new Map(S.fetchers)
      } : {})), {
        shortCircuited: !0
      }
    }
    if (!R) {
      Lt.forEach(Xt => {
        let qo = S.fetchers.get(Xt.key),
          Bu = nd(void 0, qo ? qo.data : void 0);
        S.fetchers.set(Xt.key, Bu)
      });
      let ut = Se || S.actionData;
      oe(jt({
        navigation: lt
      }, ut ? Object.keys(ut).length === 0 ? {
        actionData: null
      } : {
        actionData: ut
      } : {}, Lt.length > 0 ? {
        fetchers: new Map(S.fetchers)
      } : {}))
    }
    Lt.forEach(ut => {
      D.has(ut.key) && Yo(ut.key), ut.controller && D.set(ut.key, ut.controller)
    });
    let Ss = () => Lt.forEach(ut => Yo(ut.key));
    k && k.signal.addEventListener("abort", Ss);
    let {
      results: _s,
      loaderResults: ua,
      fetcherResults: xc
    } = await Go(S.matches, X, mt, Lt, z);
    if (z.signal.aborted) return {
      shortCircuited: !0
    };
    k && k.signal.removeEventListener("abort", Ss), Lt.forEach(ut => D.delete(ut.key));
    let Cr = iP(_s);
    if (Cr) {
      if (Cr.idx >= mt.length) {
        let ut = Lt[Cr.idx - mt.length].key;
        B.add(ut)
      }
      return await bn(S, Cr.result, {
        replace: Ne
      }), {
        shortCircuited: !0
      }
    }
    let {
      loaderData: wn,
      errors: Ec
    } = rP(S, X, mt, ua, be, Lt, xc, J);
    J.forEach((ut, Xt) => {
      ut.subscribe(qo => {
        (qo || ut.done) && J.delete(Xt)
      })
    });
    let Nu = Kh(),
      Lu = Gh(q),
      Fu = Nu || Lu || Lt.length > 0;
    return jt({
      loaderData: wn,
      errors: Ec
    }, Fu ? {
      fetchers: new Map(S.fetchers)
    } : {})
  }

  function Ze(z) {
    return S.fetchers.get(z) || XB
  }

  function xt(z, W, X, le) {
    if (r) throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    D.has(z) && Yo(z);
    let De = a || i,
      je = wS(S.location, S.matches, c, l.v7_prependBasename, X, W, le == null ? void 0 : le.relative),
      Ne = hl(De, je, c);
    if (!Ne) {
      fo(z, W, Yr(404, {
        pathname: je
      }));
      return
    }
    let {
      path: Se,
      submission: be,
      error: lt
    } = JC(l.v7_normalizeFormMethod, !0, je, le);
    if (lt) {
      fo(z, W, lt);
      return
    }
    let St = _S(Ne, Se);
    if (E = (le && le.preventScrollReset) === !0, be && bo(be.formMethod)) {
      An(z, W, Se, St, Ne, be);
      return
    }
    V.set(z, {
      routeId: W,
      path: Se
    }), ln(z, W, Se, St, Ne, be)
  }
  async function An(z, W, X, le, De, je) {
    if (Zn(), V.delete(z), !le.route.action && !le.route.lazy) {
      let Zt = Yr(405, {
        method: je.formMethod,
        pathname: X,
        routeId: W
      });
      fo(z, W, Zt);
      return
    }
    let Ne = S.fetchers.get(z),
      Se = cU(je, Ne);
    S.fetchers.set(z, Se), oe({
      fetchers: new Map(S.fetchers)
    });
    let be = new AbortController,
      lt = td(t.history, X, be.signal, je);
    D.set(z, be);
    let St = N,
      Ge = await ed("action", lt, le, De, s, o, c);
    if (lt.signal.aborted) {
      D.get(z) === be && D.delete(z);
      return
    }
    if (Ml(Ge))
      if (D.delete(z), q > St) {
        let Zt = Yc(void 0);
        S.fetchers.set(z, Zt), oe({
          fetchers: new Map(S.fetchers)
        });
        return
      } else {
        B.add(z);
        let Zt = nd(je);
        return S.fetchers.set(z, Zt), oe({
          fetchers: new Map(S.fetchers)
        }), bn(S, Ge, {
          fetcherSubmission: je
        })
      } if (Wd(Ge)) {
      fo(z, W, Ge.error);
      return
    }
    if (Ta(Ge)) throw Yr(400, {
      type: "defer-action"
    });
    let mt = S.navigation.location || S.location,
      Lt = td(t.history, mt, be.signal),
      Ss = a || i,
      _s = S.navigation.state !== "idle" ? hl(Ss, S.navigation.location, c) : S.matches;
    We(_s, "Didn't find any matches after fetcher action");
    let ua = ++N;
    F.set(z, ua);
    let xc = nd(je, Ge.data);
    S.fetchers.set(z, xc);
    let [Cr, wn] = QC(t.history, S, _s, je, mt, M, j, A, V, B, Ss, c, {
      [le.route.id]: Ge.data
    }, void 0);
    wn.filter(Zt => Zt.key !== z).forEach(Zt => {
      let da = Zt.key,
        Jh = S.fetchers.get(da),
        xs = nd(void 0, Jh ? Jh.data : void 0);
      S.fetchers.set(da, xs), D.has(da) && Yo(da), Zt.controller && D.set(da, Zt.controller)
    }), oe({
      fetchers: new Map(S.fetchers)
    });
    let Ec = () => wn.forEach(Zt => Yo(Zt.key));
    be.signal.addEventListener("abort", Ec);
    let {
      results: Nu,
      loaderResults: Lu,
      fetcherResults: Fu
    } = await Go(S.matches, _s, Cr, wn, Lt);
    if (be.signal.aborted) return;
    be.signal.removeEventListener("abort", Ec), F.delete(z), D.delete(z), wn.forEach(Zt => D.delete(Zt.key));
    let ut = iP(Nu);
    if (ut) {
      if (ut.idx >= Cr.length) {
        let Zt = wn[ut.idx - Cr.length].key;
        B.add(Zt)
      }
      return bn(S, ut.result)
    }
    let {
      loaderData: Xt,
      errors: qo
    } = rP(S, S.matches, Cr, Lu, void 0, wn, Fu, J);
    if (S.fetchers.has(z)) {
      let Zt = Yc(Ge.data);
      S.fetchers.set(z, Zt)
    }
    let Bu = Gh(ua);
    S.navigation.state === "loading" && ua > q ? (We(x, "Expected pending action"), k && k.abort(), pe(S.navigation.location, {
      matches: _s,
      loaderData: Xt,
      errors: qo,
      fetchers: new Map(S.fetchers)
    })) : (oe(jt({
      errors: qo,
      loaderData: oP(S.loaderData, Xt, _s, qo)
    }, Bu || wn.length > 0 ? {
      fetchers: new Map(S.fetchers)
    } : {})), M = !1)
  }
  async function ln(z, W, X, le, De, je) {
    let Ne = S.fetchers.get(z),
      Se = nd(je, Ne ? Ne.data : void 0);
    S.fetchers.set(z, Se), oe({
      fetchers: new Map(S.fetchers)
    });
    let be = new AbortController,
      lt = td(t.history, X, be.signal);
    D.set(z, be);
    let St = N,
      Ge = await ed("loader", lt, le, De, s, o, c);
    if (Ta(Ge) && (Ge = await aA(Ge, lt.signal, !0) || Ge), D.get(z) === be && D.delete(z), lt.signal.aborted) return;
    if (Ml(Ge))
      if (q > St) {
        let Lt = Yc(void 0);
        S.fetchers.set(z, Lt), oe({
          fetchers: new Map(S.fetchers)
        });
        return
      } else {
        B.add(z), await bn(S, Ge);
        return
      } if (Wd(Ge)) {
      let Lt = pl(S.matches, W);
      S.fetchers.delete(z), oe({
        fetchers: new Map(S.fetchers),
        errors: {
          [Lt.route.id]: Ge.error
        }
      });
      return
    }
    We(!Ta(Ge), "Unhandled fetcher deferred data");
    let mt = Yc(Ge.data);
    S.fetchers.set(z, mt), oe({
      fetchers: new Map(S.fetchers)
    })
  }
  async function bn(z, W, X) {
    let {
      submission: le,
      fetcherSubmission: De,
      replace: je
    } = X === void 0 ? {} : X;
    W.revalidate && (M = !0);
    let Ne = xf(z.location, W.location, {
      _isRedirect: !0
    });
    if (We(Ne, "Expected a location on the redirect navigation"), n) {
      let mt = !1;
      if (W.reloadDocument) mt = !0;
      else if (rA.test(W.location)) {
        const Lt = t.history.createURL(W.location);
        mt = Lt.origin !== e.location.origin || mu(Lt.pathname, c) == null
      }
      if (mt) {
        je ? e.location.replace(W.location) : e.location.assign(W.location);
        return
      }
    }
    k = null;
    let Se = je === !0 ? en.Replace : en.Push,
      {
        formMethod: be,
        formAction: lt,
        formEncType: St
      } = z.navigation;
    !le && !De && be && lt && St && (le = cP(z.navigation));
    let Ge = le || De;
    if (qB.has(W.status) && Ge && bo(Ge.formMethod)) await Me(Se, Ne, {
      submission: jt({}, Ge, {
        formAction: W.location
      }),
      preventScrollReset: E
    });
    else {
      let mt = O0(Ne, le);
      await Me(Se, Ne, {
        overrideNavigation: mt,
        fetcherSubmission: De,
        preventScrollReset: E
      })
    }
  }
  async function Go(z, W, X, le, De) {
    let je = await Promise.all([...X.map(be => ed("loader", De, be, W, s, o, c)), ...le.map(be => be.matches && be.match && be.controller ? ed("loader", td(t.history, be.path, be.controller.signal), be.match, be.matches, s, o, c) : {
        type: tn.error,
        error: Yr(404, {
          pathname: be.path
        })
      })]),
      Ne = je.slice(0, X.length),
      Se = je.slice(X.length);
    return await Promise.all([aP(z, X, Ne, Ne.map(() => De.signal), !1, S.loaderData), aP(z, le.map(be => be.match), Se, le.map(be => be.controller ? be.controller.signal : null), !0)]), {
      results: je,
      loaderResults: Ne,
      fetcherResults: Se
    }
  }

  function Zn() {
    M = !0, j.push(..._c()), V.forEach((z, W) => {
      D.has(W) && (A.push(W), Yo(W))
    })
  }

  function fo(z, W, X) {
    let le = pl(S.matches, W);
    Du(z), oe({
      errors: {
        [le.route.id]: X
      },
      fetchers: new Map(S.fetchers)
    })
  }

  function Du(z) {
    let W = S.fetchers.get(z);
    D.has(z) && !(W && W.state === "loading" && F.has(z)) && Yo(z), V.delete(z), F.delete(z), B.delete(z), S.fetchers.delete(z)
  }

  function Yo(z) {
    let W = D.get(z);
    We(W, "Expected fetch controller: " + z), W.abort(), D.delete(z)
  }

  function Wh(z) {
    for (let W of z) {
      let X = Ze(W),
        le = Yc(X.data);
      S.fetchers.set(W, le)
    }
  }

  function Kh() {
    let z = [],
      W = !1;
    for (let X of B) {
      let le = S.fetchers.get(X);
      We(le, "Expected fetcher: " + X), le.state === "loading" && (B.delete(X), z.push(X), W = !0)
    }
    return Wh(z), W
  }

  function Gh(z) {
    let W = [];
    for (let [X, le] of F)
      if (le < z) {
        let De = S.fetchers.get(X);
        We(De, "Expected fetcher: " + X), De.state === "loading" && (Yo(X), F.delete(X), W.push(X))
      } return Wh(W), W.length > 0
  }

  function wc(z, W) {
    let X = S.blockers.get(z) || Qu;
    return ee.get(z) !== W && ee.set(z, W), X
  }

  function Sc(z) {
    S.blockers.delete(z), ee.delete(z)
  }

  function ca(z, W) {
    let X = S.blockers.get(z) || Qu;
    We(X.state === "unblocked" && W.state === "blocked" || X.state === "blocked" && W.state === "blocked" || X.state === "blocked" && W.state === "proceeding" || X.state === "blocked" && W.state === "unblocked" || X.state === "proceeding" && W.state === "unblocked", "Invalid blocker state transition: " + X.state + " -> " + W.state);
    let le = new Map(S.blockers);
    le.set(z, W), oe({
      blockers: le
    })
  }

  function kr(z) {
    let {
      currentLocation: W,
      nextLocation: X,
      historyAction: le
    } = z;
    if (ee.size === 0) return;
    ee.size > 1 && Ga(!1, "A router only supports one blocker at a time");
    let De = Array.from(ee.entries()),
      [je, Ne] = De[De.length - 1],
      Se = S.blockers.get(je);
    if (!(Se && Se.state === "proceeding") && Ne({
        currentLocation: W,
        nextLocation: X,
        historyAction: le
      })) return je
  }

  function _c(z) {
    let W = [];
    return J.forEach((X, le) => {
      (!z || z(le)) && (X.cancel(), W.push(le), J.delete(le))
    }), W
  }

  function Yh(z, W, X) {
    if (f = z, m = W, h = X || null, !p && S.navigation === I0) {
      p = !0;
      let le = la(S.location, S.matches);
      le != null && oe({
        restoreScrollPosition: le
      })
    }
    return () => {
      f = null, m = null, h = null
    }
  }

  function qh(z, W) {
    return h && h(z, W.map(le => EB(le, S.loaderData))) || z.key
  }

  function Xh(z, W) {
    if (f && m) {
      let X = qh(z, W);
      f[X] = m()
    }
  }

  function la(z, W) {
    if (f) {
      let X = qh(z, W),
        le = f[X];
      if (typeof le == "number") return le
    }
    return null
  }

  function Zh(z) {
    s = {}, a = bS(z, o, void 0, s)
  }
  return _ = {
    get basename() {
      return c
    },
    get state() {
      return S
    },
    get routes() {
      return i
    },
    get window() {
      return e
    },
    initialize: ge,
    subscribe: Ce,
    enableScrollRestoration: Yh,
    navigate: _e,
    fetch: xt,
    revalidate: xe,
    createHref: z => t.history.createHref(z),
    encodeLocation: z => t.history.encodeLocation(z),
    getFetcher: Ze,
    deleteFetcher: Du,
    dispose: ce,
    getBlocker: wc,
    deleteBlocker: Sc,
    _internalFetchControllers: D,
    _internalActiveDeferreds: J,
    _internalSetRoutes: Zh
  }, _
}

function QB(t) {
  return t != null && ("formData" in t && t.formData != null || "body" in t && t.body !== void 0)
}

function wS(t, e, n, r, o, s, i) {
  let a, c;
  if (s != null && i !== "path") {
    a = [];
    for (let u of e)
      if (a.push(u), u.route.id === s) {
        c = u;
        break
      }
  } else a = e, c = e[e.length - 1];
  let l = Uy(o || ".", yh(a).map(u => u.pathnameBase), mu(t.pathname, n) || t.pathname, i === "path");
  return o == null && (l.search = t.search, l.hash = t.hash), (o == null || o === "" || o === ".") && c && c.route.index && !Jx(l.search) && (l.search = l.search ? l.search.replace(/^\?/, "?index&") : "?index"), r && n !== "/" && (l.pathname = l.pathname === "/" ? n : Ds([n, l.pathname])), Ya(l)
}

function JC(t, e, n, r) {
  if (!r || !QB(r)) return {
    path: n
  };
  if (r.formMethod && !iU(r.formMethod)) return {
    path: n,
    error: Yr(405, {
      method: r.formMethod
    })
  };
  let o = () => ({
      path: n,
      error: Yr(400, {
        type: "invalid-body"
      })
    }),
    s = r.formMethod || "get",
    i = t ? s.toUpperCase() : s.toLowerCase(),
    a = iA(n);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!bo(i)) return o();
      let f = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? Array.from(r.body.entries()).reduce((h, m) => {
        let [p, b] = m;
        return "" + h + p + "=" + b + `
`
      }, "") : String(r.body);
      return {
        path: n,
        submission: {
          formMethod: i,
          formAction: a,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: f
        }
      }
    } else if (r.formEncType === "application/json") {
      if (!bo(i)) return o();
      try {
        let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: n,
          submission: {
            formMethod: i,
            formAction: a,
            formEncType: r.formEncType,
            formData: void 0,
            json: f,
            text: void 0
          }
        }
      } catch {
        return o()
      }
    }
  }
  We(typeof FormData == "function", "FormData is not available in this environment");
  let c, l;
  if (r.formData) c = SS(r.formData), l = r.formData;
  else if (r.body instanceof FormData) c = SS(r.body), l = r.body;
  else if (r.body instanceof URLSearchParams) c = r.body, l = nP(c);
  else if (r.body == null) c = new URLSearchParams, l = new FormData;
  else try {
    c = new URLSearchParams(r.body), l = nP(c)
  } catch {
    return o()
  }
  let u = {
    formMethod: i,
    formAction: a,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: l,
    json: void 0,
    text: void 0
  };
  if (bo(u.formMethod)) return {
    path: n,
    submission: u
  };
  let d = ni(n);
  return e && d.search && Jx(d.search) && c.append("index", ""), d.search = "?" + c, {
    path: Ya(d),
    submission: u
  }
}

function eU(t, e) {
  let n = t;
  if (e) {
    let r = t.findIndex(o => o.route.id === e);
    r >= 0 && (n = t.slice(0, r))
  }
  return n
}

function QC(t, e, n, r, o, s, i, a, c, l, u, d, f, h) {
  let m = h ? Object.values(h)[0] : f ? Object.values(f)[0] : void 0,
    p = t.createURL(e.location),
    b = t.createURL(o),
    w = h ? Object.keys(h)[0] : void 0,
    _ = eU(n, w).filter((x, E) => {
      if (x.route.lazy) return !0;
      if (x.route.loader == null) return !1;
      if (tU(e.loaderData, e.matches[E], x) || i.some($ => $ === x.route.id)) return !0;
      let k = e.matches[E],
        C = x;
      return eP(x, jt({
        currentUrl: p,
        currentParams: k.params,
        nextUrl: b,
        nextParams: C.params
      }, r, {
        actionResult: m,
        defaultShouldRevalidate: s || p.pathname + p.search === b.pathname + b.search || p.search !== b.search || sA(k, C)
      }))
    }),
    S = [];
  return c.forEach((x, E) => {
    if (!n.some(R => R.route.id === x.routeId)) return;
    let k = hl(u, x.path, d);
    if (!k) {
      S.push({
        key: E,
        routeId: x.routeId,
        path: x.path,
        matches: null,
        match: null,
        controller: null
      });
      return
    }
    let C = e.fetchers.get(E),
      $ = _S(k, x.path),
      I = !1;
    l.has(E) ? I = !1 : a.includes(E) ? I = !0 : C && C.state !== "idle" && C.data === void 0 ? I = s : I = eP($, jt({
      currentUrl: p,
      currentParams: e.matches[e.matches.length - 1].params,
      nextUrl: b,
      nextParams: n[n.length - 1].params
    }, r, {
      actionResult: m,
      defaultShouldRevalidate: s
    })), I && S.push({
      key: E,
      routeId: x.routeId,
      path: x.path,
      matches: k,
      match: $,
      controller: new AbortController
    })
  }), [_, S]
}

function tU(t, e, n) {
  let r = !e || n.route.id !== e.route.id,
    o = t[n.route.id] === void 0;
  return r || o
}

function sA(t, e) {
  let n = t.route.path;
  return t.pathname !== e.pathname || n != null && n.endsWith("*") && t.params["*"] !== e.params["*"]
}

function eP(t, e) {
  if (t.route.shouldRevalidate) {
    let n = t.route.shouldRevalidate(e);
    if (typeof n == "boolean") return n
  }
  return e.defaultShouldRevalidate
}
async function tP(t, e, n) {
  if (!t.lazy) return;
  let r = await t.lazy();
  if (!t.lazy) return;
  let o = n[t.id];
  We(o, "No route found in manifest");
  let s = {};
  for (let i in r) {
    let c = o[i] !== void 0 && i !== "hasErrorBoundary";
    Ga(!c, 'Route "' + o.id + '" has a static property "' + i + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + i + '" will be ignored.')), !c && !_B.has(i) && (s[i] = r[i])
  }
  Object.assign(o, s), Object.assign(o, jt({}, e(o), {
    lazy: void 0
  }))
}
async function ed(t, e, n, r, o, s, i, a) {
  a === void 0 && (a = {});
  let c, l, u, d = m => {
    let p, b = new Promise((w, v) => p = v);
    return u = () => p(), e.signal.addEventListener("abort", u), Promise.race([m({
      request: e,
      params: n.params,
      context: a.requestContext
    }), b])
  };
  try {
    let m = n.route[t];
    if (n.route.lazy)
      if (m) {
        let p, b = await Promise.all([d(m).catch(w => {
          p = w
        }), tP(n.route, s, o)]);
        if (p) throw p;
        l = b[0]
      } else if (await tP(n.route, s, o), m = n.route[t], m) l = await d(m);
    else if (t === "action") {
      let p = new URL(e.url),
        b = p.pathname + p.search;
      throw Yr(405, {
        method: e.method,
        pathname: b,
        routeId: n.route.id
      })
    } else return {
      type: tn.data,
      data: void 0
    };
    else if (m) l = await d(m);
    else {
      let p = new URL(e.url),
        b = p.pathname + p.search;
      throw Yr(404, {
        pathname: b
      })
    }
    We(l !== void 0, "You defined " + (t === "action" ? "an action" : "a loader") + " for route " + ('"' + n.route.id + "\" but didn't return anything from your `" + t + "` ") + "function. Please return a value or `null`.")
  } catch (m) {
    c = tn.error, l = m
  } finally {
    u && e.signal.removeEventListener("abort", u)
  }
  if (sU(l)) {
    let m = l.status;
    if (YB.has(m)) {
      let w = l.headers.get("Location");
      if (We(w, "Redirects returned/thrown from loaders/actions must have a Location header"), !rA.test(w)) w = wS(new URL(e.url), r.slice(0, r.indexOf(n) + 1), i, !0, w);
      else if (!a.isStaticRequest) {
        let v = new URL(e.url),
          _ = w.startsWith("//") ? new URL(v.protocol + w) : new URL(w),
          S = mu(_.pathname, i) != null;
        _.origin === v.origin && S && (w = _.pathname + _.search + _.hash)
      }
      if (a.isStaticRequest) throw l.headers.set("Location", w), l;
      return {
        type: tn.redirect,
        status: m,
        location: w,
        revalidate: l.headers.get("X-Remix-Revalidate") !== null,
        reloadDocument: l.headers.get("X-Remix-Reload-Document") !== null
      }
    }
    if (a.isRouteRequest) throw {
      type: c === tn.error ? tn.error : tn.data,
      response: l
    };
    let p, b = l.headers.get("Content-Type");
    return b && /\bapplication\/json\b/.test(b) ? p = await l.json() : p = await l.text(), c === tn.error ? {
      type: c,
      error: new Zx(m, l.statusText, p),
      headers: l.headers
    } : {
      type: tn.data,
      data: p,
      statusCode: l.status,
      headers: l.headers
    }
  }
  if (c === tn.error) return {
    type: c,
    error: l
  };
  if (oU(l)) {
    var f, h;
    return {
      type: tn.deferred,
      deferredData: l,
      statusCode: (f = l.init) == null ? void 0 : f.status,
      headers: ((h = l.init) == null ? void 0 : h.headers) && new Headers(l.init.headers)
    }
  }
  return {
    type: tn.data,
    data: l
  }
}

function td(t, e, n, r) {
  let o = t.createURL(iA(e)).toString(),
    s = {
      signal: n
    };
  if (r && bo(r.formMethod)) {
    let {
      formMethod: i,
      formEncType: a
    } = r;
    s.method = i.toUpperCase(), a === "application/json" ? (s.headers = new Headers({
      "Content-Type": a
    }), s.body = JSON.stringify(r.json)) : a === "text/plain" ? s.body = r.text : a === "application/x-www-form-urlencoded" && r.formData ? s.body = SS(r.formData) : s.body = r.formData
  }
  return new Request(o, s)
}

function SS(t) {
  let e = new URLSearchParams;
  for (let [n, r] of t.entries()) e.append(n, typeof r == "string" ? r : r.name);
  return e
}

function nP(t) {
  let e = new FormData;
  for (let [n, r] of t.entries()) e.append(n, r);
  return e
}

function nU(t, e, n, r, o) {
  let s = {},
    i = null,
    a, c = !1,
    l = {};
  return n.forEach((u, d) => {
    let f = e[d].route.id;
    if (We(!Ml(u), "Cannot handle redirect results in processLoaderData"), Wd(u)) {
      let h = pl(t, f),
        m = u.error;
      r && (m = Object.values(r)[0], r = void 0), i = i || {}, i[h.route.id] == null && (i[h.route.id] = m), s[f] = void 0, c || (c = !0, a = tA(u.error) ? u.error.status : 500), u.headers && (l[f] = u.headers)
    } else Ta(u) ? (o.set(f, u.deferredData), s[f] = u.deferredData.data) : s[f] = u.data, u.statusCode != null && u.statusCode !== 200 && !c && (a = u.statusCode), u.headers && (l[f] = u.headers)
  }), r && (i = r, s[Object.keys(r)[0]] = void 0), {
    loaderData: s,
    errors: i,
    statusCode: a || 200,
    loaderHeaders: l
  }
}

function rP(t, e, n, r, o, s, i, a) {
  let {
    loaderData: c,
    errors: l
  } = nU(e, n, r, o, a);
  for (let u = 0; u < s.length; u++) {
    let {
      key: d,
      match: f,
      controller: h
    } = s[u];
    We(i !== void 0 && i[u] !== void 0, "Did not find corresponding fetcher result");
    let m = i[u];
    if (!(h && h.signal.aborted))
      if (Wd(m)) {
        let p = pl(t.matches, f == null ? void 0 : f.route.id);
        l && l[p.route.id] || (l = jt({}, l, {
          [p.route.id]: m.error
        })), t.fetchers.delete(d)
      } else if (Ml(m)) We(!1, "Unhandled fetcher revalidation redirect");
    else if (Ta(m)) We(!1, "Unhandled fetcher deferred data");
    else {
      let p = Yc(m.data);
      t.fetchers.set(d, p)
    }
  }
  return {
    loaderData: c,
    errors: l
  }
}

function oP(t, e, n, r) {
  let o = jt({}, e);
  for (let s of n) {
    let i = s.route.id;
    if (e.hasOwnProperty(i) ? e[i] !== void 0 && (o[i] = e[i]) : t[i] !== void 0 && s.route.loader && (o[i] = t[i]), r && r.hasOwnProperty(i)) break
  }
  return o
}

function pl(t, e) {
  return (e ? t.slice(0, t.findIndex(r => r.route.id === e) + 1) : [...t]).reverse().find(r => r.route.hasErrorBoundary === !0) || t[0]
}

function sP(t) {
  let e = t.length === 1 ? t[0] : t.find(n => n.index || !n.path || n.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: e
    }],
    route: e
  }
}

function Yr(t, e) {
  let {
    pathname: n,
    routeId: r,
    method: o,
    type: s
  } = e === void 0 ? {} : e, i = "Unknown Server Error", a = "Unknown @remix-run/router error";
  return t === 400 ? (i = "Bad Request", o && n && r ? a = "You made a " + o + ' request to "' + n + '" but ' + ('did not provide a `loader` for route "' + r + '", ') + "so there is no way to handle the request." : s === "defer-action" ? a = "defer() is not supported in actions" : s === "invalid-body" && (a = "Unable to encode submission body")) : t === 403 ? (i = "Forbidden", a = 'Route "' + r + '" does not match URL "' + n + '"') : t === 404 ? (i = "Not Found", a = 'No route matches URL "' + n + '"') : t === 405 && (i = "Method Not Allowed", o && n && r ? a = "You made a " + o.toUpperCase() + ' request to "' + n + '" but ' + ('did not provide an `action` for route "' + r + '", ') + "so there is no way to handle the request." : o && (a = 'Invalid request method "' + o.toUpperCase() + '"')), new Zx(t || 500, i, new Error(a), !0)
}

function iP(t) {
  for (let e = t.length - 1; e >= 0; e--) {
    let n = t[e];
    if (Ml(n)) return {
      result: n,
      idx: e
    }
  }
}

function iA(t) {
  let e = typeof t == "string" ? ni(t) : t;
  return Ya(jt({}, e, {
    hash: ""
  }))
}

function rU(t, e) {
  return t.pathname !== e.pathname || t.search !== e.search ? !1 : t.hash === "" ? e.hash !== "" : t.hash === e.hash ? !0 : e.hash !== ""
}

function Ta(t) {
  return t.type === tn.deferred
}

function Wd(t) {
  return t.type === tn.error
}

function Ml(t) {
  return (t && t.type) === tn.redirect
}

function oU(t) {
  let e = t;
  return e && typeof e == "object" && typeof e.data == "object" && typeof e.subscribe == "function" && typeof e.cancel == "function" && typeof e.resolveData == "function"
}

function sU(t) {
  return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.headers == "object" && typeof t.body < "u"
}

function iU(t) {
  return GB.has(t.toLowerCase())
}

function bo(t) {
  return WB.has(t.toLowerCase())
}
async function aP(t, e, n, r, o, s) {
  for (let i = 0; i < n.length; i++) {
    let a = n[i],
      c = e[i];
    if (!c) continue;
    let l = t.find(d => d.route.id === c.route.id),
      u = l != null && !sA(l, c) && (s && s[c.route.id]) !== void 0;
    if (Ta(a) && (o || u)) {
      let d = r[i];
      We(d, "Expected an AbortSignal for revalidating fetcher deferred result"), await aA(a, d, o).then(f => {
        f && (n[i] = f || n[i])
      })
    }
  }
}
async function aA(t, e, n) {
  if (n === void 0 && (n = !1), !await t.deferredData.resolveData(e)) {
    if (n) try {
      return {
        type: tn.data,
        data: t.deferredData.unwrappedData
      }
    } catch (o) {
      return {
        type: tn.error,
        error: o
      }
    }
    return {
      type: tn.data,
      data: t.deferredData.data
    }
  }
}

function Jx(t) {
  return new URLSearchParams(t).getAll("index").some(e => e === "")
}

function _S(t, e) {
  let n = typeof e == "string" ? ni(e).search : e.search;
  if (t[t.length - 1].route.index && Jx(n || "")) return t[t.length - 1];
  let r = yh(t);
  return r[r.length - 1]
}

function cP(t) {
  let {
    formMethod: e,
    formAction: n,
    formEncType: r,
    text: o,
    formData: s,
    json: i
  } = t;
  if (!(!e || !n || !r)) {
    if (o != null) return {
      formMethod: e,
      formAction: n,
      formEncType: r,
      formData: void 0,
      json: void 0,
      text: o
    };
    if (s != null) return {
      formMethod: e,
      formAction: n,
      formEncType: r,
      formData: s,
      json: void 0,
      text: void 0
    };
    if (i !== void 0) return {
      formMethod: e,
      formAction: n,
      formEncType: r,
      formData: void 0,
      json: i,
      text: void 0
    }
  }
}

function O0(t, e) {
  return e ? {
    state: "loading",
    location: t,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  } : {
    state: "loading",
    location: t,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  }
}

function aU(t, e) {
  return {
    state: "submitting",
    location: t,
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text
  }
}

function nd(t, e) {
  return t ? {
    state: "loading",
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text,
    data: e
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  }
}

function cU(t, e) {
  return {
    state: "submitting",
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text,
    data: e ? e.data : void 0
  }
}

function Yc(t) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  }
}

function lU(t, e) {
  try {
    let n = t.sessionStorage.getItem(oA);
    if (n) {
      let r = JSON.parse(n);
      for (let [o, s] of Object.entries(r || {})) s && Array.isArray(s) && e.set(o, new Set(s || []))
    }
  } catch {}
}

function uU(t, e) {
  if (e.size > 0) {
    let n = {};
    for (let [r, o] of e) n[r] = [...o];
    try {
      t.sessionStorage.setItem(oA, JSON.stringify(n))
    } catch (r) {
      Ga(!1, "Failed to save applied view transitions in sessionStorage (" + r + ").")
    }
  }
}
/**
 * React Router v6.17.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function wm() {
  return wm = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
    return t
  }, wm.apply(this, arguments)
}
const zy = g.createContext(null),
  cA = g.createContext(null),
  yu = g.createContext(null),
  Hy = g.createContext(null),
  ys = g.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
  }),
  lA = g.createContext(null);

function dU(t, e) {
  let {
    relative: n
  } = e === void 0 ? {} : e;
  vu() || We(!1);
  let {
    basename: r,
    navigator: o
  } = g.useContext(yu), {
    hash: s,
    pathname: i,
    search: a
  } = dA(t, {
    relative: n
  }), c = i;
  return r !== "/" && (c = i === "/" ? r : Ds([r, i])), o.createHref({
    pathname: c,
    search: a,
    hash: s
  })
}

function vu() {
  return g.useContext(Hy) != null
}

function uc() {
  return vu() || We(!1), g.useContext(Hy).location
}

function uA(t) {
  g.useContext(yu).static || g.useLayoutEffect(t)
}

function Qx() {
  let {
    isDataRoute: t
  } = g.useContext(ys);
  return t ? xU() : fU()
}

function fU() {
  vu() || We(!1);
  let t = g.useContext(zy),
    {
      basename: e,
      navigator: n
    } = g.useContext(yu),
    {
      matches: r
    } = g.useContext(ys),
    {
      pathname: o
    } = uc(),
    s = JSON.stringify(yh(r).map(c => c.pathnameBase)),
    i = g.useRef(!1);
  return uA(() => {
    i.current = !0
  }), g.useCallback(function(c, l) {
    if (l === void 0 && (l = {}), !i.current) return;
    if (typeof c == "number") {
      n.go(c);
      return
    }
    let u = Uy(c, JSON.parse(s), o, l.relative === "path");
    t == null && e !== "/" && (u.pathname = u.pathname === "/" ? e : Ds([e, u.pathname])), (l.replace ? n.replace : n.push)(u, l.state, l)
  }, [e, n, s, o, t])
}
const hU = g.createContext(null);

function pU(t) {
  let e = g.useContext(ys).outlet;
  return e && g.createElement(hU.Provider, {
    value: t
  }, e)
}

function gU() {
  let {
    matches: t
  } = g.useContext(ys), e = t[t.length - 1];
  return e ? e.params : {}
}

function dA(t, e) {
  let {
    relative: n
  } = e === void 0 ? {} : e, {
    matches: r
  } = g.useContext(ys), {
    pathname: o
  } = uc(), s = JSON.stringify(yh(r).map(i => i.pathnameBase));
  return g.useMemo(() => Uy(t, JSON.parse(s), o, n === "path"), [t, s, o, n])
}

function mU(t, e, n) {
  vu() || We(!1);
  let {
    navigator: r
  } = g.useContext(yu), {
    matches: o
  } = g.useContext(ys), s = o[o.length - 1], i = s ? s.params : {};
  s && s.pathname;
  let a = s ? s.pathnameBase : "/";
  s && s.route;
  let c = uc(),
    l;
  if (e) {
    var u;
    let p = typeof e == "string" ? ni(e) : e;
    a === "/" || (u = p.pathname) != null && u.startsWith(a) || We(!1), l = p
  } else l = c;
  let d = l.pathname || "/",
    f = a === "/" ? d : d.slice(a.length) || "/",
    h = hl(t, {
      pathname: f
    }),
    m = SU(h && h.map(p => Object.assign({}, p, {
      params: Object.assign({}, i, p.params),
      pathname: Ds([a, r.encodeLocation ? r.encodeLocation(p.pathname).pathname : p.pathname]),
      pathnameBase: p.pathnameBase === "/" ? a : Ds([a, r.encodeLocation ? r.encodeLocation(p.pathnameBase).pathname : p.pathnameBase])
    })), o, n);
  return e && m ? g.createElement(Hy.Provider, {
    value: {
      location: wm({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, l),
      navigationType: en.Pop
    }
  }, m) : m
}

function yU() {
  let t = r1(),
    e = tA(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t),
    n = t instanceof Error ? t.stack : null,
    o = {
      padding: "0.5rem",
      backgroundColor: "rgba(200,200,200, 0.5)"
    },
    s = null;
  return g.createElement(g.Fragment, null, g.createElement("h2", null, "Unexpected Application Error!"), g.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, e), n ? g.createElement("pre", {
    style: o
  }, n) : null, s)
}
const vU = g.createElement(yU, null);
class bU extends g.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    }
  }
  static getDerivedStateFromError(e) {
    return {
      error: e
    }
  }
  static getDerivedStateFromProps(e, n) {
    return n.location !== e.location || n.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error || n.error,
      location: n.location,
      revalidation: e.revalidation || n.revalidation
    }
  }
  componentDidCatch(e, n) {
    console.error("React Router caught the following error during render", e, n)
  }
  render() {
    return this.state.error ? g.createElement(ys.Provider, {
      value: this.props.routeContext
    }, g.createElement(lA.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children
  }
}

function wU(t) {
  let {
    routeContext: e,
    match: n,
    children: r
  } = t, o = g.useContext(zy);
  return o && o.static && o.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (o.staticContext._deepestRenderedBoundaryId = n.route.id), g.createElement(ys.Provider, {
    value: e
  }, r)
}

function SU(t, e, n) {
  var r;
  if (e === void 0 && (e = []), n === void 0 && (n = null), t == null) {
    var o;
    if ((o = n) != null && o.errors) t = n.matches;
    else return null
  }
  let s = t,
    i = (r = n) == null ? void 0 : r.errors;
  if (i != null) {
    let a = s.findIndex(c => c.route.id && (i == null ? void 0 : i[c.route.id]));
    a >= 0 || We(!1), s = s.slice(0, Math.min(s.length, a + 1))
  }
  return s.reduceRight((a, c, l) => {
    let u = c.route.id ? i == null ? void 0 : i[c.route.id] : null,
      d = null;
    n && (d = c.route.errorElement || vU);
    let f = e.concat(s.slice(0, l + 1)),
      h = () => {
        let m;
        return u ? m = d : c.route.Component ? m = g.createElement(c.route.Component, null) : c.route.element ? m = c.route.element : m = a, g.createElement(wU, {
          match: c,
          routeContext: {
            outlet: a,
            matches: f,
            isDataRoute: n != null
          },
          children: m
        })
      };
    return n && (c.route.ErrorBoundary || c.route.errorElement || l === 0) ? g.createElement(bU, {
      location: n.location,
      revalidation: n.revalidation,
      component: d,
      error: u,
      children: h(),
      routeContext: {
        outlet: null,
        matches: f,
        isDataRoute: !0
      }
    }) : h()
  }, null)
}
var e1 = function(t) {
    return t.UseBlocker = "useBlocker", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t
  }(e1 || {}),
  qa = function(t) {
    return t.UseBlocker = "useBlocker", t.UseLoaderData = "useLoaderData", t.UseActionData = "useActionData", t.UseRouteError = "useRouteError", t.UseNavigation = "useNavigation", t.UseRouteLoaderData = "useRouteLoaderData", t.UseMatches = "useMatches", t.UseRevalidator = "useRevalidator", t.UseNavigateStable = "useNavigate", t.UseRouteId = "useRouteId", t
  }(qa || {});

function fA(t) {
  let e = g.useContext(zy);
  return e || We(!1), e
}

function t1(t) {
  let e = g.useContext(cA);
  return e || We(!1), e
}

function _U(t) {
  let e = g.useContext(ys);
  return e || We(!1), e
}

function n1(t) {
  let e = _U(),
    n = e.matches[e.matches.length - 1];
  return n.route.id || We(!1), n.route.id
}

function Eve() {
  let t = fA(e1.UseRevalidator),
    e = t1(qa.UseRevalidator);
  return g.useMemo(() => ({
    revalidate: t.router.revalidate,
    state: e.revalidation
  }), [t.router.revalidate, e.revalidation])
}

function kve() {
  let t = t1(qa.UseLoaderData),
    e = n1(qa.UseLoaderData);
  if (t.errors && t.errors[e] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + e + ")");
    return
  }
  return t.loaderData[e]
}

function r1() {
  var t;
  let e = g.useContext(lA),
    n = t1(qa.UseRouteError),
    r = n1(qa.UseRouteError);
  return e || ((t = n.errors) == null ? void 0 : t[r])
}

function xU() {
  let {
    router: t
  } = fA(e1.UseNavigateStable), e = n1(qa.UseNavigateStable), n = g.useRef(!1);
  return uA(() => {
    n.current = !0
  }), g.useCallback(function(o, s) {
    s === void 0 && (s = {}), n.current && (typeof o == "number" ? t.navigate(o) : t.navigate(o, wm({
      fromRouteId: e
    }, s)))
  }, [t, e])
}

function lP(t) {
  let {
    to: e,
    replace: n,
    state: r,
    relative: o
  } = t;
  vu() || We(!1);
  let {
    matches: s
  } = g.useContext(ys), {
    pathname: i
  } = uc(), a = Qx(), c = Uy(e, yh(s).map(u => u.pathnameBase), i, o === "path"), l = JSON.stringify(c);
  return g.useEffect(() => a(JSON.parse(l), {
    replace: n,
    state: r,
    relative: o
  }), [a, l, o, n, r]), null
}

function Tg(t) {
  return pU(t.context)
}

function Ae(t) {
  We(!1)
}

function EU(t) {
  let {
    basename: e = "/",
    children: n = null,
    location: r,
    navigationType: o = en.Pop,
    navigator: s,
    static: i = !1
  } = t;
  vu() && We(!1);
  let a = e.replace(/^\/*/, "/"),
    c = g.useMemo(() => ({
      basename: a,
      navigator: s,
      static: i
    }), [a, s, i]);
  typeof r == "string" && (r = ni(r));
  let {
    pathname: l = "/",
    search: u = "",
    hash: d = "",
    state: f = null,
    key: h = "default"
  } = r, m = g.useMemo(() => {
    let p = mu(l, a);
    return p == null ? null : {
      location: {
        pathname: p,
        search: u,
        hash: d,
        state: f,
        key: h
      },
      navigationType: o
    }
  }, [a, l, u, d, f, h, o]);
  return m == null ? null : g.createElement(yu.Provider, {
    value: c
  }, g.createElement(Hy.Provider, {
    children: n,
    value: m
  }))
}
new Promise(() => {});

function xS(t, e) {
  e === void 0 && (e = []);
  let n = [];
  return g.Children.forEach(t, (r, o) => {
    if (!g.isValidElement(r)) return;
    let s = [...e, o];
    if (r.type === g.Fragment) {
      n.push.apply(n, xS(r.props.children, s));
      return
    }
    r.type !== Ae && We(!1), !r.props.index || !r.props.children || We(!1);
    let i = {
      id: r.props.id || s.join("-"),
      caseSensitive: r.props.caseSensitive,
      element: r.props.element,
      Component: r.props.Component,
      index: r.props.index,
      path: r.props.path,
      loader: r.props.loader,
      action: r.props.action,
      errorElement: r.props.errorElement,
      ErrorBoundary: r.props.ErrorBoundary,
      hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null,
      shouldRevalidate: r.props.shouldRevalidate,
      handle: r.props.handle,
      lazy: r.props.lazy
    };
    r.props.children && (i.children = xS(r.props.children, s)), n.push(i)
  }), n
}

function kU(t) {
  let e = {
    hasErrorBoundary: t.ErrorBoundary != null || t.errorElement != null
  };
  return t.Component && Object.assign(e, {
    element: g.createElement(t.Component),
    Component: void 0
  }), t.ErrorBoundary && Object.assign(e, {
    errorElement: g.createElement(t.ErrorBoundary),
    ErrorBoundary: void 0
  }), e
}
/**
 * React Router DOM v6.17.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Ef() {
  return Ef = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
    return t
  }, Ef.apply(this, arguments)
}

function CU(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    o, s;
  for (s = 0; s < r.length; s++) o = r[s], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n
}

function PU(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}

function TU(t, e) {
  return t.button === 0 && (!e || e === "_self") && !PU(t)
}

function ES(t) {
  return t === void 0 && (t = ""), new URLSearchParams(typeof t == "string" || Array.isArray(t) || t instanceof URLSearchParams ? t : Object.keys(t).reduce((e, n) => {
    let r = t[n];
    return e.concat(Array.isArray(r) ? r.map(o => [n, o]) : [
      [n, r]
    ])
  }, []))
}

function $U(t, e) {
  let n = ES(t);
  return e && e.forEach((r, o) => {
    n.has(o) || e.getAll(o).forEach(s => {
      n.append(o, s)
    })
  }), n
}
const IU = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"];

function OU(t, e) {
  return JB({
    basename: e == null ? void 0 : e.basename,
    future: Ef({}, e == null ? void 0 : e.future, {
      v7_prependBasename: !0
    }),
    history: bB({
      window: e == null ? void 0 : e.window
    }),
    hydrationData: (e == null ? void 0 : e.hydrationData) || RU(),
    routes: t,
    mapRouteProperties: kU,
    window: e == null ? void 0 : e.window
  }).initialize()
}

function RU() {
  var t;
  let e = (t = window) == null ? void 0 : t.__staticRouterHydrationData;
  return e && e.errors && (e = Ef({}, e, {
    errors: AU(e.errors)
  })), e
}

function AU(t) {
  if (!t) return null;
  let e = Object.entries(t),
    n = {};
  for (let [r, o] of e)
    if (o && o.__type === "RouteErrorResponse") n[r] = new Zx(o.status, o.statusText, o.data, o.internal === !0);
    else if (o && o.__type === "Error") {
    if (o.__subType) {
      let s = window[o.__subType];
      if (typeof s == "function") try {
        let i = new s(o.message);
        i.stack = "", n[r] = i
      } catch {}
    }
    if (n[r] == null) {
      let s = new Error(o.message);
      s.stack = "", n[r] = s
    }
  } else n[r] = o;
  return n
}
const MU = g.createContext({
    isTransitioning: !1
  }),
  jU = "startTransition",
  uP = cI[jU];

function DU(t) {
  uP ? uP(t) : t()
}
let NU = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, n) => {
      this.resolve = r => {
        this.status === "pending" && (this.status = "resolved", e(r))
      }, this.reject = r => {
        this.status === "pending" && (this.status = "rejected", n(r))
      }
    })
  }
};

function LU(t) {
  let {
    fallbackElement: e,
    router: n,
    future: r
  } = t, [o, s] = g.useState(n.state), [i, a] = g.useState(), [c, l] = g.useState({
    isTransitioning: !1
  }), [u, d] = g.useState(), [f, h] = g.useState(), [m, p] = g.useState(), {
    v7_startTransition: b
  } = r || {}, w = g.useCallback(E => {
    b ? DU(E) : E()
  }, [b]), v = g.useCallback((E, k) => {
    let {
      unstable_viewTransitionOpts: C
    } = k;
    !C || n.window == null || typeof n.window.document.startViewTransition != "function" ? w(() => s(E)) : f && u ? (u.resolve(), f.skipTransition(), p({
      state: E,
      currentLocation: C.currentLocation,
      nextLocation: C.nextLocation
    })) : (a(E), l({
      isTransitioning: !0,
      currentLocation: C.currentLocation,
      nextLocation: C.nextLocation
    }))
  }, [w, f, u, n.window]);
  g.useLayoutEffect(() => n.subscribe(v), [n, v]), g.useEffect(() => {
    c.isTransitioning && d(new NU)
  }, [c.isTransitioning]), g.useEffect(() => {
    if (u && i && n.window) {
      let E = i,
        k = u.promise,
        C = n.window.document.startViewTransition(async () => {
          w(() => s(E)), await k
        });
      C.finished.finally(() => {
        d(void 0), h(void 0), a(void 0), l({
          isTransitioning: !1
        })
      }), h(C)
    }
  }, [w, i, u, n.window]), g.useEffect(() => {
    u && i && o.location.key === i.location.key && u.resolve()
  }, [u, f, o.location, i]), g.useEffect(() => {
    !c.isTransitioning && m && (a(m.state), l({
      isTransitioning: !0,
      currentLocation: m.currentLocation,
      nextLocation: m.nextLocation
    }), p(void 0))
  }, [c.isTransitioning, m]);
  let _ = g.useMemo(() => ({
      createHref: n.createHref,
      encodeLocation: n.encodeLocation,
      go: E => n.navigate(E),
      push: (E, k, C) => n.navigate(E, {
        state: k,
        preventScrollReset: C == null ? void 0 : C.preventScrollReset
      }),
      replace: (E, k, C) => n.navigate(E, {
        replace: !0,
        state: k,
        preventScrollReset: C == null ? void 0 : C.preventScrollReset
      })
    }), [n]),
    S = n.basename || "/",
    x = g.useMemo(() => ({
      router: n,
      navigator: _,
      static: !1,
      basename: S
    }), [n, _, S]);
  return g.createElement(g.Fragment, null, g.createElement(zy.Provider, {
    value: x
  }, g.createElement(cA.Provider, {
    value: o
  }, g.createElement(MU.Provider, {
    value: c
  }, g.createElement(EU, {
    basename: S,
    location: o.location,
    navigationType: o.historyAction,
    navigator: _
  }, o.initialized ? g.createElement(FU, {
    routes: n.routes,
    state: o
  }) : e)))), null)
}

function FU(t) {
  let {
    routes: e,
    state: n
  } = t;
  return mU(e, void 0, n)
}
const BU = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u",
  UU = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  zU = g.forwardRef(function(e, n) {
    let {
      onClick: r,
      relative: o,
      reloadDocument: s,
      replace: i,
      state: a,
      target: c,
      to: l,
      preventScrollReset: u,
      unstable_viewTransition: d
    } = e, f = CU(e, IU), {
      basename: h
    } = g.useContext(yu), m, p = !1;
    if (typeof l == "string" && UU.test(l) && (m = l, BU)) try {
      let _ = new URL(window.location.href),
        S = l.startsWith("//") ? new URL(_.protocol + l) : new URL(l),
        x = mu(S.pathname, h);
      S.origin === _.origin && x != null ? l = x + S.search + S.hash : p = !0
    } catch {}
    let b = dU(l, {
        relative: o
      }),
      w = HU(l, {
        replace: i,
        state: a,
        target: c,
        preventScrollReset: u,
        relative: o,
        unstable_viewTransition: d
      });

    function v(_) {
      r && r(_), _.defaultPrevented || w(_)
    }
    return g.createElement("a", Ef({}, f, {
      href: m || b,
      onClick: p || s ? r : v,
      ref: n,
      target: c
    }))
  });
var dP;
(function(t) {
  t.UseScrollRestoration = "useScrollRestoration", t.UseSubmit = "useSubmit", t.UseSubmitFetcher = "useSubmitFetcher", t.UseFetcher = "useFetcher", t.useViewTransitionState = "useViewTransitionState"
})(dP || (dP = {}));
var fP;
(function(t) {
  t.UseFetchers = "useFetchers", t.UseScrollRestoration = "useScrollRestoration"
})(fP || (fP = {}));

function HU(t, e) {
  let {
    target: n,
    replace: r,
    state: o,
    preventScrollReset: s,
    relative: i,
    unstable_viewTransition: a
  } = e === void 0 ? {} : e, c = Qx(), l = uc(), u = dA(t, {
    relative: i
  });
  return g.useCallback(d => {
    if (TU(d, n)) {
      d.preventDefault();
      let f = r !== void 0 ? r : Ya(l) === Ya(u);
      c(t, {
        replace: f,
        state: o,
        preventScrollReset: s,
        relative: i,
        unstable_viewTransition: a
      })
    }
  }, [l, c, u, r, o, n, t, s, i, a])
}

function Pve(t) {
  let e = g.useRef(ES(t)),
    n = g.useRef(!1),
    r = uc(),
    o = g.useMemo(() => $U(r.search, n.current ? null : e.current), [r.search]),
    s = Qx(),
    i = g.useCallback((a, c) => {
      const l = ES(typeof a == "function" ? a(o) : a);
      n.current = !0, s("?" + l, c)
    }, [s, o]);
  return [o, i]
}
const hA = Object.prototype.toString;

function $g(t) {
  switch (hA.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Vy(t, Error)
  }
}

function pA(t, e) {
  return hA.call(t) === `[object ${e}]`
}

function VU(t) {
  return pA(t, "String")
}

function gA(t) {
  return pA(t, "Object")
}

function WU(t) {
  return typeof Event < "u" && Vy(t, Event)
}

function KU(t) {
  return typeof Element < "u" && Vy(t, Element)
}

function GU(t) {
  return gA(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t
}

function YU(t) {
  return typeof t == "number" && t !== t
}

function Vy(t, e) {
  try {
    return t instanceof e
  } catch {
    return !1
  }
}

function $p(t) {
  return t && t.Math == Math ? t : void 0
}
const Sm = typeof globalThis == "object" && $p(globalThis) || typeof window == "object" && $p(window) || typeof self == "object" && $p(self) || typeof global == "object" && $p(global) || function() {
  return this
}() || {};

function qU(t, e, n) {
  const r = n || Sm,
    o = r.__SENTRY__ = r.__SENTRY__ || {};
  return o[t] || (o[t] = e())
}
const XU = 80;

function ZU(t, e = {}) {
  try {
    let n = t;
    const r = 5,
      o = [];
    let s = 0,
      i = 0;
    const a = " > ",
      c = a.length;
    let l;
    const u = Array.isArray(e) ? e : e.keyAttrs,
      d = !Array.isArray(e) && e.maxStringLength || XU;
    for (; n && s++ < r && (l = JU(n, u), !(l === "html" || s > 1 && i + o.length * c + l.length >= d));) o.push(l), i += l.length, n = n.parentNode;
    return o.reverse().join(a)
  } catch {
    return "<unknown>"
  }
}

function JU(t, e) {
  const n = t,
    r = [];
  let o, s, i, a, c;
  if (!n || !n.tagName) return "";
  r.push(n.tagName.toLowerCase());
  const l = e && e.length ? e.filter(d => n.getAttribute(d)).map(d => [d, n.getAttribute(d)]) : null;
  if (l && l.length) l.forEach(d => {
    r.push(`[${d[0]}="${d[1]}"]`)
  });
  else if (n.id && r.push(`#${n.id}`), o = n.className, o && VU(o))
    for (s = o.split(/\s+/), c = 0; c < s.length; c++) r.push(`.${s[c]}`);
  const u = ["type", "name", "title", "alt"];
  for (c = 0; c < u.length; c++) i = u[c], a = n.getAttribute(i), a && r.push(`[${i}="${a}"]`);
  return r.join("")
}
const QU = "Sentry Logger ",
  kS = ["debug", "info", "warn", "error", "log", "assert", "trace"];

function ez(t) {
  if (!("console" in Sm)) return t();
  const e = Sm.console,
    n = {};
  kS.forEach(r => {
    const o = e[r] && e[r].__sentry_original__;
    r in e && o && (n[r] = e[r], e[r] = o)
  });
  try {
    return t()
  } finally {
    Object.keys(n).forEach(r => {
      e[r] = n[r]
    })
  }
}

function hP() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0
    },
    disable: () => {
      t = !1
    }
  };
  return typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? kS.forEach(n => {
    e[n] = (...r) => {
      t && ez(() => {
        Sm.console[n](`${QU}[${n}]:`, ...r)
      })
    }
  }) : kS.forEach(n => {
    e[n] = () => {}
  }), e
}
let CS;
typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__ ? CS = qU("logger", hP) : CS = hP();

function tz(t, e, n) {
  Object.defineProperty(t, e, {
    value: n,
    writable: !0,
    configurable: !0
  })
}

function nz(t) {
  if ($g(t)) return {
    message: t.message,
    name: t.name,
    stack: t.stack,
    ...gP(t)
  };
  if (WU(t)) {
    const e = {
      type: t.type,
      target: pP(t.target),
      currentTarget: pP(t.currentTarget),
      ...gP(t)
    };
    return typeof CustomEvent < "u" && Vy(t, CustomEvent) && (e.detail = t.detail), e
  } else return t
}

function pP(t) {
  try {
    return KU(t) ? ZU(t) : Object.prototype.toString.call(t)
  } catch {
    return "<unknown>"
  }
}

function gP(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e
  } else return {}
}
const R0 = "<anonymous>";

function rz(t) {
  try {
    return !t || typeof t != "function" ? R0 : t.name || R0
  } catch {
    return R0
  }
}

function oz() {
  const t = typeof WeakSet == "function",
    e = t ? new WeakSet : [];

  function n(o) {
    if (t) return e.has(o) ? !0 : (e.add(o), !1);
    for (let s = 0; s < e.length; s++)
      if (e[s] === o) return !0;
    return e.push(o), !1
  }

  function r(o) {
    if (t) e.delete(o);
    else
      for (let s = 0; s < e.length; s++)
        if (e[s] === o) {
          e.splice(s, 1);
          break
        }
  }
  return [n, r]
}

function sz(t, e = 1 / 0, n = 1 / 0) {
  try {
    return PS("", t, e, n)
  } catch (r) {
    return {
      ERROR: `**non-serializable** (${r})`
    }
  }
}

function PS(t, e, n = 1 / 0, r = 1 / 0, o = oz()) {
  const [s, i] = o;
  if (e === null || ["number", "boolean", "string"].includes(typeof e) && !YU(e)) return e;
  const a = iz(t, e);
  if (!a.startsWith("[object ")) return a;
  if (e.__sentry_skip_normalization__) return e;
  if (n === 0) return a.replace("object ", "");
  if (s(e)) return "[Circular ~]";
  const c = e;
  if (c && typeof c.toJSON == "function") try {
    const f = c.toJSON();
    return PS("", f, n - 1, r, o)
  } catch {}
  const l = Array.isArray(e) ? [] : {};
  let u = 0;
  const d = nz(e);
  for (const f in d) {
    if (!Object.prototype.hasOwnProperty.call(d, f)) continue;
    if (u >= r) {
      l[f] = "[MaxProperties ~]";
      break
    }
    const h = d[f];
    l[f] = PS(f, h, n - 1, r, o), u++
  }
  return i(e), l
}

function iz(t, e) {
  try {
    return t === "domain" && e && typeof e == "object" && e._events ? "[Domain]" : t === "domainEmitter" ? "[DomainEmitter]" : typeof global < "u" && e === global ? "[Global]" : typeof window < "u" && e === window ? "[Window]" : typeof document < "u" && e === document ? "[Document]" : GU(e) ? "[SyntheticEvent]" : typeof e == "number" && e !== e ? "[NaN]" : e === void 0 ? "[undefined]" : typeof e == "function" ? `[Function: ${rz(e)}]` : typeof e == "symbol" ? `[${String(e)}]` : typeof e == "bigint" ? `[BigInt: ${String(e)}]` : `[object ${Object.getPrototypeOf(e).constructor.name}]`
  } catch (n) {
    return `**non-serializable** (${n})`
  }
}
class jl {
  static __initStatic() {
    this.id = "ExtraErrorData"
  }
  __init() {
    this.name = jl.id
  }
  constructor(e) {
    jl.prototype.__init.call(this), this._options = {
      depth: 3,
      ...e
    }
  }
  setupOnce(e, n) {
    e((r, o) => {
      const s = n().getIntegration(jl);
      return s ? s.enhanceEventWithErrorData(r, o) : r
    })
  }
  enhanceEventWithErrorData(e, n = {}) {
    if (!n.originalException || !$g(n.originalException)) return e;
    const r = n.originalException.name || n.originalException.constructor.name,
      o = this._extractErrorData(n.originalException);
    if (o) {
      const s = {
          ...e.contexts
        },
        i = sz(o, this._options.depth);
      return gA(i) && (tz(i, "__sentry_skip_normalization__", !0), s[r] = i), {
        ...e,
        contexts: s
      }
    }
    return e
  }
  _extractErrorData(e) {
    try {
      const n = ["name", "message", "stack", "line", "column", "fileName", "lineNumber", "columnNumber", "toJSON"],
        r = {};
      for (const o of Object.keys(e)) {
        if (n.indexOf(o) !== -1) continue;
        const s = e[o];
        r[o] = $g(s) ? s.toString() : s
      }
      if (typeof e.toJSON == "function") {
        const o = e.toJSON();
        for (const s of Object.keys(o)) {
          const i = o[s];
          r[s] = $g(i) ? i.toString() : i
        }
      }
      return r
    } catch (n) {
      (typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__) && CS.error("Unable to extract extra data from the Error object:", n)
    }
    return null
  }
}
jl.__initStatic();
const mP = 8;
class mA {
  constructor() {
    P(this, "arraySize", 0);
    P(this, "array", Array(mP));
    P(this, "set", null)
  }
  get isEmpty() {
    if (this.array) return this.arraySize === 0;
    if (this.set) return this.set.size === 0;
    throw new Error("no set or array")
  }
  add(e) {
    if (this.array) return this.array.indexOf(e) !== -1 ? !1 : this.arraySize < mP ? (this.array[this.arraySize] = e, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(e), !0);
    if (this.set) return this.set.has(e) ? !1 : (this.set.add(e), !0);
    throw new Error("no set or array")
  }
  remove(e) {
    if (this.array) {
      const n = this.array.indexOf(e);
      return n === -1 ? !1 : (this.array[n] = void 0, this.arraySize--, n !== this.arraySize && (this.array[n] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0)
    }
    if (this.set) return this.set.has(e) ? (this.set.delete(e), !0) : !1;
    throw new Error("no set or array")
  }
  visit(e) {
    if (this.array) {
      for (let n = 0; n < this.arraySize; n++) {
        const r = this.array[n];
        typeof r < "u" && e(r)
      }
      return
    }
    if (this.set) {
      this.set.forEach(e);
      return
    }
    throw new Error("no set or array")
  }
}
const Fr = Symbol("RESET_VALUE");
class yA {
  constructor(e) {
    P(this, "index", 0);
    P(this, "buffer");
    this.capacity = e, this.buffer = new Array(e)
  }
  pushEntry(e, n, r) {
    if (r !== void 0) {
      if (r === Fr) {
        this.clear();
        return
      }
      this.buffer[this.index] = [e, n, r], this.index = (this.index + 1) % this.capacity
    }
  }
  clear() {
    this.index = 0, this.buffer.fill(void 0)
  }
  getChangesSince(e) {
    const {
      index: n,
      capacity: r,
      buffer: o
    } = this;
    for (let s = 0; s < r; s++) {
      const i = (n - 1 + r - s) % r,
        a = o[i];
      if (!a) return Fr;
      const [c, l] = a;
      if (s === 0 && e >= l) return [];
      if (c <= e && e < l) {
        const u = s + 1,
          d = new Array(u);
        for (let f = 0; f < u; f++) d[f] = o[(i + f) % r][2];
        return d
      }
    }
    return Fr
  }
}

function vA(t) {
  return t && typeof t == "object" && "parents" in t
}

function bA(t) {
  for (let e = 0, n = t.parents.length; e < n; e++)
    if (t.parents[e].__unsafe__getWithoutCapture(), t.parents[e].lastChangedEpoch !== t.parentEpochs[e]) return !0;
  return !1
}
const _m = (t, e) => {
    if (t.children.remove(e) && t.children.isEmpty && vA(t))
      for (let n = 0, r = t.parents.length; n < r; n++) _m(t.parents[n], t)
  },
  o1 = (t, e) => {
    if (t.children.add(e) && vA(t))
      for (let n = 0, r = t.parents.length; n < r; n++) o1(t.parents[n], t)
  };

function wA(t, e) {
  return t === e || Object.is(t, e) || !!(t && e && typeof t.equals == "function" && t.equals(e))
}
const Ns = Object.freeze([]),
  yP = Symbol.for("__@tldraw/state__"),
  vP = globalThis;
vP[yP] ? console.error('Multiple versions of @tldraw/state detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of @tldraw/state is loaded.') : vP[yP] = !0;
class az {
  constructor(e, n) {
    P(this, "offset", 0);
    P(this, "numNewParents", 0);
    P(this, "maybeRemoved");
    this.below = e, this.child = n
  }
}
let ft = null;

function SA(t) {
  ft = new az(ft, t)
}

function _A() {
  const t = ft;
  if (ft = t.below, t.numNewParents > 0 || t.offset !== t.child.parents.length) {
    for (let n = t.offset; n < t.child.parents.length; n++) {
      const r = t.child.parents[n];
      t.child.parents.indexOf(r) >= t.offset && _m(r, t.child)
    }
    if (t.child.parents.length = t.offset, t.child.parentEpochs.length = t.offset, ft != null && ft.maybeRemoved)
      for (let n = 0; n < ft.maybeRemoved.length; n++) {
        const r = ft.maybeRemoved[n];
        t.child.parents.indexOf(r) === -1 && _m(r, t.child)
      }
  }
}

function TS(t) {
  if (ft) {
    const e = ft.child.parents.indexOf(t);
    if (e < 0 && (ft.numNewParents++, ft.child.isActivelyListening && o1(t, ft.child)), e < 0 || e >= ft.offset) {
      if (e !== ft.offset && e > 0) {
        const n = ft.child.parents[ft.offset];
        ft.maybeRemoved ? ft.maybeRemoved.indexOf(n) === -1 && ft.maybeRemoved.push(n) : ft.maybeRemoved = [n]
      }
      ft.child.parents[ft.offset] = t, ft.child.parentEpochs[ft.offset] = t.lastChangedEpoch, ft.offset++
    }
  }
}

function Tve() {
  const t = ft == null ? void 0 : ft.child;
  if (!t) throw new Error("whyAmIRunning() called outside of a reactive context");
  const e = [];
  for (let n = 0; n < t.parents.length; n++) {
    const r = t.parents[n];
    r.lastChangedEpoch > t.parentEpochs[n] && e.push(r)
  }
  if (e.length === 0) console.log(t.name, "is running but none of the parents changed");
  else {
    console.log(t.name, "is running because:");
    for (const n of e) console.log("	", n.name, "changed =>", n.__unsafe__getWithoutCapture())
  }
}
const $a = -1;
let Cn = $a + 1,
  A0 = !1;

function cz() {
  Cn++
}
class lz {
  constructor(e) {
    P(this, "initialAtomValues", new Map);
    this.parent = e
  }
  get isRoot() {
    return this.parent === null
  }
  commit() {
    if (this.isRoot) {
      const e = this.initialAtomValues;
      this.initialAtomValues = new Map, xA(e.keys())
    } else this.initialAtomValues.forEach((e, n) => {
      this.parent.initialAtomValues.has(n) || this.parent.initialAtomValues.set(n, e)
    })
  }
  abort() {
    Cn++, this.initialAtomValues.forEach((e, n) => {
      var r;
      n.set(e), (r = n.historyBuffer) == null || r.clear()
    }), this.commit()
  }
}

function xA(t) {
  if (A0) throw new Error("cannot change atoms during reaction cycle");
  try {
    A0 = !0;
    const e = new Set,
      n = r => {
        r.lastTraversedEpoch !== Cn && (r.lastTraversedEpoch = Cn, "maybeScheduleEffect" in r ? e.add(r) : r.children.visit(n))
      };
    for (const r of t) r.children.visit(n);
    for (const r of e) r.maybeScheduleEffect()
  } finally {
    A0 = !1
  }
}

function uz(t, e) {
  Pi ? Pi.initialAtomValues.has(t) || Pi.initialAtomValues.set(t, e) : xA([t])
}
let Pi = null;

function dz(t) {
  const e = new lz(Pi);
  Pi = e;
  try {
    let n = !1;
    const r = t(() => n = !0);
    return n ? e.abort() : e.commit(), r
  } catch (n) {
    throw e.abort(), n
  } finally {
    Pi = Pi.parent
  }
}

function Zr(t) {
  return Pi ? t() : dz(t)
}
var Z$;
typeof process < "u" && ((Z$ = process.env) == null || Z$.NODE_ENV);
class fz {
  constructor(e, n, r) {
    P(this, "isEqual");
    P(this, "computeDiff");
    P(this, "lastChangedEpoch", Cn);
    P(this, "children", new mA);
    P(this, "historyBuffer");
    this.name = e, this.current = n, this.isEqual = (r == null ? void 0 : r.isEqual) ?? null, r && (r.historyLength && (this.historyBuffer = new yA(r.historyLength)), this.computeDiff = r.computeDiff)
  }
  __unsafe__getWithoutCapture() {
    return this.current
  }
  get() {
    return TS(this), this.current
  }
  get value() {
    return this.get()
  }
  set(e, n) {
    var o, s;
    if (((o = this.isEqual) == null ? void 0 : o.call(this, this.current, e)) ?? wA(this.current, e)) return this.current;
    cz(), this.historyBuffer && this.historyBuffer.pushEntry(this.lastChangedEpoch, Cn, n ?? ((s = this.computeDiff) == null ? void 0 : s.call(this, this.current, e, this.lastChangedEpoch, Cn)) ?? Fr), this.lastChangedEpoch = Cn;
    const r = this.current;
    return this.current = e, uz(this, r), e
  }
  update(e) {
    return this.set(e(this.current))
  }
  getDiffSince(e) {
    var n;
    return TS(this), e >= this.lastChangedEpoch ? Ns : ((n = this.historyBuffer) == null ? void 0 : n.getChangesSince(e)) ?? Fr
  }
}

function tr(t, e, n) {
  return new fz(t, e, n)
}
const $S = Symbol("UNINITIALIZED"),
  Dl = t => t === $S;
class IS {
  constructor(e, n) {
    this.value = e, this.diff = n
  }
}

function Td(t, e) {
  return new IS(t, e)
}
class s1 {
  constructor(e, n, r) {
    P(this, "lastChangedEpoch", $a);
    P(this, "lastTraversedEpoch", $a);
    P(this, "lastCheckedEpoch", $a);
    P(this, "parents", []);
    P(this, "parentEpochs", []);
    P(this, "children", new mA);
    P(this, "historyBuffer");
    P(this, "state", $S);
    P(this, "computeDiff");
    P(this, "isEqual");
    this.name = e, this.derive = n, r != null && r.historyLength && (this.historyBuffer = new yA(r.historyLength)), this.computeDiff = r == null ? void 0 : r.computeDiff, this.isEqual = (r == null ? void 0 : r.isEqual) ?? wA
  }
  get isActivelyListening() {
    return !this.children.isEmpty
  }
  __unsafe__getWithoutCapture() {
    var n;
    const e = this.lastChangedEpoch === $a;
    if (!e && (this.lastCheckedEpoch === Cn || !bA(this))) return this.lastCheckedEpoch = Cn, this.state;
    try {
      SA(this);
      const r = this.derive(this.state, this.lastCheckedEpoch),
        o = r instanceof IS ? r.value : r;
      if (this.state === $S || !this.isEqual(o, this.state)) {
        if (this.historyBuffer && !e) {
          const s = r instanceof IS ? r.diff : void 0;
          this.historyBuffer.pushEntry(this.lastChangedEpoch, Cn, s ?? ((n = this.computeDiff) == null ? void 0 : n.call(this, this.state, o, this.lastCheckedEpoch, Cn)) ?? Fr)
        }
        this.lastChangedEpoch = Cn, this.state = o
      }
      return this.lastCheckedEpoch = Cn, this.state
    } finally {
      _A()
    }
  }
  get() {
    const e = this.__unsafe__getWithoutCapture();
    return TS(this), e
  }
  get value() {
    return this.get()
  }
  getDiffSince(e) {
    var n;
    return this.get(), e >= this.lastChangedEpoch ? Ns : ((n = this.historyBuffer) == null ? void 0 : n.getChangesSince(e)) ?? Fr
  }
}

function hz(t = {}, e, n, r) {
  const o = r.value,
    s = Symbol.for("__@tldraw/state__computed__" + n);
  return r.value = function() {
    let i = this[s];
    return i || (i = new s1(n, o.bind(this), t), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: i
    })), i.get()
  }, r.value[gz] = !0, r
}

function bP(t = {}, e, n, r) {
  return r.get ? pz(t, e, n, r) : hz(t, e, n, r)
}

function pz(t = {}, e, n, r) {
  const o = r.get,
    s = Symbol.for("__@tldraw/state__computed__" + n);
  return r.get = function() {
    let i = this[s];
    return i || (i = new s1(n, o.bind(this), t), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: i
    })), i.get()
  }, r
}
const gz = "@@__isComputedMethod__@@";

function Q() {
  if (arguments.length === 1) {
    const t = arguments[0];
    return (e, n, r) => bP(t, e, n, r)
  } else return typeof arguments[0] == "string" ? new s1(arguments[0], arguments[1], arguments[2]) : bP(void 0, arguments[0], arguments[1], arguments[2])
}
class vh {
  constructor(e, n, r) {
    P(this, "_isActivelyListening", !1);
    P(this, "lastTraversedEpoch", $a);
    P(this, "lastReactedEpoch", $a);
    P(this, "_scheduleCount", 0);
    P(this, "parentEpochs", []);
    P(this, "parents", []);
    P(this, "_scheduleEffect");
    P(this, "maybeExecute", () => {
      this._isActivelyListening && this.execute()
    });
    this.name = e, this.runEffect = n, this._scheduleEffect = r == null ? void 0 : r.scheduleEffect
  }
  get isActivelyListening() {
    return this._isActivelyListening
  }
  get scheduleCount() {
    return this._scheduleCount
  }
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== Cn) {
      if (this.parents.length && !bA(this)) {
        this.lastReactedEpoch = Cn;
        return
      }
      this.scheduleEffect()
    }
  }
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute()
  }
  attach() {
    this._isActivelyListening = !0;
    for (let e = 0, n = this.parents.length; e < n; e++) o1(this.parents[e], this)
  }
  detach() {
    this._isActivelyListening = !1;
    for (let e = 0, n = this.parents.length; e < n; e++) _m(this.parents[e], this)
  }
  execute() {
    try {
      SA(this);
      const e = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = Cn, e
    } finally {
      _A()
    }
  }
}

function bh(t, e, n) {
  const r = new vh(t, e, n);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach()
  }
}

function mz(t, e, n) {
  const r = new vh(t, e, n);
  return {
    scheduler: r,
    start: o => {
      const s = (o == null ? void 0 : o.force) ?? !1;
      r.attach(), s ? r.scheduleEffect() : r.maybeScheduleEffect()
    },
    stop: () => {
      r.detach()
    }
  }
}

function Wy(t, e) {
  const n = se.useRef(e);
  n.current = e;
  const [r, o, s] = se.useMemo(() => {
    let i = null;
    const a = u => (i = u, () => {
        i = null
      }),
      c = new vh(`useStateTracking(${t})`, () => {
        var u;
        return (u = n.current) == null ? void 0 : u.call(n)
      }, {
        scheduleEffect() {
          i == null || i()
        }
      });
    return [c, a, () => c.scheduleCount]
  }, [t]);
  return se.useSyncExternalStore(o, s, s), se.useEffect(() => (r.attach(), r.maybeScheduleEffect(), () => {
    r.detach()
  }), [r]), r.execute()
}
const wP = {
    apply(t, e, n) {
      return Wy(t.displayName ?? t.name ?? "tracked(???)", () => t.apply(e, n))
    }
  },
  yz = Symbol.for("react.memo"),
  vz = Symbol.for("react.forward_ref");

function pt(t) {
  let e = null;
  const n = t.$$typeof;
  return n === yz && (t = t.type, e = t.compare), n === vz ? g.memo(g.forwardRef(new Proxy(t.render, wP))) : g.memo(new Proxy(t, wP), e)
}

function EA() {
  const t = arguments[0],
    e = arguments[1],
    n = arguments.length === 3 ? void 0 : arguments[2],
    r = arguments.length === 3 ? arguments[2] : arguments[3];
  return g.useMemo(() => Q(`useComputed(${t})`, e, n), r)
}

function ja(t, e, n = Ns) {
  g.useEffect(() => {
    const r = new vh(t, e);
    return r.attach(), r.execute(), () => {
      r.detach()
    }
  }, n)
}

function te() {
  const t = arguments,
    e = t.length === 3 ? t[2] : [t[0]],
    n = t.length === 3 ? t[0] : `useValue(${t[0].name})`,
    r = g.useRef(!0);
  r.current = !0;
  const o = g.useMemo(() => t.length === 1 ? t[0] : Q(n, () => {
    if (r.current) return t[1]();
    try {
      return t[1]()
    } catch {
      return {}
    }
  }), e);
  try {
    const {
      subscribe: s,
      getSnapshot: i
    } = g.useMemo(() => ({
      subscribe: a => bh(`useValue(${n})`, () => {
        o.get(), a()
      }),
      getSnapshot: () => o.get()
    }), [o]);
    return g.useSyncExternalStore(s, i, i)
  } finally {
    r.current = !1
  }
}
class Ig {
  constructor(e) {
    P(this, "nextValue");
    P(this, "diff");
    this.previousValue = e
  }
  get() {
    var r, o, s, i;
    const e = ((o = (r = this.diff) == null ? void 0 : r.removed) == null ? void 0 : o.size) ?? 0,
      n = ((i = (s = this.diff) == null ? void 0 : s.added) == null ? void 0 : i.size) ?? 0;
    if (!(e === 0 && n === 0)) return {
      value: this.nextValue,
      diff: this.diff
    }
  }
  _add(e, n) {
    var r, o;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.add(e), this.diff ?? (this.diff = {}), n ? (r = this.diff.removed) == null || r.delete(e) : ((o = this.diff).added ?? (o.added = new Set), this.diff.added.add(e))
  }
  add(e) {
    var o, s, i;
    const n = this.previousValue.has(e);
    if (n) return ((s = (o = this.diff) == null ? void 0 : o.removed) == null ? void 0 : s.has(e)) ? this._add(e, n) : void 0;
    (i = this.nextValue) != null && i.has(e) || this._add(e, n)
  }
  _remove(e, n) {
    var r, o;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.delete(e), this.diff ?? (this.diff = {}), n ? ((r = this.diff).removed ?? (r.removed = new Set), this.diff.removed.add(e)) : (o = this.diff.added) == null || o.delete(e)
  }
  remove(e) {
    var o, s, i, a;
    const n = this.previousValue.has(e);
    if (!n) return ((s = (o = this.diff) == null ? void 0 : o.added) == null ? void 0 : s.has(e)) ? this._remove(e, n) : void 0;
    (a = (i = this.diff) == null ? void 0 : i.removed) != null && a.has(e) || this._remove(e, n)
  }
}

function $ve(t, e) {
  return t.map((n, r) => t[(r + e) % t.length])
}

function xm(t, e) {
  const n = [];
  e: for (const r of t) {
    for (const o of n)
      if (e ? e(r, o) : r === o) continue e;
    n.push(r)
  }
  return n
}

function Fe(t) {
  return t.filter(e => e != null)
}

function bz(t) {
  return t[t.length - 1]
}

function wz(t, e) {
  let n, r = 1 / 0;
  for (const o of t) {
    const s = e(o);
    s < r && (n = o, r = s)
  }
  return n
}

function Sz(t, e) {
  const n = [],
    r = [];
  for (const o of t) e(o) ? n.push(o) : r.push(o);
  return [n, r]
}

function Ive(t, e) {
  let n, r;
  return function(...o) {
    return n || (n = !0, setTimeout(() => n = !1, e), r = t(...o)), r
  }
}

function kA(t) {
  const e = (...n) => {
    try {
      return t(...n)
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, e), r
    }
  };
  return e
}

function Ove() {}
const qe = {
  ok(t) {
    return {
      ok: !0,
      value: t
    }
  },
  err(t) {
    return {
      ok: !1,
      error: t
    }
  }
};

function bu(t, e) {
  const n = e && t && typeof t == "object" && e in t ? t[e] : t;
  throw new Error(`Unknown switch case ${n}`)
}
const Xa = kA((t, e) => {
    if (!t) throw new Error(e || "Assertion Error")
  }),
  Nl = kA((t, e) => {
    if (t == null) throw new Error(e ?? "value must be defined");
    return t
  });

function Rve() {
  let t, e;
  const n = new Promise((r, o) => {
    t = r, e = o
  });
  return Object.assign(n, {
    resolve: t,
    reject: e
  })
}

function CA(t, e) {
  let n;
  const r = (...o) => (n || (n = {}, n.promise = new Promise((s, i) => {
    n.resolve = s, n.reject = i
  })), clearTimeout(n.timeout), n.latestArgs = o, n.timeout = setTimeout(() => {
    const s = n;
    n = void 0;
    try {
      s.resolve(t(...s.latestArgs))
    } catch (i) {
      s.reject(i)
    }
  }, e), n.promise);
  return r.cancel = () => {
    n && clearTimeout(n.timeout)
  }, r
}
const OS = new WeakMap;

function i1(t, e) {
  if (typeof t != "object" || t === null) return;
  let n = OS.get(t);
  n || (n = {
    tags: {},
    extras: {}
  }, OS.set(t, n)), e.tags && (n.tags = {
    ...n.tags,
    ...e.tags
  }), e.extras && (n.extras = {
    ...n.extras,
    ...e.extras
  })
}

function _z(t) {
  return OS.get(t) ?? {
    tags: {},
    extras: {}
  }
}
class xz {
  static async base64ToFile(e) {
    return fetch(e).then(function(n) {
      return n.arrayBuffer()
    })
  }
  static async fileToBase64(e) {
    return await new Promise((n, r) => {
      if (e) {
        const o = new FileReader;
        o.readAsDataURL(e), o.onload = () => n(o.result), o.onerror = s => r(s), o.onabort = s => r(s)
      }
    })
  }
}

function PA(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) e = (e << 5) - e + t.charCodeAt(n), e |= 0;
  return e + ""
}

function Ave(t) {
  return PA(JSON.stringify(t))
}

function Mve(t) {
  const e = t.split("");
  return e.push(...e.splice(0, Math.round(e.length / 5))), e.push(...e.splice(0, Math.round(e.length / 4))), e.push(...e.splice(0, Math.round(e.length / 3))), e.push(...e.splice(0, Math.round(e.length / 2))), e.reverse().map(n => +n ? +n < 5 ? 5 + +n : +n > 5 ? +n - 5 : n : n).join("")
}
let RS = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
typeof Int32Array < "u" && (RS = new Int32Array(RS));
const Ez = (t, e) => {
    let n = e === 0 ? 0 : ~~e ^ -1;
    for (let r = 0; r < t.length; r++) n = RS[(n ^ t[r]) & 255] ^ n >>> 8;
    return n ^ -1
  },
  SP = 4,
  _P = 4;
class Sa {
  static isPng(e, n) {
    return e.getUint8(n + 0) === 137 && e.getUint8(n + 1) === 80 && e.getUint8(n + 2) === 78 && e.getUint8(n + 3) === 71 && e.getUint8(n + 4) === 13 && e.getUint8(n + 5) === 10 && e.getUint8(n + 6) === 26 && e.getUint8(n + 7) === 10
  }
  static getChunkType(e, n) {
    return [String.fromCharCode(e.getUint8(n)), String.fromCharCode(e.getUint8(n + 1)), String.fromCharCode(e.getUint8(n + 2)), String.fromCharCode(e.getUint8(n + 3))].join("")
  }
  static readChunks(e, n = 0) {
    const r = {};
    if (!Sa.isPng(e, n)) throw new Error("Not a PNG");
    for (n += 8; n <= e.buffer.byteLength;) {
      const o = n,
        s = e.getInt32(n);
      n += 4;
      const i = Sa.getChunkType(e, n);
      if (i === "IDAT" && r[i]) {
        n += s + SP + _P;
        continue
      }
      if (i === "IEND") break;
      r[i] = {
        start: o,
        dataOffset: n + 4,
        size: s
      }, n += s + SP + _P
    }
    return r
  }
  static parsePhys(e, n) {
    return {
      ppux: e.getUint32(n),
      ppuy: e.getUint32(n + 4),
      unit: e.getUint8(n + 4)
    }
  }
  static findChunk(e, n) {
    return Sa.readChunks(e)[n]
  }
  static setPhysChunk(e, n = 1, r) {
    let o = 46,
      s = 0;
    const i = Sa.findChunk(e, "pHYs");
    i && (o = i.start, s = i.size);
    const a = Sa.findChunk(e, "IDAT");
    a && (o = a.start, s = 0);
    const c = new ArrayBuffer(21),
      l = new DataView(c);
    l.setUint32(0, 9), l.setUint8(4, "p".charCodeAt(0)), l.setUint8(5, "H".charCodeAt(0)), l.setUint8(6, "Y".charCodeAt(0)), l.setUint8(7, "s".charCodeAt(0));
    const u = 2835.5;
    l.setInt32(8, u * n), l.setInt32(12, u * n), l.setInt8(16, 1);
    const d = new Uint8Array(c.slice(4, 17));
    l.setInt32(17, Ez(d));
    const f = e.buffer.slice(0, o),
      h = e.buffer.slice(o + s);
    return new Blob([f, c, h], r)
  }
}

function jve(t, e, n) {
  return t + (e - t) * n
}

function a1(t = "") {
  let e = 0,
    n = 0,
    r = 0,
    o = 0;

  function s() {
    const i = e ^ e << 11;
    return e = n, n = r, r = o, o ^= (o >>> 19 ^ i ^ i >>> 8) >>> 0, o / 4294967296 * 2
  }
  for (let i = 0; i < t.length + 64; i++) e ^= t.charCodeAt(i) | 0, s();
  return s
}

function Em(t, e, n, r = !1) {
  const [o, s] = e, [i, a] = n, c = i + (t - o) / (s - o) * (a - i);
  return r ? i < a ? Math.max(Math.min(c, a), i) : Math.max(Math.min(c, i), a) : c
}

function Ky(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e)
}

function Da(t, e) {
  if (Ky(t, e)) return t[e]
}

function Ni(t) {
  if (!t) return t;
  if (Array.isArray(t)) {
    const e = [],
      n = t.length;
    for (let r = 0; r < n; r++) e.push(Ni(t[r]));
    return e
  } else if (typeof t == "object") {
    const e = Object.keys(t),
      n = e.length,
      r = {};
    for (let o = 0; o < n; o++) {
      const s = e[o];
      r[s] = Ni(t[s])
    }
    return r
  }
  return t
}

function xP(t) {
  return Object.keys(t)
}

function Gt(t) {
  return Object.values(t)
}

function Ls(t) {
  return Object.entries(t)
}

function TA(t) {
  return Object.fromEntries(t)
}

function M0(t, e) {
  const n = {};
  let r = !1;
  for (const [o, s] of Ls(t)) e(o, s) ? n[o] = s : r = !0;
  return r ? n : t
}

function EP(t, e) {
  const n = {};
  for (const [r, o] of Ls(t)) {
    const s = e(r, o);
    n[r] = s
  }
  return n
}
const $A = () => typeof process < "u" && !1,
  eu = [],
  kz = () => {
    const t = eu.splice(0, eu.length);
    for (const e of t) e()
  };
let j0;

function IA() {
  j0 || (j0 = requestAnimationFrame(() => {
    j0 = void 0, kz()
  }))
}

function Dve(t) {
  return $A() ? t : () => {
    eu.includes(t) || (eu.push(t), IA())
  }
}

function Cz(t) {
  if ($A()) return t();
  eu.includes(t) || (eu.push(t), IA())
}

function Pz(t, e) {
  return t.id > e.id ? 1 : -1
}
const Tz = new RegExp(/^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i);

function AS(t) {
  return Tz.test(t)
}

function Nve(t) {
  return t !== void 0
}

function $z(t) {
  return t !== null
}

function Lve(t) {
  return t != null
}
const Na = typeof window < "u" && window.structuredClone ? window.structuredClone : t => t && JSON.parse(JSON.stringify(t));
class c1 {
  constructor(e, n) {
    P(this, "createDefaultProperties");
    P(this, "migrations");
    P(this, "validator");
    P(this, "scope");
    P(this, "isInstance", e => (e == null ? void 0 : e.typeName) === this.typeName);
    this.typeName = e, this.createDefaultProperties = n.createDefaultProperties, this.migrations = n.migrations, this.validator = n.validator ?? {
      validate: r => r
    }, this.scope = n.scope ?? "document"
  }
  create(e) {
    const n = {
      ...this.createDefaultProperties(),
      id: this.createId()
    };
    for (const [r, o] of Object.entries(e)) o !== void 0 && (n[r] = o);
    return n.typeName = this.typeName, n
  }
  clone(e) {
    return {
      ...Na(e),
      id: this.createId()
    }
  }
  createId(e) {
    return this.typeName + ":" + (e ?? Ui())
  }
  createCustomId(e) {
    return this.typeName + ":" + e
  }
  parseId(e) {
    if (!this.isId(e)) throw new Error(`ID "${e}" is not a valid ID for type "${this.typeName}"`);
    return e.slice(this.typeName.length + 1)
  }
  isId(e) {
    if (!e) return !1;
    for (let n = 0; n < this.typeName.length; n++)
      if (e[n] !== this.typeName[n]) return !1;
    return e[this.typeName.length] === ":"
  }
  withDefaultProperties(e) {
    return new c1(this.typeName, {
      createDefaultProperties: e,
      migrations: this.migrations,
      validator: this.validator,
      scope: this.scope
    })
  }
  validate(e) {
    return this.validator.validate(e)
  }
}

function _r(t, e) {
  return new c1(t, {
    createDefaultProperties: () => ({}),
    migrations: e.migrations ?? {
      currentVersion: 0,
      firstVersion: 0,
      migrators: {}
    },
    validator: e.validator,
    scope: e.scope
  })
}

function Fve(t, e) {
  if (!t || !e.isId(t)) throw new Error(`string ${JSON.stringify(t)} is not a valid ${e.typeName} id`)
}
class kP {
  constructor() {
    P(this, "items", new WeakMap)
  }
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e)
  }
}
var km = {
  exports: {}
};
km.exports;
(function(t, e) {
  var n = 200,
    r = "__lodash_hash_undefined__",
    o = 1,
    s = 2,
    i = 9007199254740991,
    a = "[object Arguments]",
    c = "[object Array]",
    l = "[object AsyncFunction]",
    u = "[object Boolean]",
    d = "[object Date]",
    f = "[object Error]",
    h = "[object Function]",
    m = "[object GeneratorFunction]",
    p = "[object Map]",
    b = "[object Number]",
    w = "[object Null]",
    v = "[object Object]",
    _ = "[object Promise]",
    S = "[object Proxy]",
    x = "[object RegExp]",
    E = "[object Set]",
    k = "[object String]",
    C = "[object Symbol]",
    $ = "[object Undefined]",
    I = "[object WeakMap]",
    R = "[object ArrayBuffer]",
    M = "[object DataView]",
    j = "[object Float32Array]",
    A = "[object Float64Array]",
    D = "[object Int8Array]",
    N = "[object Int16Array]",
    q = "[object Int32Array]",
    F = "[object Uint8Array]",
    B = "[object Uint8ClampedArray]",
    V = "[object Uint16Array]",
    J = "[object Uint32Array]",
    ee = /[\\^$.*+?()[\]{}|]/g,
    ye = /^\[object .+?Constructor\]$/,
    ge = /^(?:0|[1-9]\d*)$/,
    ce = {};
  ce[j] = ce[A] = ce[D] = ce[N] = ce[q] = ce[F] = ce[B] = ce[V] = ce[J] = !0, ce[a] = ce[c] = ce[R] = ce[u] = ce[M] = ce[d] = ce[f] = ce[h] = ce[p] = ce[b] = ce[v] = ce[x] = ce[E] = ce[k] = ce[I] = !1;
  var Ce = typeof hn == "object" && hn && hn.Object === Object && hn,
    oe = typeof self == "object" && self && self.Object === Object && self,
    pe = Ce || oe || Function("return this")(),
    _e = e && !e.nodeType && e,
    xe = _e && !0 && t && !t.nodeType && t,
    Me = xe && xe.exports === _e,
    Le = Me && Ce.process,
    gt = function() {
      try {
        return Le && Le.binding && Le.binding("util")
      } catch {}
    }(),
    Ze = gt && gt.isTypedArray;

  function xt(O, L) {
    for (var Z = -1, fe = O == null ? 0 : O.length, Tt = 0, He = []; ++Z < fe;) {
      var Kt = O[Z];
      L(Kt, Z, O) && (He[Tt++] = Kt)
    }
    return He
  }

  function An(O, L) {
    for (var Z = -1, fe = L.length, Tt = O.length; ++Z < fe;) O[Tt + Z] = L[Z];
    return O
  }

  function ln(O, L) {
    for (var Z = -1, fe = O == null ? 0 : O.length; ++Z < fe;)
      if (L(O[Z], Z, O)) return !0;
    return !1
  }

  function bn(O, L) {
    for (var Z = -1, fe = Array(O); ++Z < O;) fe[Z] = L(Z);
    return fe
  }

  function Go(O) {
    return function(L) {
      return O(L)
    }
  }

  function Zn(O, L) {
    return O.has(L)
  }

  function fo(O, L) {
    return O == null ? void 0 : O[L]
  }

  function Du(O) {
    var L = -1,
      Z = Array(O.size);
    return O.forEach(function(fe, Tt) {
      Z[++L] = [Tt, fe]
    }), Z
  }

  function Yo(O, L) {
    return function(Z) {
      return O(L(Z))
    }
  }

  function Wh(O) {
    var L = -1,
      Z = Array(O.size);
    return O.forEach(function(fe) {
      Z[++L] = fe
    }), Z
  }
  var Kh = Array.prototype,
    Gh = Function.prototype,
    wc = Object.prototype,
    Sc = pe["__core-js_shared__"],
    ca = Gh.toString,
    kr = wc.hasOwnProperty,
    _c = function() {
      var O = /[^.]+$/.exec(Sc && Sc.keys && Sc.keys.IE_PROTO || "");
      return O ? "Symbol(src)_1." + O : ""
    }(),
    Yh = wc.toString,
    qh = RegExp("^" + ca.call(kr).replace(ee, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
    Xh = Me ? pe.Buffer : void 0,
    la = pe.Symbol,
    Zh = pe.Uint8Array,
    z = wc.propertyIsEnumerable,
    W = Kh.splice,
    X = la ? la.toStringTag : void 0,
    le = Object.getOwnPropertySymbols,
    De = Xh ? Xh.isBuffer : void 0,
    je = Yo(Object.keys, Object),
    Ne = kc(pe, "DataView"),
    Se = kc(pe, "Map"),
    be = kc(pe, "Promise"),
    lt = kc(pe, "Set"),
    St = kc(pe, "WeakMap"),
    Ge = kc(Object, "create"),
    mt = fa(Ne),
    Lt = fa(Se),
    Ss = fa(be),
    _s = fa(lt),
    ua = fa(St),
    xc = la ? la.prototype : void 0,
    Cr = xc ? xc.valueOf : void 0;

  function wn(O) {
    var L = -1,
      Z = O == null ? 0 : O.length;
    for (this.clear(); ++L < Z;) {
      var fe = O[L];
      this.set(fe[0], fe[1])
    }
  }

  function Ec() {
    this.__data__ = Ge ? Ge(null) : {}, this.size = 0
  }

  function Nu(O) {
    var L = this.has(O) && delete this.__data__[O];
    return this.size -= L ? 1 : 0, L
  }

  function Lu(O) {
    var L = this.__data__;
    if (Ge) {
      var Z = L[O];
      return Z === r ? void 0 : Z
    }
    return kr.call(L, O) ? L[O] : void 0
  }

  function Fu(O) {
    var L = this.__data__;
    return Ge ? L[O] !== void 0 : kr.call(L, O)
  }

  function ut(O, L) {
    var Z = this.__data__;
    return this.size += this.has(O) ? 0 : 1, Z[O] = Ge && L === void 0 ? r : L, this
  }
  wn.prototype.clear = Ec, wn.prototype.delete = Nu, wn.prototype.get = Lu, wn.prototype.has = Fu, wn.prototype.set = ut;

  function Xt(O) {
    var L = -1,
      Z = O == null ? 0 : O.length;
    for (this.clear(); ++L < Z;) {
      var fe = O[L];
      this.set(fe[0], fe[1])
    }
  }

  function qo() {
    this.__data__ = [], this.size = 0
  }

  function Bu(O) {
    var L = this.__data__,
      Z = ep(L, O);
    if (Z < 0) return !1;
    var fe = L.length - 1;
    return Z == fe ? L.pop() : W.call(L, Z, 1), --this.size, !0
  }

  function Zt(O) {
    var L = this.__data__,
      Z = ep(L, O);
    return Z < 0 ? void 0 : L[Z][1]
  }

  function da(O) {
    return ep(this.__data__, O) > -1
  }

  function Jh(O, L) {
    var Z = this.__data__,
      fe = ep(Z, O);
    return fe < 0 ? (++this.size, Z.push([O, L])) : Z[fe][1] = L, this
  }
  Xt.prototype.clear = qo, Xt.prototype.delete = Bu, Xt.prototype.get = Zt, Xt.prototype.has = da, Xt.prototype.set = Jh;

  function xs(O) {
    var L = -1,
      Z = O == null ? 0 : O.length;
    for (this.clear(); ++L < Z;) {
      var fe = O[L];
      this.set(fe[0], fe[1])
    }
  }

  function EN() {
    this.size = 0, this.__data__ = {
      hash: new wn,
      map: new(Se || Xt),
      string: new wn
    }
  }

  function kN(O) {
    var L = tp(this, O).delete(O);
    return this.size -= L ? 1 : 0, L
  }

  function CN(O) {
    return tp(this, O).get(O)
  }

  function PN(O) {
    return tp(this, O).has(O)
  }

  function TN(O, L) {
    var Z = tp(this, O),
      fe = Z.size;
    return Z.set(O, L), this.size += Z.size == fe ? 0 : 1, this
  }
  xs.prototype.clear = EN, xs.prototype.delete = kN, xs.prototype.get = CN, xs.prototype.has = PN, xs.prototype.set = TN;

  function Qh(O) {
    var L = -1,
      Z = O == null ? 0 : O.length;
    for (this.__data__ = new xs; ++L < Z;) this.add(O[L])
  }

  function $N(O) {
    return this.__data__.set(O, r), this
  }

  function IN(O) {
    return this.__data__.has(O)
  }
  Qh.prototype.add = Qh.prototype.push = $N, Qh.prototype.has = IN;

  function si(O) {
    var L = this.__data__ = new Xt(O);
    this.size = L.size
  }

  function ON() {
    this.__data__ = new Xt, this.size = 0
  }

  function RN(O) {
    var L = this.__data__,
      Z = L.delete(O);
    return this.size = L.size, Z
  }

  function AN(O) {
    return this.__data__.get(O)
  }

  function MN(O) {
    return this.__data__.has(O)
  }

  function jN(O, L) {
    var Z = this.__data__;
    if (Z instanceof Xt) {
      var fe = Z.__data__;
      if (!Se || fe.length < n - 1) return fe.push([O, L]), this.size = ++Z.size, this;
      Z = this.__data__ = new xs(fe)
    }
    return Z.set(O, L), this.size = Z.size, this
  }
  si.prototype.clear = ON, si.prototype.delete = RN, si.prototype.get = AN, si.prototype.has = MN, si.prototype.set = jN;

  function DN(O, L) {
    var Z = np(O),
      fe = !Z && ZN(O),
      Tt = !Z && !fe && Yv(O),
      He = !Z && !fe && !Tt && nk(O),
      Kt = Z || fe || Tt || He,
      un = Kt ? bn(O.length, String) : [],
      Sn = un.length;
    for (var Ft in O)(L || kr.call(O, Ft)) && !(Kt && (Ft == "length" || Tt && (Ft == "offset" || Ft == "parent") || He && (Ft == "buffer" || Ft == "byteLength" || Ft == "byteOffset") || KN(Ft, Sn))) && un.push(Ft);
    return un
  }

  function ep(O, L) {
    for (var Z = O.length; Z--;)
      if (JE(O[Z][0], L)) return Z;
    return -1
  }

  function NN(O, L, Z) {
    var fe = L(O);
    return np(O) ? fe : An(fe, Z(O))
  }

  function Uu(O) {
    return O == null ? O === void 0 ? $ : w : X && X in Object(O) ? VN(O) : XN(O)
  }

  function YE(O) {
    return zu(O) && Uu(O) == a
  }

  function qE(O, L, Z, fe, Tt) {
    return O === L ? !0 : O == null || L == null || !zu(O) && !zu(L) ? O !== O && L !== L : LN(O, L, Z, fe, qE, Tt)
  }

  function LN(O, L, Z, fe, Tt, He) {
    var Kt = np(O),
      un = np(L),
      Sn = Kt ? c : ii(O),
      Ft = un ? c : ii(L);
    Sn = Sn == a ? v : Sn, Ft = Ft == a ? v : Ft;
    var Pr = Sn == v,
      ho = Ft == v,
      Mn = Sn == Ft;
    if (Mn && Yv(O)) {
      if (!Yv(L)) return !1;
      Kt = !0, Pr = !1
    }
    if (Mn && !Pr) return He || (He = new si), Kt || nk(O) ? XE(O, L, Z, fe, Tt, He) : zN(O, L, Sn, Z, fe, Tt, He);
    if (!(Z & o)) {
      var Vr = Pr && kr.call(O, "__wrapped__"),
        Wr = ho && kr.call(L, "__wrapped__");
      if (Vr || Wr) {
        var ai = Vr ? O.value() : O,
          Es = Wr ? L.value() : L;
        return He || (He = new si), Tt(ai, Es, Z, fe, He)
      }
    }
    return Mn ? (He || (He = new si), HN(O, L, Z, fe, Tt, He)) : !1
  }

  function FN(O) {
    if (!tk(O) || YN(O)) return !1;
    var L = QE(O) ? qh : ye;
    return L.test(fa(O))
  }

  function BN(O) {
    return zu(O) && ek(O.length) && !!ce[Uu(O)]
  }

  function UN(O) {
    if (!qN(O)) return je(O);
    var L = [];
    for (var Z in Object(O)) kr.call(O, Z) && Z != "constructor" && L.push(Z);
    return L
  }

  function XE(O, L, Z, fe, Tt, He) {
    var Kt = Z & o,
      un = O.length,
      Sn = L.length;
    if (un != Sn && !(Kt && Sn > un)) return !1;
    var Ft = He.get(O);
    if (Ft && He.get(L)) return Ft == L;
    var Pr = -1,
      ho = !0,
      Mn = Z & s ? new Qh : void 0;
    for (He.set(O, L), He.set(L, O); ++Pr < un;) {
      var Vr = O[Pr],
        Wr = L[Pr];
      if (fe) var ai = Kt ? fe(Wr, Vr, Pr, L, O, He) : fe(Vr, Wr, Pr, O, L, He);
      if (ai !== void 0) {
        if (ai) continue;
        ho = !1;
        break
      }
      if (Mn) {
        if (!ln(L, function(Es, ha) {
            if (!Zn(Mn, ha) && (Vr === Es || Tt(Vr, Es, Z, fe, He))) return Mn.push(ha)
          })) {
          ho = !1;
          break
        }
      } else if (!(Vr === Wr || Tt(Vr, Wr, Z, fe, He))) {
        ho = !1;
        break
      }
    }
    return He.delete(O), He.delete(L), ho
  }

  function zN(O, L, Z, fe, Tt, He, Kt) {
    switch (Z) {
      case M:
        if (O.byteLength != L.byteLength || O.byteOffset != L.byteOffset) return !1;
        O = O.buffer, L = L.buffer;
      case R:
        return !(O.byteLength != L.byteLength || !He(new Zh(O), new Zh(L)));
      case u:
      case d:
      case b:
        return JE(+O, +L);
      case f:
        return O.name == L.name && O.message == L.message;
      case x:
      case k:
        return O == L + "";
      case p:
        var un = Du;
      case E:
        var Sn = fe & o;
        if (un || (un = Wh), O.size != L.size && !Sn) return !1;
        var Ft = Kt.get(O);
        if (Ft) return Ft == L;
        fe |= s, Kt.set(O, L);
        var Pr = XE(un(O), un(L), fe, Tt, He, Kt);
        return Kt.delete(O), Pr;
      case C:
        if (Cr) return Cr.call(O) == Cr.call(L)
    }
    return !1
  }

  function HN(O, L, Z, fe, Tt, He) {
    var Kt = Z & o,
      un = ZE(O),
      Sn = un.length,
      Ft = ZE(L),
      Pr = Ft.length;
    if (Sn != Pr && !Kt) return !1;
    for (var ho = Sn; ho--;) {
      var Mn = un[ho];
      if (!(Kt ? Mn in L : kr.call(L, Mn))) return !1
    }
    var Vr = He.get(O);
    if (Vr && He.get(L)) return Vr == L;
    var Wr = !0;
    He.set(O, L), He.set(L, O);
    for (var ai = Kt; ++ho < Sn;) {
      Mn = un[ho];
      var Es = O[Mn],
        ha = L[Mn];
      if (fe) var rk = Kt ? fe(ha, Es, Mn, L, O, He) : fe(Es, ha, Mn, O, L, He);
      if (!(rk === void 0 ? Es === ha || Tt(Es, ha, Z, fe, He) : rk)) {
        Wr = !1;
        break
      }
      ai || (ai = Mn == "constructor")
    }
    if (Wr && !ai) {
      var rp = O.constructor,
        op = L.constructor;
      rp != op && "constructor" in O && "constructor" in L && !(typeof rp == "function" && rp instanceof rp && typeof op == "function" && op instanceof op) && (Wr = !1)
    }
    return He.delete(O), He.delete(L), Wr
  }

  function ZE(O) {
    return NN(O, e6, WN)
  }

  function tp(O, L) {
    var Z = O.__data__;
    return GN(L) ? Z[typeof L == "string" ? "string" : "hash"] : Z.map
  }

  function kc(O, L) {
    var Z = fo(O, L);
    return FN(Z) ? Z : void 0
  }

  function VN(O) {
    var L = kr.call(O, X),
      Z = O[X];
    try {
      O[X] = void 0;
      var fe = !0
    } catch {}
    var Tt = Yh.call(O);
    return fe && (L ? O[X] = Z : delete O[X]), Tt
  }
  var WN = le ? function(O) {
      return O == null ? [] : (O = Object(O), xt(le(O), function(L) {
        return z.call(O, L)
      }))
    } : t6,
    ii = Uu;
  (Ne && ii(new Ne(new ArrayBuffer(1))) != M || Se && ii(new Se) != p || be && ii(be.resolve()) != _ || lt && ii(new lt) != E || St && ii(new St) != I) && (ii = function(O) {
    var L = Uu(O),
      Z = L == v ? O.constructor : void 0,
      fe = Z ? fa(Z) : "";
    if (fe) switch (fe) {
      case mt:
        return M;
      case Lt:
        return p;
      case Ss:
        return _;
      case _s:
        return E;
      case ua:
        return I
    }
    return L
  });

  function KN(O, L) {
    return L = L ?? i, !!L && (typeof O == "number" || ge.test(O)) && O > -1 && O % 1 == 0 && O < L
  }

  function GN(O) {
    var L = typeof O;
    return L == "string" || L == "number" || L == "symbol" || L == "boolean" ? O !== "__proto__" : O === null
  }

  function YN(O) {
    return !!_c && _c in O
  }

  function qN(O) {
    var L = O && O.constructor,
      Z = typeof L == "function" && L.prototype || wc;
    return O === Z
  }

  function XN(O) {
    return Yh.call(O)
  }

  function fa(O) {
    if (O != null) {
      try {
        return ca.call(O)
      } catch {}
      try {
        return O + ""
      } catch {}
    }
    return ""
  }

  function JE(O, L) {
    return O === L || O !== O && L !== L
  }
  var ZN = YE(function() {
      return arguments
    }()) ? YE : function(O) {
      return zu(O) && kr.call(O, "callee") && !z.call(O, "callee")
    },
    np = Array.isArray;

  function JN(O) {
    return O != null && ek(O.length) && !QE(O)
  }
  var Yv = De || n6;

  function QN(O, L) {
    return qE(O, L)
  }

  function QE(O) {
    if (!tk(O)) return !1;
    var L = Uu(O);
    return L == h || L == m || L == l || L == S
  }

  function ek(O) {
    return typeof O == "number" && O > -1 && O % 1 == 0 && O <= i
  }

  function tk(O) {
    var L = typeof O;
    return O != null && (L == "object" || L == "function")
  }

  function zu(O) {
    return O != null && typeof O == "object"
  }
  var nk = Ze ? Go(Ze) : BN;

  function e6(O) {
    return JN(O) ? DN(O) : UN(O)
  }

  function t6() {
    return []
  }

  function n6() {
    return !1
  }
  t.exports = QN
})(km, km.exports);
var Iz = km.exports;
const Oz = co(Iz);

function Rz(t) {
  if (t.length === 0) return new Set;
  const e = t[0],
    n = t.slice(1),
    r = new Set;
  for (const o of e) n.every(s => s.has(o)) && r.add(o);
  return r
}

function Az(t, e) {
  const n = {};
  for (const r of e) t.has(r) || (n.added ?? (n.added = new Set), n.added.add(r));
  for (const r of t) e.has(r) || (n.removed ?? (n.removed = new Set), n.removed.add(r));
  return n.added || n.removed ? n : void 0
}

function CP(t, e) {
  for (const [n, r] of Object.entries(t)) {
    const o = r,
      s = e[n];
    if ("eq" in o && s !== o.eq || "neq" in o && s === o.neq || "gt" in o && (typeof s != "number" || s <= o.gt)) return !1
  }
  return !0
}

function PP(t, e, n) {
  const r = Object.fromEntries(Object.keys(n).map(o => [o, new Set]));
  for (const [o, s] of Object.entries(n))
    if ("eq" in s) {
      const a = t.index(e, o).get().get(s.eq);
      if (a)
        for (const c of a) r[o].add(c)
    } else if ("neq" in s) {
    const i = t.index(e, o);
    for (const [a, c] of i.get())
      if (a !== s.neq)
        for (const l of c) r[o].add(l)
  } else if ("gt" in s) {
    const i = t.index(e, o);
    for (const [a, c] of i.get())
      if (a > s.gt)
        for (const l of c) r[o].add(l)
  }
  return Rz(Object.values(r))
}
class Mz {
  constructor(e, n) {
    P(this, "indexCache", new Map);
    P(this, "historyCache", new Map);
    this.atoms = e, this.history = n
  }
  filterHistory(e) {
    if (this.historyCache.has(e)) return this.historyCache.get(e);
    const n = Q("filterHistory:" + e, (r, o) => {
      if (Dl(r)) return this.history.get();
      const s = this.history.getDiffSince(o);
      if (s === Fr) return this.history.get();
      const i = {
        added: {},
        removed: {},
        updated: {}
      };
      let a = 0,
        c = 0,
        l = 0;
      for (const u of s) {
        for (const d of Gt(u.added))
          if (d.typeName === e)
            if (i.removed[d.id]) {
              const f = i.removed[d.id];
              delete i.removed[d.id], c--, f !== d && (i.updated[d.id] = [f, d], l++)
            } else i.added[d.id] = d, a++;
        for (const [d, f] of Gt(u.updated)) f.typeName === e && (i.added[f.id] ? i.added[f.id] = f : i.updated[f.id] ? i.updated[f.id] = [i.updated[f.id][0], f] : (i.updated[f.id] = [d, f], l++));
        for (const d of Gt(u.removed)) d.typeName === e && (i.added[d.id] ? (delete i.added[d.id], a--) : i.updated[d.id] ? (i.removed[d.id] = i.updated[d.id][0], delete i.updated[d.id], l--, c++) : (i.removed[d.id] = d, c++))
      }
      return a || c || l ? Td(this.history.get(), i) : r
    }, {
      historyLength: 100
    });
    return this.historyCache.set(e, n), n
  }
  index(e, n) {
    const r = e + ":" + n;
    if (this.indexCache.has(r)) return this.indexCache.get(r);
    const o = this.__uncached_createIndex(e, n);
    return this.indexCache.set(r, o), o
  }
  __uncached_createIndex(e, n) {
    const r = this.filterHistory(e),
      o = () => {
        r.get();
        const s = new Map;
        for (const i of Gt(this.atoms.get())) {
          const a = i.get();
          if (a.typeName === e) {
            const c = a[n];
            s.has(c) || s.set(c, new Set), s.get(c).add(a.id)
          }
        }
        return s
      };
    return Q("index:" + e + ":" + n, (s, i) => {
      if (Dl(s)) return o();
      const a = r.getDiffSince(i);
      if (a === Fr) return o();
      const c = new Map,
        l = (h, m) => {
          let p = c.get(h);
          p || (p = new Ig(s.get(h) ?? new Set)), p.add(m), c.set(h, p)
        },
        u = (h, m) => {
          let p = c.get(h);
          p || (p = new Ig(s.get(h) ?? new Set)), p.remove(m), c.set(h, p)
        };
      for (const h of a) {
        for (const m of Gt(h.added))
          if (m.typeName === e) {
            const p = m[n];
            l(p, m.id)
          } for (const [m, p] of Gt(h.updated))
          if (p.typeName === e) {
            const b = m[n],
              w = p[n];
            b !== w && (u(b, p.id), l(w, p.id))
          } for (const m of Gt(h.removed))
          if (m.typeName === e) {
            const p = m[n];
            u(p, m.id)
          }
      }
      let d, f;
      for (const [h, m] of c) {
        const p = m.get();
        p && (d || (d = new Map(s)), f || (f = new Map), p.value.size === 0 ? d.delete(h) : d.set(h, p.value), f.set(h, p.diff))
      }
      return d && f ? Td(d, f) : s
    }, {
      historyLength: 100
    })
  }
  record(e, n = () => ({}), r = "record:" + e + (n ? ":" + n.toString() : "")) {
    const o = this.ids(e, n, r);
    return Q(r, () => {
      var s;
      for (const i of o.get()) return (s = this.atoms.get()[i]) == null ? void 0 : s.get()
    })
  }
  records(e, n = () => ({}), r = "records:" + e + (n ? ":" + n.toString() : "")) {
    const o = this.ids(e, n, "ids:" + r);
    return Q(r, () => [...o.get()].map(s => {
      const i = this.atoms.get()[s];
      if (!i) throw new Error("no atom found for record id: " + s);
      return i.get()
    }))
  }
  ids(e, n = () => ({}), r = "ids:" + e + (n ? ":" + n.toString() : "")) {
    const o = this.filterHistory(e),
      s = () => {
        o.get();
        const c = n();
        return Object.keys(c).length === 0 ? new Set(Gt(this.atoms.get()).flatMap(l => {
          const u = l.get();
          return u.typeName === e ? u.id : []
        })) : PP(this, e, c)
      },
      i = c => {
        const l = s(),
          u = Az(c, l);
        return u ? Td(l, u) : c
      },
      a = Q("ids_query:" + r, n, {
        isEqual: Oz
      });
    return Q("query:" + r, (c, l) => {
      const u = a.get();
      if (Dl(c)) return s();
      if (l < a.lastChangedEpoch) return i(c);
      const d = o.getDiffSince(l);
      if (d === Fr) return i(c);
      const f = new Ig(c);
      for (const m of d) {
        for (const p of Gt(m.added)) p.typeName === e && CP(u, p) && f.add(p.id);
        for (const [p, b] of Gt(m.updated)) b.typeName === e && (CP(u, b) ? f.add(b.id) : f.remove(b.id));
        for (const p of Gt(m.removed)) p.typeName === e && f.remove(p.id)
      }
      const h = f.get();
      return h ? Td(h.value, h.diff) : c
    }, {
      historyLength: 50
    })
  }
  exec(e, n) {
    const r = PP(this, e, n);
    if (r.size === 0) return Ns;
    const o = this.atoms.get();
    return [...r].map(s => o[s].get())
  }
}

function Bve(t) {
  return t
}
class l1 {
  constructor(e) {
    P(this, "id", Ui());
    P(this, "atoms", tr("store_atoms", {}));
    P(this, "history", tr("history", 0, {
      historyLength: 1e3
    }));
    P(this, "query", new Mz(this.atoms, this.history));
    P(this, "listeners", new Set);
    P(this, "historyAccumulator", new Dz);
    P(this, "historyReactor");
    P(this, "schema");
    P(this, "props");
    P(this, "scopedTypes");
    P(this, "onBeforeCreate");
    P(this, "onAfterCreate");
    P(this, "onBeforeChange");
    P(this, "onAfterChange");
    P(this, "onBeforeDelete");
    P(this, "onAfterDelete");
    P(this, "_runCallbacks", !0);
    P(this, "put", (e, n) => {
      Zr(() => {
        const r = {},
          o = {},
          s = this.atoms.__unsafe__getWithoutCapture();
        let i = null,
          a, c = !1;
        const l = this.onBeforeCreate && this._runCallbacks ? this.onBeforeCreate : null,
          u = this.onBeforeChange && this._runCallbacks ? this.onBeforeChange : null,
          d = this.isMergingRemoteChanges ? "remote" : "user";
        for (let f = 0, h = e.length; f < h; f++) {
          a = e[f];
          const m = (i ?? s)[a.id];
          if (m) {
            u && (a = u(m.get(), a, d));
            const p = m.__unsafe__getWithoutCapture();
            a = this.schema.validateRecord(this, a, n ?? "updateRecord", p), m.set(a);
            const b = m.__unsafe__getWithoutCapture();
            p !== b && (c = !0, r[a.id] = [p, b])
          } else l && (a = l(a, d)), c = !0, a = this.schema.validateRecord(this, a, n ?? "createRecord", null), o[a.id] = a, i || (i = {
            ...s
          }), i[a.id] = tr("atom:" + a.id, a)
        }
        if (i && this.atoms.set(i), !!c && (this.updateHistory({
            added: o,
            updated: r,
            removed: {}
          }), this._runCallbacks)) {
          const {
            onAfterCreate: f,
            onAfterChange: h
          } = this;
          f && Object.values(o).forEach(m => {
            f(m, d)
          }), h && Object.values(r).forEach(([m, p]) => {
            h(m, p, d)
          })
        }
      })
    });
    P(this, "remove", e => {
      Zr(() => {
        const n = [],
          r = this.isMergingRemoteChanges ? "remote" : "user";
        if (this.onBeforeDelete && this._runCallbacks)
          for (const s of e) {
            const i = this.atoms.__unsafe__getWithoutCapture()[s];
            i && this.onBeforeDelete(i.get(), r) === !1 && n.push(s)
          }
        let o;
        if (this.atoms.update(s => {
            let i;
            for (const a of e) n.includes(a) || a in s && (i || (i = {
              ...s
            }), o || (o = {}), delete i[a], o[a] = s[a].get());
            return i ?? s
          }), !!o && (this.updateHistory({
            added: {},
            updated: {},
            removed: o
          }), this.onAfterDelete && this._runCallbacks)) {
          let s;
          for (let i = 0, a = e.length; i < a; i++) s = o[e[i]], s && this.onAfterDelete(s, r)
        }
      })
    });
    P(this, "get", e => {
      var n;
      return (n = this.atoms.get()[e]) == null ? void 0 : n.get()
    });
    P(this, "unsafeGetWithoutCapture", e => {
      var n;
      return (n = this.atoms.get()[e]) == null ? void 0 : n.__unsafe__getWithoutCapture()
    });
    P(this, "serialize", (e = "document") => {
      const n = {};
      for (const [r, o] of Ls(this.atoms.get())) {
        const s = o.get();
        (e === "all" || this.scopedTypes[e].has(s.typeName)) && (n[r] = s)
      }
      return n
    });
    P(this, "allRecords", () => Gt(this.atoms.get()).map(e => e.get()));
    P(this, "clear", () => {
      this.remove(xP(this.atoms.get()))
    });
    P(this, "update", (e, n) => {
      const r = this.atoms.get()[e];
      if (!r) {
        console.error(`Record ${e} not found. This is probably an error`);
        return
      }
      this.put([n(r.__unsafe__getWithoutCapture())])
    });
    P(this, "has", e => !!this.atoms.get()[e]);
    P(this, "listen", (e, n) => {
      this._flushHistory();
      const r = {
        onHistory: e,
        filters: {
          source: (n == null ? void 0 : n.source) ?? "all",
          scope: (n == null ? void 0 : n.scope) ?? "all"
        }
      };
      return this.listeners.add(r), this.historyReactor.scheduler.isActivelyListening || this.historyReactor.start(), () => {
        this.listeners.delete(r), this.listeners.size === 0 && this.historyReactor.stop()
      }
    });
    P(this, "isMergingRemoteChanges", !1);
    P(this, "mergeRemoteChanges", e => {
      if (this.isMergingRemoteChanges) return e();
      try {
        this.isMergingRemoteChanges = !0, Zr(e)
      } finally {
        this.isMergingRemoteChanges = !1
      }
    });
    P(this, "createComputedCache", (e, n, r) => {
      const o = new kP;
      return {
        get: s => {
          const i = this.atoms.get()[s];
          if (i) return o.get(i, () => {
            const a = r ? Q(i.name + ":equals", () => i.get(), {
              isEqual: r
            }) : i;
            return Q(e + ":" + s, () => n(a.get()))
          }).get()
        }
      }
    });
    P(this, "createSelectedComputedCache", (e, n, r) => {
      const o = new kP;
      return {
        get: s => {
          const i = this.atoms.get()[s];
          if (!i) return;
          const a = Q(e + ":" + s + ":selector", () => n(i.get()));
          return o.get(i, () => Q(e + ":" + s, () => r(a.get()))).get()
        }
      }
    });
    P(this, "getRecordType", e => {
      const n = this.schema.types[e.typeName];
      if (!n) throw new Error(`Record type ${e.typeName} not found`);
      return n
    });
    P(this, "_integrityChecker");
    P(this, "_isPossiblyCorrupted", !1);
    const {
      initialData: n,
      schema: r
    } = e;
    this.schema = r, this.props = e.props, n && this.atoms.set(TA(Ls(n).map(([o, s]) => [o, tr("atom:" + o, this.schema.validateRecord(this, s, "initialize", null))]))), this.historyReactor = mz("Store.historyReactor", () => {
      this.history.get(), this._flushHistory()
    }, {
      scheduleEffect: o => Cz(o)
    }), this.scopedTypes = {
      document: new Set(Gt(this.schema.types).filter(o => o.scope === "document").map(o => o.typeName)),
      session: new Set(Gt(this.schema.types).filter(o => o.scope === "session").map(o => o.typeName)),
      presence: new Set(Gt(this.schema.types).filter(o => o.scope === "presence").map(o => o.typeName))
    }
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const e = this.historyAccumulator.flush();
      for (const {
          changes: n,
          source: r
        }
        of e) {
        let o = null,
          s = null,
          i = null;
        for (const {
            onHistory: a,
            filters: c
          }
          of this.listeners)
          if (!(c.source !== "all" && c.source !== r))
            if (c.scope !== "all")
              if (c.scope === "document") {
                if (s ?? (s = this.filterChangesByScope(n, "document")), !s) continue;
                a({
                  changes: s,
                  source: r
                })
              } else if (c.scope === "session") {
          if (o ?? (o = this.filterChangesByScope(n, "session")), !o) continue;
          a({
            changes: o,
            source: r
          })
        } else {
          if (i ?? (i = this.filterChangesByScope(n, "presence")), !i) continue;
          a({
            changes: i,
            source: r
          })
        } else a({
          changes: n,
          source: r
        })
      }
    }
  }
  filterChangesByScope(e, n) {
    const r = {
      added: M0(e.added, (o, s) => this.scopedTypes[n].has(s.typeName)),
      updated: M0(e.updated, (o, s) => this.scopedTypes[n].has(s[1].typeName)),
      removed: M0(e.removed, (o, s) => this.scopedTypes[n].has(s.typeName))
    };
    return Object.keys(r.added).length === 0 && Object.keys(r.updated).length === 0 && Object.keys(r.removed).length === 0 ? null : r
  }
  updateHistory(e) {
    this.historyAccumulator.add({
      changes: e,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.get() + 1, e)
  }
  validate(e) {
    this.allRecords().forEach(n => this.schema.validateRecord(this, n, e, null))
  }
  getSnapshot(e = "document") {
    return {
      store: this.serialize(e),
      schema: this.schema.serialize()
    }
  }
  migrateSnapshot(e) {
    const n = this.schema.migrateStoreSnapshot(e);
    if (n.type === "error") throw new Error(`Failed to migrate snapshot: ${n.reason}`);
    return {
      store: n.value,
      schema: this.schema.serialize()
    }
  }
  loadSnapshot(e) {
    const n = this.schema.migrateStoreSnapshot(e);
    if (n.type === "error") throw new Error(`Failed to migrate snapshot: ${n.reason}`);
    Zr(() => {
      this.clear(), this.put(Object.values(n.value)), this.ensureStoreIsUsable()
    })
  }
  extractingChanges(e) {
    const n = [],
      r = this.historyAccumulator.intercepting(o => n.push(o.changes));
    try {
      return Zr(e), Gy(n)
    } finally {
      r()
    }
  }
  applyDiff(e, n = !0) {
    const r = this._runCallbacks;
    try {
      this._runCallbacks = n, Zr(() => {
        const o = Gt(e.added).concat(Gt(e.updated).map(([i, a]) => a)),
          s = xP(e.removed);
        o.length && this.put(o), s.length && this.remove(s)
      })
    } finally {
      this._runCallbacks = r
    }
  }
  ensureStoreIsUsable() {
    var e;
    this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this)), (e = this._integrityChecker) == null || e.call(this)
  }
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0
  }
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted
  }
}

function Gy(t) {
  const e = {
    added: {},
    removed: {},
    updated: {}
  };
  for (const n of t) {
    for (const [r, o] of Ls(n.added))
      if (e.removed[r]) {
        const s = e.removed[r];
        delete e.removed[r], s !== o && (e.updated[r] = [s, o])
      } else e.added[r] = o;
    for (const [r, [o, s]] of Ls(n.updated)) {
      if (e.added[r]) {
        e.added[r] = s, delete e.updated[r], delete e.removed[r];
        continue
      }
      if (e.updated[r]) {
        e.updated[r][1] = s, delete e.removed[r];
        continue
      }
      e.updated[r] = n.updated[r], delete e.removed[r]
    }
    for (const [r, o] of Ls(n.removed)) e.added[r] ? delete e.added[r] : e.updated[r] ? (e.removed[r] = e.updated[r][0], delete e.updated[r]) : e.removed[r] = o
  }
  return e
}

function jz(t) {
  const e = [];
  let n = t[0],
    r;
  for (let o = 1, s = t.length; o < s; o++) r = t[o], n.source !== r.source ? (e.push(n), n = r) : n = {
    source: n.source,
    changes: Gy([n.changes, r.changes])
  };
  return e.push(n), e
}

function Uve(t) {
  const e = {
    added: t.removed,
    removed: t.added,
    updated: {}
  };
  for (const [n, r] of Object.values(t.updated)) e.updated[n.id] = [r, n];
  return e
}
class Dz {
  constructor() {
    P(this, "_history", []);
    P(this, "_interceptors", new Set)
  }
  intercepting(e) {
    return this._interceptors.add(e), () => {
      this._interceptors.delete(e)
    }
  }
  add(e) {
    this._history.push(e);
    for (const n of this._interceptors) n(e)
  }
  flush() {
    const e = jz(this._history);
    return this._history = [], e
  }
  clear() {
    this._history = []
  }
  hasChanges() {
    return this._history.length > 0
  }
}

function Nz(t) {
  return typeof t == "object" && t !== null && "id" in t && "typeName" in t
}

function ht(t) {
  const {
    currentVersion: e,
    firstVersion: n,
    migrators: r = {},
    subTypeKey: o,
    subTypeMigrations: s
  } = t;
  if (typeof e == "number" && typeof n == "number") {
    if (e === n) throw Error("Current version is equal to initial version.");
    if (e < n) throw Error("Current version is lower than initial version.")
  }
  return {
    firstVersion: n ?? 0,
    currentVersion: e ?? 0,
    migrators: r,
    subTypeKey: o,
    subTypeMigrations: s
  }
}
var gl = (t => (t.IncompatibleSubtype = "incompatible-subtype", t.UnknownType = "unknown-type", t.TargetVersionTooNew = "target-version-too-new", t.TargetVersionTooOld = "target-version-too-old", t.MigrationError = "migration-error", t.UnrecognizedSubtype = "unrecognized-subtype", t))(gl || {});

function zve(t, e) {
  const n = e.recordVersions[t.typeName];
  if (!n) return {
    rootVersion: 0
  };
  if ("subTypeKey" in n) {
    const r = t[n.subTypeKey],
      o = n.subTypeVersions[r];
    return {
      rootVersion: n.version,
      subTypeVersion: o
    }
  }
  return {
    rootVersion: n.version
  }
}

function Hve(t, e) {
  if (t.rootVersion > e.rootVersion) return 1;
  if (t.rootVersion < e.rootVersion) return -1;
  if (t.subTypeVersion != null && e.subTypeVersion != null) {
    if (t.subTypeVersion > e.subTypeVersion) return 1;
    if (t.subTypeVersion < e.subTypeVersion) return -1
  }
  return 0
}

function Ip({
  record: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let o = n;
  if (!Nz(t)) throw new Error("[migrateRecord] object is not a record");
  const {
    typeName: s,
    id: i,
    ...a
  } = t;
  let c = a;
  for (; o < r;) {
    const l = o + 1,
      u = e.migrators[l];
    if (!u) return {
      type: "error",
      reason: "target-version-too-new"
    };
    c = u.up(c), o = l
  }
  for (; o > r;) {
    const l = o - 1,
      u = e.migrators[o];
    if (!u) return {
      type: "error",
      reason: "target-version-too-old"
    };
    c = u.down(c), o = l
  }
  return {
    type: "success",
    value: {
      ...c,
      id: i,
      typeName: s
    }
  }
}

function u1({
  value: t,
  migrations: e,
  fromVersion: n,
  toVersion: r
}) {
  let o = n;
  for (; o < r;) {
    const s = o + 1,
      i = e.migrators[s];
    if (!i) return {
      type: "error",
      reason: "target-version-too-new"
    };
    t = i.up(t), o = s
  }
  for (; o > r;) {
    const s = o - 1,
      i = e.migrators[o];
    if (!i) return {
      type: "error",
      reason: "target-version-too-old"
    };
    t = i.down(t), o = s
  }
  return {
    type: "success",
    value: t
  }
}
class Yy {
  constructor(e, n) {
    this.types = e, this.options = n
  }
  static create(e, n) {
    return new Yy(e, n ?? {})
  }
  get currentStoreVersion() {
    var e;
    return ((e = this.options.snapshotMigrations) == null ? void 0 : e.currentVersion) ?? 0
  }
  validateRecord(e, n, r, o) {
    try {
      const s = Da(this.types, n.typeName);
      if (!s) throw new Error(`Missing definition for record type ${n.typeName}`);
      return s.validate(n)
    } catch (s) {
      if (this.options.onValidationFailure) return this.options.onValidationFailure({
        store: e,
        record: n,
        phase: r,
        recordBefore: o,
        error: s
      });
      throw s
    }
  }
  migratePersistedRecord(e, n, r = "up") {
    var d;
    const o = Da(this.types, e.typeName),
      s = n.recordVersions[e.typeName];
    if (!s || !o) return {
      type: "error",
      reason: gl.UnknownType
    };
    const i = o.migrations.currentVersion,
      a = s.version;
    if (i !== a) {
      const f = Ip(r === "up" ? {
        record: e,
        migrations: o.migrations,
        fromVersion: a,
        toVersion: i
      } : {
        record: e,
        migrations: o.migrations,
        fromVersion: i,
        toVersion: a
      });
      if (f.type === "error") return f;
      e = f.value
    }
    if (!o.migrations.subTypeKey) return {
      type: "success",
      value: e
    };
    const c = (d = o.migrations.subTypeMigrations) == null ? void 0 : d[e[o.migrations.subTypeKey]],
      l = "subTypeVersions" in s ? s.subTypeVersions[e[o.migrations.subTypeKey]] : void 0;
    if (c === void 0) return {
      type: "error",
      reason: gl.UnrecognizedSubtype
    };
    if (l === void 0) return {
      type: "error",
      reason: gl.IncompatibleSubtype
    };
    const u = Ip(r === "up" ? {
      record: e,
      migrations: c,
      fromVersion: l,
      toVersion: c.currentVersion
    } : {
      record: e,
      migrations: c,
      fromVersion: c.currentVersion,
      toVersion: l
    });
    return u.type === "error" ? u : {
      type: "success",
      value: u.value
    }
  }
  migrateStoreSnapshot(e) {
    let {
      store: n
    } = e;
    const r = this.options.snapshotMigrations;
    if (!r) return {
      type: "success",
      value: n
    };
    const o = r.currentVersion,
      s = e.schema.storeVersion ?? 0;
    if (o < s) return {
      type: "error",
      reason: gl.TargetVersionTooOld
    };
    if (o > s) {
      const a = u1({
        value: n,
        migrations: r,
        fromVersion: s,
        toVersion: o
      });
      if (a.type === "error") return a;
      n = a.value
    }
    const i = [];
    for (const a of Gt(n)) {
      const c = this.migratePersistedRecord(a, e.schema);
      if (c.type === "error") return c;
      c.value && c.value !== a && i.push(c.value)
    }
    if (i.length) {
      n = {
        ...n
      };
      for (const a of i) n[a.id] = a
    }
    return {
      type: "success",
      value: n
    }
  }
  createIntegrityChecker(e) {
    var n, r;
    return ((r = (n = this.options).createIntegrityChecker) == null ? void 0 : r.call(n, e)) ?? void 0
  }
  serialize() {
    var e;
    return {
      schemaVersion: 1,
      storeVersion: ((e = this.options.snapshotMigrations) == null ? void 0 : e.currentVersion) ?? 0,
      recordVersions: Object.fromEntries(Gt(this.types).map(n => [n.typeName, n.migrations.subTypeKey && n.migrations.subTypeMigrations ? {
        version: n.migrations.currentVersion,
        subTypeKey: n.migrations.subTypeKey,
        subTypeVersions: n.migrations.subTypeMigrations ? Object.fromEntries(Object.entries(n.migrations.subTypeMigrations).map(([r, o]) => [r, o.currentVersion])) : void 0
      } : {
        version: n.migrations.currentVersion
      }]))
    }
  }
  serializeEarliestVersion() {
    var e;
    return {
      schemaVersion: 1,
      storeVersion: ((e = this.options.snapshotMigrations) == null ? void 0 : e.firstVersion) ?? 0,
      recordVersions: Object.fromEntries(Gt(this.types).map(n => [n.typeName, n.migrations.subTypeKey && n.migrations.subTypeMigrations ? {
        version: n.migrations.firstVersion,
        subTypeKey: n.migrations.subTypeKey,
        subTypeVersions: n.migrations.subTypeMigrations ? Object.fromEntries(Object.entries(n.migrations.subTypeMigrations).map(([r, o]) => [r, o.firstVersion])) : void 0
      } : {
        version: n.migrations.firstVersion
      }]))
    }
  }
}
const Lz = (t, e) => {
  if (t.schemaVersion > e.schemaVersion) return 1;
  if (t.schemaVersion < e.schemaVersion) return -1;
  if (t.storeVersion > e.storeVersion) return 1;
  if (t.storeVersion < e.storeVersion) return -1;
  for (const n of Object.keys(t.recordVersions)) {
    const r = t.recordVersions[n],
      o = e.recordVersions[n];
    if (r.version > o.version) return 1;
    if (r.version < o.version) return -1;
    if ("subTypeVersions" in r && !("subTypeVersions" in o)) return 1;
    if (!("subTypeVersions" in r) && "subTypeVersions" in o) return -1;
    if (!(!("subTypeVersions" in r) || !("subTypeVersions" in o)))
      for (const s of Object.keys(r.subTypeVersions)) {
        const i = r.subTypeVersions[s],
          a = o.subTypeVersions[s];
        if (i > a) return 1;
        if (i < a) return -1
      }
  }
  return 0
};

function Fz(t) {
  if (!t.length) return null;
  let e = "";
  for (const n of t) typeof n == "number" ? e += `.${n}` : n.startsWith("(") ? e.endsWith(")") ? e = `${e.slice(0,-1)}, ${n.slice(1)}` : e += n : e += `.${n}`;
  return e.startsWith(".") ? e.slice(1) : e
}
class Pt extends Error {
  constructor(n, r = []) {
    const o = Fz(r),
      s = n.split(`
`).map((i, a) => a === 0 ? i : `  ${i}`).join(`
`);
    super(r ? `At ${o}: ${s}` : s);
    P(this, "name", "ValidationError");
    this.rawMessage = n, this.path = r
  }
}

function wu(t, e) {
  try {
    return e()
  } catch (n) {
    throw n instanceof Pt ? new Pt(n.rawMessage, [t, ...n.path]) : new Pt(n.toString(), [t])
  }
}

function Za(t) {
  if (t === null) return "null";
  if (Array.isArray(t)) return "an array";
  const e = typeof t;
  switch (e) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${e}`;
    case "object":
      return `an ${e}`;
    case "undefined":
      return "undefined";
    default:
      bu(e)
  }
}
class mn {
  constructor(e) {
    this.validationFn = e
  }
  validate(e) {
    return this.validationFn(e)
  }
  nullable() {
    return DA(this)
  }
  optional() {
    return f1(this)
  }
  refine(e) {
    return new mn(n => e(this.validate(n)))
  }
  check(e, n) {
    return typeof e == "string" ? this.refine(r => (wu(`(check ${e})`, () => n(r)), r)) : this.refine(r => (e(r), r))
  }
}
class OA extends mn {
  constructor(e) {
    super(n => {
      const r = jA.validate(n);
      for (let o = 0; o < r.length; o++) wu(o, () => e.validate(r[o]));
      return r
    }), this.itemValidator = e
  }
  nonEmpty() {
    return this.check(e => {
      if (e.length === 0) throw new Pt("Expected a non-empty array")
    })
  }
  lengthGreaterThan1() {
    return this.check(e => {
      if (e.length <= 1) throw new Pt("Expected an array with length greater than 1")
    })
  }
}
class kf extends mn {
  constructor(e, n = !1) {
    super(r => {
      if (typeof r != "object" || r === null) throw new Pt(`Expected object, got ${Za(r)}`);
      for (const [o, s] of Object.entries(e)) wu(o, () => {
        s.validate(Da(r, o))
      });
      if (!n) {
        for (const o of Object.keys(r))
          if (!Ky(e, o)) throw new Pt("Unexpected property", [o])
      }
      return r
    }), this.config = e, this.shouldAllowUnknownProperties = n
  }
  allowUnknownProperties() {
    return new kf(this.config, !0)
  }
  extend(e) {
    return new kf({
      ...this.config,
      ...e
    })
  }
}
class qy extends mn {
  constructor(e, n, r) {
    super(o => {
      if (typeof o != "object" || o === null) throw new Pt(`Expected an object, got ${Za(o)}`, []);
      const s = Da(o, e);
      if (typeof s != "string") throw new Pt(`Expected a string for key "${e}", got ${Za(s)}`);
      const i = Ky(n, s) ? n[s] : void 0;
      return i === void 0 ? this.unknownValueValidation(o, s) : wu(`(${e} = ${s})`, () => i.validate(o))
    }), this.key = e, this.config = n, this.unknownValueValidation = r
  }
  validateUnknownVariants(e) {
    return new qy(this.key, this.config, e)
  }
}
class RA extends mn {
  constructor(e, n) {
    super(r => {
      if (typeof r != "object" || r === null) throw new Pt(`Expected object, got ${Za(r)}`);
      for (const [o, s] of Object.entries(r)) wu(o, () => {
        e.validate(o), n.validate(s)
      });
      return r
    }), this.keyValidator = e, this.valueValidator = n
  }
}

function Xy(t) {
  return new mn(e => {
    if (typeof e !== t) throw new Pt(`Expected ${t}, got ${Za(e)}`);
    return e
  })
}
const Bz = new mn(t => t),
  AA = new mn(t => t),
  Te = Xy("string"),
  Oe = Xy("number").check(t => {
    if (Number.isNaN(t)) throw new Pt("Expected a number, got NaN");
    if (!Number.isFinite(t)) throw new Pt(`Expected a finite number, got ${t}`)
  }),
  Zy = Oe.check(t => {
    if (t < 0) throw new Pt(`Expected a positive number, got ${t}`)
  }),
  rr = Oe.check(t => {
    if (t <= 0) throw new Pt(`Expected a non-zero positive number, got ${t}`)
  }),
  d1 = Oe.check(t => {
    if (!Number.isInteger(t)) throw new Pt(`Expected an integer, got ${t}`)
  }),
  $d = d1.check(t => {
    if (t < 0) throw new Pt(`Expected a positive integer, got ${t}`)
  }),
  MA = d1.check(t => {
    if (t <= 0) throw new Pt(`Expected a non-zero positive integer, got ${t}`)
  }),
  Je = Xy("boolean"),
  Uz = Xy("bigint");

function or(t) {
  return new mn(e => {
    if (e !== t) throw new Pt(`Expected ${t}, got ${JSON.stringify(e)}`);
    return t
  })
}
const jA = new mn(t => {
  if (!Array.isArray(t)) throw new Pt(`Expected an array, got ${Za(t)}`);
  return t
});

function Vn(t) {
  return new OA(t)
}
const zz = new mn(t => {
  if (typeof t != "object" || t === null) throw new Pt(`Expected object, got ${Za(t)}`);
  return t
});

function tt(t) {
  return new kf(t)
}

function MS(t) {
  return t === null || typeof t == "number" || typeof t == "string" || typeof t == "boolean" ? !0 : Array.isArray(t) ? t.every(MS) : typeof t == "object" ? Object.values(t).every(MS) : !1
}
const io = new mn(t => {
  if (MS(t)) return t;
  throw new Pt(`Expected json serializable value, got ${typeof t}`)
});

function Hz() {
  return Cf(Te, io)
}

function Cf(t, e) {
  return new RA(t, e)
}

function Jy(t, e) {
  return new qy(t, e, (n, r) => {
    throw new Pt(`Expected one of ${Object.keys(e).map(o=>JSON.stringify(o)).join(" or ")}, got ${JSON.stringify(r)}`, [t])
  })
}

function vs(t, e) {
  return new mn(n => {
    const r = n && typeof n == "object" && "id" in n && typeof n.id == "string" ? `${t}(id = ${n.id})` : t;
    return wu(r, () => e.validate(n))
  })
}

function Su(t) {
  return new mn(e => {
    if (!t.has(e)) {
      const n = Array.from(t, r => JSON.stringify(r)).join(" or ");
      throw new Pt(`Expected ${n}, got ${e}`)
    }
    return e
  })
}

function f1(t) {
  return new mn(e => {
    if (e !== void 0) return t.validate(e)
  })
}

function DA(t) {
  return new mn(e => e === null ? null : t.validate(e))
}

function h1(...t) {
  return Su(new Set(t))
}
const Vve = Object.freeze(Object.defineProperty({
  __proto__: null,
  ArrayOfValidator: OA,
  DictValidator: RA,
  ObjectValidator: kf,
  UnionValidator: qy,
  ValidationError: Pt,
  Validator: mn,
  any: AA,
  array: jA,
  arrayOf: Vn,
  bigint: Uz,
  boolean: Je,
  dict: Cf,
  integer: d1,
  jsonDict: Hz,
  jsonValue: io,
  literal: or,
  literalEnum: h1,
  model: vs,
  nonZeroInteger: MA,
  nonZeroNumber: rr,
  nullable: DA,
  number: Oe,
  object: tt,
  optional: f1,
  positiveInteger: $d,
  positiveNumber: Zy,
  setEnum: Su,
  string: Te,
  union: Jy,
  unknown: Bz,
  unknownObject: zz
}, Symbol.toStringTag, {
  value: "Module"
}));

function Ao(t) {
  return Te.refine(e => {
    if (!e.startsWith(`${t}:`)) throw new Error(`${t} ID must start with "${t}:"`);
    return e
  })
}
const Qy = Ao("asset");

function p1(t, e) {
  return tt({
    id: Qy,
    typeName: or("asset"),
    type: or(t),
    props: e,
    meta: io
  })
}
const Vz = vs("camera", tt({
    typeName: or("camera"),
    id: Ao("camera"),
    x: Oe,
    y: Oe,
    z: Oe,
    meta: io
  })),
  TP = {
    AddMeta: 1
  },
  Wz = ht({
    currentVersion: TP.AddMeta,
    migrators: {
      [TP.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  }),
  Bn = _r("camera", {
    validator: Vz,
    migrations: Wz,
    scope: "session"
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })),
  Pf = tt({
    x: Oe,
    y: Oe,
    z: Oe.optional()
  }),
  Kd = tt({
    x: Oe,
    y: Oe,
    w: Oe,
    h: Oe
  }),
  Kz = new Set(["none", "default", "pointer", "cross", "grab", "rotate", "grabbing", "resize-edge", "resize-corner", "text", "move", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "nesw-rotate", "nwse-rotate", "swne-rotate", "senw-rotate", "zoom-in", "zoom-out"]),
  NA = Su(Kz),
  Gz = tt({
    type: NA,
    rotation: Oe
  }),
  LA = Oe.check(t => {
    if (t < 0 || t > 1) throw new Pt("Opacity must be between 0 and 1")
  }),
  Yz = new Set(["accent", "white", "black", "selection-stroke", "selection-fill", "laser", "muted-1"]),
  qz = Su(Yz),
  Xz = new Set(["starting", "paused", "active", "stopping"]),
  FA = tt({
    id: Te,
    points: Vn(Pf),
    size: Zy,
    color: qz,
    opacity: Oe,
    state: Su(Xz),
    delay: Oe,
    shrink: Oe,
    taper: Je
  }),
  Tf = Ao("page"),
  Zz = vs("page", tt({
    typeName: or("page"),
    id: Tf,
    name: Te,
    index: Te,
    meta: io
  })),
  $P = {
    AddMeta: 1
  },
  Jz = ht({
    currentVersion: $P.AddMeta,
    migrators: {
      [$P.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  }),
  Ys = _r("page", {
    validator: Zz,
    migrations: Jz,
    scope: "document"
  }).withDefaultProperties(() => ({
    meta: {}
  }));

function $r(t) {
  return Ys.isId(t)
}
Ao("instance");

function Qz(t) {
  const e = {};
  for (const [r, o] of t) e[r] = f1(o);
  const n = vs("instance", tt({
    typeName: or("instance"),
    id: Ao("instance"),
    currentPageId: Tf,
    followingUserId: Te.nullable(),
    brush: Kd.nullable(),
    opacityForNextShape: LA,
    stylesForNextShape: tt(e),
    cursor: Gz,
    scribbles: Vn(FA),
    isFocusMode: Je,
    isDebugMode: Je,
    isToolLocked: Je,
    exportBackground: Je,
    screenBounds: Kd,
    zoomBrush: Kd.nullable(),
    isPenMode: Je,
    isGridMode: Je,
    chatMessage: Te,
    isChatting: Je,
    highlightedUserIds: Vn(Te),
    canMoveCamera: Je,
    isFocused: Je,
    devicePixelRatio: Oe,
    isCoarsePointer: Je,
    isHoveringCanvas: Je.nullable(),
    openMenus: Vn(Te),
    isChangingStyle: Je,
    isReadonly: Je,
    meta: io
  }));
  return _r("instance", {
    migrations: eH,
    validator: n,
    scope: "session"
  }).withDefaultProperties(() => ({
    followingUserId: null,
    opacityForNextShape: 1,
    stylesForNextShape: {},
    brush: null,
    scribbles: [],
    cursor: {
      type: "default",
      rotation: 0
    },
    isFocusMode: !1,
    exportBackground: !1,
    isDebugMode: !1,
    isToolLocked: !1,
    screenBounds: {
      x: 0,
      y: 0,
      w: 1080,
      h: 720
    },
    zoomBrush: null,
    isGridMode: !1,
    isPenMode: !1,
    chatMessage: "",
    isChatting: !1,
    highlightedUserIds: [],
    canMoveCamera: !0,
    isFocused: !1,
    devicePixelRatio: typeof window > "u" ? 1 : window.devicePixelRatio,
    isCoarsePointer: !1,
    isHoveringCanvas: null,
    openMenus: [],
    isChangingStyle: !1,
    isReadonly: !1,
    meta: {}
  }))
}
const Bt = {
    AddTransparentExportBgs: 1,
    RemoveDialog: 2,
    AddToolLockMode: 3,
    RemoveExtraPropsForNextShape: 4,
    AddLabelColor: 5,
    AddFollowingUserId: 6,
    RemoveAlignJustify: 7,
    AddZoom: 8,
    AddVerticalAlign: 9,
    AddScribbleDelay: 10,
    RemoveUserId: 11,
    AddIsPenModeAndIsGridMode: 12,
    HoistOpacity: 13,
    AddChat: 14,
    AddHighlightedUserIds: 15,
    ReplacePropsForNextShapeWithStylesForNextShape: 16,
    AddMeta: 17,
    RemoveCursorColor: 18,
    AddLonelyProperties: 19,
    ReadOnlyReadonly: 20,
    AddHoveringCanvas: 21,
    AddScribbles: 22
  },
  eH = ht({
    currentVersion: Bt.AddScribbles,
    migrators: {
      [Bt.AddTransparentExportBgs]: {
        up: t => ({
          ...t,
          exportBackground: !0
        }),
        down: ({
          exportBackground: t,
          ...e
        }) => e
      },
      [Bt.RemoveDialog]: {
        up: ({
          dialog: t,
          ...e
        }) => e,
        down: t => ({
          ...t,
          dialog: null
        })
      },
      [Bt.AddToolLockMode]: {
        up: t => ({
          ...t,
          isToolLocked: !1
        }),
        down: ({
          isToolLocked: t,
          ...e
        }) => e
      },
      [Bt.RemoveExtraPropsForNextShape]: {
        up: ({
          propsForNextShape: t,
          ...e
        }) => ({
          ...e,
          propsForNextShape: Object.fromEntries(Object.entries(t).filter(([n]) => ["color", "labelColor", "dash", "fill", "size", "font", "align", "verticalAlign", "icon", "geo", "arrowheadStart", "arrowheadEnd", "spline"].includes(n)))
        }),
        down: t => t
      },
      [Bt.AddLabelColor]: {
        up: ({
          propsForNextShape: t,
          ...e
        }) => ({
          ...e,
          propsForNextShape: {
            ...t,
            labelColor: "black"
          }
        }),
        down: t => {
          const {
            labelColor: e,
            ...n
          } = t.propsForNextShape;
          return {
            ...t,
            propsForNextShape: {
              ...n
            }
          }
        }
      },
      [Bt.AddFollowingUserId]: {
        up: t => ({
          ...t,
          followingUserId: null
        }),
        down: ({
          followingUserId: t,
          ...e
        }) => e
      },
      [Bt.RemoveAlignJustify]: {
        up: t => {
          let e = t.propsForNextShape.align;
          return e === "justify" && (e = "start"), {
            ...t,
            propsForNextShape: {
              ...t.propsForNextShape,
              align: e
            }
          }
        },
        down: t => ({
          ...t
        })
      },
      [Bt.AddZoom]: {
        up: t => ({
          ...t,
          zoomBrush: null
        }),
        down: ({
          zoomBrush: t,
          ...e
        }) => e
      },
      [Bt.AddVerticalAlign]: {
        up: t => ({
          ...t,
          propsForNextShape: {
            ...t.propsForNextShape,
            verticalAlign: "middle"
          }
        }),
        down: t => {
          const {
            verticalAlign: e,
            ...n
          } = t.propsForNextShape;
          return {
            ...t,
            propsForNextShape: n
          }
        }
      },
      [Bt.AddScribbleDelay]: {
        up: t => t.scribble !== null ? {
          ...t,
          scribble: {
            ...t.scribble,
            delay: 0
          }
        } : {
          ...t
        },
        down: t => {
          if (t.scribble !== null) {
            const {
              delay: e,
              ...n
            } = t.scribble;
            return {
              ...t,
              scribble: n
            }
          }
          return {
            ...t
          }
        }
      },
      [Bt.RemoveUserId]: {
        up: ({
          userId: t,
          ...e
        }) => e,
        down: t => ({
          ...t,
          userId: "user:none"
        })
      },
      [Bt.AddIsPenModeAndIsGridMode]: {
        up: t => ({
          ...t,
          isPenMode: !1,
          isGridMode: !1
        }),
        down: ({
          isPenMode: t,
          isGridMode: e,
          ...n
        }) => n
      },
      [Bt.HoistOpacity]: {
        up: ({
          propsForNextShape: {
            opacity: t,
            ...e
          },
          ...n
        }) => ({
          ...n,
          opacityForNextShape: Number(t ?? "1"),
          propsForNextShape: e
        }),
        down: ({
          opacityForNextShape: t,
          ...e
        }) => ({
          ...e,
          propsForNextShape: {
            ...e.propsForNextShape,
            opacity: t < .175 ? "0.1" : t < .375 ? "0.25" : t < .625 ? "0.5" : t < .875 ? "0.75" : "1"
          }
        })
      },
      [Bt.AddChat]: {
        up: t => ({
          ...t,
          chatMessage: "",
          isChatting: !1
        }),
        down: ({
          chatMessage: t,
          isChatting: e,
          ...n
        }) => n
      },
      [Bt.AddHighlightedUserIds]: {
        up: t => ({
          ...t,
          highlightedUserIds: []
        }),
        down: ({
          highlightedUserIds: t,
          ...e
        }) => e
      },
      [Bt.ReplacePropsForNextShapeWithStylesForNextShape]: {
        up: ({
          propsForNextShape: t,
          ...e
        }) => ({
          ...e,
          stylesForNextShape: {}
        }),
        down: ({
          stylesForNextShape: t,
          ...e
        }) => ({
          ...e,
          propsForNextShape: {
            color: "black",
            labelColor: "black",
            dash: "draw",
            fill: "none",
            size: "m",
            icon: "file",
            font: "draw",
            align: "middle",
            verticalAlign: "middle",
            geo: "rectangle",
            arrowheadStart: "none",
            arrowheadEnd: "arrow",
            spline: "line"
          }
        })
      },
      [Bt.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      },
      [Bt.RemoveCursorColor]: {
        up: t => {
          const {
            color: e,
            ...n
          } = t.cursor;
          return {
            ...t,
            cursor: n
          }
        },
        down: t => ({
          ...t,
          cursor: {
            ...t.cursor,
            color: "black"
          }
        })
      },
      [Bt.AddLonelyProperties]: {
        up: t => ({
          ...t,
          canMoveCamera: !0,
          isFocused: !1,
          devicePixelRatio: 1,
          isCoarsePointer: !1,
          openMenus: [],
          isChangingStyle: !1,
          isReadOnly: !1
        }),
        down: ({
          canMoveCamera: t,
          isFocused: e,
          devicePixelRatio: n,
          isCoarsePointer: r,
          openMenus: o,
          isChangingStyle: s,
          isReadOnly: i,
          ...a
        }) => ({
          ...a
        })
      },
      [Bt.ReadOnlyReadonly]: {
        up: ({
          isReadOnly: t,
          ...e
        }) => ({
          ...e,
          isReadonly: t
        }),
        down: ({
          isReadonly: t,
          ...e
        }) => ({
          ...e,
          isReadOnly: t
        })
      },
      [Bt.AddHoveringCanvas]: {
        up: t => ({
          ...t,
          isHoveringCanvas: null
        }),
        down: ({
          isHoveringCanvas: t,
          ...e
        }) => ({
          ...e
        })
      },
      [Bt.AddScribbles]: {
        up: ({
          scribble: t,
          ...e
        }) => ({
          ...e,
          scribbles: []
        }),
        down: ({
          scribbles: t,
          ...e
        }) => ({
          ...e,
          scribble: null
        })
      }
    }
  }),
  er = "instance:instance",
  tH = Te.refine(t => {
    if (!t.startsWith("page:") && !t.startsWith("shape:")) throw new Error('Parent ID must start with "page:" or "shape:"');
    return t
  }),
  wo = Ao("shape");

function nH(t, e, n) {
  return tt({
    id: wo,
    typeName: or("shape"),
    x: Oe,
    y: Oe,
    rotation: Oe,
    index: Te,
    parentId: tH,
    type: or(t),
    isLocked: Je,
    opacity: LA,
    props: e ? tt(e) : io,
    meta: n ? tt(n) : io
  })
}
const rH = vs("instance_page_state", tt({
    typeName: or("instance_page_state"),
    id: Ao("instance_page_state"),
    pageId: Tf,
    selectedShapeIds: Vn(wo),
    hintingShapeIds: Vn(wo),
    erasingShapeIds: Vn(wo),
    hoveredShapeId: wo.nullable(),
    editingShapeId: wo.nullable(),
    croppingShapeId: wo.nullable(),
    focusedGroupId: wo.nullable(),
    meta: io
  })),
  Tc = {
    AddCroppingId: 1,
    RemoveInstanceIdAndCameraId: 2,
    AddMeta: 3,
    RenameProperties: 4,
    RenamePropertiesAgain: 5
  },
  oH = ht({
    currentVersion: Tc.RenamePropertiesAgain,
    migrators: {
      [Tc.AddCroppingId]: {
        up(t) {
          return {
            ...t,
            croppingShapeId: null
          }
        },
        down({
          croppingShapeId: t,
          ...e
        }) {
          return e
        }
      },
      [Tc.RemoveInstanceIdAndCameraId]: {
        up({
          instanceId: t,
          cameraId: e,
          ...n
        }) {
          return n
        },
        down(t) {
          return {
            ...t,
            instanceId: er,
            cameraId: Bn.createId("void")
          }
        }
      },
      [Tc.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      },
      [Tc.RenameProperties]: {
        up: t => {
          const {
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a,
            ...c
          } = t;
          return {
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a,
            ...c
          }
        },
        down: t => {
          const {
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a,
            ...c
          } = t;
          return {
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a,
            ...c
          }
        }
      },
      [Tc.RenamePropertiesAgain]: {
        up: t => {
          const {
            selectedIds: e,
            hintingIds: n,
            erasingIds: r,
            hoveredId: o,
            editingId: s,
            croppingId: i,
            focusLayerId: a,
            ...c
          } = t;
          return {
            ...c,
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a
          }
        },
        down: t => {
          const {
            selectedShapeIds: e,
            hintingShapeIds: n,
            erasingShapeIds: r,
            hoveredShapeId: o,
            editingShapeId: s,
            croppingShapeId: i,
            focusedGroupId: a,
            ...c
          } = t;
          return {
            ...c,
            selectedIds: e,
            hintingIds: n,
            erasingIds: r,
            hoveredId: o,
            editingId: s,
            croppingId: i,
            focusLayerId: a
          }
        }
      }
    }
  }),
  Un = _r("instance_page_state", {
    migrations: oH,
    validator: rH,
    scope: "session"
  }).withDefaultProperties(() => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })),
  sH = vs("pointer", tt({
    typeName: or("pointer"),
    id: Ao("pointer"),
    x: Oe,
    y: Oe,
    lastActivityTimestamp: Oe,
    meta: io
  })),
  IP = {
    AddMeta: 1
  },
  iH = ht({
    currentVersion: IP.AddMeta,
    migrators: {
      [IP.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  }),
  g1 = _r("pointer", {
    validator: sH,
    migrations: iH,
    scope: "session"
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })),
  Cm = g1.createId("pointer"),
  aH = vs("instance_presence", tt({
    typeName: or("instance_presence"),
    id: Ao("instance_presence"),
    userId: Te,
    userName: Te,
    lastActivityTimestamp: Oe,
    followingUserId: Te.nullable(),
    cursor: tt({
      x: Oe,
      y: Oe,
      type: NA,
      rotation: Oe
    }),
    color: Te,
    camera: tt({
      x: Oe,
      y: Oe,
      z: Oe
    }),
    screenBounds: Kd,
    selectedShapeIds: Vn(Ao("shape")),
    currentPageId: Ao("page"),
    brush: Kd.nullable(),
    scribbles: Vn(FA),
    chatMessage: Te,
    meta: io
  })),
  $c = {
    AddScribbleDelay: 1,
    RemoveInstanceId: 2,
    AddChatMessage: 3,
    AddMeta: 4,
    RenameSelectedShapeIds: 5
  },
  cH = ht({
    currentVersion: $c.RenameSelectedShapeIds,
    migrators: {
      [$c.AddScribbleDelay]: {
        up: t => t.scribble !== null ? {
          ...t,
          scribble: {
            ...t.scribble,
            delay: 0
          }
        } : {
          ...t
        },
        down: t => {
          if (t.scribble !== null) {
            const {
              delay: e,
              ...n
            } = t.scribble;
            return {
              ...t,
              scribble: n
            }
          }
          return {
            ...t
          }
        }
      },
      [$c.RemoveInstanceId]: {
        up: ({
          instanceId: t,
          ...e
        }) => e,
        down: t => ({
          ...t,
          instanceId: er
        })
      },
      [$c.AddChatMessage]: {
        up: t => ({
          ...t,
          chatMessage: ""
        }),
        down: ({
          chatMessage: t,
          ...e
        }) => e
      },
      [$c.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      },
      [$c.RenameSelectedShapeIds]: {
        up: t => {
          const {
            selectedShapeIds: e,
            ...n
          } = t;
          return {
            selectedShapeIds: e,
            ...n
          }
        },
        down: t => {
          const {
            selectedShapeIds: e,
            ...n
          } = t;
          return {
            selectedShapeIds: e,
            ...n
          }
        }
      }
    }
  }),
  lH = _r("instance_presence", {
    migrations: cH,
    validator: aH,
    scope: "presence"
  }).withDefaultProperties(() => ({
    lastActivityTimestamp: 0,
    followingUserId: null,
    color: "#FF0000",
    camera: {
      x: 0,
      y: 0,
      z: 1
    },
    cursor: {
      x: 0,
      y: 0,
      type: "default",
      rotation: 0
    },
    screenBounds: {
      x: 0,
      y: 0,
      w: 1,
      h: 1
    },
    selectedShapeIds: [],
    brush: null,
    scribbles: [],
    chatMessage: "",
    meta: {}
  })),
  uH = vs("document", tt({
    typeName: or("document"),
    id: or("document:document"),
    gridSize: Oe,
    name: Te,
    meta: io
  })),
  D0 = {
    AddName: 1,
    AddMeta: 2
  },
  dH = ht({
    currentVersion: D0.AddMeta,
    migrators: {
      [D0.AddName]: {
        up: t => ({
          ...t,
          name: ""
        }),
        down: ({
          name: t,
          ...e
        }) => e
      },
      [D0.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  }),
  m1 = _r("document", {
    migrations: dH,
    validator: uH,
    scope: "document"
  }).withDefaultProperties(() => ({
    gridSize: 10,
    name: "",
    meta: {}
  })),
  jS = m1.createId("document");

function fH(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0
}

function OP(t) {
  t.typeName === "asset" && ("src" in t && (t.src = "<redacted>"), "src" in t.props && (t.props.src = "<redacted>"))
}
const hH = ({
  error: t,
  phase: e,
  record: n,
  recordBefore: r
}) => {
  throw i1(t, {
    tags: {
      origin: "store.validateRecord",
      storePhase: e,
      isExistingValidationIssue: e === "initialize"
    },
    extras: {
      recordBefore: r ? OP(Na(r)) : void 0,
      recordAfter: OP(Na(n))
    }
  }), t
};

function pH() {
  return [Ys.create({
    id: "page:page",
    name: "Page 1",
    index: "a1",
    meta: {}
  })]
}

function gH(t) {
  const e = t.query.ids("page"),
    n = () => {
      if (!t.has(jS)) return t.put([m1.create({
        id: jS,
        name: t.props.defaultName
      })]), n();
      if (!t.has(Cm)) return t.put([g1.create({
        id: Cm
      })]), n();
      const r = e.get();
      if (r.size === 0) return t.put(pH()), n();
      const o = () => [...r].map(c => t.get(c)).sort(fH)[0].id,
        s = t.get(er);
      if (s) {
        if (!r.has(s.currentPageId)) return t.put([{
          ...s,
          currentPageId: o()
        }]), n()
      } else return t.put([t.schema.types.instance.create({
        id: er,
        currentPageId: o(),
        exportBackground: !0
      })]), n();
      const i = new Set,
        a = new Set;
      for (const c of r) {
        const l = Un.createId(c);
        t.has(l) || i.add(l);
        const u = Bn.createId(c);
        t.has(u) || a.add(u)
      }
      i.size > 0 && t.put([...i].map(c => Un.create({
        id: c,
        pageId: Un.parseId(c)
      }))), a.size > 0 && t.put([...a].map(c => Bn.create({
        id: c
      })))
    };
  return n
}
const mH = p1("bookmark", tt({
    title: Te,
    description: Te,
    image: Te,
    src: Te.nullable()
  })),
  yH = ht({}),
  vH = p1("image", tt({
    w: Oe,
    h: Oe,
    name: Te,
    isAnimated: Je,
    mimeType: Te.nullable(),
    src: Te.nullable()
  })),
  N0 = {
    AddIsAnimated: 1,
    RenameWidthHeight: 2
  },
  bH = ht({
    currentVersion: N0.RenameWidthHeight,
    migrators: {
      [N0.AddIsAnimated]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            isAnimated: !1
          }
        }),
        down: t => {
          const {
            isAnimated: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [N0.RenameWidthHeight]: {
        up: t => {
          const {
            width: e,
            height: n,
            ...r
          } = t.props;
          return {
            ...t,
            props: {
              w: e,
              h: n,
              ...r
            }
          }
        },
        down: t => {
          const {
            w: e,
            h: n,
            ...r
          } = t.props;
          return {
            ...t,
            props: {
              width: e,
              height: n,
              ...r
            }
          }
        }
      }
    }
  }),
  wH = p1("video", tt({
    w: Oe,
    h: Oe,
    name: Te,
    isAnimated: Je,
    mimeType: Te.nullable(),
    src: Te.nullable()
  })),
  L0 = {
    AddIsAnimated: 1,
    RenameWidthHeight: 2
  },
  SH = ht({
    currentVersion: L0.RenameWidthHeight,
    migrators: {
      [L0.AddIsAnimated]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            isAnimated: !1
          }
        }),
        down: t => {
          const {
            isAnimated: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [L0.RenameWidthHeight]: {
        up: t => {
          const {
            width: e,
            height: n,
            ...r
          } = t.props;
          return {
            ...t,
            props: {
              w: e,
              h: n,
              ...r
            }
          }
        },
        down: t => {
          const {
            w: e,
            h: n,
            ...r
          } = t.props;
          return {
            ...t,
            props: {
              width: e,
              height: n,
              ...r
            }
          }
        }
      }
    }
  }),
  _H = vs("asset", Jy("type", {
    image: vH,
    video: wH,
    bookmark: mH
  })),
  RP = {
    AddMeta: 1
  },
  xH = ht({
    subTypeKey: "type",
    subTypeMigrations: {
      image: bH,
      video: SH,
      bookmark: yH
    },
    currentVersion: RP.AddMeta,
    migrators: {
      [RP.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  }),
  $f = _r("asset", {
    migrations: xH,
    validator: _H,
    scope: "document"
  }).withDefaultProperties(() => ({
    meta: {}
  }));
class qn {
  constructor(e, n, r) {
    this.id = e, this.defaultValue = n, this.type = r
  }
  static define(e, n) {
    const {
      defaultValue: r,
      type: o = AA
    } = n;
    return new qn(e, r, o)
  }
  static defineEnum(e, n) {
    const {
      defaultValue: r,
      values: o
    } = n;
    return new EH(e, r, o)
  }
  validate(e) {
    return this.type.validate(e)
  }
}
class EH extends qn {
  constructor(e, n, r) {
    super(e, n, h1(...r)), this.values = r
  }
}
const Op = {
    AddIsLocked: 1,
    HoistOpacity: 2,
    AddMeta: 3
  },
  F0 = ht({
    currentVersion: Op.AddMeta,
    migrators: {
      [Op.AddIsLocked]: {
        up: t => ({
          ...t,
          isLocked: !1
        }),
        down: t => {
          const {
            isLocked: e,
            ...n
          } = t;
          return {
            ...n
          }
        }
      },
      [Op.HoistOpacity]: {
        up: ({
          props: {
            opacity: t,
            ...e
          },
          ...n
        }) => ({
          ...n,
          opacity: Number(t ?? "1"),
          props: e
        }),
        down: ({
          opacity: t,
          ...e
        }) => ({
          ...e,
          props: {
            ...e.props,
            opacity: t < .175 ? "0.1" : t < .375 ? "0.25" : t < .625 ? "0.5" : t < .875 ? "0.75" : "1"
          }
        })
      },
      [Op.AddMeta]: {
        up: t => ({
          ...t,
          meta: {}
        }),
        down: ({
          meta: t,
          ...e
        }) => ({
          ...e
        })
      }
    }
  });

function Ia(t) {
  return t ? t.typeName === "shape" : !1
}

function yo(t) {
  return t ? t.startsWith("shape:") : !1
}

function is(t) {
  return `shape:${t??Ui()}`
}

function BA(t) {
  const e = new Map;
  for (const [n, r] of Object.entries(t))
    if (r instanceof qn) {
      if (e.has(r)) throw new Error(`Duplicate style prop ${r.id}. Each style prop can only be used once within a shape.`);
      e.set(r, n)
    } return e
}

function kH(t) {
  return _r("shape", {
    migrations: ht({
      currentVersion: F0.currentVersion,
      firstVersion: F0.firstVersion,
      migrators: F0.migrators,
      subTypeKey: "type",
      subTypeMigrations: EP(t, (e, n) => n.migrations ?? ht({}))
    }),
    scope: "document",
    validator: vs("shape", Jy("type", EP(t, (e, {
      props: n,
      meta: r
    }) => nH(e, n, r))))
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: !1,
    opacity: 1,
    meta: {}
  }))
}
const rd = {
    RemoveCodeAndIconShapeTypes: 1,
    AddInstancePresenceType: 2,
    RemoveTLUserAndPresenceAndAddPointer: 3,
    RemoveUserDocument: 4
  },
  CH = ht({
    currentVersion: rd.RemoveUserDocument,
    migrators: {
      [rd.RemoveCodeAndIconShapeTypes]: {
        up: t => Object.fromEntries(Object.entries(t).filter(([e, n]) => n.typeName !== "shape" || n.type !== "icon" && n.type !== "code")),
        down: t => t
      },
      [rd.AddInstancePresenceType]: {
        up: t => t,
        down: t => Object.fromEntries(Object.entries(t).filter(([e, n]) => n.typeName !== "instance_presence"))
      },
      [rd.RemoveTLUserAndPresenceAndAddPointer]: {
        up: t => Object.fromEntries(Object.entries(t).filter(([e, n]) => !n.typeName.match(/^(user|user_presence)$/))),
        down: t => Object.fromEntries(Object.entries(t).filter(([e, n]) => n.typeName !== "pointer"))
      },
      [rd.RemoveUserDocument]: {
        up: t => Object.fromEntries(Object.entries(t).filter(([e, n]) => !n.typeName.match("user_document"))),
        down: t => t
      }
    }
  });

function PH({
  shapes: t
}) {
  const e = new Map;
  for (const o of Gt(t))
    for (const s of BA(o.props ?? {}).keys()) {
      if (e.has(s.id) && e.get(s.id) !== s) throw new Error(`Multiple StyleProp instances with the same id: ${s.id}`);
      e.set(s.id, s)
    }
  const n = kH(t),
    r = Qz(e);
  return Yy.create({
    asset: $f,
    camera: Bn,
    document: m1,
    instance: r,
    instance_page_state: Un,
    page: Ys,
    shape: n,
    instance_presence: lH,
    pointer: g1
  }, {
    snapshotMigrations: CH,
    onValidationFailure: hH,
    createIntegrityChecker: gH
  })
}
const UA = ["black", "grey", "light-violet", "violet", "blue", "light-blue", "yellow", "orange", "green", "light-green", "light-red", "red"],
  AP = {
    lightMode: {
      id: "light",
      text: "#000000",
      background: "rgb(249, 250, 251)",
      solid: "#fcfffe",
      black: {
        solid: "#1d1d1d",
        semi: "#e8e8e8",
        pattern: "#494949",
        highlight: {
          srgb: "#fddd00",
          p3: "color(display-p3 0.972 0.8705 0.05)"
        }
      },
      blue: {
        solid: "#4263eb",
        semi: "#dce1f8",
        pattern: "#6681ee",
        highlight: {
          srgb: "#10acff",
          p3: "color(display-p3 0.308 0.6632 0.9996)"
        }
      },
      green: {
        solid: "#099268",
        semi: "#d3e9e3",
        pattern: "#39a785",
        highlight: {
          srgb: "#00ffc8",
          p3: "color(display-p3 0.2536 0.984 0.7981)"
        }
      },
      grey: {
        solid: "#adb5bd",
        semi: "#eceef0",
        pattern: "#bcc3c9",
        highlight: {
          srgb: "#cbe7f1",
          p3: "color(display-p3 0.8163 0.9023 0.9416)"
        }
      },
      "light-blue": {
        solid: "#4dabf7",
        semi: "#ddedfa",
        pattern: "#6fbbf8",
        highlight: {
          srgb: "#00f4ff",
          p3: "color(display-p3 0.1512 0.9414 0.9996)"
        }
      },
      "light-green": {
        solid: "#40c057",
        semi: "#dbf0e0",
        pattern: "#65cb78",
        highlight: {
          srgb: "#65f641",
          p3: "color(display-p3 0.563 0.9495 0.3857)"
        }
      },
      "light-red": {
        solid: "#ff8787",
        semi: "#f4dadb",
        pattern: "#fe9e9e",
        highlight: {
          srgb: "#ff7fa3",
          p3: "color(display-p3 0.9988 0.5301 0.6397)"
        }
      },
      "light-violet": {
        solid: "#e599f7",
        semi: "#f5eafa",
        pattern: "#e9acf8",
        highlight: {
          srgb: "#ff88ff",
          p3: "color(display-p3 0.9676 0.5652 0.9999)"
        }
      },
      orange: {
        solid: "#f76707",
        semi: "#f8e2d4",
        pattern: "#f78438",
        highlight: {
          srgb: "#ffa500",
          p3: "color(display-p3 0.9988 0.6905 0.266)"
        }
      },
      red: {
        solid: "#e03131",
        semi: "#f4dadb",
        pattern: "#e55959",
        highlight: {
          srgb: "#ff636e",
          p3: "color(display-p3 0.9992 0.4376 0.45)"
        }
      },
      violet: {
        solid: "#ae3ec9",
        semi: "#ecdcf2",
        pattern: "#bd63d3",
        highlight: {
          srgb: "#c77cff",
          p3: "color(display-p3 0.7469 0.5089 0.9995)"
        }
      },
      yellow: {
        solid: "#ffc078",
        semi: "#f9f0e6",
        pattern: "#fecb92",
        highlight: {
          srgb: "#fddd00",
          p3: "color(display-p3 0.972 0.8705 0.05)"
        }
      }
    },
    darkMode: {
      id: "dark",
      text: "#f8f9fa",
      background: "#212529",
      solid: "#28292e",
      black: {
        solid: "#e1e1e1",
        semi: "#2c3036",
        pattern: "#989898",
        highlight: {
          srgb: "#d2b700",
          p3: "color(display-p3 0.8078 0.7225 0.0312)"
        }
      },
      blue: {
        solid: "#4156be",
        semi: "#262d40",
        pattern: "#3a4b9e",
        highlight: {
          srgb: "#0079d2",
          p3: "color(display-p3 0.0032 0.4655 0.7991)"
        }
      },
      green: {
        solid: "#3b7b5e",
        semi: "#253231",
        pattern: "#366a53",
        highlight: {
          srgb: "#009774",
          p3: "color(display-p3 0.0085 0.582 0.4604)"
        }
      },
      grey: {
        solid: "#93989f",
        semi: "#33373c",
        pattern: "#7c8187",
        highlight: {
          srgb: "#9cb4cb",
          p3: "color(display-p3 0.6299 0.7012 0.7856)"
        }
      },
      "light-blue": {
        solid: "#588fc9",
        semi: "#2a3642",
        pattern: "#4d7aa9",
        highlight: {
          srgb: "#00bdc8",
          p3: "color(display-p3 0.0023 0.7259 0.7735)"
        }
      },
      "light-green": {
        solid: "#599f57",
        semi: "#2a3830",
        pattern: "#4e874e",
        highlight: {
          srgb: "#00a000",
          p3: "color(display-p3 0.2711 0.6172 0.0195)"
        }
      },
      "light-red": {
        solid: "#c67877",
        semi: "#3b3235",
        pattern: "#a56767",
        highlight: {
          srgb: "#db005b",
          p3: "color(display-p3 0.7849 0.0585 0.3589)"
        }
      },
      "light-violet": {
        solid: "#b583c9",
        semi: "#383442",
        pattern: "#9770a9",
        highlight: {
          srgb: "#c400c7",
          p3: "color(display-p3 0.7024 0.0403 0.753)"
        }
      },
      orange: {
        solid: "#bf612e",
        semi: "#3a2e2a",
        pattern: "#9f552d",
        highlight: {
          srgb: "#d07a00",
          p3: "color(display-p3 0.7699 0.4937 0.0085)"
        }
      },
      red: {
        solid: "#aa3c37",
        semi: "#36292b",
        pattern: "#8f3734",
        highlight: {
          srgb: "#de002c",
          p3: "color(display-p3 0.7978 0.0509 0.2035)"
        }
      },
      violet: {
        solid: "#873fa3",
        semi: "#31293c",
        pattern: "#763a8b",
        highlight: {
          srgb: "#9e00ee",
          p3: "color(display-p3 0.5651 0.0079 0.8986)"
        }
      },
      yellow: {
        solid: "#cba371",
        semi: "#3c3934",
        pattern: "#fecb92",
        highlight: {
          srgb: "#d2b700",
          p3: "color(display-p3 0.8078 0.7225 0.0312)"
        }
      }
    }
  };

function wh(t) {
  return t.isDarkMode ? AP.darkMode : AP.lightMode
}
const ao = qn.defineEnum("tldraw:color", {
    defaultValue: "black",
    values: UA
  }),
  zA = qn.defineEnum("tldraw:labelColor", {
    defaultValue: "black",
    values: UA
  }),
  Ja = qn.defineEnum("tldraw:dash", {
    defaultValue: "draw",
    values: ["draw", "solid", "dashed", "dotted"]
  }),
  tu = qn.defineEnum("tldraw:fill", {
    defaultValue: "none",
    values: ["none", "semi", "solid", "pattern"]
  }),
  Qa = qn.defineEnum("tldraw:font", {
    defaultValue: "draw",
    values: ["draw", "sans", "serif", "mono"]
  }),
  Wve = {
    draw: "'tldraw_draw', sans-serif",
    sans: "'tldraw_sans', sans-serif",
    serif: "'tldraw_serif', serif",
    mono: "'tldraw_mono', monospace"
  },
  us = qn.defineEnum("tldraw:size", {
    defaultValue: "m",
    values: ["s", "m", "l", "xl"]
  }),
  HA = ["arrow", "triangle", "square", "dot", "pipe", "diamond", "inverted", "bar", "none"],
  Pm = qn.defineEnum("tldraw:arrowheadStart", {
    defaultValue: "none",
    values: HA
  }),
  Tm = qn.defineEnum("tldraw:arrowheadEnd", {
    defaultValue: "arrow",
    values: HA
  }),
  MP = Jy("type", {
    binding: tt({
      type: or("binding"),
      boundShapeId: wo,
      normalizedAnchor: Pf,
      isExact: Je
    }),
    point: tt({
      type: or("point"),
      x: Oe,
      y: Oe
    })
  }),
  Kve = {
    labelColor: zA,
    color: ao,
    fill: tu,
    dash: Ja,
    size: us,
    arrowheadStart: Pm,
    arrowheadEnd: Tm,
    font: Qa,
    start: MP,
    end: MP,
    bend: Oe,
    text: Te
  },
  jP = {
    AddLabelColor: 1
  },
  Gve = ht({
    currentVersion: jP.AddLabelColor,
    migrators: {
      [jP.AddLabelColor]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            labelColor: "black"
          }
        }),
        down: t => {
          const {
            labelColor: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      }
    }
  }),
  TH = {
    w: rr,
    h: rr,
    assetId: Qy.nullable(),
    url: Te
  },
  DP = {
    NullAssetId: 1
  },
  $H = ht({
    currentVersion: DP.NullAssetId,
    migrators: {
      [DP.NullAssetId]: {
        up: t => t.props.assetId === void 0 ? {
          ...t,
          props: {
            ...t.props,
            assetId: null
          }
        } : t,
        down: t => {
          if (t.props.assetId === null) {
            const {
              assetId: e,
              ...n
            } = t.props;
            return {
              ...t,
              props: n
            }
          }
          return t
        }
      }
    }
  }),
  VA = tt({
    type: h1("free", "straight"),
    points: Vn(Pf)
  }),
  Yve = {
    color: ao,
    fill: tu,
    dash: Ja,
    size: us,
    segments: Vn(VA),
    isComplete: Je,
    isClosed: Je,
    isPen: Je
  },
  NP = {
    AddInPen: 1
  },
  qve = ht({
    currentVersion: NP.AddInPen,
    migrators: {
      [NP.AddInPen]: {
        up: t => {
          const {
            points: e
          } = t.props.segments[0];
          if (e.length === 0) return {
            ...t,
            props: {
              ...t.props,
              isPen: !1
            }
          };
          let n = !(e[0].z === 0 || e[0].z === .5);
          return e[1] && (n = n && !(e[1].z === 0 || e[1].z === .5)), {
            ...t,
            props: {
              ...t.props,
              isPen: n
            }
          }
        },
        down: t => {
          const {
            isPen: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: {
              ...n
            }
          }
        }
      }
    }
  }),
  LP = /(^\/r\/[^/]+\/?$)/,
  bt = t => {
    try {
      return new URL(t)
    } catch {
      return
    }
  },
  nu = [{
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !0,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(LP)) return t
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(LP)) return t
    }
  }, {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !0,
    toEmbedUrl: t => {
      if (t.match(/https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/) && !t.includes("figma.com/embed")) return `https://www.figma.com/embed?embed_host=share&url=${t}`
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const n = e.searchParams.get("url");
        if (n) return n
      }
    }
  }, {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      if (t.includes("/maps/")) {
        const e = t.match(/@(.*),(.*),(.*)z/);
        let n;
        if (e) {
          const [, r, o, s] = e;
          n = `https://${new URL(t).host.replace("www.","")}/maps/embed/v1/view?key=AIzaSyD2M5rZTN_CWNWl1egdKaQBSZk-uxhIl5Q&center=${r},${o}&zoom=${s}`
        } else n = "";
        return n
      }
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (!e) return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"),
          [o, s] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${o},${s},${r}z`
      }
    }
  }, {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t),
        n = e && e.pathname.match(/\/v\/([^/]+)\/?/);
      if (n) return `https://www.val.town/embed/${n[1]}`
    },
    fromEmbedUrl: t => {
      const e = bt(t),
        n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n) return `https://www.val.town/v/${n[1]}`
    }
  }, {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t),
        n = e && e.pathname.match(/\/s\/([^/]+)\/?/);
      if (n) return `https://codesandbox.io/embed/${n[1]}`
    },
    fromEmbedUrl: t => {
      const e = bt(t),
        n = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (n) return `https://codesandbox.io/s/${n[1]}`
    }
  }, {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/,
        n = t.match(e);
      if (n) {
        const [r, o, s] = n;
        return `https://codepen.io/${o}/embed/${s}`
      }
    },
    fromEmbedUrl: t => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/,
        n = t.match(e);
      if (n) {
        const [r, o, s] = n;
        return `https://codepen.io/${o}/pen/${s}`
      }
    }
  }, {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/,
        n = t.match(e);
      if (n) {
        const [r, o] = n;
        return `https://scratch.mit.edu/projects/embed/${o}`
      }
    },
    fromEmbedUrl: t => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/,
        n = t.match(e);
      if (n) {
        const [r, o] = n;
        return `https://scratch.mit.edu/projects/${o}`
      }
    }
  }, {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    canUnmount: !1,
    overridePermissions: {
      "allow-presentation": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: t => {
      const e = bt(t);
      if (!e) return;
      const n = e.hostname.replace(/^www./, "");
      if (n === "youtu.be") return `https://www.youtube.com/embed/${e.pathname.split("/").filter(Boolean)[0]}`;
      if ((n === "youtube.com" || n === "m.youtube.com") && e.pathname.match(/^\/watch/)) return `https://www.youtube.com/embed/${e.searchParams.get("v")}`
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (!e) return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r) return `https://www.youtube.com/watch?v=${r[1]}`
      }
    }
  }, {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    canUnmount: !1,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    toEmbedUrl: t => {
      const e = bt(t),
        n = e == null ? void 0 : e.searchParams.get("cid");
      if (e != null && e.pathname.match(/\/calendar\/u\/0/) && n) {
        e.pathname = "/calendar/embed";
        const r = Array.from(e.searchParams.keys());
        for (const o of r) e.searchParams.delete(o);
        return e.searchParams.set("src", n), e.href
      }
    },
    fromEmbedUrl: t => {
      const e = bt(t),
        n = e == null ? void 0 : e.searchParams.get("src");
      if (e != null && e.pathname.match(/\/calendar\/embed/) && n) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const o of r) e.searchParams.delete(o);
        return e.searchParams.set("cid", n), e.href
      }
    }
  }, {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/pub\/?$/))) {
        e.pathname = e.pathname.replace(/\/pub$/, "/embed");
        const n = Array.from(e.searchParams.keys());
        for (const r of n) e.searchParams.delete(r);
        return e.href
      }
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/embed\/?$/))) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const n = Array.from(e.searchParams.keys());
        for (const r of n) e.searchParams.delete(r);
        return e.href
      }
    }
  }, {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !0,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/)) return t.split("/").pop() ? t : void 0
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/)) return t.split("/").pop() ? t : void 0
    }
  }, {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/)) return `${t}?embed=true`
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed")) return e.searchParams.delete("embed"), e.href
    }
  }, {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/map\//)) return e.origin + "/embed" + e.pathname
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/map\//)) return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href
    }
  }, {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    canUnmount: !1,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/(artist|album)\//)) return e.origin + "/embed" + e.pathname
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//)) return e.origin + e.pathname.replace(/^\/embed/, "")
    }
  }, {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    canUnmount: !1,
    isAspectRatioLocked: !0,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.hostname === "vimeo.com" && e.pathname.match(/^\/[0-9]+/)) return "https://player.vimeo.com/video/" + e.pathname.split("/")[1] + "?title=0&byline=0"
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.hostname === "player.vimeo.com") {
        const n = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (n) return "https://vimeo.com/" + n[1]
      }
    }
  }, {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    isAspectRatioLocked: !0,
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.hash.match(/#room=/)) return t
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.hash.match(/#room=/)) return t
    }
  }, {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    canUnmount: !1,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) return `${e.origin}/embed${e.pathname}?cell=*`;
      if (e && e.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const n = e.pathname.replace(/^\/d/, "");
        return `${e.origin}/embed${n}?cell=*`
      }
    },
    fromEmbedUrl: t => {
      const e = bt(t);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) return `${e.origin}${e.pathname.replace("/embed","")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/)) return `${e.origin}${e.pathname.replace("/embed","/d")}#cell-*`
    }
  }],
  Xve = {
    "allow-downloads-without-user-activation": !1,
    "allow-downloads": !1,
    "allow-modals": !1,
    "allow-orientation-lock": !1,
    "allow-pointer-lock": !1,
    "allow-popups": !0,
    "allow-popups-to-escape-sandbox": !1,
    "allow-presentation": !1,
    "allow-storage-access-by-user-activation": !1,
    "allow-top-navigation": !1,
    "allow-top-navigation-by-user-activation": !1,
    "allow-scripts": !0,
    "allow-same-origin": !0,
    "allow-forms": !0
  },
  Zve = {
    w: rr,
    h: rr,
    url: Te
  },
  od = {
    GenOriginalUrlInEmbed: 1,
    RemoveDoesResize: 2,
    RemoveTmpOldUrl: 3,
    RemovePermissionOverrides: 4
  },
  Jve = ht({
    currentVersion: od.RemovePermissionOverrides,
    migrators: {
      [od.GenOriginalUrlInEmbed]: {
        up: t => {
          const e = t.props.url,
            n = new URL(e).host.replace("www.", "");
          let r;
          for (const o of nu)
            if (o.hostnames.includes(n)) try {
              r = o.fromEmbedUrl(e)
            } catch (s) {
              console.warn(s)
            }
          return {
            ...t,
            props: {
              ...t.props,
              tmpOldUrl: t.props.url,
              url: r ?? ""
            }
          }
        },
        down: t => {
          let e = t.props.tmpOldUrl;
          if (!e || e === "") {
            const o = t.props.url,
              s = new URL(o).host.replace("www.", "");
            for (const i of nu)
              if (i.hostnames.includes(s)) try {
                e = i.toEmbedUrl(o)
              } catch (a) {
                console.warn(a)
              }
          }
          const {
            tmpOldUrl: n,
            ...r
          } = t.props;
          return {
            ...t,
            props: {
              ...r,
              url: e ?? ""
            }
          }
        }
      },
      [od.RemoveDoesResize]: {
        up: t => {
          const {
            doesResize: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: {
              ...n
            }
          }
        },
        down: t => ({
          ...t,
          props: {
            ...t.props,
            doesResize: !0
          }
        })
      },
      [od.RemoveTmpOldUrl]: {
        up: t => {
          const {
            tmpOldUrl: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: {
              ...n
            }
          }
        },
        down: t => ({
          ...t,
          props: {
            ...t.props
          }
        })
      },
      [od.RemovePermissionOverrides]: {
        up: t => {
          const {
            overridePermissions: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: {
              ...n
            }
          }
        },
        down: t => ({
          ...t,
          props: {
            ...t.props
          }
        })
      }
    }
  }),
  IH = {
    w: rr,
    h: rr,
    name: Te
  },
  OH = ht({}),
  If = qn.defineEnum("tldraw:horizontalAlign", {
    defaultValue: "middle",
    values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
  }),
  $m = qn.defineEnum("tldraw:verticalAlign", {
    defaultValue: "middle",
    values: ["start", "middle", "end"]
  }),
  ec = qn.defineEnum("tldraw:geo", {
    defaultValue: "rectangle",
    values: ["cloud", "rectangle", "ellipse", "triangle", "diamond", "pentagon", "hexagon", "octagon", "star", "rhombus", "rhombus-2", "oval", "trapezoid", "arrow-right", "arrow-left", "arrow-up", "arrow-down", "x-box", "check-box"]
  }),
  Qve = {
    geo: ec,
    labelColor: zA,
    color: ao,
    fill: tu,
    dash: Ja,
    size: us,
    font: Qa,
    align: If,
    verticalAlign: $m,
    url: Te,
    w: rr,
    h: rr,
    growY: Zy,
    text: Te
  },
  li = {
    AddUrlProp: 1,
    AddLabelColor: 2,
    RemoveJustify: 3,
    AddCheckBox: 4,
    AddVerticalAlign: 5,
    MigrateLegacyAlign: 6,
    AddCloud: 7
  },
  e0e = ht({
    currentVersion: li.AddCloud,
    migrators: {
      [li.AddUrlProp]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            url: ""
          }
        }),
        down: t => {
          const {
            url: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [li.AddLabelColor]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            labelColor: "black"
          }
        }),
        down: t => {
          const {
            labelColor: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [li.RemoveJustify]: {
        up: t => {
          let e = t.props.align;
          return e === "justify" && (e = "start"), {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        },
        down: t => ({
          ...t
        })
      },
      [li.AddCheckBox]: {
        up: t => ({
          ...t
        }),
        down: t => ({
          ...t,
          props: {
            ...t.props,
            geo: t.props.geo === "check-box" ? "rectangle" : t.props.geo
          }
        })
      },
      [li.AddVerticalAlign]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            verticalAlign: "middle"
          }
        }),
        down: t => {
          const {
            verticalAlign: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [li.MigrateLegacyAlign]: {
        up: t => {
          let e;
          switch (t.props.align) {
            case "start":
              e = "start-legacy";
              break;
            case "end":
              e = "end-legacy";
              break;
            default:
              e = "middle-legacy";
              break
          }
          return {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        },
        down: t => {
          let e;
          switch (t.props.align) {
            case "start-legacy":
              e = "start";
              break;
            case "end-legacy":
              e = "end";
              break;
            case "middle-legacy":
              e = "middle";
              break;
            default:
              e = t.props.align
          }
          return {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        }
      },
      [li.AddCloud]: {
        up: t => t,
        down: t => {
          if (t.props.geo === "cloud") return {
            ...t,
            props: {
              ...t.props,
              geo: "rectangle"
            }
          }
        }
      }
    }
  }),
  RH = {},
  AH = ht({}),
  t0e = {
    color: ao,
    size: us,
    segments: Vn(VA),
    isComplete: Je,
    isPen: Je
  },
  n0e = ht({}),
  MH = tt({
    topLeft: Pf,
    bottomRight: Pf
  }),
  r0e = {
    w: rr,
    h: rr,
    playing: Je,
    url: Te,
    assetId: Qy.nullable(),
    crop: MH.nullable()
  },
  B0 = {
    AddUrlProp: 1,
    AddCropProp: 2
  },
  o0e = ht({
    currentVersion: B0.AddCropProp,
    migrators: {
      [B0.AddUrlProp]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            url: ""
          }
        }),
        down: t => {
          const {
            url: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [B0.AddCropProp]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            crop: null
          }
        }),
        down: t => {
          const {
            crop: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      }
    }
  }),
  jH = new Set(["vertex", "virtual", "create"]),
  DH = tt({
    id: Te,
    type: Su(jH),
    canBind: Je.optional(),
    canSnap: Je.optional(),
    index: Te,
    x: Oe,
    y: Oe
  }),
  Im = qn.defineEnum("tldraw:spline", {
    defaultValue: "line",
    values: ["cubic", "line"]
  }),
  s0e = {
    color: ao,
    dash: Ja,
    size: us,
    spline: Im,
    handles: Cf(Te, DH)
  },
  FP = {
    AddSnapHandles: 1
  },
  i0e = ht({
    currentVersion: FP.AddSnapHandles,
    migrators: {
      [FP.AddSnapHandles]: {
        up: t => {
          const e = Ni(t.props.handles);
          for (const n in e) e[n].canSnap = !0;
          return {
            ...t,
            props: {
              ...t.props,
              handles: e
            }
          }
        },
        down: t => {
          const e = Ni(t.props.handles);
          for (const n in e) delete e[n].canSnap;
          return {
            ...t,
            props: {
              ...t.props,
              handles: e
            }
          }
        }
      }
    }
  }),
  a0e = {
    color: ao,
    size: us,
    font: Qa,
    align: If,
    verticalAlign: $m,
    growY: Zy,
    url: Te,
    text: Te
  },
  sd = {
    AddUrlProp: 1,
    RemoveJustify: 2,
    MigrateLegacyAlign: 3,
    AddVerticalAlign: 4
  },
  c0e = ht({
    currentVersion: sd.AddVerticalAlign,
    migrators: {
      [sd.AddUrlProp]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            url: ""
          }
        }),
        down: t => {
          const {
            url: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      },
      [sd.RemoveJustify]: {
        up: t => {
          let e = t.props.align;
          return e === "justify" && (e = "start"), {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        },
        down: t => ({
          ...t
        })
      },
      [sd.MigrateLegacyAlign]: {
        up: t => {
          let e;
          switch (t.props.align) {
            case "start":
              e = "start-legacy";
              break;
            case "end":
              e = "end-legacy";
              break;
            default:
              e = "middle-legacy";
              break
          }
          return {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        },
        down: t => {
          let e;
          switch (t.props.align) {
            case "start-legacy":
              e = "start";
              break;
            case "end-legacy":
              e = "end";
              break;
            case "middle-legacy":
              e = "middle";
              break;
            default:
              e = t.props.align
          }
          return {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        }
      },
      [sd.AddVerticalAlign]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            verticalAlign: "middle"
          }
        }),
        down: t => {
          const {
            verticalAlign: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      }
    }
  }),
  l0e = {
    color: ao,
    size: us,
    font: Qa,
    align: If,
    w: rr,
    text: Te,
    scale: rr,
    autoSize: Je
  },
  BP = {
    RemoveJustify: 1
  },
  u0e = ht({
    currentVersion: BP.RemoveJustify,
    migrators: {
      [BP.RemoveJustify]: {
        up: t => {
          let e = t.props.align;
          return e === "justify" && (e = "start"), {
            ...t,
            props: {
              ...t.props,
              align: e
            }
          }
        },
        down: t => ({
          ...t
        })
      }
    }
  }),
  NH = {
    w: rr,
    h: rr,
    time: Oe,
    playing: Je,
    url: Te,
    assetId: Qy.nullable()
  },
  UP = {
    AddUrlProp: 1
  },
  LH = ht({
    currentVersion: UP.AddUrlProp,
    migrators: {
      [UP.AddUrlProp]: {
        up: t => ({
          ...t,
          props: {
            ...t.props,
            url: ""
          }
        }),
        down: t => {
          const {
            url: e,
            ...n
          } = t.props;
          return {
            ...t,
            props: n
          }
        }
      }
    }
  }),
  Of = [{
    locale: "ar",
    label: ""
  }, {
    locale: "ca",
    label: "Catal"
  }, {
    locale: "da",
    label: "Danish"
  }, {
    locale: "de",
    label: "Deutsch"
  }, {
    locale: "en",
    label: "English"
  }, {
    locale: "es",
    label: "Espaol"
  }, {
    locale: "fa",
    label: ""
  }, {
    locale: "fi",
    label: "Suomi"
  }, {
    locale: "fr",
    label: "Franais"
  }, {
    locale: "gl",
    label: "Galego"
  }, {
    locale: "he",
    label: ""
  }, {
    locale: "it",
    label: "Italiano"
  }, {
    locale: "ja",
    label: ""
  }, {
    locale: "ko-kr",
    label: ""
  }, {
    locale: "ku",
    label: ""
  }, {
    locale: "hi-in",
    label: ""
  }, {
    locale: "hu",
    label: "Magyar"
  }, {
    locale: "my",
    label: ""
  }, {
    locale: "ne",
    label: ""
  }, {
    locale: "no",
    label: "Norwegian"
  }, {
    locale: "pl",
    label: "Polski"
  }, {
    locale: "pt-br",
    label: "Portugus - Brasil"
  }, {
    locale: "pt-pt",
    label: "Portugus - Europeu"
  }, {
    locale: "ro",
    label: "Romn"
  }, {
    locale: "ru",
    label: "Russian"
  }, {
    locale: "sv",
    label: "Svenska"
  }, {
    locale: "te",
    label: ""
  }, {
    locale: "th",
    label: ""
  }, {
    locale: "tr",
    label: "Trke"
  }, {
    locale: "uk",
    label: "Ukrainian"
  }, {
    locale: "vi",
    label: "Ting Vit"
  }, {
    locale: "zh-cn",
    label: "Chinese - Simplified"
  }, {
    locale: "zh-tw",
    label: " ()"
  }];

function FH() {
  const t = typeof window < "u" ? window.navigator.languages ?? ["en"] : ["en"];
  return BH(t)
}

function BH(t) {
  for (const e of t) {
    const n = UH(e);
    if (n) return n
  }
  return "en"
}
const zP = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};

function UH(t) {
  const e = Of.find(o => o.locale === t.toLowerCase());
  if (e) return e.locale;
  const [n, r] = t.split(/[-_]/).map(o => o.toLowerCase());
  if (r) {
    const o = Of.find(s => s.locale === n);
    if (o) return o.locale
  }
  return n in zP ? zP[n] : null
}
var WA = {
  exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;

    function n() {
      for (var r = [], o = 0; o < arguments.length; o++) {
        var s = arguments[o];
        if (s) {
          var i = typeof s;
          if (i === "string" || i === "number") r.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var a = n.apply(null, s);
              a && r.push(a)
            }
          } else if (i === "object") {
            if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]")) {
              r.push(s.toString());
              continue
            }
            for (var c in s) e.call(s, c) && s[c] && r.push(c)
          }
        }
      }
      return r.join(" ")
    }
    t.exports ? (n.default = n, t.exports = n) : window.classNames = n
  })()
})(WA);
var zH = WA.exports;
const ae = co(zH),
  HH = {},
  Nt = {
    preventDefaultLogging: Tr("preventDefaultLogging", {
      defaults: {
        all: !1
      }
    }),
    pointerCaptureLogging: Tr("pointerCaptureLogging", {
      defaults: {
        all: !1
      }
    }),
    pointerCaptureTracking: Tr("pointerCaptureTracking", {
      defaults: {
        all: !1
      }
    }),
    pointerCaptureTrackingObject: Tr("pointerCaptureTrackingObject", {
      defaults: {
        all: new Map
      },
      shouldStoreForSession: !1
    }),
    elementRemovalLogging: Tr("elementRemovalLogging", {
      defaults: {
        all: !1
      }
    }),
    debugSvg: Tr("debugSvg", {
      defaults: {
        all: !1
      }
    }),
    throwToBlob: Tr("throwToBlob", {
      defaults: {
        all: !1
      }
    }),
    logMessages: Tr("uiLog", {
      defaults: {
        all: []
      }
    }),
    resetConnectionEveryPing: Tr("resetConnectionEveryPing", {
      defaults: {
        all: !1
      }
    }),
    debugCursors: Tr("debugCursors", {
      defaults: {
        all: !1
      }
    }),
    forceSrgb: Tr("forceSrgbColors", {
      defaults: {
        all: !1
      }
    }),
    debugGeometry: Tr("debugGeometry", {
      defaults: {
        all: !1
      }
    }),
    hideShapes: Tr("hideShapes", {
      defaults: {
        all: !1
      }
    })
  };
typeof window < "u" && (window.tldrawLog = t => {
  Nt.logMessages.set(Nt.logMessages.get().concat(t))
});
if (typeof Element < "u") {
  const t = Element.prototype.removeChild;
  bh("element removal logging", () => {
    Nt.elementRemovalLogging.get() ? Element.prototype.removeChild = function(e) {
      return console.warn("[tldraw] removing child:", e), t.call(this, e)
    } : Element.prototype.removeChild = t
  })
}

function Tr(t, {
  defaults: e,
  shouldStoreForSession: n = !0
}) {
  return VH({
    name: t,
    defaults: e,
    shouldStoreForSession: n
  })
}

function VH(t) {
  const e = KH(t),
    n = t.shouldStoreForSession ? WH(t.name) : null,
    r = tr(`debug:${t.name}`, n ?? e);
  return typeof window < "u" && (t.shouldStoreForSession && bh(`debug:${t.name}`, () => {
    const o = r.get();
    try {
      o === e ? window.sessionStorage.removeItem(`tldraw_debug:${t.name}`) : window.sessionStorage.setItem(`tldraw_debug:${t.name}`, JSON.stringify(o))
    } catch {}
  }), Object.defineProperty(window, `tldraw${t.name.replace(/^[a-z]/,o=>o.toUpperCase())}`, {
    get() {
      return r.get()
    },
    set(o) {
      r.set(o)
    },
    configurable: !0
  })), Object.assign(r, t)
}

function WH(t) {
  try {
    return JSON.parse((window == null ? void 0 : window.sessionStorage.getItem(`tldraw_debug:${t}`)) ?? "null")
  } catch {
    return null
  }
}

function U0(t) {
  try {
    return t()
  } catch {
    return null
  }
}

function KH(t) {
  switch (U0(() => "production") ?? U0(() => ({}).VERCEL_PUBLIC_TLDRAW_ENV) ?? U0(() => ({}).NEXT_PUBLIC_TLDRAW_ENV) ?? "production") {
    case "production":
      return t.defaults.production ?? t.defaults.all;
    case "preview":
    case "staging":
      return t.defaults.staging ?? t.defaults.all;
    default:
      return t.defaults.development ?? t.defaults.all
  }
}

function Om(t) {
  if (t instanceof HTMLElement) return t;
  if (t.parentElement) return Om(t.parentElement);
  throw Error("Could not find a parent element of an HTML type!")
}

function at(t) {
  t.preventDefault(), Nt.preventDefaultLogging.get() && console.warn("preventDefault called on event:", t)
}

function Sh(t, e) {
  if (t.setPointerCapture(e.pointerId), Nt.pointerCaptureTracking.get()) {
    const n = Nt.pointerCaptureTrackingObject.get();
    n.set(t, (n.get(t) ?? 0) + 1)
  }
  Nt.pointerCaptureLogging.get() && console.warn("setPointerCapture called on element:", t, e)
}

function _h(t, e) {
  if (t.hasPointerCapture(e.pointerId)) {
    if (t.releasePointerCapture(e.pointerId), Nt.pointerCaptureTracking.get()) {
      const n = Nt.pointerCaptureTrackingObject.get();
      n.get(t) === 1 ? n.delete(t) : n.has(t) ? n.set(t, n.get(t) - 1) : console.warn("Release without capture")
    }
    Nt.pointerCaptureLogging.get() && console.warn("releasePointerCapture called on element:", t, e)
  }
}
const Wn = t => t.stopPropagation();

function gr(t) {
  return t.isKilled = !0, {
    point: {
      x: t.clientX,
      y: t.clientY,
      z: t.pressure
    },
    shiftKey: t.shiftKey,
    altKey: t.altKey,
    ctrlKey: t.metaKey || t.ctrlKey,
    pointerId: t.pointerId,
    button: t.button,
    isPen: t.pointerType === "pen"
  }
}
const y1 = se.createContext({}),
  Y = () => se.useContext(y1);

function GH() {
  const t = Y();
  return g.useMemo(function() {
    let r, o;

    function s(p) {
      if (!p.isKilled) {
        if (p.button === 2) {
          t.dispatch({
            type: "pointer",
            target: "canvas",
            name: "right_click",
            ...gr(p)
          });
          return
        }
        p.button !== 0 && p.button !== 1 && p.button !== 5 || (Sh(p.currentTarget, p), t.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_down",
          ...gr(p)
        }), t.getOpenMenus().length > 0 && (t.updateInstanceState({
          openMenus: []
        }), document.body.click(), t.getContainer().focus()))
      }
    }

    function i(p) {
      p.isKilled || p.clientX === r && p.clientY === o || (r = p.clientX, o = p.clientY, t.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...gr(p)
      }))
    }

    function a(p) {
      p.isKilled || p.button !== 0 && p.button !== 1 && p.button !== 2 && p.button !== 5 || (r = p.clientX, o = p.clientY, _h(p.currentTarget, p), t.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_up",
        ...gr(p)
      }))
    }

    function c(p) {
      if (p.isKilled || t.getInstanceState().isPenMode && p.pointerType !== "pen") return;
      const b = p.pointerType === "mouse" || p.pointerType === "pen";
      t.updateInstanceState({
        isHoveringCanvas: b ? !0 : null
      })
    }

    function l(p) {
      if (p.isKilled || t.getInstanceState().isPenMode && p.pointerType !== "pen") return;
      const b = p.pointerType === "mouse" || p.pointerType === "pen";
      t.updateInstanceState({
        isHoveringCanvas: b ? !1 : null
      })
    }

    function u(p) {
      p.isKilled = !0, document.body.click(), at(p)
    }

    function d(p) {
      p.isKilled = !0, p.target.tagName !== "A" && p.target.tagName !== "TEXTAREA" && at(p)
    }

    function f(p) {
      at(p)
    }
    async function h(p) {
      var w, v;
      if (at(p), !((v = (w = p.dataTransfer) == null ? void 0 : w.files) != null && v.length)) return;
      const b = Array.from(p.dataTransfer.files);
      await t.putExternalContent({
        type: "files",
        files: b,
        point: t.screenToPage({
          x: p.clientX,
          y: p.clientY
        }),
        ignoreParent: !1
      })
    }

    function m(p) {
      Wn(p)
    }
    return {
      onPointerDown: s,
      onPointerMove: i,
      onPointerUp: a,
      onPointerEnter: c,
      onPointerLeave: l,
      onDragOver: f,
      onDrop: h,
      onTouchStart: u,
      onTouchEnd: d,
      onClick: m
    }
  }, [t])
}

function YH() {
  const t = Y();
  g.useEffect(() => {
    if (t.environment.isFirefox && !t.environment.isAndroid && !t.environment.isIos) {
      t.updateInstanceState({
        isCoarsePointer: !1
      });
      return
    }
    if (window.matchMedia) {
      const e = window.matchMedia("(pointer: coarse)"),
        n = () => {
          t.updateInstanceState({
            isCoarsePointer: !!e.matches
          })
        };
      if (n(), e) return e.addEventListener("change", n), () => e.removeEventListener("change", n)
    }
  }, [t])
}
const KA = g.createContext(null);

function qH({
  container: t,
  children: e
}) {
  return y.jsx(KA.Provider, {
    value: t,
    children: e
  })
}

function Rn() {
  return Nl(g.useContext(KA), "useContainer used outside of <Tldraw />")
}

function XH() {
  const t = Y(),
    e = Rn(),
    n = te("isFocused", () => t.getInstanceState().isFocused, [t]);
  g.useEffect(() => {
    if (typeof matchMedia === void 0) return;
    let r = null;
    const o = () => {
      r != null && r();
      const s = `(resolution: ${window.devicePixelRatio}dppx)`,
        i = matchMedia(s),
        a = c => {
          c.type === "change" && o()
        };
      i.addEventListener ? i.addEventListener("change", o) : i.addListener && i.addListener(a), r = () => {
        i.removeEventListener ? i.removeEventListener("change", o) : i.removeListener && i.removeListener(a)
      }, t.updateInstanceState({
        devicePixelRatio: window.devicePixelRatio
      })
    };
    return o(), () => {
      r == null || r()
    }
  }, [t]), g.useEffect(() => {
    if (!n) return;
    const r = a => {
        if (a.altKey && (t.isIn("zoom") || !t.root.path.get().endsWith(".idle")) && !id() && at(a), a.isKilled) return;
        switch (a.isKilled = !0, a.key) {
          case "=":
          case "-":
          case "0": {
            if (a.metaKey || a.ctrlKey) {
              at(a);
              return
            }
            break
          }
          case "Tab": {
            if (id() || t.getIsMenuOpen()) return;
            break
          }
          case ",": {
            if (!id() && (at(a), !t.inputs.keys.has("Comma"))) {
              const {
                x: l,
                y: u,
                z: d
              } = t.inputs.currentScreenPoint;
              t.inputs.keys.add("Comma");
              const f = {
                type: "pointer",
                name: "pointer_down",
                point: {
                  x: l,
                  y: u,
                  z: d
                },
                shiftKey: a.shiftKey,
                altKey: a.altKey,
                ctrlKey: a.metaKey || a.ctrlKey,
                pointerId: 0,
                button: 0,
                isPen: t.getInstanceState().isPenMode,
                target: "canvas"
              };
              t.dispatch(f);
              return
            }
            break
          }
          case "Escape": {
            if ((t.getEditingShape() || t.getSelectedShapeIds().length > 0) && a.preventDefault(), t.getOpenMenus().length > 0) return;
            t.inputs.keys.has("Escape") || (t.inputs.keys.add("Escape"), t.cancel(), e.focus());
            return
          }
          default:
            if (id() || t.getIsMenuOpen()) return
        }
        const c = {
          type: "keyboard",
          name: a.repeat ? "key_repeat" : "key_down",
          key: a.key,
          code: a.code,
          shiftKey: a.shiftKey,
          altKey: a.altKey,
          ctrlKey: a.metaKey || a.ctrlKey
        };
        t.dispatch(c)
      },
      o = a => {
        var l;
        if (a.isKilled || (a.isKilled = !0, id() || t.getIsMenuOpen())) return;
        if (a.key === "," && ((l = document.activeElement) != null && l.ELEMENT_NODE && at(a), t.inputs.keys.has(a.code))) {
          const {
            x: u,
            y: d,
            z: f
          } = t.inputs.currentScreenPoint;
          t.inputs.keys.delete(a.code);
          const h = {
            type: "pointer",
            name: "pointer_up",
            point: {
              x: u,
              y: d,
              z: f
            },
            shiftKey: a.shiftKey,
            altKey: a.altKey,
            ctrlKey: a.metaKey || a.ctrlKey,
            pointerId: 0,
            button: 0,
            isPen: t.getInstanceState().isPenMode,
            target: "canvas"
          };
          t.dispatch(h);
          return
        }
        const c = {
          type: "keyboard",
          name: "key_up",
          key: a.key,
          code: a.code,
          shiftKey: a.shiftKey,
          altKey: a.altKey,
          ctrlKey: a.metaKey || a.ctrlKey
        };
        t.dispatch(c)
      };

    function s(a) {
      var c, l;
      if (e.contains(a.target)) {
        const u = a.touches[0].pageX,
          d = a.touches[0].radiusX || 0;
        (u - d < 10 || u + d > t.viewportScreenBounds.width - 10) && (((c = a.target) == null ? void 0 : c.tagName) === "BUTTON" && ((l = a.target) == null || l.click()), at(a))
      }
    }
    const i = a => {
      e.contains(a.target) && (a.ctrlKey || a.metaKey) && at(a)
    };
    return e.addEventListener("touchstart", s, {
      passive: !1
    }), e.addEventListener("wheel", i, {
      passive: !1
    }), document.addEventListener("gesturestart", at), document.addEventListener("gesturechange", at), document.addEventListener("gestureend", at), e.addEventListener("keydown", r), e.addEventListener("keyup", o), () => {
      e.removeEventListener("touchstart", s), e.removeEventListener("wheel", i), document.removeEventListener("gesturestart", at), document.removeEventListener("gesturechange", at), document.removeEventListener("gestureend", at), e.removeEventListener("keydown", r), e.removeEventListener("keyup", o)
    }
  }, [t, e, n])
}
const ZH = ["input", "select", "button", "textarea"];

function id() {
  const {
    activeElement: t
  } = document;
  return !!(t && (t.getAttribute("contenteditable") || ZH.indexOf(t.tagName.toLowerCase()) > -1))
}
const JH = {
  error: null
};
class GA extends g.Component {
  constructor() {
    super(...arguments);
    P(this, "state", JH)
  }
  static getDerivedStateFromError(n) {
    return {
      error: n
    }
  }
  componentDidCatch(n) {
    var r, o;
    (o = (r = this.props).onError) == null || o.call(r, n)
  }
  render() {
    const {
      error: n
    } = this.state;
    if (n !== null) {
      const {
        fallback: r
      } = this.props;
      return y.jsx(r, {
        error: n
      })
    }
    return this.props.children
  }
}

function Rf({
  children: t,
  fallback: e,
  ...n
}) {
  return e === null ? y.jsx(y.Fragment, {
    children: t
  }) : y.jsx(GA, {
    fallback: e,
    ...n,
    children: t
  })
}
class QH {
  constructor(e) {
    this.shape = e
  }
  equals(e) {
    var n, r, o, s, i, a;
    return ((n = this.shape) == null ? void 0 : n.isLocked) === ((r = e == null ? void 0 : e.shape) == null ? void 0 : r.isLocked) && ((o = this.shape) == null ? void 0 : o.props) === ((s = e == null ? void 0 : e.shape) == null ? void 0 : s.props) && ((i = this.shape) == null ? void 0 : i.meta) === ((a = e == null ? void 0 : e.shape) == null ? void 0 : a.meta)
  }
}
const eV = ({
    shape: t,
    util: e
  }) => Wy("Indicator:" + t.type, () => e.indicator(t)),
  tV = ({
    editor: t,
    id: e
  }) => {
    const n = te("shape", () => new QH(t.store.get(e)), [t, e]),
      {
        ShapeIndicatorErrorFallback: r
      } = yn();
    return !n.shape || n.shape.isLocked ? null : y.jsx(Rf, {
      fallback: r,
      onError: o => t.annotateError(o, {
        origin: "react.shapeIndicator",
        willCrashApp: !1
      }),
      children: y.jsx(eV, {
        shape: n.shape,
        util: t.getShapeUtil(n.shape)
      }, n.shape.id)
    })
  },
  nV = ({
    id: t,
    className: e,
    color: n,
    opacity: r
  }) => {
    const o = Y(),
      s = te("transform", () => {
        const i = o.getShapePageTransform(t);
        return i ? i.toCssString() : ""
      }, [o, t]);
    return y.jsx("svg", {
      className: ae("tl-overlays__item", e),
      children: y.jsx("g", {
        className: "tl-shape-indicator",
        transform: s,
        stroke: n ?? "var(--color-selected)",
        opacity: r,
        children: y.jsx(tV, {
          editor: o,
          id: t
        })
      })
    })
  },
  ev = g.memo(nV);

function rV() {
  return y.jsx("div", {
    className: "tl-background"
  })
}

function _u(t, e, n, r, o, s) {
  g.useLayoutEffect(() => {
    const i = t.current;
    if (!i || e === void 0) return;
    let a = `translate(${e}px, ${n}px)`;
    r !== void 0 && (a += ` scale(${r})`), o !== void 0 && (a += ` rotate(${o}rad)`), s && (a += ` translate(${s.x}px, ${s.y}px)`), i.style.transform = a
  })
}
const Vi = {
  linear: t => t,
  easeInQuad: t => t * t,
  easeOutQuad: t => t * (2 - t),
  easeInOutQuad: t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  easeInCubic: t => t * t * t,
  easeOutCubic: t => --t * t * t + 1,
  easeInOutCubic: t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
  easeInQuart: t => t * t * t * t,
  easeOutQuart: t => 1 - --t * t * t * t,
  easeInOutQuart: t => t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,
  easeInQuint: t => t * t * t * t * t,
  easeOutQuint: t => 1 + --t * t * t * t * t,
  easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
  easeInSine: t => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: t => Math.sin(t * Math.PI / 2),
  easeInOutSine: t => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: t => t <= 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: t => t >= 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: t => t <= 0 ? 0 : t >= 1 ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2
};
class T {
  constructor(e = 0, n = 0, r = 1) {
    this.x = e, this.y = n, this.z = r
  }
  get pressure() {
    return this.z
  }
  set(e = this.x, n = this.y, r = this.z) {
    return this.x = e, this.y = n, this.z = r, this
  }
  setTo({
    x: e = 0,
    y: n = 0,
    z: r = 1
  }) {
    return this.x = e, this.y = n, this.z = r, this
  }
  rot(e) {
    if (e === 0) return this;
    const {
      x: n,
      y: r
    } = this, o = Math.sin(e), s = Math.cos(e);
    return this.x = n * s - r * o, this.y = n * o + r * s, this
  }
  rotWith(e, n) {
    if (n === 0) return this;
    const r = this.x - e.x,
      o = this.y - e.y,
      s = Math.sin(n),
      i = Math.cos(n);
    return this.x = e.x + (r * i - o * s), this.y = e.y + (r * s + o * i), this
  }
  clone() {
    const {
      x: e,
      y: n,
      z: r
    } = this;
    return new T(e, n, r)
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this
  }
  subXY(e, n) {
    return this.x -= e, this.y -= n, this
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this
  }
  addXY(e, n) {
    return this.x += e, this.y += n, this
  }
  addScalar(e) {
    return this.x += e, this.y += e, this
  }
  clamp(e, n) {
    return this.x = Math.max(this.x, e), this.y = Math.max(this.y, e), n !== void 0 && (this.x = Math.min(this.x, n), this.y = Math.min(this.y, n)), this
  }
  div(e) {
    return this.x /= e, this.y /= e, this
  }
  divV(e) {
    return this.x /= e.x, this.y /= e.y, this
  }
  mul(e) {
    return this.x *= e, this.y *= e, this
  }
  mulV(e) {
    return this.x *= e.x, this.y *= e.y, this
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this
  }
  nudge(e, n) {
    const r = T.Tan(e, this);
    return this.add(r.mul(n))
  }
  neg() {
    return this.x *= -1, this.y *= -1, this
  }
  cross(e) {
    return this.x = this.y * e.z - this.z * e.y, this.y = this.z * e.x - this.x * e.z, this
  }
  dpr(e) {
    return T.Dpr(this, e)
  }
  cpr(e) {
    return T.Cpr(this, e)
  }
  len2() {
    return T.Len2(this)
  }
  len() {
    return T.Len(this)
  }
  pry(e) {
    return T.Pry(this, e)
  }
  per() {
    const {
      x: e,
      y: n
    } = this;
    return this.x = n, this.y = -e, this
  }
  uni() {
    return T.Uni(this)
  }
  tan(e) {
    return T.Tan(this, e)
  }
  dist(e) {
    return T.Dist(this, e)
  }
  distanceToLineSegment(e, n) {
    return T.DistanceToLineSegment(e, n, this)
  }
  slope(e) {
    return T.Slope(this, e)
  }
  snapToGrid(e) {
    return this.x = Math.round(this.x / e) * e, this.y = Math.round(this.y / e) * e, this
  }
  angle(e) {
    return T.Angle(this, e)
  }
  toAngle() {
    return T.ToAngle(this)
  }
  lrp(e, n) {
    return this.x = this.x + (e.x - this.x) * n, this.y = this.y + (e.y - this.y) * n, this
  }
  equals(e) {
    return T.Equals(this, e)
  }
  equalsXY(e, n) {
    return T.EqualsXY(this, e, n)
  }
  norm() {
    const e = this.len();
    return this.x = e === 0 ? 0 : this.x / e, this.y = e === 0 ? 0 : this.y / e, this
  }
  toFixed() {
    return T.ToFixed(this)
  }
  toString() {
    return T.ToString(T.ToFixed(this))
  }
  toJson() {
    return T.ToJson(this)
  }
  toArray() {
    return T.ToArray(this)
  }
  static Add(e, n) {
    return new T(e.x + n.x, e.y + n.y)
  }
  static AddXY(e, n, r) {
    return new T(e.x + n, e.y + r)
  }
  static Sub(e, n) {
    return new T(e.x - n.x, e.y - n.y)
  }
  static SubXY(e, n, r) {
    return new T(e.x - n, e.y - r)
  }
  static AddScalar(e, n) {
    return new T(e.x + n, e.y + n)
  }
  static SubScalar(e, n) {
    return new T(e.x - n, e.y - n)
  }
  static Div(e, n) {
    return new T(e.x / n, e.y / n)
  }
  static Mul(e, n) {
    return new T(e.x * n, e.y * n)
  }
  static DivV(e, n) {
    return new T(e.x / n.x, e.y / n.y)
  }
  static MulV(e, n) {
    return new T(e.x * n.x, e.y * n.y)
  }
  static Neg(e) {
    return new T(-e.x, -e.y)
  }
  static Per(e) {
    return new T(e.y, -e.x)
  }
  static Dist2(e, n) {
    return T.Sub(e, n).len2()
  }
  static Abs(e) {
    return new T(Math.abs(e.x), Math.abs(e.y))
  }
  static Dist(e, n) {
    return Math.hypot(e.y - n.y, e.x - n.x)
  }
  static Dpr(e, n) {
    return e.x * n.x + e.y * n.y
  }
  static Cross(e, n) {
    return new T(e.y * n.z - e.z * n.y, e.z * n.x - e.x * n.z)
  }
  static Cpr(e, n) {
    return e.x * n.y - n.x * e.y
  }
  static Len2(e) {
    return e.x * e.x + e.y * e.y
  }
  static Len(e) {
    return Math.hypot(e.x, e.y)
  }
  static Pry(e, n) {
    return T.Dpr(e, n) / T.Len(n)
  }
  static Uni(e) {
    return T.Div(e, T.Len(e))
  }
  static Tan(e, n) {
    return T.Uni(T.Sub(e, n))
  }
  static Min(e, n) {
    return new T(Math.min(e.x, n.x), Math.min(e.y, n.y))
  }
  static Max(e, n) {
    return new T(Math.max(e.x, n.x), Math.max(e.y, n.y))
  }
  static From({
    x: e,
    y: n,
    z: r = 1
  }) {
    return new T(e, n, r)
  }
  static FromArray(e) {
    return new T(e[0], e[1])
  }
  static Rot(e, n = 0) {
    const r = Math.sin(n),
      o = Math.cos(n);
    return new T(e.x * o - e.y * r, e.x * r + e.y * o)
  }
  static RotWith(e, n, r) {
    const o = e.x - n.x,
      s = e.y - n.y,
      i = Math.sin(r),
      a = Math.cos(r);
    return new T(n.x + (o * a - s * i), n.y + (o * i + s * a))
  }
  static NearestPointOnLineThroughPoint(e, n, r) {
    return T.Mul(n, T.Sub(r, e).pry(n)).add(e)
  }
  static NearestPointOnLineSegment(e, n, r, o = !0) {
    const s = T.Tan(n, e),
      i = T.Add(e, T.Mul(s, T.Sub(r, e).pry(s)));
    if (o) {
      if (i.x < Math.min(e.x, n.x)) return T.Cast(e.x < n.x ? e : n);
      if (i.x > Math.max(e.x, n.x)) return T.Cast(e.x > n.x ? e : n);
      if (i.y < Math.min(e.y, n.y)) return T.Cast(e.y < n.y ? e : n);
      if (i.y > Math.max(e.y, n.y)) return T.Cast(e.y > n.y ? e : n)
    }
    return i
  }
  static DistanceToLineThroughPoint(e, n, r) {
    return T.Dist(r, T.NearestPointOnLineThroughPoint(e, n, r))
  }
  static DistanceToLineSegment(e, n, r, o = !0) {
    return T.Dist(r, T.NearestPointOnLineSegment(e, n, r, o))
  }
  static Snap(e, n = 1) {
    return new T(Math.round(e.x / n) * n, Math.round(e.y / n) * n)
  }
  static Cast(e) {
    return e instanceof T ? e : T.From(e)
  }
  static Slope(e, n) {
    return e.x === n.y ? NaN : (e.y - n.y) / (e.x - n.x)
  }
  static Angle(e, n) {
    return Math.atan2(n.y - e.y, n.x - e.x)
  }
  static Lrp(e, n, r) {
    return T.Sub(n, e).mul(r).add(e)
  }
  static Med(e, n) {
    return new T((e.x + n.x) / 2, (e.y + n.y) / 2)
  }
  static Equals(e, n) {
    return Math.abs(e.x - n.x) < 1e-4 && Math.abs(e.y - n.y) < 1e-4
  }
  static EqualsXY(e, n, r) {
    return e.x === n && e.y === r
  }
  static Clockwise(e, n, r) {
    return (r.x - e.x) * (n.y - e.y) - (n.x - e.x) * (r.y - e.y) < 0
  }
  static Rescale(e, n) {
    const r = T.Len(e);
    return new T(n * e.x / r, n * e.y / r)
  }
  static ScaleWithOrigin(e, n, r) {
    return T.Sub(e, r).mul(n).add(r)
  }
  static ToFixed(e, n = 2) {
    return new T(+e.x.toFixed(n), +e.y.toFixed(n), +e.z.toFixed(n))
  }
  static Nudge(e, n, r) {
    return T.Add(e, T.Tan(n, e).mul(r))
  }
  static ToString(e) {
    return `${e.x}, ${e.y}`
  }
  static ToAngle(e) {
    let n = Math.atan2(e.y, e.x);
    return n < 0 && (n += Math.PI * 2), n
  }
  static FromAngle(e, n = 1) {
    return new T(Math.cos(e) * n, Math.sin(e) * n)
  }
  static ToArray(e) {
    return [e.x, e.y, e.z]
  }
  static ToJson(e) {
    const {
      x: n,
      y: r,
      z: o
    } = e;
    return {
      x: n,
      y: r,
      z: o
    }
  }
  static Average(e) {
    const n = e.length,
      r = new T(0, 0);
    for (let o = 0; o < n; o++) r.add(e[o]);
    return r.div(n)
  }
  static Clamp(e, n, r) {
    return r === void 0 ? new T(Math.min(Math.max(e.x, n)), Math.min(Math.max(e.y, n))) : new T(Math.min(Math.max(e.x, n), r), Math.min(Math.max(e.y, n), r))
  }
  static PointsBetween(e, n, r = 6) {
    const o = [];
    for (let s = 0; s < r; s++) {
      const i = Vi.easeInQuad(s / (r - 1)),
        a = T.Lrp(e, n, i);
      a.z = Math.min(1, .5 + Math.abs(.5 - oV(i)) * .65), o.push(a)
    }
    return o
  }
  static SnapToGrid(e, n = 8) {
    return new T(Math.round(e.x / n) * n, Math.round(e.y / n) * n)
  }
}
const oV = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t,
  Mt = class Mt {
    constructor(e = 0, n = 0, r = 0, o = 0) {
      P(this, "x", 0);
      P(this, "y", 0);
      P(this, "w", 0);
      P(this, "h", 0);
      this.x = e, this.y = n, this.w = r, this.h = o
    }
    get point() {
      return new T(this.x, this.y)
    }
    set point(e) {
      this.x = e.x, this.y = e.y
    }
    get minX() {
      return this.x
    }
    set minX(e) {
      this.x = e
    }
    get midX() {
      return this.x + this.w / 2
    }
    get maxX() {
      return this.x + this.w
    }
    get minY() {
      return this.y
    }
    set minY(e) {
      this.y = e
    }
    get midY() {
      return this.y + this.h / 2
    }
    get maxY() {
      return this.y + this.h
    }
    get width() {
      return this.w
    }
    set width(e) {
      this.w = e
    }
    get height() {
      return this.h
    }
    set height(e) {
      this.h = e
    }
    get aspectRatio() {
      return this.width / this.height
    }
    get center() {
      return new T(this.midX, this.midY)
    }
    set center(e) {
      this.minX = e.x - this.width / 2, this.minY = e.y - this.height / 2
    }
    get corners() {
      return [new T(this.minX, this.minY), new T(this.maxX, this.minY), new T(this.maxX, this.maxY), new T(this.minX, this.maxY)]
    }
    get snapPoints() {
      return [new T(this.minX, this.minY), new T(this.maxX, this.minY), new T(this.maxX, this.maxY), new T(this.minX, this.maxY), this.center]
    }
    get sides() {
      const {
        corners: e
      } = this;
      return [
        [e[0], e[1]],
        [e[1], e[2]],
        [e[2], e[3]],
        [e[3], e[0]]
      ]
    }
    get size() {
      return new T(this.w, this.h)
    }
    toFixed() {
      return this.x = Rp(this.x), this.y = Rp(this.y), this.w = Rp(this.w), this.h = Rp(this.h), this
    }
    setTo(e) {
      return this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h, this
    }
    set(e = 0, n = 0, r = 0, o = 0) {
      return this.x = e, this.y = n, this.w = r, this.h = o, this
    }
    expand(e) {
      const n = Math.min(this.minX, e.minX),
        r = Math.min(this.minY, e.minY),
        o = Math.max(this.maxX, e.maxX),
        s = Math.max(this.maxY, e.maxY);
      return this.x = n, this.y = r, this.w = o - n, this.h = s - r, this
    }
    expandBy(e) {
      return this.x -= e, this.y -= e, this.w += e * 2, this.h += e * 2, this
    }
    scale(e) {
      return this.x /= e, this.y /= e, this.w /= e, this.h /= e, this
    }
    clone() {
      const {
        x: e,
        y: n,
        w: r,
        h: o
      } = this;
      return new Mt(e, n, r, o)
    }
    translate(e) {
      return this.x += e.x, this.y += e.y, this
    }
    snapToGrid(e) {
      const n = Math.round(this.minX / e) * e,
        r = Math.round(this.minY / e) * e,
        o = Math.round(this.maxX / e) * e,
        s = Math.round(this.maxY / e) * e;
      this.minX = n, this.minY = r, this.width = Math.max(1, o - n), this.height = Math.max(1, s - r)
    }
    collides(e) {
      return Mt.Collides(this, e)
    }
    contains(e) {
      return Mt.Contains(this, e)
    }
    includes(e) {
      return Mt.Includes(this, e)
    }
    containsPoint(e, n = 0) {
      return Mt.ContainsPoint(this, e, n)
    }
    getHandlePoint(e) {
      switch (e) {
        case "top_left":
          return new T(this.minX, this.minY);
        case "top_right":
          return new T(this.maxX, this.minY);
        case "bottom_left":
          return new T(this.minX, this.maxY);
        case "bottom_right":
          return new T(this.maxX, this.maxY);
        case "top":
          return new T(this.midX, this.minY);
        case "right":
          return new T(this.maxX, this.midY);
        case "bottom":
          return new T(this.midX, this.maxY);
        case "left":
          return new T(this.minX, this.midY)
      }
    }
    toJson() {
      return {
        x: this.minX,
        y: this.minY,
        w: this.w,
        h: this.h
      }
    }
    resize(e, n, r) {
      const {
        minX: o,
        minY: s,
        maxX: i,
        maxY: a
      } = this;
      let {
        minX: c,
        minY: l,
        maxX: u,
        maxY: d
      } = this;
      switch (e) {
        case "left":
        case "top_left":
        case "bottom_left": {
          c += n;
          break
        }
        case "right":
        case "top_right":
        case "bottom_right": {
          u += n;
          break
        }
      }
      switch (e) {
        case "top":
        case "top_left":
        case "top_right": {
          l += r;
          break
        }
        case "bottom":
        case "bottom_left":
        case "bottom_right": {
          d += r;
          break
        }
      }
      const f = (u - c) / (i - o),
        h = (d - l) / (a - s),
        m = f < 0,
        p = h < 0;
      if (m) {
        const b = u;
        u = c, c = b
      }
      if (p) {
        const b = d;
        d = l, l = b
      }
      this.minX = c, this.minY = l, this.width = Math.abs(u - c), this.height = Math.abs(d - l)
    }
    union(e) {
      const n = Math.min(this.minX, e.x),
        r = Math.min(this.minY, e.y),
        o = Math.max(this.maxX, e.w + e.x),
        s = Math.max(this.maxY, e.h + e.y);
      return this.x = n, this.y = r, this.width = o - n, this.height = s - r, this
    }
    static From(e) {
      return new Mt(e.x, e.y, e.w, e.h)
    }
    static FromPoints(e) {
      if (e.length === 0) return new Mt;
      let n = 1 / 0,
        r = 1 / 0,
        o = -1 / 0,
        s = -1 / 0,
        i;
      for (let a = 0, c = e.length; a < c; a++) i = e[a], n = Math.min(i.x, n), r = Math.min(i.y, r), o = Math.max(i.x, o), s = Math.max(i.y, s);
      return new Mt(n, r, o - n, s - r)
    }
    static Expand(e, n) {
      const r = Math.min(n.minX, e.minX),
        o = Math.min(n.minY, e.minY),
        s = Math.max(n.maxX, e.maxX),
        i = Math.max(n.maxY, e.maxY);
      return new Mt(r, o, s - r, i - o)
    }
    static ExpandBy(e, n) {
      return new Mt(e.minX - n, e.minY - n, e.width + n * 2, e.height + n * 2)
    }
    static Resize(e, n, r, o, s = !1) {
      const {
        minX: i,
        minY: a,
        maxX: c,
        maxY: l
      } = e;
      let {
        minX: u,
        minY: d,
        maxX: f,
        maxY: h
      } = e;
      switch (n) {
        case "left":
        case "top_left":
        case "bottom_left": {
          u += r;
          break
        }
        case "right":
        case "top_right":
        case "bottom_right": {
          f += r;
          break
        }
      }
      switch (n) {
        case "top":
        case "top_left":
        case "top_right": {
          d += o;
          break
        }
        case "bottom":
        case "bottom_left":
        case "bottom_right": {
          h += o;
          break
        }
      }
      const m = (f - u) / (c - i),
        p = (h - d) / (l - a),
        b = m < 0,
        w = p < 0;
      if (s) {
        const _ = (c - i) / (l - a),
          S = Math.abs(f - u),
          x = Math.abs(h - d),
          E = S * (p < 0 ? 1 : -1) * (1 / _),
          k = x * (m < 0 ? 1 : -1) * _,
          C = _ < S / x;
        switch (n) {
          case "top_left": {
            C ? d = h + E : u = f + k;
            break
          }
          case "top_right": {
            C ? d = h + E : f = u - k;
            break
          }
          case "bottom_right": {
            C ? h = d - E : f = u - k;
            break
          }
          case "bottom_left": {
            C ? h = d - E : u = f + k;
            break
          }
          case "bottom":
          case "top": {
            const $ = (u + f) / 2,
              I = x * _;
            u = $ - I / 2, f = $ + I / 2;
            break
          }
          case "left":
          case "right": {
            const $ = (d + h) / 2,
              I = S / _;
            d = $ - I / 2, h = $ + I / 2;
            break
          }
        }
      }
      if (b) {
        const _ = f;
        f = u, u = _
      }
      if (w) {
        const _ = h;
        h = d, d = _
      }
      const v = new Mt(u, d, Math.abs(f - u), Math.abs(h - d));
      return {
        box: v,
        scaleX: +(v.width / e.width * (m > 0 ? 1 : -1)).toFixed(5),
        scaleY: +(v.height / e.height * (p > 0 ? 1 : -1)).toFixed(5)
      }
    }
    equals(e) {
      return Mt.Equals(this, e)
    }
    static Equals(e, n) {
      return n.x === e.x && n.y === e.y && n.w === e.w && n.h === e.h
    }
    zeroFix() {
      return this.w = Math.max(1, this.w), this.h = Math.max(1, this.h), this
    }
    static ZeroFix(e) {
      return new Mt(e.x, e.y, Math.max(1, e.w), Math.max(1, e.h))
    }
  };
P(Mt, "Collides", (e, n) => !(e.maxX < n.minX || e.minX > n.maxX || e.maxY < n.minY || e.minY > n.maxY)), P(Mt, "Contains", (e, n) => e.minX < n.minX && e.minY < n.minY && e.maxY > n.maxY && e.maxX > n.maxX), P(Mt, "Includes", (e, n) => Mt.Collides(e, n) || Mt.Contains(e, n)), P(Mt, "ContainsPoint", (e, n, r = 0) => !(n.x < e.minX - r || n.y < e.minY - r || n.x > e.maxX + r || n.y > e.maxY + r)), P(Mt, "Common", e => {
  let n = 1 / 0,
    r = 1 / 0,
    o = -1 / 0,
    s = -1 / 0;
  for (let i = 0; i < e.length; i++) {
    const a = e[i];
    n = Math.min(n, a.minX), r = Math.min(r, a.minY), o = Math.max(o, a.maxX), s = Math.max(s, a.maxY)
  }
  return new Mt(n, r, o - n, s - r)
}), P(Mt, "Sides", (e, n = 0) => {
  const {
    corners: r
  } = e;
  return [
    [r[0], r[1]],
    [r[1], r[2]],
    [r[2], r[3]],
    [r[3], r[0]]
  ]
});
let Be = Mt;

function sV(t) {
  switch (t) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return t
  }
}

function iV(t) {
  switch (t) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return t
  }
}
const z0 = ["top", "top_right", "right", "bottom_right", "bottom", "bottom_left", "left", "top_left"];

function d0e(t, e) {
  e = e % Rt;
  const n = Math.round(e / (Hn / 4)),
    r = z0.indexOf(t);
  return z0[(r + n) % z0.length]
}

function aV(t) {
  return t === "top_left" || t === "top_right" || t === "bottom_right" || t === "bottom_left"
}
const f0e = {
  top_left_rotate: "top_left",
  top_right_rotate: "top_right",
  bottom_right_rotate: "bottom_right",
  bottom_left_rotate: "bottom_left",
  mobile_rotate: "top_left"
};

function Jr(t) {
  return `${U(t.x)},${U(t.y)} `
}

function Qr(t, e) {
  return `${U((t.x+e.x)/2)},${U((t.y+e.y)/2)} `
}
const Hn = Math.PI,
  hr = Hn / 2,
  Rt = Hn * 2,
  h0e = Math.PI / 180,
  p0e = Math.sin;

function eo(t, e, n) {
  return Math.max(e, typeof n < "u" ? Math.min(t, n) : t)
}

function Rp(t, e = 1e10) {
  return t ? Math.round(t * e) / e : 0
}

function Gd(t, e, n = 1e-6) {
  return Math.abs(t - e) <= n
}

function Af(t, e) {
  const n = Math.pow(t - e, 2) / Math.pow(t + e, 2);
  return Hn * (t + e) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n)))
}

function br(t) {
  return t = t % Rt, t < 0 ? t = t + Rt : t === 0 && (t = 0), t
}

function tv(t, e) {
  return t = br(t), e = br(e), t > e && (e += Rt), e - t
}

function cV(t, e) {
  return Rt - tv(t, e)
}

function v1(t, e) {
  const n = (e - t) % Rt;
  return 2 * n % Rt - n
}

function g0e(t, e) {
  return Rt - v1(t, e)
}

function m0e(t, e, n) {
  return t + v1(t, e) * n
}

function lV(t, e) {
  return v1(t, e)
}

function uV(t, e, n) {
  return lV(T.Angle(t, e), T.Angle(t, n))
}

function DS(t) {
  return (Rt + t) % Rt
}

function y0e(t, e) {
  const n = Rt / e;
  let r = Math.floor((DS(t) + n / 2) / n) * n % Rt;
  return r < Hn && (r += Rt), r > Hn && (r -= Rt), r
}

function dV(t, e) {
  return t === e || Gd(t % (Math.PI / 2) - e % (Math.PI / 2), 0)
}

function v0e(t, e, n) {
  t = br(t), e = br(e), n = br(n);
  const r = Math.cos(t),
    o = Math.sin(t),
    s = Math.cos(e),
    i = Math.sin(e),
    a = Math.cos(n),
    c = Math.sin(n),
    l = r * a + o * c,
    u = s * a + i * c;
  return l >= 0 && u >= 0
}

function b0e(t) {
  return t * Hn / 180
}

function fV(t) {
  return t * 180 / Hn
}

function w0e(t, e, n, r) {
  const o = uV(t, n, r);
  return e * Rt * (o / Rt)
}

function YA(t, e, n, r) {
  return new T(t + n * Math.cos(r), e + n * Math.sin(r))
}

function S0e(t, e, n) {
  const r = t / 2,
    o = e / 2,
    s = [];
  let i = 1 / 0,
    a = 1 / 0;
  for (let c = 0; c < n; c++) {
    const l = Rt / n,
      u = -hr + c * l,
      d = r + r * Math.cos(u),
      f = o + o * Math.sin(u);
    d < i && (i = d), f < a && (a = f), s.push(new T(d, f))
  }
  if (i !== 0 || a !== 0)
    for (let c = 0; c < s.length; c++) {
      const l = s[c];
      l.x -= i, l.y -= a
    }
  return s
}

function ad(t, e, n, r) {
  return t < r && n < e
}

function So(t, e, n, r) {
  const o = Math.max(t, n),
    s = Math.min(e, r);
  return o <= s ? [o, s] : null
}
const _0e = (t, e, n) => {
  const r = Rt / t / 2,
    o = Math.floor(t / 4) * 2,
    s = t * 2 - o,
    i = 0,
    a = Math.floor(t / 2) * 2,
    c = Math.cos(-hr + o * r) * e / 2,
    l = Math.cos(-hr + s * r) * e / 2,
    u = Math.sin(-hr + i * r) * n / 2,
    d = Math.sin(-hr + a * r) * n / 2;
  return new Be(0, 0, c - l, d - u)
};

function HP(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (n.x - t.x) * (e.y - t.y)
}

function x0e(t, e, n) {
  return T.Dist(t, e) <= n
}

function E0e(t, e, n, r, o = 0) {
  o = o || 0;
  const s = Math.cos(o),
    i = Math.sin(o),
    a = T.Sub(t, e),
    c = s * a.x + i * a.y,
    l = i * a.x - s * a.y;
  return c * c / (n * n) + l * l / (r * r) <= 1
}

function k0e(t, e, n) {
  return !(t.x < e.x || t.x > e.x + n.x || t.y < e.y || t.y > e.y + n.y)
}

function ru(t, e) {
  let n = 0,
    r, o;
  for (let s = 0; s < e.length; s++) r = e[s], o = e[(s + 1) % e.length], r.y <= t.y ? o.y > t.y && HP(r, o, t) > 0 && (n += 1) : o.y <= t.y && HP(r, o, t) < 0 && (n -= 1);
  return n !== 0
}

function C0e(t, e) {
  return !(t.x < e.minX || t.x > e.maxX || t.y < e.minY || t.y > e.maxY)
}

function P0e(t, e, n = 3) {
  for (let r = 1; r < e.length; r++)
    if (T.DistanceToLineSegment(e[r - 1], e[r], t) < n) return !0;
  return !1
}

function T0e(t, e, n = 8) {
  const r = e.length;
  for (let o = 1; o < r; o++) {
    const s = e[o - 1],
      i = e[o];
    if (T.DistanceToLineSegment(s, i, t) < n) return !0
  }
  return !1
}

function $0e(t, e, n, r = 8) {
  return T.DistanceToLineSegment(e, n, t) < r
}

function U(t) {
  return +t.toFixed(4)
}

function I0e(t) {
  return +t.toFixed(2)
}
const VP = t => Math.abs(t) < Number.MAX_SAFE_INTEGER,
  H0 = ({
    brush: t,
    color: e,
    opacity: n
  }) => {
    const r = g.useRef(null);
    _u(r, t.x, t.y);
    const o = U(Math.max(1, t.w)),
      s = U(Math.max(1, t.h));
    return y.jsx("svg", {
      className: "tl-overlays__item",
      ref: r,
      children: e ? y.jsxs("g", {
        className: "tl-brush",
        opacity: n,
        children: [y.jsx("rect", {
          width: o,
          height: s,
          fill: e,
          opacity: .75
        }), y.jsx("rect", {
          width: o,
          height: s,
          fill: "none",
          stroke: e,
          opacity: .1
        })]
      }) : y.jsx("rect", {
        className: "tl-brush tl-brush__default",
        width: o,
        height: s
      })
    })
  },
  hV = ({
    className: t,
    zoom: e,
    point: n,
    color: r,
    viewport: o,
    opacity: s = 1
  }) => {
    const i = g.useRef(null);
    return _u(i, eo(n.x, o.minX + 5 / e, o.maxX - 5 / e), eo(n.y, o.minY + 5 / e, o.maxY - 5 / e), 1 / e, T.Angle(o.center, n)), y.jsxs("svg", {
      ref: i,
      className: ae("tl-overlays__item", t),
      children: [y.jsx("use", {
        href: "#cursor_hint",
        color: r,
        strokeWidth: 3,
        stroke: "var(--color-background)"
      }), y.jsx("use", {
        href: "#cursor_hint",
        color: r,
        opacity: s
      })]
    })
  },
  pV = ({
    className: t,
    zoom: e,
    point: n,
    color: r,
    name: o,
    chatMessage: s
  }) => {
    const i = g.useRef(null);
    return _u(i, n == null ? void 0 : n.x, n == null ? void 0 : n.y, 1 / e), n ? y.jsxs("div", {
      ref: i,
      className: ae("tl-overlays__item", t),
      children: [y.jsx("svg", {
        className: "tl-cursor",
        children: y.jsx("use", {
          href: "#cursor",
          color: r
        })
      }), s ? y.jsxs(y.Fragment, {
        children: [o && y.jsx("div", {
          className: "tl-nametag-title",
          style: {
            color: r
          },
          children: o
        }), y.jsx("div", {
          className: "tl-nametag-chat",
          style: {
            backgroundColor: r
          },
          children: s
        })]
      }) : o && y.jsx("div", {
        className: "tl-nametag",
        style: {
          backgroundColor: r
        },
        children: o
      })]
    }) : null
  },
  WP = g.memo(pV),
  nv = {
    openWindow: (t, e) => window.open(t, e, "noopener noreferrer"),
    refreshPage: () => window.location.reload(),
    hardReset: async () => {
      var t;
      return await ((t = window.__tldraw__hardReset) == null ? void 0 : t.call(window))
    }
  };

function O0e(t) {
  Object.assign(nv, t)
}

function qA() {
  nv.hardReset()
}

function gV() {
  nv.refreshPage()
}
const mV = "https://github.com/tldraw/tldraw/issues/new";

function yV() {}
const b1 = ({
    error: t,
    editor: e
  }) => {
    const n = g.useRef(null),
      [r, o] = g.useState(!1),
      [s, i] = g.useState(!1),
      [a, c] = g.useState(!1),
      l = t instanceof Error ? t.message : String(t),
      u = t instanceof Error ? t.stack : null,
      d = te("isDarkMode", () => {
        try {
          if (e) return e.user.isDarkMode
        } catch {}
        return null
      }, [e]),
      [f, h] = g.useState(null);
    g.useLayoutEffect(() => {
      var S;
      d !== null && h(d);
      let v = (S = n.current) == null ? void 0 : S.parentElement,
        _ = !1;
      for (; v;) {
        if (v.classList.contains("tl-theme__dark") || v.classList.contains("tl-theme__light")) {
          _ = !0;
          break
        }
        v = v.parentElement
      }
      if (_) {
        h(null);
        return
      }
      h(window.matchMedia("(prefers-color-scheme: dark)").matches)
    }, [d]), g.useEffect(() => {
      if (s) {
        const v = setTimeout(() => {
          i(!1)
        }, 2e3);
        return () => clearTimeout(v)
      }
    }, [s]);
    const m = () => {
        const v = document.createElement("textarea");
        v.value = u ?? l, document.body.appendChild(v), v.select(), document.execCommand("copy"), v.remove(), i(!0)
      },
      p = () => {
        gV()
      },
      b = async () => {
        qA()
      }, w = new URL(mV);
    return w.searchParams.set("title", l), w.searchParams.set("labels", "bug"), w.searchParams.set("body", `Hey, I ran into an error while using tldraw:

\`\`\`js
${u??l}
\`\`\`

My browser: ${navigator.userAgent}`), y.jsxs("div", {
      ref: n,
      className: ae("tl-container tl-error-boundary", f === null ? "" : f ? "tl-theme__dark" : "tl-theme__light"),
      children: [y.jsx("div", {
        className: "tl-error-boundary__overlay"
      }), e && y.jsx(GA, {
        onError: yV,
        fallback: () => null,
        children: y.jsx(y1.Provider, {
          value: e,
          children: y.jsx("div", {
            className: "tl-overlay tl-error-boundary__canvas",
            children: y.jsx(y3, {})
          })
        })
      }), y.jsx("div", {
        className: ae("tl-modal", "tl-error-boundary__content", {
          "tl-error-boundary__content__expanded": r && !a
        }),
        children: a ? y.jsxs(y.Fragment, {
          children: [y.jsx("h2", {
            children: "Are you sure?"
          }), y.jsx("p", {
            children: "Resetting your data will delete your drawing and cannot be undone."
          }), y.jsxs("div", {
            className: "tl-error-boundary__content__actions",
            children: [y.jsx("button", {
              onClick: () => c(!1),
              children: "Cancel"
            }), y.jsx("button", {
              className: "tl-error-boundary__reset",
              onClick: b,
              children: "Reset data"
            })]
          })]
        }) : y.jsxs(y.Fragment, {
          children: [y.jsx("h2", {
            children: "Something's gone wrong."
          }), y.jsxs("p", {
            children: ["Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ", y.jsx("a", {
              href: w.toString(),
              children: "create a GitHub issue"
            }), " or", " ", y.jsx("a", {
              href: "https://discord.gg/Cq6cPsTfNy",
              children: "ask for help on Discord"
            }), "."]
          }), r && y.jsxs("div", {
            className: "tl-error-boundary__content__error",
            children: [y.jsx("pre", {
              children: y.jsx("code", {
                children: u ?? l
              })
            }), y.jsx("button", {
              onClick: m,
              children: s ? "Copied!" : "Copy"
            })]
          }), y.jsxs("div", {
            className: "tl-error-boundary__content__actions",
            children: [y.jsx("button", {
              onClick: () => o(!r),
              children: r ? "Hide details" : "Show details"
            }), y.jsxs("div", {
              className: "tl-error-boundary__content__actions__group",
              children: [y.jsx("button", {
                className: "tl-error-boundary__reset",
                onClick: () => c(!0),
                children: "Reset data"
              }), y.jsx("button", {
                className: "tl-error-boundary__refresh",
                onClick: p,
                children: "Refresh Page"
              })]
            })]
          })]
        })
      })]
    })
  },
  Qo = 2e3,
  Rm = 40,
  R0e = 80,
  Os = 320,
  Ic = [.1, .25, .5, 1, 2, 4, 8],
  cd = .1,
  qc = 8,
  vV = .5,
  bV = .1,
  wV = .2,
  SV = .005,
  _V = .05,
  xV = 450,
  EV = 200,
  NS = 6,
  LS = 4,
  kV = 32,
  FS = {};
for (let t = 1; t <= Math.ceil(qc); t++) FS[t + "_dark"] = `hash_pattern_zoom_${t}_dark`, FS[t + "_light"] = `hash_pattern_zoom_${t}_light`;
const CV = {
    duration: 0,
    easing: Vi.easeInOutCubic
  },
  V0 = .09,
  KP = [{
    min: -1,
    mid: .15,
    step: 64
  }, {
    min: .05,
    mid: .375,
    step: 16
  }, {
    min: .15,
    mid: 1,
    step: 4
  }, {
    min: .7,
    mid: 2.5,
    step: 1
  }],
  PV = 6e4,
  XA = 3e3,
  TV = 1200,
  GP = {
    CAMERA_MOVE: -10
  },
  $V = 64,
  IV = 620,
  OV = 8,
  RV = ({
    x: t,
    y: e,
    z: n,
    size: r
  }) => y.jsxs("svg", {
    className: "tl-grid",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    children: [y.jsx("defs", {
      children: KP.map(({
        min: o,
        mid: s,
        step: i
      }, a) => {
        const c = i * r * n,
          l = .5 + t * n,
          u = .5 + e * n,
          d = l > 0 ? l % c : c + l % c,
          f = u > 0 ? u % c : c + u % c,
          h = n < s ? Em(n, [o, s], [0, 1]) : 1;
        return y.jsx("pattern", {
          id: `grid-${i}`,
          width: c,
          height: c,
          patternUnits: "userSpaceOnUse",
          children: y.jsx("circle", {
            className: "tl-grid-dot",
            cx: d,
            cy: f,
            r: 1,
            opacity: h
          })
        }, `grid-pattern-${a}`)
      })
    }), KP.map(({
      step: o
    }, s) => y.jsx("rect", {
      width: "100%",
      height: "100%",
      fill: `url(#grid-${o})`
    }, `grid-rect-${s}`))]
  }),
  AV = ({
    handle: t,
    isCoarse: e,
    className: n,
    zoom: r
  }) => {
    const o = (e ? 20 : 12) / r,
      s = (t.type === "create" && e ? 3 : 4) / r;
    return y.jsxs("g", {
      className: ae("tl-handle", {
        "tl-handle__virtual": t.type === "virtual",
        "tl-handle__create": t.type === "create"
      }, n),
      children: [y.jsx("circle", {
        className: "tl-handle__bg",
        r: o
      }), y.jsx("circle", {
        className: "tl-handle__fg",
        r: s
      })]
    })
  },
  MV = ({
    children: t
  }) => y.jsx("svg", {
    className: "tl-user-handles tl-overlays__item",
    children: t
  }),
  jV = ({
    shapeId: t
  }) => y.jsx(ev, {
    className: "tl-user-indicator__hovered",
    id: t
  });

function ZA(t, e = !0) {
  const n = t.length;
  if (n < 2) return "";
  let r = t[0],
    o = t[1];
  if (n === 2) return `M${Jr(r)}L${Jr(o)}`;
  let s = "";
  for (let i = 2, a = n - 1; i < a; i++) r = t[i], o = t[i + 1], s += Qr(r, o);
  return e ? `M${Qr(t[0],t[1])}Q${Jr(t[1])}${Qr(t[1],t[2])}T${s}${Qr(t[n-1],t[0])}${Qr(t[0],t[1])}Z` : `M${Jr(t[0])}Q${Jr(t[1])}${Qr(t[1],t[2])}${t.length>3?"T":""}${s}L${Jr(t[n-1])}`
}
const YP = ({
    scribble: t,
    zoom: e,
    color: n,
    opacity: r,
    className: o
  }) => t.points.length ? y.jsx("svg", {
    className: o && ae("tl-overlays__item", o),
    children: y.jsx("path", {
      className: "tl-scribble",
      d: ZA(t.points, !1),
      stroke: n ?? `var(--color-${t.color})`,
      fill: "none",
      strokeWidth: 8 / e,
      opacity: r ?? t.opacity
    })
  }) : null,
  DV = ({
    bounds: t,
    rotation: e
  }) => {
    const n = g.useRef(null);
    return _u(n, t.x, t.y, 1, e), g.useLayoutEffect(() => {
      const r = n.current;
      r && (r.style.width = U(Math.max(1, t.width)) + "px", r.style.height = U(Math.max(1, t.height)) + "px")
    }, [t.width, t.height]), y.jsx("div", {
      ref: n,
      className: "tl-selection__bg",
      draggable: !1
    })
  },
  NV = ({
    bounds: t,
    rotation: e
  }) => {
    const n = Y(),
      r = g.useRef(null),
      o = te("only selected shape", () => n.getOnlySelectedShape(), [n]),
      s = o ? n.getShapeUtil(o).expandSelectionOutlinePx(o) : 0;
    return _u(r, t == null ? void 0 : t.x, t == null ? void 0 : t.y, 1, e, {
      x: -s,
      y: -s
    }), t = t.clone().expandBy(s).zeroFix(), y.jsx("svg", {
      ref: r,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: y.jsx("rect", {
        className: ae("tl-selection__fg__outline"),
        width: U(t.width),
        height: U(t.height)
      })
    })
  },
  LV = () => y.jsx("div", {
    className: "tl-shape-error-boundary"
  }),
  FV = () => y.jsx("circle", {
    cx: 4,
    cy: 4,
    r: 8,
    strokeWidth: "1",
    stroke: "red"
  });

function BV({
  points: t,
  zoom: e
}) {
  const n = 2.5 / e,
    r = t.reduce((f, h) => Math.min(f, h.x), 1 / 0),
    o = t.reduce((f, h) => Math.max(f, h.x), -1 / 0),
    s = t.reduce((f, h) => Math.min(f, h.y), 1 / 0),
    i = t.reduce((f, h) => Math.max(f, h.y), -1 / 0),
    a = t.some(f => f.x === r && f.y === s);
  let c, l, u, d;
  return a ? (c = r, l = s, u = o, d = i) : (c = r, l = i, u = o, d = s), y.jsxs("g", {
    className: "tl-snap-line",
    children: [y.jsx("line", {
      x1: c,
      y1: l,
      x2: u,
      y2: d
    }), t.map((f, h) => y.jsx("g", {
      transform: `translate(${f.x},${f.y})`,
      children: y.jsx("path", {
        className: "tl-snap-point",
        d: `M ${-n},${-n} L ${n},${n} M ${-n},${n} L ${n},${-n}`
      })
    }, h))]
  })
}

function UV({
  gaps: t,
  direction: e,
  zoom: n
}) {
  const r = 3.5 / n;
  let o = [-1 / 0, 1 / 0],
    s = null;
  const i = e === "horizontal";
  for (const c of t) {
    if (s = So(o[0], o[1], i ? c.startEdge[0].y : c.startEdge[0].x, i ? c.startEdge[1].y : c.startEdge[1].x), s) o = s;
    else continue;
    if (s = So(o[0], o[1], i ? c.endEdge[0].y : c.endEdge[0].x, i ? c.endEdge[1].y : c.endEdge[1].x), s) o = s;
    else continue
  }
  if (o === null) return null;
  const a = (o[0] + o[1]) / 2;
  return y.jsx("g", {
    className: "tl-snap-line",
    children: t.map(({
      startEdge: c,
      endEdge: l
    }, u) => y.jsx(g.Fragment, {
      children: i ? y.jsxs(y.Fragment, {
        children: [y.jsx("line", {
          x1: c[0].x,
          y1: a - 2 * r,
          x2: c[1].x,
          y2: a + 2 * r
        }), y.jsx("line", {
          x1: l[0].x,
          y1: a - 2 * r,
          x2: l[1].x,
          y2: a + 2 * r
        }), y.jsx("line", {
          x1: c[0].x,
          y1: a,
          x2: l[0].x,
          y2: a
        }), y.jsx("line", {
          x1: (c[0].x + l[0].x) / 2,
          y1: a - r,
          x2: (c[0].x + l[0].x) / 2,
          y2: a + r
        })]
      }) : y.jsxs(y.Fragment, {
        children: [y.jsx("line", {
          x1: a - 2 * r,
          y1: c[0].y,
          x2: a + 2 * r,
          y2: c[1].y
        }), y.jsx("line", {
          x1: a - 2 * r,
          y1: l[0].y,
          x2: a + 2 * r,
          y2: l[1].y
        }), y.jsx("line", {
          x1: a,
          y1: c[0].y,
          x2: a,
          y2: l[0].y
        }), y.jsx("line", {
          x1: a - r,
          y1: (c[0].y + l[0].y) / 2,
          x2: a + r,
          y2: (c[0].y + l[0].y) / 2
        })]
      })
    }, u))
  })
}
const zV = ({
    className: t,
    line: e,
    zoom: n
  }) => y.jsx("svg", {
    className: ae("tl-overlays__item", t),
    children: e.type === "points" ? y.jsx(BV, {
      ...e,
      zoom: n
    }) : e.type === "gaps" ? y.jsx(UV, {
      ...e,
      zoom: n
    }) : null
  }),
  HV = () => y.jsx("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    children: y.jsxs("g", {
      strokeWidth: 2,
      fill: "none",
      fillRule: "evenodd",
      children: [y.jsx("circle", {
        strokeOpacity: .25,
        cx: 8,
        cy: 8,
        r: 7,
        stroke: "var(--color-text-1)"
      }), y.jsx("path", {
        strokeLinecap: "round",
        d: "M15 8c0-4.5-4.5-7-7-7",
        stroke: "var(--color-text-1)",
        children: y.jsx("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          from: "0 8 8",
          to: "360 8 8",
          dur: "1s",
          repeatCount: "indefinite"
        })
      })]
    })
  }),
  VV = () => null,
  JA = g.createContext({});

function WV({
  overrides: t,
  children: e
}) {
  return y.jsx(JA.Provider, {
    value: g.useMemo(() => ({
      Background: rV,
      SvgDefs: VV,
      Brush: H0,
      ZoomBrush: H0,
      CollaboratorBrush: H0,
      Cursor: WP,
      CollaboratorCursor: WP,
      CollaboratorHint: hV,
      CollaboratorShapeIndicator: ev,
      Grid: RV,
      Scribble: YP,
      SnapLine: zV,
      Handles: MV,
      Handle: AV,
      CollaboratorScribble: YP,
      ErrorFallback: b1,
      ShapeErrorFallback: LV,
      ShapeIndicatorErrorFallback: FV,
      Spinner: HV,
      SelectionBackground: DV,
      SelectionForeground: NV,
      HoveredShapeIndicator: jV,
      OnTheCanvas: null,
      InFrontOfTheCanvas: null,
      ...t
    }), [t]),
    children: e
  })
}

function yn() {
  return g.useContext(JA)
}
const KV = ["textarea", "input"];

function GV(t) {
  const e = Y();
  g.useEffect(() => {
    const n = t.current;
    if (!n) return;
    const r = o => {
      var s;
      if (o instanceof PointerEvent && o.pointerType === "pen") {
        o.isKilled = !0;
        const {
          target: i
        } = o;
        if (KV.includes((s = i.tagName) == null ? void 0 : s.toLocaleLowerCase()) || e.isIn("select.editing_shape")) return;
        at(o)
      }
    };
    return n.addEventListener("touchstart", r), n.addEventListener("touchend", r), () => {
      n.removeEventListener("touchstart", r), n.addEventListener("touchend", r)
    }
  }, [e, t])
}

function YV(t, e, n) {
  return Math.max(e, Math.min(t, n))
}
const $n = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t]
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]]
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]]
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1]
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1]
  }
};

function qP(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t)
}

function XP(t, e, n, r = .15) {
  return r === 0 ? YV(t, e, n) : t < e ? -qP(e - t, n - e, r) + e : t > n ? +qP(t - n, n - e, r) + n : t
}

function qV(t, [e, n], [r, o]) {
  const [
    [s, i],
    [a, c]
  ] = t;
  return [XP(e, s, i, r), XP(n, a, c, o)]
}

function XV(t, e) {
  if (typeof t != "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(t)
}

function ZV(t) {
  var e = XV(t, "string");
  return typeof e == "symbol" ? e : String(e)
}

function Fn(t, e, n) {
  return e = ZV(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t
}

function ZP(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable
    })), n.push.apply(n, r)
  }
  return n
}

function Ht(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ZP(Object(n), !0).forEach(function(r) {
      Fn(t, r, n[r])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ZP(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
    })
  }
  return t
}
const QA = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};

function JP(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : ""
}
const JV = ["enter", "leave"];

function QV(t = !1, e) {
  return t && !JV.includes(e)
}

function eW(t, e = "", n = !1) {
  const r = QA[t],
    o = r && r[e] || e;
  return "on" + JP(t) + JP(o) + (QV(n, o) ? "Capture" : "")
}
const tW = ["gotpointercapture", "lostpointercapture"];

function nW(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const r = tW.includes(e) ? "capturecapture" : "capture",
    o = !!~e.indexOf(r);
  return o && (e = e.replace("capture", "")), {
    device: e,
    capture: o,
    passive: n
  }
}

function rW(t, e = "") {
  const n = QA[t],
    r = n && n[e] || e;
  return t + r
}

function e3(t) {
  return "touches" in t
}

function oW(t) {
  return e3(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse"
}

function sW(t) {
  return Array.from(t.touches).filter(e => {
    var n, r;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (r = n.contains) === null || r === void 0 ? void 0 : r.call(n, e.target))
  })
}

function BS(t, e) {
  try {
    const n = e.clientX - t.clientX,
      r = e.clientY - t.clientY,
      o = (e.clientX + t.clientX) / 2,
      s = (e.clientY + t.clientY) / 2,
      i = Math.hypot(n, r);
    return {
      angle: -(Math.atan2(n, r) * 180) / Math.PI,
      distance: i,
      origin: [o, s]
    }
  } catch {}
  return null
}

function iW(t) {
  return sW(t).map(e => e.identifier)
}

function QP(t, e) {
  const [n, r] = Array.from(t.touches).filter(o => e.includes(o.identifier));
  return BS(n, r)
}
const eT = 40,
  tT = 800;

function t3(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: r
  } = t;
  return r === 1 ? (e *= eT, n *= eT) : r === 2 && (e *= tT, n *= tT), [e, n]
}

function aW(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: r,
      metaKey: o,
      ctrlKey: s
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: r,
      metaKey: o,
      ctrlKey: s
    })
  }
  return e
}

function Am(t, ...e) {
  return typeof t == "function" ? t(...e) : t
}

function cW() {}

function lW(...t) {
  return t.length === 0 ? cW : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t) e = n.apply(this, arguments) || e;
    return e
  }
}

function nT(t, e) {
  return Object.assign({}, e, t || {})
}
const uW = 32;
class n3 {
  constructor(e, n, r) {
    this.ctrl = e, this.args = n, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset())
  }
  get state() {
    return this.ctrl.state[this.key]
  }
  set state(e) {
    this.ctrl.state[this.key] = e
  }
  get shared() {
    return this.ctrl.state.shared
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key]
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key]
  }
  get config() {
    return this.ctrl.config[this.key]
  }
  get sharedConfig() {
    return this.ctrl.config.shared
  }
  get handler() {
    return this.ctrl.handlers[this.key]
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: r,
      args: o
    } = this;
    n[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [
      [-1 / 0, 1 / 0],
      [-1 / 0, 1 / 0]
    ], e.args = o, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0
  }
  start(e) {
    const n = this.state,
      r = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = r.from ? Am(r.from, n) : n.offset, n.offset = n.lastOffset, n.startTime = n.timeStamp = e.timeStamp)
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e)
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values
  }
  compute(e) {
    const {
      state: n,
      config: r,
      shared: o
    } = this;
    n.args = this.args;
    let s = 0;
    if (e && (n.event = e, r.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, o.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, o.locked = !!document.pointerLockElement, Object.assign(o, aW(e)), o.down = o.pressed = o.buttons % 2 === 1 || o.touches > 0, s = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const E = n._delta.map(Math.abs);
      $n.addTo(n._distance, E)
    }
    this.axisIntent && this.axisIntent(e);
    const [i, a] = n._movement, [c, l] = r.threshold, {
      _step: u,
      values: d
    } = n;
    if (r.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(i) >= c && d[0]), u[1] === !1 && (u[1] = Math.abs(a) >= l && d[1])) : (u[0] === !1 && (u[0] = Math.abs(i) >= c && Math.sign(i) * c), u[1] === !1 && (u[1] = Math.abs(a) >= l && Math.sign(a) * l)), n.intentional = u[0] !== !1 || u[1] !== !1, !n.intentional) return;
    const f = [0, 0];
    if (r.hasCustomTransform) {
      const [E, k] = d;
      f[0] = u[0] !== !1 ? E - u[0] : 0, f[1] = u[1] !== !1 ? k - u[1] : 0
    } else f[0] = u[0] !== !1 ? i - u[0] : 0, f[1] = u[1] !== !1 ? a - u[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(f);
    const h = n.offset,
      m = n._active && !n._blocked || n.active;
    m && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = o[this.ingKey] = n._active, e && (n.first && ("bounds" in r && (n._bounds = Am(r.bounds, n)), this.setup && this.setup()), n.movement = f, this.computeOffset()));
    const [p, b] = n.offset, [
      [w, v],
      [_, S]
    ] = n._bounds;
    n.overflow = [p < w ? -1 : p > v ? 1 : 0, b < _ ? -1 : b > S ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const x = n._active ? r.rubberband || [0, 0] : [0, 0];
    if (n.offset = qV(n._bounds, n.offset, x), n.delta = $n.sub(n.offset, h), this.computeMovement(), m && (!n.last || s > uW)) {
      n.delta = $n.sub(n.offset, h);
      const E = n.delta.map(Math.abs);
      $n.addTo(n.distance, E), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && s > 0 && (n.velocity = [E[0] / s, E[1] / s], n.timeDelta = s)
    }
  }
  emit() {
    const e = this.state,
      n = this.shared,
      r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents) return;
    const o = this.handler(Ht(Ht(Ht({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    o !== void 0 && (e.memo = o)
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean()
  }
}

function dW([t, e], n) {
  const r = Math.abs(t),
    o = Math.abs(e);
  if (r > o && r > n) return "x";
  if (o > r && o > n) return "y"
}
class fW extends n3 {
  constructor(...e) {
    super(...e), Fn(this, "aliasKey", "xy")
  }
  reset() {
    super.reset(), this.state.axis = void 0
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0]
  }
  computeOffset() {
    this.state.offset = $n.add(this.state.lastOffset, this.state.movement)
  }
  computeMovement() {
    this.state.movement = $n.sub(this.state.offset, this.state.lastOffset)
  }
  axisIntent(e) {
    const n = this.state,
      r = this.config;
    if (!n.axis && e) {
      const o = typeof r.axisThreshold == "object" ? r.axisThreshold[oW(e)] : r.axisThreshold;
      n.axis = dW(n._movement, o)
    }
    n._blocked = (r.lockDirection || !!r.axis) && !n.axis || !!r.axis && r.axis !== n.axis
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection) switch (this.state.axis) {
      case "x":
        e[1] = 0;
        break;
      case "y":
        e[0] = 0;
        break
    }
  }
}
const hW = t => t,
  rT = .15,
  r3 = {
    enabled(t = !0) {
      return t
    },
    eventOptions(t, e, n) {
      return Ht(Ht({}, n.shared.eventOptions), t)
    },
    preventDefault(t = !1) {
      return t
    },
    triggerAllEvents(t = !1) {
      return t
    },
    rubberband(t = 0) {
      switch (t) {
        case !0:
          return [rT, rT];
        case !1:
          return [0, 0];
        default:
          return $n.toVector(t)
      }
    },
    from(t) {
      if (typeof t == "function") return t;
      if (t != null) return $n.toVector(t)
    },
    transform(t, e, n) {
      const r = t || n.shared.transform;
      return this.hasCustomTransform = !!r, r || hW
    },
    threshold(t) {
      return $n.toVector(t, 0)
    }
  },
  pW = 0,
  xh = Ht(Ht({}, r3), {}, {
    axis(t, e, {
      axis: n
    }) {
      if (this.lockDirection = n === "lock", !this.lockDirection) return n
    },
    axisThreshold(t = pW) {
      return t
    },
    bounds(t = {}) {
      if (typeof t == "function") return s => xh.bounds(t(s));
      if ("current" in t) return () => t.current;
      if (typeof HTMLElement == "function" && t instanceof HTMLElement) return t;
      const {
        left: e = -1 / 0,
        right: n = 1 / 0,
        top: r = -1 / 0,
        bottom: o = 1 / 0
      } = t;
      return [
        [e, n],
        [r, o]
      ]
    }
  }),
  Eh = typeof window < "u" && window.document && window.document.createElement;

function gW() {
  return Eh && "ontouchstart" in window
}

function oT() {
  return gW() || Eh && window.navigator.maxTouchPoints > 1
}

function mW() {
  return Eh && "onpointerdown" in window
}

function yW() {
  return Eh && "exitPointerLock" in window.document
}

function vW() {
  try {
    return "constructor" in GestureEvent
  } catch {
    return !1
  }
}
const to = {
    isBrowser: Eh,
    gesture: vW(),
    touch: oT(),
    touchscreen: oT(),
    pointer: mW(),
    pointerLock: yW()
  },
  bW = 250,
  wW = 180,
  SW = .5,
  _W = 50,
  xW = 250,
  EW = 10,
  sT = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
Ht(Ht({}, xh), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: r = !1,
      mouse: o = !1
    } = {}
  }) {
    return this.pointerLock = r && to.pointerLock, to.touch && n ? "touch" : this.pointerLock ? "mouse" : to.pointer && !o ? "pointer" : to.touch ? "touch" : "mouse"
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? bW : void 0, !(!to.touchscreen || n === !1)) return t || (n !== void 0 ? "y" : void 0)
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: r = 1,
      keys: o = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = o, !this.pointerLock && this.device === "pointer" && n
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: r = 3,
    axis: o = void 0
  }) {
    const s = $n.toVector(t, n ? r : o ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = r, s
  },
  swipe({
    velocity: t = SW,
    distance: e = _W,
    duration: n = xW
  } = {}) {
    return {
      velocity: this.transform($n.toVector(t)),
      distance: this.transform($n.toVector(e)),
      duration: n
    }
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return wW;
      case !1:
        return 0;
      default:
        return t
    }
  },
  axisThreshold(t) {
    return t ? Ht(Ht({}, sT), t) : sT
  },
  keyboardDisplacement(t = EW) {
    return t
  }
});

function o3(t) {
  const [e, n] = t.overflow, [r, o] = t._delta, [s, i] = t._direction;
  (e < 0 && r > 0 && s < 0 || e > 0 && r < 0 && s > 0) && (t._movement[0] = t._movementBound[0]), (n < 0 && o > 0 && i < 0 || n > 0 && o < 0 && i > 0) && (t._movement[1] = t._movementBound[1])
}
const kW = 30,
  CW = 100;
class PW extends n3 {
  constructor(...e) {
    super(...e), Fn(this, "ingKey", "pinching"), Fn(this, "aliasKey", "da")
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = new Map
  }
  reset() {
    super.reset();
    const e = this.state;
    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0
  }
  computeOffset() {
    const {
      type: e,
      movement: n,
      lastOffset: r
    } = this.state;
    e === "wheel" ? this.state.offset = $n.add(n, r) : this.state.offset = [(1 + n[0]) * r[0], n[1] + r[1]]
  }
  computeMovement() {
    const {
      offset: e,
      lastOffset: n
    } = this.state;
    this.state.movement = [e[0] / n[0], e[1] - n[1]]
  }
  axisIntent() {
    const e = this.state,
      [n, r] = e._movement;
    if (!e.axis) {
      const o = Math.abs(n) * kW - Math.abs(r);
      o < 0 ? e.axis = "angle" : o > 0 && (e.axis = "scale")
    }
  }
  restrictToAxis(e) {
    this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0))
  }
  cancel() {
    const e = this.state;
    e.canceled || setTimeout(() => {
      e.canceled = !0, e._active = !1, this.compute(), this.emit()
    }, 0)
  }
  touchStart(e) {
    this.ctrl.setEventIds(e);
    const n = this.state,
      r = this.ctrl.touchIds;
    if (n._active && n._touchIds.every(s => r.has(s)) || r.size < 2) return;
    this.start(e), n._touchIds = Array.from(r).slice(0, 2);
    const o = QP(e, n._touchIds);
    o && this.pinchStart(e, o)
  }
  pointerStart(e) {
    if (e.buttons != null && e.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
    const n = this.state,
      r = n._pointerEvents,
      o = this.ctrl.pointerIds;
    if (n._active && Array.from(r.keys()).every(i => o.has(i)) || (r.size < 2 && r.set(e.pointerId, e), n._pointerEvents.size < 2)) return;
    this.start(e);
    const s = BS(...Array.from(r.values()));
    s && this.pinchStart(e, s)
  }
  pinchStart(e, n) {
    const r = this.state;
    r.origin = n.origin, this.computeValues([n.distance, n.angle]), this.computeInitial(), this.compute(e), this.emit()
  }
  touchMove(e) {
    if (!this.state._active) return;
    const n = QP(e, this.state._touchIds);
    n && this.pinchMove(e, n)
  }
  pointerMove(e) {
    const n = this.state._pointerEvents;
    if (n.has(e.pointerId) && n.set(e.pointerId, e), !this.state._active) return;
    const r = BS(...Array.from(n.values()));
    r && this.pinchMove(e, r)
  }
  pinchMove(e, n) {
    const r = this.state,
      o = r._values[1],
      s = n.angle - o;
    let i = 0;
    Math.abs(s) > 270 && (i += Math.sign(s)), this.computeValues([n.distance, n.angle - 360 * i]), r.origin = n.origin, r.turns = i, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit()
  }
  touchEnd(e) {
    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some(n => !this.ctrl.touchIds.has(n)) && (this.state._active = !1, this.compute(e), this.emit())
  }
  pointerEnd(e) {
    const n = this.state;
    this.ctrl.setEventIds(e);
    try {
      e.target.releasePointerCapture(e.pointerId)
    } catch {}
    n._pointerEvents.has(e.pointerId) && n._pointerEvents.delete(e.pointerId), n._active && n._pointerEvents.size < 2 && (n._active = !1, this.compute(e), this.emit())
  }
  gestureStart(e) {
    e.cancelable && e.preventDefault();
    const n = this.state;
    n._active || (this.start(e), this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY], this.compute(e), this.emit())
  }
  gestureMove(e) {
    if (e.cancelable && e.preventDefault(), !this.state._active) return;
    const n = this.state;
    this.computeValues([e.scale, e.rotation]), n.origin = [e.clientX, e.clientY];
    const r = n._movement;
    n._movement = [e.scale - 1, e.rotation], n._delta = $n.sub(n._movement, r), this.compute(e), this.emit()
  }
  gestureEnd(e) {
    this.state._active && (this.state._active = !1, this.compute(e), this.emit())
  }
  wheel(e) {
    const n = this.config.modifierKey;
    n && !e[n] || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)))
  }
  wheelStart(e) {
    this.start(e), this.wheelChange(e)
  }
  wheelChange(e) {
    "uv" in e || e.cancelable && e.preventDefault();
    const r = this.state;
    r._delta = [-t3(e)[1] / CW * r.offset[0], 0], $n.addTo(r._movement, r._delta), o3(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit()
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit())
  }
  bind(e) {
    const n = this.config.device;
    n && (e(n, "start", this[n + "Start"].bind(this)), e(n, "change", this[n + "Move"].bind(this)), e(n, "end", this[n + "End"].bind(this)), e(n, "cancel", this[n + "End"].bind(this)), e("lostPointerCapture", "", this[n + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
      passive: !1
    })
  }
}
const TW = Ht(Ht({}, r3), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (n.target && !to.touch && to.gesture) return "gesture";
    if (to.touch && r) return "touch";
    if (to.touchscreen) {
      if (to.pointer) return "pointer";
      if (to.touch) return "touch"
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: r = {}
  }) {
    const o = i => {
        const a = nT(Am(n, i), {
          min: -1 / 0,
          max: 1 / 0
        });
        return [a.min, a.max]
      },
      s = i => {
        const a = nT(Am(r, i), {
          min: -1 / 0,
          max: 1 / 0
        });
        return [a.min, a.max]
      };
    return typeof n != "function" && typeof r != "function" ? [o(), s()] : i => [o(i), s(i)]
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", $n.toVector(t, this.lockDirection ? [.1, 3] : 0)
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t
  },
  pinchOnWheel(t = !0) {
    return t
  }
});
Ht(Ht({}, xh), {}, {
  mouseOnly: (t = !0) => t
});
class $W extends fW {
  constructor(...e) {
    super(...e), Fn(this, "ingKey", "wheeling")
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this))
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = t3(e), $n.addTo(n._movement, n._delta), o3(n), this.compute(e), this.emit()
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit())
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this))
  }
}
const IW = xh;
Ht(Ht({}, xh), {}, {
  mouseOnly: (t = !0) => t
});
const w1 = new Map,
  US = new Map;

function OW(t) {
  w1.set(t.key, t.engine), US.set(t.key, t.resolver)
}
const RW = {
    key: "pinch",
    engine: PW,
    resolver: TW
  },
  AW = {
    key: "wheel",
    engine: $W,
    resolver: IW
  };

function MW(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    o, s;
  for (s = 0; s < r.length; s++) o = r[s], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n
}

function jW(t, e) {
  if (t == null) return {};
  var n = MW(t, e),
    r, o;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (o = 0; o < s.length; o++) r = s[o], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
  }
  return n
}
const DW = {
    target(t) {
      if (t) return () => "current" in t ? t.current : t
    },
    enabled(t = !0) {
      return t
    },
    window(t = to.isBrowser ? window : void 0) {
      return t
    },
    eventOptions({
      passive: t = !0,
      capture: e = !1
    } = {}) {
      return {
        passive: t,
        capture: e
      }
    },
    transform(t) {
      return t
    }
  },
  NW = ["target", "eventOptions", "window", "enabled", "transform"];

function Og(t = {}, e) {
  const n = {};
  for (const [r, o] of Object.entries(e)) switch (typeof o) {
    case "function":
      n[r] = o.call(n, t[r], r, t);
      break;
    case "object":
      n[r] = Og(t[r], o);
      break;
    case "boolean":
      o && (n[r] = t[r]);
      break
  }
  return n
}

function LW(t, e, n = {}) {
  const r = t,
    {
      target: o,
      eventOptions: s,
      window: i,
      enabled: a,
      transform: c
    } = r,
    l = jW(r, NW);
  if (n.shared = Og({
      target: o,
      eventOptions: s,
      window: i,
      enabled: a,
      transform: c
    }, DW), e) {
    const u = US.get(e);
    n[e] = Og(Ht({
      shared: n.shared
    }, l), u)
  } else
    for (const u in l) {
      const d = US.get(u);
      d && (n[u] = Og(Ht({
        shared: n.shared
      }, l[u]), d))
    }
  return n
}
class s3 {
  constructor(e, n) {
    Fn(this, "_listeners", new Set), this._ctrl = e, this._gestureKey = n
  }
  add(e, n, r, o, s) {
    const i = this._listeners,
      a = rW(n, r),
      c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {},
      l = Ht(Ht({}, c), s);
    e.addEventListener(a, o, l);
    const u = () => {
      e.removeEventListener(a, o, l), i.delete(u)
    };
    return i.add(u), u
  }
  clean() {
    this._listeners.forEach(e => e()), this._listeners.clear()
  }
}
class FW {
  constructor() {
    Fn(this, "_timeouts", new Map)
  }
  add(e, n, r = 140, ...o) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, r, ...o))
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n)
  }
  clean() {
    this._timeouts.forEach(e => void window.clearTimeout(e)), this._timeouts.clear()
  }
}
class BW {
  constructor(e) {
    Fn(this, "gestures", new Set), Fn(this, "_targetEventStore", new s3(this)), Fn(this, "gestureEventStores", {}), Fn(this, "gestureTimeoutStores", {}), Fn(this, "handlers", {}), Fn(this, "config", {}), Fn(this, "pointerIds", new Set), Fn(this, "touchIds", new Set), Fn(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), UW(this, e)
  }
  setEventIds(e) {
    if (e3(e)) return this.touchIds = new Set(iW(e)), this.touchIds;
    if ("pointerId" in e) return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n
  }
  applyConfig(e, n) {
    this.config = LW(e, n, this.config)
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures) this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean()
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean()
  }
  bind(...e) {
    const n = this.config.shared,
      r = {};
    let o;
    if (!(n.target && (o = n.target(), !o))) {
      if (n.enabled) {
        for (const i of this.gestures) {
          const a = this.config[i],
            c = iT(r, a.eventOptions, !!o);
          if (a.enabled) {
            const l = w1.get(i);
            new l(this, e, i).bind(c)
          }
        }
        const s = iT(r, n.eventOptions, !!o);
        for (const i in this.nativeHandlers) s(i, "", a => this.nativeHandlers[i](Ht(Ht({}, this.state.shared), {}, {
          event: a,
          args: e
        })), void 0, !0)
      }
      for (const s in r) r[s] = lW(...r[s]);
      if (!o) return r;
      for (const s in r) {
        const {
          device: i,
          capture: a,
          passive: c
        } = nW(s);
        this._targetEventStore.add(o, i, "", r[s], {
          capture: a,
          passive: c
        })
      }
    }
  }
}

function Oc(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new s3(t, e), t.gestureTimeoutStores[e] = new FW
}

function UW(t, e) {
  e.drag && Oc(t, "drag"), e.wheel && Oc(t, "wheel"), e.scroll && Oc(t, "scroll"), e.move && Oc(t, "move"), e.pinch && Oc(t, "pinch"), e.hover && Oc(t, "hover")
}
const iT = (t, e, n) => (r, o, s, i = {}, a = !1) => {
    var c, l;
    const u = (c = i.capture) !== null && c !== void 0 ? c : e.capture,
      d = (l = i.passive) !== null && l !== void 0 ? l : e.passive;
    let f = a ? r : eW(r, o, u);
    n && d && (f += "Passive"), t[f] = t[f] || [], t[f].push(s)
  },
  zW = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;

function HW(t) {
  const e = {},
    n = {},
    r = new Set;
  for (let o in t) zW.test(o) ? (r.add(RegExp.lastMatch), n[o] = t[o]) : e[o] = t[o];
  return [n, e, r]
}

function Rc(t, e, n, r, o, s) {
  if (!t.has(n) || !w1.has(r)) return;
  const i = n + "Start",
    a = n + "End",
    c = l => {
      let u;
      return l.first && i in e && e[i](l), n in e && (u = e[n](l)), l.last && a in e && e[a](l), u
    };
  o[r] = c, s[r] = s[r] || {}
}

function VW(t, e) {
  const [n, r, o] = HW(t), s = {};
  return Rc(o, n, "onDrag", "drag", s, e), Rc(o, n, "onWheel", "wheel", s, e), Rc(o, n, "onScroll", "scroll", s, e), Rc(o, n, "onPinch", "pinch", s, e), Rc(o, n, "onMove", "move", s, e), Rc(o, n, "onHover", "hover", s, e), {
    handlers: s,
    config: e,
    nativeHandlers: r
  }
}

function WW(t, e = {}, n, r) {
  const o = se.useMemo(() => new BW(t), []);
  if (o.applyHandlers(t, r), o.applyConfig(e, n), se.useEffect(o.effect.bind(o)), se.useEffect(() => o.clean.bind(o), []), e.target === void 0) return o.bind.bind(o)
}

function KW(t) {
  return t.forEach(OW),
    function(n, r) {
      const {
        handlers: o,
        nativeHandlers: s,
        config: i
      } = VW(n, r || {});
      return WW(o, i, void 0, s)
    }
}
const aT = 10,
  GW = /Mac|iPod|iPhone|iPad/.test(typeof window > "u" ? "node" : window.navigator.platform);

function i3(t) {
  let {
    deltaY: e,
    deltaX: n
  } = t, r = 0;
  if (t.ctrlKey || t.altKey || t.metaKey) {
    const o = Math.sign(t.deltaY),
      s = Math.abs(t.deltaY);
    let i = e;
    s > aT && (i = aT * o), r = i / 100
  } else t.shiftKey && !GW && (n = e, e = 0);
  return {
    x: -n,
    y: -e,
    z: -r
  }
}
const YW = KW([AW, RW]);
let Ac;
const qW = t => Ac === void 0 ? (Ac = t, !1) : t - Ac > 120 && t - Ac < 160 ? (Ac = t, !0) : (Ac = t, !1);

function XW(t) {
  const e = Y(),
    n = g.useMemo(() => {
      let r = "not sure";
      const o = ({
        event: p
      }) => {
        if (!e.getInstanceState().isFocused || (r = "not sure", qW(Date.now()))) return;
        const b = e.getEditingShapeId();
        if (b) {
          const S = e.getShape(b);
          if (S && e.getShapeUtil(S).canScroll(S)) {
            const E = e.getShapePageBounds(b);
            if (E != null && E.containsPoint(e.inputs.currentPagePoint)) return
          }
        }
        at(p);
        const w = i3(p);
        if (w.x === 0 && w.y === 0) return;
        const v = e.getContainer().getBoundingClientRect(),
          _ = {
            type: "wheel",
            name: "wheel",
            delta: w,
            point: new T(p.clientX, p.clientY).sub({
              x: v.left,
              y: v.top
            }),
            shiftKey: p.shiftKey,
            altKey: p.altKey,
            ctrlKey: p.metaKey || p.ctrlKey
          };
        e.dispatch(_)
      };
      let s = 1,
        i = 1,
        a = 1,
        c = 0;
      const l = new T,
        u = new T,
        d = p => {
          const b = t.current;
          r = "not sure";
          const {
            event: w,
            origin: v,
            da: _
          } = p;
          w instanceof WheelEvent || (w.target === b || b != null && b.contains(w.target)) && (u.x = v[0], u.y = v[1], l.x = v[0], l.y = v[1], s = _[0], i = e.zoomLevel, e.dispatch({
            type: "pinch",
            name: "pinch_start",
            point: {
              x: v[0],
              y: v[1],
              z: e.zoomLevel
            },
            delta: {
              x: 0,
              y: 0
            },
            shiftKey: w.shiftKey,
            altKey: w.altKey,
            ctrlKey: w.metaKey || w.ctrlKey
          }))
        },
        f = p => {
          if (p && (r = "zooming"), r === "zooming") return;
          const b = Math.abs(c - s),
            w = T.Dist(l, u);
          switch (r) {
            case "not sure": {
              b > 24 ? r = "zooming" : w > 16 && (r = "panning");
              break
            }
            case "panning": {
              b > 64 && (r = "zooming");
              break
            }
          }
        };
      return {
        onWheel: o,
        onPinchStart: d,
        onPinchEnd: p => {
          const b = t.current,
            {
              event: w,
              origin: v,
              offset: _
            } = p;
          if (w instanceof WheelEvent || !(w.target === b || b != null && b.contains(w.target))) return;
          const S = _[0];
          r = "not sure", requestAnimationFrame(() => {
            e.dispatch({
              type: "pinch",
              name: "pinch_end",
              point: {
                x: v[0],
                y: v[1],
                z: S
              },
              delta: {
                x: v[0],
                y: v[1]
              },
              shiftKey: w.shiftKey,
              altKey: w.altKey,
              ctrlKey: w.metaKey || w.ctrlKey
            })
          })
        },
        onPinch: p => {
          const b = t.current,
            {
              event: w,
              origin: v,
              offset: _,
              da: S
            } = p;
          if (w instanceof WheelEvent || !(w.target === b || b != null && b.contains(w.target))) return;
          const x = p.type === "gesturechange" || p.type === "gestureend";
          c = S[0];
          const E = v[0] - u.x,
            k = v[1] - u.y;
          switch (u.x = v[0], u.y = v[1], f(x), r) {
            case "zooming": {
              a = _[0], e.dispatch({
                type: "pinch",
                name: "pinch",
                point: {
                  x: v[0],
                  y: v[1],
                  z: a
                },
                delta: {
                  x: E,
                  y: k
                },
                shiftKey: w.shiftKey,
                altKey: w.altKey,
                ctrlKey: w.metaKey || w.ctrlKey
              });
              break
            }
            case "panning": {
              e.dispatch({
                type: "pinch",
                name: "pinch",
                point: {
                  x: v[0],
                  y: v[1],
                  z: i
                },
                delta: {
                  x: E,
                  y: k
                },
                shiftKey: w.shiftKey,
                altKey: w.altKey,
                ctrlKey: w.metaKey || w.ctrlKey
              });
              break
            }
          }
        }
      }
    }, [e, t]);
  YW(n, {
    target: t,
    eventOptions: {
      passive: !1
    },
    pinch: {
      from: () => [e.zoomLevel, 0],
      scaleBounds: () => ({
        from: e.zoomLevel,
        max: 8,
        min: .05
      })
    }
  })
}

function W0(t, e, n) {
  const r = t.getShape(e),
    o = t.getShapeHandles(r);
  return {
    shape: r,
    handle: o.find(s => s.id === n)
  }
}

function ZW(t, e) {
  const n = Y();
  return g.useMemo(() => {
    const r = c => {
      if (c.isKilled) return;
      const l = Om(c.currentTarget);
      Sh(l, c);
      const {
        shape: u,
        handle: d
      } = W0(n, t, e);
      d && n.dispatch({
        type: "pointer",
        target: "handle",
        handle: d,
        shape: u,
        name: "pointer_down",
        ...gr(c)
      })
    };
    let o, s;
    return {
      onPointerDown: r,
      onPointerMove: c => {
        if (c.isKilled || c.clientX === o && c.clientY === s) return;
        o = c.clientX, s = c.clientY;
        const {
          shape: l,
          handle: u
        } = W0(n, t, e);
        u && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: u,
          shape: l,
          name: "pointer_move",
          ...gr(c)
        })
      },
      onPointerUp: c => {
        if (c.isKilled) return;
        const l = Om(c.currentTarget);
        _h(l, c);
        const {
          shape: u,
          handle: d
        } = W0(n, t, e);
        d && n.dispatch({
          type: "pointer",
          target: "handle",
          handle: d,
          shape: u,
          name: "pointer_up",
          ...gr(c)
        })
      }
    }
  }, [n, t, e])
}
var a3 = "Expected a function",
  cT = 0 / 0,
  JW = "[object Symbol]",
  QW = /^\s+|\s+$/g,
  eK = /^[-+]0x[0-9a-f]+$/i,
  tK = /^0b[01]+$/i,
  nK = /^0o[0-7]+$/i,
  rK = parseInt,
  oK = typeof hn == "object" && hn && hn.Object === Object && hn,
  sK = typeof self == "object" && self && self.Object === Object && self,
  iK = oK || sK || Function("return this")(),
  aK = Object.prototype,
  cK = aK.toString,
  lK = Math.max,
  uK = Math.min,
  K0 = function() {
    return iK.Date.now()
  };

function dK(t, e, n) {
  var r, o, s, i, a, c, l = 0,
    u = !1,
    d = !1,
    f = !0;
  if (typeof t != "function") throw new TypeError(a3);
  e = lT(e) || 0, Mm(n) && (u = !!n.leading, d = "maxWait" in n, s = d ? lK(lT(n.maxWait) || 0, e) : s, f = "trailing" in n ? !!n.trailing : f);

  function h(E) {
    var k = r,
      C = o;
    return r = o = void 0, l = E, i = t.apply(C, k), i
  }

  function m(E) {
    return l = E, a = setTimeout(w, e), u ? h(E) : i
  }

  function p(E) {
    var k = E - c,
      C = E - l,
      $ = e - k;
    return d ? uK($, s - C) : $
  }

  function b(E) {
    var k = E - c,
      C = E - l;
    return c === void 0 || k >= e || k < 0 || d && C >= s
  }

  function w() {
    var E = K0();
    if (b(E)) return v(E);
    a = setTimeout(w, p(E))
  }

  function v(E) {
    return a = void 0, f && r ? h(E) : (r = o = void 0, i)
  }

  function _() {
    a !== void 0 && clearTimeout(a), l = 0, r = c = o = a = void 0
  }

  function S() {
    return a === void 0 ? i : v(K0())
  }

  function x() {
    var E = K0(),
      k = b(E);
    if (r = arguments, o = this, c = E, k) {
      if (a === void 0) return m(c);
      if (d) return a = setTimeout(w, e), h(c)
    }
    return a === void 0 && (a = setTimeout(w, e)), i
  }
  return x.cancel = _, x.flush = S, x
}

function fK(t, e, n) {
  var r = !0,
    o = !0;
  if (typeof t != "function") throw new TypeError(a3);
  return Mm(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), dK(t, e, {
    leading: r,
    maxWait: e,
    trailing: o
  })
}

function Mm(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function")
}

function hK(t) {
  return !!t && typeof t == "object"
}

function pK(t) {
  return typeof t == "symbol" || hK(t) && cK.call(t) == JW
}

function lT(t) {
  if (typeof t == "number") return t;
  if (pK(t)) return cT;
  if (Mm(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Mm(e) ? e + "" : e
  }
  if (typeof t != "string") return t === 0 ? t : +t;
  t = t.replace(QW, "");
  var n = tK.test(t);
  return n || nK.test(t) ? rK(t.slice(2), n ? 2 : 8) : eK.test(t) ? cT : +t
}
var gK = fK;
const mK = co(gK);

function yK() {
  const t = Y();
  g.useLayoutEffect(() => {
    const e = mK(() => {
      t.updateViewportScreenBounds()
    }, 200, {
      trailing: !0
    });
    t.updateViewportScreenBounds();
    const n = setInterval(e, 1e3);
    return window.addEventListener("resize", e), window.addEventListener("scroll", e), () => {
      clearInterval(n), window.removeEventListener("resize", e), window.removeEventListener("scroll", e)
    }
  }, [t])
}
const dt = class dt {
  constructor(e, n, r, o, s, i) {
    P(this, "a", 1);
    P(this, "b", 0);
    P(this, "c", 0);
    P(this, "d", 1);
    P(this, "e", 0);
    P(this, "f", 0);
    this.a = e, this.b = n, this.c = r, this.d = o, this.e = s, this.f = i
  }
  equals(e) {
    return this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.e === e.e && this.f === e.f
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this
  }
  multiply(e) {
    const n = e,
      {
        a: r,
        b: o,
        c: s,
        d: i,
        e: a,
        f: c
      } = this;
    return this.a = r * n.a + s * n.b, this.c = r * n.c + s * n.d, this.e = r * n.e + s * n.f + a, this.b = o * n.a + i * n.b, this.d = o * n.c + i * n.d, this.f = o * n.e + i * n.f + c, this
  }
  rotate(e, n, r) {
    return e === 0 ? this : n === void 0 ? this.multiply(dt.Rotate(e)) : this.translate(n, r).multiply(dt.Rotate(e)).translate(-n, -r)
  }
  translate(e, n) {
    return this.multiply(dt.Translate(e, n))
  }
  scale(e, n) {
    return this.multiply(dt.Scale(e, n))
  }
  invert() {
    const {
      a: e,
      b: n,
      c: r,
      d: o,
      e: s,
      f: i
    } = this, a = e * o - n * r;
    return this.a = o / a, this.b = n / -a, this.c = r / -a, this.d = e / a, this.e = (o * s - r * i) / -a, this.f = (n * s - e * i) / a, this
  }
  applyToPoint(e) {
    return dt.applyToPoint(this, e)
  }
  applyToPoints(e) {
    return dt.applyToPoints(this, e)
  }
  rotation() {
    return dt.Rotation(this)
  }
  point() {
    return dt.Point(this)
  }
  decomposed() {
    return dt.Decompose(this)
  }
  toCssString() {
    return dt.toCssString(this)
  }
  setTo(e) {
    return Object.assign(this, e), this
  }
  decompose() {
    return dt.Decompose(this)
  }
  clone() {
    return new dt(this.a, this.b, this.c, this.d, this.e, this.f)
  }
  static Identity() {
    return new dt(1, 0, 0, 1, 0, 0)
  }
  static Translate(e, n) {
    return new dt(1, 0, 0, 1, e, n)
  }
  static Rotate(e, n, r) {
    if (e === 0) return dt.Identity();
    const o = Math.cos(e),
      s = Math.sin(e),
      i = new dt(o, s, -s, o, 0, 0);
    return n === void 0 ? i : dt.Compose(dt.Translate(n, r), i, dt.Translate(-n, -r))
  }
  static Multiply(e, n) {
    return {
      a: e.a * n.a + e.c * n.b,
      c: e.a * n.c + e.c * n.d,
      e: e.a * n.e + e.c * n.f + e.e,
      b: e.b * n.a + e.d * n.b,
      d: e.b * n.c + e.d * n.d,
      f: e.b * n.e + e.d * n.f + e.f
    }
  }
  static Inverse(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / -n,
      f: (e.b * e.e - e.a * e.f) / n
    }
  }
  static Absolute(e) {
    const n = e.a * e.d - e.b * e.c;
    return {
      a: e.d / n,
      b: e.b / -n,
      c: e.c / -n,
      d: e.a / n,
      e: (e.d * e.e - e.c * e.f) / n,
      f: (e.b * e.e - e.a * e.f) / -n
    }
  }
  static Compose(...e) {
    const n = dt.Identity();
    for (let r = 0, o = e.length; r < o; r++) n.multiply(e[r]);
    return n
  }
  static Point(e) {
    return new T(e.e, e.f)
  }
  static Rotation(e) {
    let n;
    if (e.a !== 0 || e.c !== 0) {
      const r = Math.hypot(e.a, e.c);
      n = Math.acos(e.a / r) * (e.c > 0 ? -1 : 1)
    } else if (e.b !== 0 || e.d !== 0) {
      const r = Math.hypot(e.b, e.d);
      n = hr + Math.acos(e.b / r) * (e.d > 0 ? -1 : 1)
    } else n = 0;
    return DS(n)
  }
  static Decompose(e) {
    let n, r, o;
    if (e.a !== 0 || e.c !== 0) {
      const s = Math.hypot(e.a, e.c);
      n = s, r = (e.a * e.d - e.b * e.c) / s, o = Math.acos(e.a / s) * (e.c > 0 ? -1 : 1)
    } else if (e.b !== 0 || e.d !== 0) {
      const s = Math.hypot(e.b, e.d);
      n = (e.a * e.d - e.b * e.c) / s, r = s, o = hr + Math.acos(e.b / s) * (e.d > 0 ? -1 : 1)
    } else n = 0, r = 0, o = 0;
    return {
      x: e.e,
      y: e.f,
      scaleX: n,
      scaleY: r,
      rotation: DS(o)
    }
  }
  static Smooth(e, n = 1e10) {
    return e.a = Math.round(e.a * n) / n, e.b = Math.round(e.b * n) / n, e.c = Math.round(e.c * n) / n, e.d = Math.round(e.d * n) / n, e.e = Math.round(e.e * n) / n, e.f = Math.round(e.f * n) / n, e
  }
  static toCssString(e) {
    return `matrix(${U(e.a)}, ${U(e.b)}, ${U(e.c)}, ${U(e.d)}, ${U(e.e)}, ${U(e.f)})`
  }
  static applyToPoint(e, n) {
    return new T(e.a * n.x + e.c * n.y + e.e, e.b * n.x + e.d * n.y + e.f, n.z)
  }
  static applyToXY(e, n, r) {
    return [e.a * n + e.c * r + e.e, e.b * n + e.d * r + e.f]
  }
  static applyToPoints(e, n) {
    return n.map(r => new T(e.a * r.x + e.c * r.y + e.e, e.b * r.x + e.d * r.y + e.f, r.z))
  }
  static applyToBounds(e, n) {
    return new Be(e.e + n.minX, e.f + n.minY, n.width, n.height)
  }
  static From(e) {
    return new dt(e.a, e.b, e.c, e.d, e.e, e.f)
  }
  static Cast(e) {
    return e instanceof dt ? e : dt.From(e)
  }
};
P(dt, "Scale", (e, n, r, o) => {
  const s = new dt(e, 0, 0, 0, n, 0);
  return r === void 0 ? s : dt.Compose(dt.Translate(r, o), s, dt.Translate(-r, -o))
});
let Ee = dt;

function vK(t = !0) {
  const [e, n] = g.useState(0), r = Y();
  g.useEffect(() => {
    if (!t) return;
    const o = () => n(s => s + 1);
    return r.on("tick", o), () => {
      r.off("tick", o)
    }
  }, [r, t])
}
const bK = pt(function({
  showStroke: e = !0,
  showVertices: n = !0,
  showClosestPointOnOutline: r = !0
}) {
  const o = Y();
  vK(r);
  const {
    zoomLevel: s,
    renderingShapes: i,
    inputs: {
      currentPagePoint: a
    }
  } = o;
  return y.jsx("svg", {
    style: {
      position: "absolute",
      pointerEvents: "none",
      zIndex: 999999999,
      top: 0,
      left: 0,
      overflow: "visible"
    },
    children: i.map(c => {
      const l = o.getShape(c.id);
      if (l.type === "group") return null;
      const u = o.getShapeGeometry(l),
        d = o.getShapePageTransform(l),
        f = o.getPointInShapeSpace(l, a),
        h = u.nearestPoint(f),
        m = u.distanceToPoint(f, !0),
        p = Math.abs(m) * s,
        b = m < 0,
        {
          vertices: w
        } = u;
      return y.jsxs("g", {
        transform: d.toCssString(),
        strokeLinecap: "round",
        strokeLinejoin: "round",
        children: [e && y.jsx("path", {
          stroke: "red",
          strokeWidth: "2",
          fill: "none",
          opacity: "1",
          d: u.toSimpleSvgPath()
        }), n && w.map((v, _) => y.jsx("circle", {
          cx: v.x,
          cy: v.y,
          r: "2",
          fill: `hsl(${Em(_,[0,w.length-1],[120,200])}, 100%, 50%)`,
          stroke: "black",
          strokeWidth: "1"
        }, `v${_}`)), r && p < 150 && y.jsx("line", {
          x1: h.x,
          y1: h.y,
          x2: f.x,
          y2: f.y,
          opacity: 1 - p / 150,
          stroke: b ? "goldenrod" : "dodgerblue",
          strokeWidth: "2"
        })]
      }, c.id + "_outline")
    })
  })
});
var wK = 200,
  S1 = "__lodash_hash_undefined__",
  SK = 1 / 0,
  _K = "[object Function]",
  xK = "[object GeneratorFunction]",
  EK = /[\\^$.*+?()[\]{}|]/g,
  kK = /^\[object .+?Constructor\]$/,
  CK = typeof hn == "object" && hn && hn.Object === Object && hn,
  PK = typeof self == "object" && self && self.Object === Object && self,
  _1 = CK || PK || Function("return this")();

function TK(t, e) {
  var n = t ? t.length : 0;
  return !!n && OK(t, e, 0) > -1
}

function $K(t, e, n) {
  for (var r = -1, o = t ? t.length : 0; ++r < o;)
    if (n(e, t[r])) return !0;
  return !1
}

function IK(t, e, n, r) {
  for (var o = t.length, s = n + (r ? 1 : -1); r ? s-- : ++s < o;)
    if (e(t[s], s, t)) return s;
  return -1
}

function OK(t, e, n) {
  if (e !== e) return IK(t, RK, n);
  for (var r = n - 1, o = t.length; ++r < o;)
    if (t[r] === e) return r;
  return -1
}

function RK(t) {
  return t !== t
}

function AK(t, e) {
  return t.has(e)
}

function MK(t, e) {
  return t == null ? void 0 : t[e]
}

function jK(t) {
  var e = !1;
  if (t != null && typeof t.toString != "function") try {
    e = !!(t + "")
  } catch {}
  return e
}

function c3(t) {
  var e = -1,
    n = Array(t.size);
  return t.forEach(function(r) {
    n[++e] = r
  }), n
}
var DK = Array.prototype,
  NK = Function.prototype,
  l3 = Object.prototype,
  G0 = _1["__core-js_shared__"],
  uT = function() {
    var t = /[^.]+$/.exec(G0 && G0.keys && G0.keys.IE_PROTO || "");
    return t ? "Symbol(src)_1." + t : ""
  }(),
  u3 = NK.toString,
  x1 = l3.hasOwnProperty,
  LK = l3.toString,
  FK = RegExp("^" + u3.call(x1).replace(EK, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
  BK = DK.splice,
  UK = E1(_1, "Map"),
  Y0 = E1(_1, "Set"),
  Mf = E1(Object, "create");

function tc(t) {
  var e = -1,
    n = t ? t.length : 0;
  for (this.clear(); ++e < n;) {
    var r = t[e];
    this.set(r[0], r[1])
  }
}

function zK() {
  this.__data__ = Mf ? Mf(null) : {}
}

function HK(t) {
  return this.has(t) && delete this.__data__[t]
}

function VK(t) {
  var e = this.__data__;
  if (Mf) {
    var n = e[t];
    return n === S1 ? void 0 : n
  }
  return x1.call(e, t) ? e[t] : void 0
}

function WK(t) {
  var e = this.__data__;
  return Mf ? e[t] !== void 0 : x1.call(e, t)
}

function KK(t, e) {
  var n = this.__data__;
  return n[t] = Mf && e === void 0 ? S1 : e, this
}
tc.prototype.clear = zK;
tc.prototype.delete = HK;
tc.prototype.get = VK;
tc.prototype.has = WK;
tc.prototype.set = KK;

function xu(t) {
  var e = -1,
    n = t ? t.length : 0;
  for (this.clear(); ++e < n;) {
    var r = t[e];
    this.set(r[0], r[1])
  }
}

function GK() {
  this.__data__ = []
}

function YK(t) {
  var e = this.__data__,
    n = rv(e, t);
  if (n < 0) return !1;
  var r = e.length - 1;
  return n == r ? e.pop() : BK.call(e, n, 1), !0
}

function qK(t) {
  var e = this.__data__,
    n = rv(e, t);
  return n < 0 ? void 0 : e[n][1]
}

function XK(t) {
  return rv(this.__data__, t) > -1
}

function ZK(t, e) {
  var n = this.__data__,
    r = rv(n, t);
  return r < 0 ? n.push([t, e]) : n[r][1] = e, this
}
xu.prototype.clear = GK;
xu.prototype.delete = YK;
xu.prototype.get = qK;
xu.prototype.has = XK;
xu.prototype.set = ZK;

function Eu(t) {
  var e = -1,
    n = t ? t.length : 0;
  for (this.clear(); ++e < n;) {
    var r = t[e];
    this.set(r[0], r[1])
  }
}

function JK() {
  this.__data__ = {
    hash: new tc,
    map: new(UK || xu),
    string: new tc
  }
}

function QK(t) {
  return ov(this, t).delete(t)
}

function eG(t) {
  return ov(this, t).get(t)
}

function tG(t) {
  return ov(this, t).has(t)
}

function nG(t, e) {
  return ov(this, t).set(t, e), this
}
Eu.prototype.clear = JK;
Eu.prototype.delete = QK;
Eu.prototype.get = eG;
Eu.prototype.has = tG;
Eu.prototype.set = nG;

function jm(t) {
  var e = -1,
    n = t ? t.length : 0;
  for (this.__data__ = new Eu; ++e < n;) this.add(t[e])
}

function rG(t) {
  return this.__data__.set(t, S1), this
}

function oG(t) {
  return this.__data__.has(t)
}
jm.prototype.add = jm.prototype.push = rG;
jm.prototype.has = oG;

function rv(t, e) {
  for (var n = t.length; n--;)
    if (fG(t[n][0], e)) return n;
  return -1
}

function sG(t) {
  if (!d3(t) || lG(t)) return !1;
  var e = hG(t) || jK(t) ? FK : kK;
  return e.test(uG(t))
}

function iG(t, e, n) {
  var r = -1,
    o = TK,
    s = t.length,
    i = !0,
    a = [],
    c = a;
  if (n) i = !1, o = $K;
  else if (s >= wK) {
    var l = e ? null : aG(t);
    if (l) return c3(l);
    i = !1, o = AK, c = new jm
  } else c = e ? [] : a;
  e: for (; ++r < s;) {
    var u = t[r],
      d = e ? e(u) : u;
    if (u = n || u !== 0 ? u : 0, i && d === d) {
      for (var f = c.length; f--;)
        if (c[f] === d) continue e;
      e && c.push(d), a.push(u)
    } else o(c, d, n) || (c !== a && c.push(d), a.push(u))
  }
  return a
}
var aG = Y0 && 1 / c3(new Y0([, -0]))[1] == SK ? function(t) {
  return new Y0(t)
} : pG;

function ov(t, e) {
  var n = t.__data__;
  return cG(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map
}

function E1(t, e) {
  var n = MK(t, e);
  return sG(n) ? n : void 0
}

function cG(t) {
  var e = typeof t;
  return e == "string" || e == "number" || e == "symbol" || e == "boolean" ? t !== "__proto__" : t === null
}

function lG(t) {
  return !!uT && uT in t
}

function uG(t) {
  if (t != null) {
    try {
      return u3.call(t)
    } catch {}
    try {
      return t + ""
    } catch {}
  }
  return ""
}

function dG(t) {
  return t && t.length ? iG(t) : []
}

function fG(t, e) {
  return t === e || t !== t && e !== e
}

function hG(t) {
  var e = d3(t) ? LK.call(t) : "";
  return e == _K || e == xK
}

function d3(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function")
}

function pG() {}
var gG = dG;
const mG = co(gG);

function f3(t) {
  return mG(t)
}

function yG() {
  const t = Y(),
    e = g.useMemo(() => t.store.query.records("instance_presence", () => ({
      userId: {
        neq: t.user.id
      }
    })), [t]),
    n = EA("userIds", () => f3(e.get().map(r => r.userId)).sort(), {
      isEqual: (r, o) => {
        var s;
        return r.join(",") === ((s = o.join) == null ? void 0 : s.call(o, ","))
      }
    }, [e]);
  return te(n)
}

function h3(t) {
  const e = Y(),
    n = g.useMemo(() => e.store.query.records("instance_presence", () => ({
      userId: {
        eq: t
      }
    })), [e, t]);
  return te(`latestPresence:${t}`, () => n.get().slice().sort((o, s) => s.lastActivityTimestamp - o.lastActivityTimestamp)[0], []) ?? null
}
const vG = pt(function() {
    const e = yG();
    return y.jsx(y.Fragment, {
      children: e.map(n => y.jsx(bG, {
        collaboratorId: n
      }, n))
    })
  }),
  bG = pt(function({
    collaboratorId: e
  }) {
    const n = Y(),
      r = h3(e),
      o = SG(r);
    if (!(r && r.currentPageId === n.currentPageId)) return null;
    switch (o) {
      case "inactive": {
        const {
          followingUserId: s,
          highlightedUserIds: i
        } = n.getInstanceState();
        if (!(s === r.userId || i.includes(r.userId))) return null;
        break
      }
      case "idle": {
        const {
          highlightedUserIds: s
        } = n.getInstanceState();
        if (r.followingUserId === n.user.id && !(r.chatMessage || s.includes(r.userId))) return null;
        break
      }
    }
    return y.jsx(wG, {
      latestPresence: r
    })
  }),
  wG = pt(function({
    latestPresence: e
  }) {
    const n = Y(),
      {
        CollaboratorBrush: r,
        CollaboratorScribble: o,
        CollaboratorCursor: s,
        CollaboratorHint: i,
        CollaboratorShapeIndicator: a
      } = yn(),
      {
        viewportPageBounds: c,
        zoomLevel: l
      } = n,
      {
        userId: u,
        chatMessage: d,
        brush: f,
        scribbles: h,
        selectedShapeIds: m,
        userName: p,
        cursor: b,
        color: w
      } = e,
      v = !(b.x < c.minX - 12 / l || b.y < c.minY - 16 / l || b.x > c.maxX - 12 / l || b.y > c.maxY - 16 / l);
    return y.jsxs(y.Fragment, {
      children: [f && r ? y.jsx(r, {
        className: "tl-collaborator__brush",
        brush: f,
        color: w,
        opacity: .1
      }, u + "_brush") : null, v && s ? y.jsx(s, {
        className: "tl-collaborator__cursor",
        point: b,
        color: w,
        zoom: l,
        name: p !== "New User" ? p : null,
        chatMessage: d
      }, u + "_cursor") : i ? y.jsx(i, {
        className: "tl-collaborator__cursor-hint",
        point: b,
        color: w,
        zoom: l,
        viewport: c
      }, u + "_cursor_hint") : null, o && h.length ? y.jsx(y.Fragment, {
        children: h.map(_ => y.jsx(o, {
          className: "tl-collaborator__scribble",
          scribble: _,
          color: w,
          zoom: l,
          opacity: _.color === "laser" ? .5 : .1
        }, u + "_scribble_" + _.id))
      }) : null, a && m.map(_ => y.jsx(a, {
        className: "tl-collaborator__shape-indicator",
        id: _,
        color: w,
        opacity: .5
      }, u + "_" + _))]
    })
  });

function dT(t) {
  return t > PV ? "inactive" : t > XA ? "idle" : "active"
}

function SG(t) {
  const e = g.useRef((t == null ? void 0 : t.lastActivityTimestamp) ?? -1),
    [n, r] = g.useState(() => dT(Date.now() - e.current));
  return g.useEffect(() => {
    const o = setInterval(() => {
      r(dT(Date.now() - e.current))
    }, TV);
    return () => clearInterval(o)
  }, []), t && (e.current = t.lastActivityTimestamp), n
}

function p3(t, e) {
  return e === 0 ? t : p3(e, t % e)
}

function g3(t) {
  const e = t.toString().split(".")[1];
  if (!e) return 1;
  const n = Math.pow(10, e.length),
    r = parseInt(e, 10);
  return n / p3(r, n)
}

function _G() {
  const t = Y(),
    e = Rn();
  g.useEffect(() => bh("useDPRMultiple", () => {
    const n = t.getInstanceState().devicePixelRatio;
    e.style.setProperty("--tl-dpr-multiple", g3(n).toString())
  }), [t, e])
}
const m3 = pt(function({
    id: e,
    shape: n,
    util: r,
    index: o,
    backgroundIndex: s,
    opacity: i,
    isCulled: a
  }) {
    const c = Y(),
      {
        ShapeErrorFallback: l
      } = yn(),
      u = g.useRef(null),
      d = g.useRef(null),
      f = g.useCallback((m, p) => {
        var b, w;
        (b = u.current) == null || b.style.setProperty(m, p), (w = d.current) == null || w.style.setProperty(m, p)
      }, []);
    ja("set shape container transform position", () => {
      if (!c.getShape(e)) return;
      const p = c.getShapePageTransform(e),
        b = Ee.toCssString(p);
      f("transform", b)
    }, [c, f]), ja("set shape container clip path", () => {
      if (!c.getShape(e)) return null;
      const p = c.getShapeClipPath(e);
      f("clip-path", p ?? "none")
    }, [c, f]), ja("set shape height and width", () => {
      const m = c.getShape(e);
      if (!m) return null;
      const p = c.getShapeGeometry(m).bounds,
        b = Math.floor(c.getInstanceState().devicePixelRatio * 100) / 100,
        w = g3(b),
        v = p.w % w,
        _ = v === 0 ? p.w : p.w + (w - v),
        S = p.h % w,
        x = S === 0 ? p.h : p.h + (w - S);
      f("width", Math.max(_, w) + "px"), f("height", Math.max(x, w) + "px")
    }, [c]), g.useLayoutEffect(() => {
      var m, p;
      f("opacity", i + ""), (m = u.current) == null || m.style.setProperty("z-index", o + ""), (p = d.current) == null || p.style.setProperty("z-index", s + "")
    }, [i, o, s, f]);
    const h = g.useCallback(m => {
      c.annotateError(m, {
        origin: "react.shape",
        willCrashApp: !1
      })
    }, [c]);
    return n ? y.jsxs(y.Fragment, {
      children: [r.backgroundComponent && y.jsx("div", {
        ref: d,
        className: "tl-shape tl-shape-background",
        "data-shape-type": n.type,
        draggable: !1,
        children: !a && y.jsx(Rf, {
          fallback: l,
          onError: h,
          children: y.jsx(EG, {
            shape: n,
            util: r
          })
        })
      }), y.jsx("div", {
        ref: u,
        className: "tl-shape",
        "data-shape-type": n.type,
        draggable: !1,
        children: a ? y.jsx(kG, {
          shape: n
        }) : y.jsx(Rf, {
          fallback: l,
          onError: h,
          children: y.jsx(xG, {
            shape: n,
            util: r
          })
        })
      })]
    }) : null
  }),
  xG = g.memo(function({
    shape: e,
    util: n
  }) {
    return Wy("InnerShape:" + e.type, () => n.component(e))
  }, (t, e) => t.shape.props === e.shape.props && t.shape.meta === e.shape.meta),
  EG = g.memo(function({
    shape: e,
    util: n
  }) {
    return Wy("InnerShape:" + e.type, () => {
      var r;
      return (r = n.backgroundComponent) == null ? void 0 : r.call(n, e)
    })
  }, (t, e) => t.shape.props === e.shape.props && t.shape.meta === e.shape.meta),
  kG = g.memo(function({
    shape: e
  }) {
    const r = Y().getShapeGeometry(e).bounds;
    return y.jsx("div", {
      className: "tl-shape__culled",
      style: {
        transform: `translate(${U(r.minX)}px, ${U(r.minY)}px)`,
        width: Math.max(1, U(r.width)),
        height: Math.max(1, U(r.height))
      }
    })
  }, () => !0);

function y3({
  className: t
}) {
  const e = Y(),
    {
      Background: n,
      SvgDefs: r
    } = yn(),
    o = se.useRef(null),
    s = se.useRef(null),
    i = se.useRef(null);
  yK(), XH(), YH(), XW(o), GV(o), ja("position layers", () => {
    const f = s.current;
    if (!f) return;
    const h = i.current;
    if (!h) return;
    const {
      x: m,
      y: p,
      z: b
    } = e.getCamera(), w = b >= 1 ? Em(b, [1, 8], [.125, .5], !0) : Em(b, [.1, 1], [-2, .125], !0), v = `scale(${U(b)}) translate(${U(m+w)}px,${U(p+w)}px)`;
    f.style.setProperty("transform", v), h.style.setProperty("transform", v)
  }, [e]);
  const a = GH(),
    c = te("shapeSvgDefs", () => {
      const f = new Map;
      for (const h of Gt(e.shapeUtils)) {
        if (!h) return;
        const m = h.getCanvasSvgDefs();
        for (const {
            key: p,
            component: b
          }
          of m) f.has(p) || f.set(p, y.jsx(b, {}, p))
      }
      return [...f.values()]
    }, [e]),
    l = te("debug_shapes", () => Nt.hideShapes.get(), [Nt]),
    u = te("debug_svg", () => Nt.debugSvg.get(), [Nt]),
    d = te("debug_geometry", () => Nt.debugGeometry.get(), [Nt]);
  return y.jsxs("div", {
    ref: o,
    draggable: !1,
    className: ae("tl-canvas", t),
    "data-testid": "canvas",
    ...a,
    children: [n && y.jsx(n, {}), y.jsx(CG, {}), y.jsx(HG, {}), y.jsx("svg", {
      className: "tl-svg-context",
      children: y.jsxs("defs", {
        children: [c, fT && y.jsx(fT, {}), y.jsx(FG, {}), y.jsx(BG, {}), y.jsx(UG, {}), r && y.jsx(r, {})]
      })
    }), y.jsxs("div", {
      ref: s,
      className: "tl-html-layer tl-shapes",
      draggable: !1,
      children: [y.jsx(KG, {}), y.jsx(WG, {}), l ? null : u ? y.jsx(MG, {}) : y.jsx(jG, {})]
    }), y.jsxs("div", {
      className: "tl-fixed-layer tl-overlays",
      children: [y.jsxs("div", {
        ref: i,
        className: "tl-html-layer",
        children: [d ? y.jsx(bK, {}) : null, y.jsx(RG, {}), y.jsx(TG, {}), y.jsx(PG, {}), y.jsx($G, {}), y.jsx(DG, {}), y.jsx(NG, {}), y.jsx(LG, {}), y.jsx(IG, {}), y.jsx(VG, {}), y.jsx(vG, {})]
      }), y.jsx(GG, {})]
    })]
  })
}

function CG() {
  const t = Y(),
    e = te("gridSize", () => t.getDocumentSettings().gridSize, [t]),
    {
      x: n,
      y: r,
      z: o
    } = te("camera", () => t.getCamera(), [t]),
    s = te("isGridMode", () => t.getInstanceState().isGridMode, [t]),
    {
      Grid: i
    } = yn();
  return i && s ? y.jsx(i, {
    x: n,
    y: r,
    z: o,
    size: e
  }) : null
}

function PG() {
  const t = Y(),
    e = te("scribbles", () => t.getInstanceState().scribbles, [t]),
    n = te("zoomLevel", () => t.zoomLevel, [t]),
    {
      Scribble: r
    } = yn();
  return r && e.length ? y.jsx(y.Fragment, {
    children: e.map(o => y.jsx(r, {
      className: "tl-user-scribble",
      scribble: o,
      zoom: n
    }, o.id))
  }) : null
}

function TG() {
  const t = Y(),
    e = te("brush", () => t.getInstanceState().brush, [t]),
    {
      Brush: n
    } = yn();
  return n && e ? y.jsx(n, {
    className: "tl-user-brush",
    brush: e
  }) : null
}

function $G() {
  const t = Y(),
    e = te("zoomBrush", () => t.getInstanceState().zoomBrush, [t]),
    {
      ZoomBrush: n
    } = yn();
  return n && e ? y.jsx(n, {
    className: "tl-user-brush",
    brush: e
  }) : null
}

function IG() {
  const t = Y(),
    e = te("snapLines", () => t.snaps.lines, [t]),
    n = te("zoomLevel", () => t.zoomLevel, [t]),
    {
      SnapLine: r
    } = yn();
  return r && e.length > 0 ? y.jsx(y.Fragment, {
    children: e.map(o => y.jsx(r, {
      className: "tl-user-snapline",
      line: o,
      zoom: n
    }, o.id))
  }) : null
}
const OG = 48;

function RG() {
  const t = Y(),
    {
      Handles: e
    } = yn(),
    n = te("zoomLevel", () => t.zoomLevel, [t]),
    r = te("coarse pointer", () => t.getInstanceState().isCoarsePointer, [t]),
    o = te("onlySelectedShape", () => t.getOnlySelectedShape(), [t]),
    s = te("isChangingStyle", () => t.getInstanceState().isChangingStyle, [t]),
    i = te("isChangingStyle", () => t.getInstanceState().isReadonly, [t]),
    a = te("handles", () => {
      const u = t.getOnlySelectedShape();
      if (u) return t.getShapeHandles(u)
    }, [t]),
    c = te("transform", () => {
      const u = t.getOnlySelectedShape();
      if (u) return t.getShapePageTransform(u)
    }, [t]);
  if (!e || !o || s || i || !a || !c) return null;
  const l = [];
  for (let u = 0, d = a[u]; u < a.length; u++, d = a[u]) {
    if (d.type !== "vertex") {
      const f = a[u - 1],
        h = a[u + 1];
      if (f && h && Math.hypot(f.y - h.y, f.x - h.x) < OG / n) continue
    }
    l.push(d)
  }
  return l.sort(u => u.type === "vertex" ? 1 : -1), y.jsx(e, {
    children: y.jsx("g", {
      transform: Ee.toCssString(c),
      children: l.map(u => y.jsx(AG, {
        shapeId: o.id,
        handle: u,
        zoom: n,
        isCoarse: r
      }, u.id))
    })
  })
}

function AG({
  shapeId: t,
  handle: e,
  zoom: n,
  isCoarse: r
}) {
  const o = ZW(t, e.id),
    {
      Handle: s
    } = yn();
  return s ? y.jsx("g", {
    "aria-label": "handle",
    transform: `translate(${e.x}, ${e.y})`,
    ...o,
    children: y.jsx(s, {
      shapeId: t,
      handle: e,
      zoom: n,
      isCoarse: r
    })
  }) : null
}

function MG() {
  const t = Y(),
    e = te("rendering shapes", () => t.renderingShapes, [t]);
  return y.jsx(y.Fragment, {
    children: e.map(n => y.jsxs(se.Fragment, {
      children: [y.jsx(m3, {
        ...n
      }), y.jsx(zG, {
        id: n.id
      })]
    }, n.id + "_fragment"))
  })
}

function jG() {
  const t = Y(),
    e = te("rendering shapes", () => t.renderingShapes, [t]);
  return y.jsx(y.Fragment, {
    children: e.map(n => y.jsx(m3, {
      ...n
    }, n.id + "_shape"))
  })
}

function DG() {
  const t = Y(),
    e = te("selectedShapeIds", () => t.getCurrentPageState().selectedShapeIds, [t]);
  return te("should display selected ids", () => t.isInAny("select.idle", "select.brushing", "select.scribble_brushing", "select.editing_shape", "select.pointing_shape", "select.pointing_selection", "select.pointing_handle") && !t.getInstanceState().isChangingStyle, [t]) ? y.jsx(y.Fragment, {
    children: e.map(r => y.jsx(ev, {
      className: "tl-user-indicator__selected",
      id: r
    }, r + "_indicator"))
  }) : null
}
const NG = function() {
    const e = Y(),
      {
        HoveredShapeIndicator: n
      } = yn(),
      r = te("coarse pointer", () => e.getInstanceState().isCoarsePointer, [e]),
      o = te("hovering canvas", () => e.getInstanceState().isHoveringCanvas, [e]),
      s = te("hovered id", () => e.getCurrentPageState().hoveredShapeId, [e]);
    return r || !o || !s || !n ? null : y.jsx(n, {
      shapeId: s
    })
  },
  LG = pt(function() {
    const e = Y(),
      n = xm(e.getHintingShapeIds());
    return n.length ? y.jsx(y.Fragment, {
      children: n.map(r => y.jsx(ev, {
        className: "tl-user-indicator__hint",
        id: r
      }, r + "_hinting"))
    }) : null
  });

function fT() {
  return y.jsxs("g", {
    id: "cursor",
    children: [y.jsxs("g", {
      fill: "rgba(0,0,0,.2)",
      transform: "translate(-11,-11)",
      children: [y.jsx("path", {
        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
      }), y.jsx("path", {
        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
      })]
    }), y.jsxs("g", {
      fill: "white",
      transform: "translate(-12,-12)",
      children: [y.jsx("path", {
        d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z"
      }), y.jsx("path", {
        d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z"
      })]
    }), y.jsxs("g", {
      fill: "currentColor",
      transform: "translate(-12,-12)",
      children: [y.jsx("path", {
        d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z"
      }), y.jsx("path", {
        d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z"
      })]
    })]
  })
}

function FG() {
  return y.jsx("path", {
    id: "cursor_hint",
    fill: "currentColor",
    d: "M -2,-5 2,0 -2,5 Z"
  })
}

function BG() {
  return y.jsx("marker", {
    id: "arrowhead-dot",
    className: "tl-arrow-hint",
    refX: "3.0",
    refY: "3.0",
    orient: "0",
    children: y.jsx("circle", {
      cx: "3",
      cy: "3",
      r: "2",
      strokeDasharray: "100%"
    })
  })
}

function UG() {
  return y.jsxs("marker", {
    id: "arrowhead-cross",
    className: "tl-arrow-hint",
    refX: "3.0",
    refY: "3.0",
    orient: "auto",
    children: [y.jsx("line", {
      x1: "1.5",
      y1: "1.5",
      x2: "4.5",
      y2: "4.5",
      strokeDasharray: "100%"
    }), y.jsx("line", {
      x1: "1.5",
      y1: "4.5",
      x2: "4.5",
      y2: "1.5",
      strokeDasharray: "100%"
    })]
  })
}
const zG = pt(function({
  id: e
}) {
  const n = Y(),
    r = n.getShape(e),
    [o, s] = se.useState(""),
    i = (r == null ? void 0 : r.parentId) === n.currentPageId;
  return se.useEffect(() => {
    if (!i) return;
    let a = null;
    const c = bh("shape to svg", async () => {
      const l = Math.random();
      a = l;
      const u = n.getShapePageBounds(e),
        d = await n.getSvg([e], {
          padding: 0
        });
      d && u && a === l && (d.style.setProperty("overflow", "visible"), d.setAttribute("preserveAspectRatio", "xMidYMin slice"), d.style.setProperty("transform", `translate(${u.x}px, ${u.y+u.h+12}px)`), d.style.setProperty("border", "1px solid black"), s(d == null ? void 0 : d.outerHTML))
    });
    return () => {
      a = null, c()
    }
  }, [n, e, i]), i ? y.jsx("div", {
    style: {
      paddingTop: 12,
      position: "absolute"
    },
    children: y.jsx("div", {
      style: {
        display: "flex"
      },
      dangerouslySetInnerHTML: {
        __html: o
      }
    })
  }) : null
});

function HG() {
  const t = te("debugging ui log", () => Nt.logMessages.get(), [Nt]);
  return t.length ? y.jsx("div", {
    className: "debug__ui-logger",
    children: t.map((e, n) => {
      const r = typeof e == "string" ? e : JSON.stringify(e);
      return y.jsx("div", {
        className: "debug__ui-logger__line",
        children: r
      }, n)
    })
  }) : null
}

function VG() {
  const t = Y(),
    e = te("selection rotation", () => t.getSelectionRotation(), [t]),
    n = te("selection bounds", () => t.getSelectionRotatedPageBounds(), [t]),
    {
      SelectionForeground: r
    } = yn();
  return !n || !r ? null : y.jsx(r, {
    bounds: n,
    rotation: e
  })
}

function WG() {
  const t = Y(),
    e = te("selection rotation", () => t.getSelectionRotation(), [t]),
    n = te("selection bounds", () => t.getSelectionRotatedPageBounds(), [t]),
    {
      SelectionBackground: r
    } = yn();
  return !n || !r ? null : y.jsx(r, {
    bounds: n,
    rotation: e
  })
}

function KG() {
  const {
    OnTheCanvas: t
  } = yn();
  return t ? y.jsx(t, {}) : null
}

function GG() {
  const {
    InFrontOfTheCanvas: t
  } = yn();
  return t ? y.jsx(t, {}) : null
}

function It() {
  return Ui()
}
const v3 = "TLDRAW_USER_DATA_v3",
  b3 = tt({
    id: Te,
    name: Te.nullable().optional(),
    locale: Te.nullable().optional(),
    color: Te.nullable().optional(),
    isDarkMode: Je.nullable().optional(),
    animationSpeed: Oe.nullable().optional(),
    isSnapMode: Je.nullable().optional()
  }),
  Ap = {
    AddAnimationSpeed: 1,
    AddIsSnapMode: 2,
    MakeFieldsNullable: 3
  },
  Dm = ht({
    currentVersion: Ap.MakeFieldsNullable,
    migrators: {
      [Ap.AddAnimationSpeed]: {
        up: t => ({
          ...t,
          animationSpeed: 1
        }),
        down: ({
          animationSpeed: t,
          ...e
        }) => e
      },
      [Ap.AddIsSnapMode]: {
        up: t => ({
          ...t,
          isSnapMode: !1
        }),
        down: ({
          isSnapMode: t,
          ...e
        }) => e
      },
      [Ap.MakeFieldsNullable]: {
        up: t => t,
        down: t => ({
          id: t.id,
          name: t.name ?? ko.name,
          locale: t.locale ?? ko.locale,
          color: t.color ?? ko.color,
          isDarkMode: t.isDarkMode ?? ko.isDarkMode,
          animationSpeed: t.animationSpeed ?? ko.animationSpeed,
          isSnapMode: t.isSnapMode ?? ko.isSnapMode
        })
      }
    }
  }),
  hT = ["#FF802B", "#EC5E41", "#F2555A", "#F04F88", "#E34BA9", "#BD54C6", "#9D5BD2", "#7B66DC", "#02B1CC", "#11B3A3", "#39B178", "#55B467"];

function YG() {
  return hT[Math.floor(Math.random() * hT.length)]
}

function qG() {
  var t, e;
  return typeof window > "u" ? !1 : ((e = (t = window.matchMedia) == null ? void 0 : t.call(window, "(prefers-color-scheme: dark)")) == null ? void 0 : e.matches) ?? !1
}

function XG() {
  var t, e;
  return typeof window > "u" ? !1 : ((e = (t = window.matchMedia) == null ? void 0 : t.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : e.matches) ?? !1
}
const ko = Object.freeze({
  name: "New User",
  locale: FH(),
  color: YG(),
  isDarkMode: !1,
  animationSpeed: XG() ? 0 : 1,
  isSnapMode: !1
});

function Mp() {
  return {
    id: It()
  }
}

function w3(t) {
  if (t === null || typeof t != "object" || !("version" in t) || !("user" in t) || typeof t.version != "number") return Mp();
  const e = u1({
    value: t.user,
    fromVersion: t.version,
    toVersion: Dm.currentVersion ?? 0,
    migrations: Dm
  });
  if (e.type === "error") return Mp();
  try {
    b3.validate(e.value)
  } catch {
    return Mp()
  }
  return e.value
}

function ZG() {
  var e;
  const t = typeof window > "u" ? null : JSON.parse(((e = window == null ? void 0 : window.localStorage) == null ? void 0 : e.getItem(v3)) || "null") ?? null;
  return w3(t)
}
const kh = tr("globalUserData", ZG());

function JG() {
  typeof window < "u" && window.localStorage && window.localStorage.setItem(v3, JSON.stringify({
    version: Dm.currentVersion,
    user: kh.get()
  }))
}

function QG(t) {
  b3.validate(t), kh.set(t), JG(), tY()
}
const eY = typeof process < "u" && !1,
  Ll = typeof BroadcastChannel < "u" && !eY ? new BroadcastChannel("tldraw-user-sync") : null;
Ll == null || Ll.addEventListener("message", t => {
  const e = t.data;
  (e == null ? void 0 : e.type) === _3 && (e == null ? void 0 : e.origin) !== S3 && kh.set(w3(e.data))
});
const S3 = It(),
  _3 = "tldraw-user-preferences-change";

function tY() {
  Ll == null || Ll.postMessage({
    type: _3,
    origin: S3,
    data: {
      user: kh.get(),
      version: Dm.currentVersion
    }
  })
}

function nY() {
  return kh.get()
}

function x3(t = {}) {
  return {
    derivePresenceState: t.derivePresenceState ?? (() => Q("presence", () => null)),
    userPreferences: t.userPreferences ?? Q("userPreferences", () => nY()),
    setUserPreferences: t.setUserPreferences ?? QG
  }
}
var E3 = {
  exports: {}
};
(function(t) {
  var e = Object.prototype.hasOwnProperty,
    n = "~";

  function r() {}
  Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1));

  function o(c, l, u) {
    this.fn = c, this.context = l, this.once = u || !1
  }

  function s(c, l, u, d, f) {
    if (typeof u != "function") throw new TypeError("The listener must be a function");
    var h = new o(u, d || c, f),
      m = n ? n + l : l;
    return c._events[m] ? c._events[m].fn ? c._events[m] = [c._events[m], h] : c._events[m].push(h) : (c._events[m] = h, c._eventsCount++), c
  }

  function i(c, l) {
    --c._eventsCount === 0 ? c._events = new r : delete c._events[l]
  }

  function a() {
    this._events = new r, this._eventsCount = 0
  }
  a.prototype.eventNames = function() {
    var l = [],
      u, d;
    if (this._eventsCount === 0) return l;
    for (d in u = this._events) e.call(u, d) && l.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols ? l.concat(Object.getOwnPropertySymbols(u)) : l
  }, a.prototype.listeners = function(l) {
    var u = n ? n + l : l,
      d = this._events[u];
    if (!d) return [];
    if (d.fn) return [d.fn];
    for (var f = 0, h = d.length, m = new Array(h); f < h; f++) m[f] = d[f].fn;
    return m
  }, a.prototype.listenerCount = function(l) {
    var u = n ? n + l : l,
      d = this._events[u];
    return d ? d.fn ? 1 : d.length : 0
  }, a.prototype.emit = function(l, u, d, f, h, m) {
    var p = n ? n + l : l;
    if (!this._events[p]) return !1;
    var b = this._events[p],
      w = arguments.length,
      v, _;
    if (b.fn) {
      switch (b.once && this.removeListener(l, b.fn, void 0, !0), w) {
        case 1:
          return b.fn.call(b.context), !0;
        case 2:
          return b.fn.call(b.context, u), !0;
        case 3:
          return b.fn.call(b.context, u, d), !0;
        case 4:
          return b.fn.call(b.context, u, d, f), !0;
        case 5:
          return b.fn.call(b.context, u, d, f, h), !0;
        case 6:
          return b.fn.call(b.context, u, d, f, h, m), !0
      }
      for (_ = 1, v = new Array(w - 1); _ < w; _++) v[_ - 1] = arguments[_];
      b.fn.apply(b.context, v)
    } else {
      var S = b.length,
        x;
      for (_ = 0; _ < S; _++) switch (b[_].once && this.removeListener(l, b[_].fn, void 0, !0), w) {
        case 1:
          b[_].fn.call(b[_].context);
          break;
        case 2:
          b[_].fn.call(b[_].context, u);
          break;
        case 3:
          b[_].fn.call(b[_].context, u, d);
          break;
        case 4:
          b[_].fn.call(b[_].context, u, d, f);
          break;
        default:
          if (!v)
            for (x = 1, v = new Array(w - 1); x < w; x++) v[x - 1] = arguments[x];
          b[_].fn.apply(b[_].context, v)
      }
    }
    return !0
  }, a.prototype.on = function(l, u, d) {
    return s(this, l, u, d, !1)
  }, a.prototype.once = function(l, u, d) {
    return s(this, l, u, d, !0)
  }, a.prototype.removeListener = function(l, u, d, f) {
    var h = n ? n + l : l;
    if (!this._events[h]) return this;
    if (!u) return i(this, h), this;
    var m = this._events[h];
    if (m.fn) m.fn === u && (!f || m.once) && (!d || m.context === d) && i(this, h);
    else {
      for (var p = 0, b = [], w = m.length; p < w; p++)(m[p].fn !== u || f && !m[p].once || d && m[p].context !== d) && b.push(m[p]);
      b.length ? this._events[h] = b.length === 1 ? b[0] : b : i(this, h)
    }
    return this
  }, a.prototype.removeAllListeners = function(l) {
    var u;
    return l ? (u = n ? n + l : l, this._events[u] && i(this, u)) : (this._events = new r, this._eventsCount = 0), this
  }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a
})(E3);
var rY = E3.exports;

function k3({
  children: t,
  className: e = "",
  ...n
}) {
  return y.jsx("svg", {
    ...n,
    className: `tl-svg-container ${e}`,
    children: t
  })
}
class k1 {
  constructor(e) {
    P(this, "isFilled", !1);
    P(this, "isClosed", !0);
    P(this, "isLabel", !1);
    P(this, "isSnappable", !0);
    P(this, "_vertices");
    P(this, "_bounds");
    P(this, "_snapPoints");
    P(this, "_area");
    this.isFilled = e.isFilled, this.isClosed = e.isClosed, this.isSnappable = e.isSnappable ?? !1, this.isLabel = e.isLabel ?? !1
  }
  hitTestPoint(e, n = 0, r = !1) {
    return this.distanceToPoint(e, r) <= n
  }
  distanceToPoint(e, n = !1) {
    const r = e.dist(this.nearestPoint(e));
    return this.isClosed && (this.isFilled || n) && ru(e, this.vertices) ? -r : r
  }
  distanceToLineSegment(e, n) {
    const r = this.nearestPointOnLineSegment(e, n),
      o = T.DistanceToLineSegment(e, n, r);
    return this.isClosed && this.isFilled && ru(r, this.vertices) ? -o : o
  }
  hitTestLineSegment(e, n, r = 0) {
    return this.distanceToLineSegment(e, n) <= r
  }
  nearestPointOnLineSegment(e, n) {
    let r = 1 / 0,
      o;
    for (let s = 0; s < this.vertices.length; s++) {
      const i = this.vertices[s],
        a = T.DistanceToLineSegment(e, n, i);
      a < r && (r = a, o = i)
    }
    if (!o) throw Error("nearest point not found");
    return o
  }
  isPointInBounds(e, n = 0) {
    const {
      bounds: r
    } = this;
    return !(e.x < r.minX - n || e.y < r.minY - n || e.x > r.maxX + n || e.y > r.maxY + n)
  }
  get vertices() {
    return this._vertices || (this._vertices = this.getVertices()), this._vertices
  }
  getBounds() {
    return Be.FromPoints(this.vertices)
  }
  get bounds() {
    return this._bounds || (this._bounds = this.getBounds()), this._bounds
  }
  get snapPoints() {
    return this._snapPoints || (this._snapPoints = this.bounds.snapPoints), this._snapPoints
  }
  get center() {
    return this.bounds.center
  }
  get area() {
    return this._area || (this._area = this.getArea()), this._area
  }
  getArea() {
    if (!this.isClosed) return 0;
    const {
      vertices: e
    } = this;
    let n = 0;
    for (let r = 0, o = e.length; r < o; r++) {
      const s = e[r],
        i = e[(r + 1) % o];
      n += s.x * i.y - i.x * s.y
    }
    return n / 2
  }
  toSimpleSvgPath() {
    let e = "";
    const {
      vertices: n
    } = this, r = n.length;
    if (r === 0) return e;
    e += `M${n[0].x},${n[0].y}`;
    for (let o = 1; o < r; o++) e += `L${n[o].x},${n[o].y}`;
    return this.isClosed && (e += "Z"), e
  }
}
class C1 extends k1 {
  constructor(n) {
    super({
      ...n,
      isClosed: !0,
      isFilled: !1
    });
    P(this, "children");
    const {
      children: r
    } = n;
    if (r.length === 0) throw Error("Group2d must have at least one child");
    this.children = r
  }
  getVertices() {
    return this.children.filter(n => !n.isLabel).flatMap(n => n.vertices)
  }
  nearestPoint(n) {
    let r = 1 / 0,
      o;
    const {
      children: s
    } = this;
    if (s.length === 0) throw Error("no children");
    for (const i of s) {
      const a = i.nearestPoint(n),
        c = a.dist(n);
      c < r && (r = c, o = a)
    }
    if (!o) throw Error("nearest point not found");
    return o
  }
  distanceToPoint(n, r = !1) {
    return Math.min(...this.children.map((o, s) => o.distanceToPoint(n, r || s > 0)))
  }
  hitTestPoint(n, r, o) {
    return !!this.children.filter(s => !s.isLabel).find(s => s.hitTestPoint(n, r, o))
  }
  hitTestLineSegment(n, r, o) {
    return !!this.children.filter(s => !s.isLabel).find(s => s.hitTestLineSegment(n, r, o))
  }
  getArea() {
    return this.children[0].area
  }
  toSimpleSvgPath() {
    let n = "";
    for (const o of this.children) n += o.toSimpleSvgPath();
    const r = Be.FromPoints(this.vertices).corners;
    for (let o = 0, s = r.length; o < s; o++) {
      const i = r[o],
        a = r[(o - 1 + s) % s],
        c = i.dist(a),
        l = r[(o + 1) % s],
        u = i.dist(l),
        d = i.clone().lrp(a, 4 / c),
        f = i,
        h = i.clone().lrp(l, 4 / u);
      n += `M${d.x},${d.y} L${f.x},${f.y} L${h.x},${h.y} `
    }
    return n
  }
}

function P1(t, e, n, r) {
  const o = t.x - n.x,
    s = t.y - n.y,
    i = r.x - n.x,
    a = r.y - n.y,
    c = e.x - t.x,
    l = e.y - t.y,
    u = i * s - a * o,
    d = c * s - l * o,
    f = a * c - i * l;
  if (u === 0 || d === 0 || f === 0) return null;
  if (f !== 0) {
    const h = u / f,
      m = d / f;
    if (0 <= h && h <= 1 && 0 <= m && m <= 1) return T.AddXY(t, h * c, h * l)
  }
  return null
}

function C3(t, e, n, r) {
  const o = (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y),
    s = 2 * ((e.x - t.x) * (t.x - n.x) + (e.y - t.y) * (t.y - n.y)),
    i = n.x * n.x + n.y * n.y + t.x * t.x + t.y * t.y - 2 * (n.x * t.x + n.y * t.y) - r * r,
    a = s * s - 4 * o * i;
  if (a < 0 || a === 0) return null;
  const c = Math.sqrt(a),
    l = (-s + c) / (2 * o),
    u = (-s - c) / (2 * o);
  if ((l < 0 || l > 1) && (u < 0 || u > 1)) return null;
  const d = [];
  return 0 <= l && l <= 1 && d.push(T.Lrp(t, e, l)), 0 <= u && u <= 1 && d.push(T.Lrp(t, e, u)), d.length === 0 ? null : d
}

function oY(t, e, n) {
  const r = [];
  let o;
  for (let s = 0, i = n.length - 1; s < i; s++) o = P1(t, e, n[s], n[s + 1]), o && r.push(o);
  return r.length === 0 ? null : r
}

function sY(t, e, n) {
  const r = [];
  let o;
  for (let s = 1, i = n.length; s < i + 1; s++) o = P1(t, e, n[s - 1], n[s % n.length]), o && r.push(o);
  return r.length === 0 ? null : r
}

function A0e(t, e, n, r) {
  let o = n.x - t.x,
    s = n.y - t.y;
  const i = Math.sqrt(o * o + s * s),
    a = (i * i - r * r + e * e) / (2 * i),
    c = Math.sqrt(e * e - a * a);
  return o /= i, s /= i, [new T(t.x + o * a - s * c, t.y + s * a + o * c), new T(t.x + o * a + s * c, t.y + s * a - o * c)]
}

function pT(t, e, n) {
  const r = [];
  let o, s, i;
  for (let a = 0, c = n.length; a < c; a++) o = n[a], s = n[(a + 1) % n.length], i = C3(o, s, t, e), i && r.push(...i);
  return r.length === 0 ? null : r
}

function gT(t, e, n) {
  const r = [];
  let o, s, i;
  for (let a = 1, c = n.length; a < c; a++) o = n[a - 1], s = n[a], i = C3(o, s, t, e), i && r.push(...i);
  return r.length === 0 ? null : r
}

function jp(t, e, n) {
  return (n.y - t.y) * (e.x - t.x) > (e.y - t.y) * (n.x - t.x)
}

function P3(t, e, n, r) {
  return jp(t, n, r) !== jp(e, n, r) && jp(t, e, n) !== jp(t, e, r)
}

function zS(t, e) {
  const n = [];
  let r, o, s, i;
  for (let a = 0, c = t.length; a < c; a++) r = t[a], ru(r, e) && n.push(r);
  for (let a = 0, c = e.length; a < c; a++) r = e[a], ru(r, t) && n.push(r);
  for (let a = 0, c = t.length; a < c; a++) {
    r = t[a], o = t[(a + 1) % t.length];
    for (let l = 0, u = e.length; l < u; l++) {
      s = e[l], i = e[(l + 1) % e.length];
      const d = P1(r, o, s, i);
      d !== null && n.push(d)
    }
  }
  return n.length === 0 ? null : iY(n)
}

function iY(t) {
  const e = T.Average(t);
  return t.sort((n, r) => T.Angle(e, n) - T.Angle(e, r))
}

function M0e(t, e) {
  let n, r, o, s;
  for (let i = 0, a = t.length; i < a; i++) {
    n = t[i], r = t[(i + 1) % a];
    for (let c = 0, l = e.length; c < l; c++)
      if (o = e[c], s = e[(c + 1) % l], P3(n, r, o, s)) return !0
  }
  return !1
}
class mT extends k1 {
  constructor(n) {
    super({
      ...n,
      isClosed: !1,
      isFilled: !1
    });
    P(this, "start");
    P(this, "end");
    P(this, "d");
    P(this, "u");
    P(this, "ul");
    P(this, "_length");
    const {
      start: r,
      end: o
    } = n;
    this.start = r, this.end = o, this.d = r.clone().sub(o), this.u = this.d.clone().uni(), this.ul = this.u.len()
  }
  get length() {
    return this._length ? this._length : this.d.len()
  }
  midPoint() {
    return this.start.lrp(this.end, .5)
  }
  getVertices() {
    return [this.start, this.end]
  }
  nearestPoint(n) {
    const {
      start: r,
      end: o,
      u: s,
      ul: i
    } = this;
    if (i === 0) return r;
    const a = T.Sub(n, r).dpr(s) / i,
      c = r.x + s.x * a;
    if (c < Math.min(r.x, o.x)) return r.x < o.x ? r : o;
    if (c > Math.max(r.x, o.x)) return r.x > o.x ? r : o;
    const l = r.y + s.y * a;
    return l < Math.min(r.y, o.y) ? r.y < o.y ? r : o : l > Math.max(r.y, o.y) ? r.y > o.y ? r : o : new T(c, l)
  }
  hitTestLineSegment(n, r, o) {
    return P3(n, r, this.start, this.end)
  }
}
class T3 extends k1 {
  constructor(n) {
    super({
      isClosed: !1,
      isFilled: !1,
      ...n
    });
    P(this, "points");
    P(this, "_segments");
    P(this, "_length");
    const {
      points: r
    } = n;
    this.points = r
  }
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const {
        vertices: n
      } = this;
      for (let r = 0, o = n.length - 1; r < o; r++) {
        const s = n[r],
          i = n[r + 1];
        this._segments.push(new mT({
          start: s,
          end: i
        }))
      }
      this.isClosed && this._segments.push(new mT({
        start: n[n.length - 1],
        end: n[0]
      }))
    }
    return this._segments
  }
  get length() {
    return this._length || (this._length = this.segments.reduce((n, r) => n + r.length, 0)), this._length
  }
  getVertices() {
    return this.points
  }
  nearestPoint(n) {
    const {
      segments: r
    } = this;
    let o = this.points[0],
      s = 1 / 0,
      i, a;
    for (let c = 0; c < r.length; c++) i = r[c].nearestPoint(n), a = i.dist(n), a < s && (o = i, s = a);
    return o
  }
  hitTestLineSegment(n, r, o) {
    return this.segments.some(s => s.hitTestLineSegment(n, r, o))
  }
}
class $3 extends T3 {
  constructor(e) {
    super({
      ...e
    }), this.isClosed = !0
  }
}
class T1 extends $3 {
  constructor(n) {
    const {
      x: r = 0,
      y: o = 0,
      width: s,
      height: i
    } = n;
    super({
      ...n,
      points: [new T(r, o), new T(r + s, o), new T(r + s, o + i), new T(r, o + i)]
    });
    P(this, "x");
    P(this, "y");
    P(this, "w");
    P(this, "h");
    this.x = r, this.y = o, this.w = s, this.h = i
  }
  getBounds() {
    return new Be(this.x, this.y, this.w, this.h)
  }
}
class Yd {
  constructor(e) {
    P(this, "canSnap", () => !0);
    P(this, "canScroll", () => !1);
    P(this, "canUnmount", () => !0);
    P(this, "canBind", (e, n) => !0);
    P(this, "canEdit", () => !1);
    P(this, "canResize", () => !0);
    P(this, "canEditInReadOnly", () => !1);
    P(this, "canCrop", () => !1);
    P(this, "hideResizeHandles", () => !1);
    P(this, "hideRotateHandle", () => !1);
    P(this, "hideSelectionBoundsBg", () => !1);
    P(this, "hideSelectionBoundsFg", () => !1);
    P(this, "isAspectRatioLocked", () => !1);
    P(this, "onBeforeCreate");
    P(this, "onBeforeUpdate");
    P(this, "onDragShapesOver");
    P(this, "onDragShapesOut");
    P(this, "onDropShapesOver");
    P(this, "onResizeStart");
    P(this, "onResize");
    P(this, "onResizeEnd");
    P(this, "onTranslateStart");
    P(this, "onTranslate");
    P(this, "onTranslateEnd");
    P(this, "onRotateStart");
    P(this, "onRotate");
    P(this, "onRotateEnd");
    P(this, "onHandleChange");
    P(this, "onBindingChange");
    P(this, "onChildrenChange");
    P(this, "onDoubleClickHandle");
    P(this, "onDoubleClickEdge");
    P(this, "onDoubleClick");
    P(this, "onClick");
    P(this, "onEditEnd");
    this.editor = e
  }
  providesBackgroundForChildren(e) {
    return !1
  }
  getOutlineSegments(e) {
    return [this.editor.getShapeGeometry(e).vertices]
  }
  canReceiveNewChildrenOfType(e, n) {
    return !1
  }
  canDropShapes(e, n) {
    return !1
  }
  expandSelectionOutlinePx(e) {
    return 0
  }
  getCanvasSvgDefs() {
    return []
  }
}
P(Yd, "props"), P(Yd, "migrations"), P(Yd, "type");

function aY(t, e, n = {}) {
  const {
    closed: r = !1,
    snap: o = 1,
    start: s = "outset",
    end: i = "outset",
    lengthRatio: a = 2,
    style: c = "dashed"
  } = n;
  let l = 0,
    u = 0,
    d = 1,
    f = 0,
    h = 0;
  switch (c) {
    case "dashed": {
      d = 1, l = Math.min(e * a, t / 4);
      break
    }
    case "dotted": {
      d = 100, l = e / d;
      break
    }
    default:
      return {
        strokeDasharray: "none", strokeDashoffset: "none"
      }
  }
  return r || (s === "outset" ? (t += l / 2, h += l / 2) : s === "skip" && (t -= l, h -= l), i === "outset" ? t += l / 2 : i === "skip" && (t -= l)), u = Math.floor(t / l / (2 * d)), u -= u % o, u < 3 && c === "dashed" ? t / e < 5 ? (l = t, u = 1, f = 0) : (l = t * .333, f = t * .333) : (u = Math.max(u, 3), l = t / u / (2 * d), r ? (h = l / 2, f = (t - u * l) / u) : f = (t - u * l) / Math.max(1, u - 1)), {
    strokeDasharray: [l, f].join(" "),
    strokeDashoffset: h.toString()
  }
}

function yT({
  bounds: t,
  className: e
}) {
  const n = Y(),
    r = te("zoom level", () => n.zoomLevel, [n]);
  return y.jsx("g", {
    className: e,
    pointerEvents: "none",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: t.sides.map((o, s) => {
      const {
        strokeDasharray: i,
        strokeDashoffset: a
      } = aY(o[0].dist(o[1]), 1 / r, {
        style: "dashed",
        lengthRatio: 4
      });
      return y.jsx("line", {
        x1: o[0].x,
        y1: o[0].y,
        x2: o[1].x,
        y2: o[1].y,
        strokeDasharray: i,
        strokeDashoffset: a
      }, s)
    })
  })
}
class Rg extends Yd {
  constructor() {
    super(...arguments);
    P(this, "hideSelectionBoundsFg", () => !0);
    P(this, "canBind", () => !1);
    P(this, "onChildrenChange", n => {
      const r = this.editor.getSortedChildIdsForParent(n.id);
      if (r.length === 0) {
        this.editor.getCurrentPageState().focusedGroupId === n.id && this.editor.popFocusedGroupId(), this.editor.deleteShapes([n.id]);
        return
      } else if (r.length === 1) {
        this.editor.getCurrentPageState().focusedGroupId === n.id && this.editor.popFocusedGroupId(), this.editor.reparentShapes(r, n.parentId), this.editor.deleteShapes([n.id]);
        return
      }
    })
  }
  getDefaultProps() {
    return {}
  }
  getGeometry(n) {
    const r = this.editor.getSortedChildIdsForParent(n.id);
    return r.length === 0 ? new T1({
      width: 1,
      height: 1,
      isFilled: !1
    }) : new C1({
      children: r.map(o => {
        const s = this.editor.getShape(o),
          i = this.editor.getShapeGeometry(o),
          a = this.editor.getShapeLocalTransform(s).applyToPoints(i.vertices);
        return i.isClosed ? new $3({
          points: a,
          isFilled: !0
        }) : new T3({
          points: a
        })
      })
    })
  }
  component(n) {
    const r = this.editor.getErasingShapeIds().includes(n.id),
      {
        hintingShapeIds: o
      } = this.editor.getCurrentPageState(),
      s = o.length > 0 && o.some(c => c !== n.id && this.editor.isShapeOfType(this.editor.getShape(c), "group")),
      i = this.editor.getCurrentPageState().focusedGroupId !== n.id;
    if (!r && (i || s)) return null;
    const a = this.editor.getShapeGeometry(n).bounds;
    return y.jsx(k3, {
      id: n.id,
      children: y.jsx(yT, {
        className: "tl-group",
        bounds: a
      })
    })
  }
  indicator(n) {
    const r = this.editor.getShapeGeometry(n).bounds;
    return y.jsx(yT, {
      className: "",
      bounds: r
    })
  }
}
P(Rg, "type", "group"), P(Rg, "props", RH), P(Rg, "migrations", AH);
const I3 = [Rg],
  cY = new Set(I3.map(t => t.type));

function O3(t) {
  const e = [...I3],
    n = new Set;
  for (const r of t) {
    if (cY.has(r.type)) throw new Error(`Shape type "${r.type}" is a core shapes type and cannot be overridden`);
    if (n.has(r.type)) throw new Error(`Shape type "${r.type}" is defined more than once`);
    e.push(r), n.add(r.type)
  }
  return e
}

function vT(t, e) {
  if (!e) return !1;
  switch (t.type) {
    case "mixed":
      return e.type === "mixed";
    case "shared":
      return e.type === "shared" && t.value === e.value;
    default:
      throw bu(t)
  }
}
class lY {
  constructor(e) {
    P(this, "map");
    this.map = new Map(e)
  }
  get(e) {
    return this.map.get(e)
  }
  getAsKnownValue(e) {
    const n = this.get(e);
    if (n && n.type !== "mixed") return n.value
  }
  get size() {
    return this.map.size
  }
  equals(e) {
    if (this.size !== e.size) return !1;
    const n = new Set;
    for (const [r, o] of this) {
      if (!vT(o, e.get(r))) return !1;
      n.add(r)
    }
    for (const [r, o] of e)
      if (!n.has(r) && !vT(o, this.get(r))) return !1;
    return !0
  }
  keys() {
    return this.map.keys()
  }
  values() {
    return this.map.values()
  }
  entries() {
    return this.map.entries()
  } [Symbol.iterator]() {
    return this.map[Symbol.iterator]()
  }
}
class HS extends lY {
  set(e, n) {
    this.map.set(e, n)
  }
  applyValue(e, n) {
    const r = this.get(e);
    if (!r) {
      this.set(e, {
        type: "shared",
        value: n
      });
      return
    }
    switch (r.type) {
      case "mixed":
        return;
      case "shared":
        r.value !== n && this.set(e, {
          type: "mixed"
        });
        return;
      default:
        bu(r, "type")
    }
  }
}
class uY {
  constructor() {
    P(this, "items", new WeakMap)
  }
  get(e, n) {
    return this.items.has(e) || this.items.set(e, n(e)), this.items.get(e)
  }
  access(e) {
    return this.items.get(e)
  }
  set(e, n) {
    this.items.set(e, n)
  }
  has(e) {
    return this.items.has(e)
  }
  invalidate(e) {
    this.items.delete(e)
  }
  bust() {
    this.items = new WeakMap
  }
}

function dY(t, e, n) {
  return fetch(t).then(function(r) {
    return r.arrayBuffer()
  }).then(function(r) {
    return new File([r], e, {
      type: n
    })
  })
}

function fY(t, e) {
  var o;
  let n = t;
  const r = new Set(e);
  for (; r.has(n);) n = (o = /^.*(\d+)$/.exec(n)) != null && o[1] ? n.replace(/(\d+)(?=\D?)$/, s => (+s + 1).toString()) : `${n} 1`;
  return n
}
const jr = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  hY = "a0",
  R3 = "A00000000000000000000000000";

function A3(t) {
  if (t >= "a" && t <= "z") return t.charCodeAt(0) - "a".charCodeAt(0) + 2;
  if (t >= "A" && t <= "Z") return "Z".charCodeAt(0) - t.charCodeAt(0) + 2;
  throw new Error("Invalid index key head: " + t)
}

function M3(t) {
  if (t.length !== A3(t.charAt(0))) throw new Error("invalid integer part of index key: " + t)
}

function bT(t) {
  if (t === void 0) throw Error("n is undefined")
}

function wT(t) {
  M3(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let o = n.length - 1; r && o >= 0; o--) {
    const s = jr.indexOf(n[o]) + 1;
    s === jr.length ? n[o] = "0" : (n[o] = jr.charAt(s), r = !1)
  }
  if (r) {
    if (e === "Z") return "a0";
    if (e === "z") return;
    const o = String.fromCharCode(e.charCodeAt(0) + 1);
    return o > "a" ? n.push("0") : n.pop(), o + n.join("")
  } else return e + n.join("")
}

function pY(t) {
  M3(t);
  const [e, ...n] = t.split("");
  let r = !0;
  for (let o = n.length - 1; r && o >= 0; o--) {
    const s = jr.indexOf(n[o]) - 1;
    s === -1 ? n[o] = jr.slice(-1) : (n[o] = jr.charAt(s), r = !1)
  }
  if (r) {
    if (e === "a") return "Z" + jr.slice(-1);
    if (e === "A") return;
    const o = String.fromCharCode(e.charCodeAt(0) - 1);
    return o < "Z" ? n.push(jr.slice(-1)) : n.pop(), o + n.join("")
  } else return e + n.join("")
}

function ml(t, e) {
  if (e !== void 0 && t >= e) throw new Error(t + " >= " + e);
  if (t.slice(-1) === "0" || e && e.slice(-1) === "0") throw new Error("trailing zero");
  if (e) {
    let o = 0;
    for (;
      (t.charAt(o) || "0") === e.charAt(o);) o++;
    if (o > 0) return e.slice(0, o) + ml(t.slice(o), e.slice(o))
  }
  const n = t ? jr.indexOf(t.charAt(0)) : 0,
    r = e !== void 0 ? jr.indexOf(e.charAt(0)) : jr.length;
  if (r - n > 1) {
    const o = Math.round(.5 * (n + r));
    return jr.charAt(o)
  } else return e && e.length > 1 ? e.slice(0, 1) : jr.charAt(n) + ml(t.slice(1), void 0)
}

function Id(t) {
  const e = A3(t.charAt(0));
  if (e > t.length) throw new Error("invalid index: " + t);
  return t.slice(0, e)
}

function ST(t) {
  if (t === R3) throw new Error("invalid index: " + t);
  const e = Id(t);
  if (t.slice(e.length).slice(-1) === "0") throw new Error("invalid index: " + t)
}

function Mc(t, e) {
  if (t !== void 0 && ST(t), e !== void 0 && ST(e), t !== void 0 && e !== void 0 && t >= e) throw new Error(t + " >= " + e);
  if (t === void 0 && e === void 0) return hY;
  if (t === void 0) {
    if (e === void 0) throw Error("b is undefined");
    const a = Id(e),
      c = e.slice(a.length);
    if (a === R3) return a + ml("", c);
    if (a < e) return a;
    const l = pY(a);
    return bT(l), l
  }
  if (e === void 0) {
    const a = Id(t),
      c = t.slice(a.length),
      l = wT(a);
    return l === void 0 ? a + ml(c, void 0) : l
  }
  const n = Id(t),
    r = t.slice(n.length),
    o = Id(e),
    s = e.slice(o.length);
  if (n === o) return n + ml(r, s);
  const i = wT(n);
  return bT(i), i < e ? i : n + ml(r, void 0)
}

function qs(t, e, n) {
  if (n === 0) return [];
  if (n === 1) return [Mc(t, e)];
  if (e === void 0) {
    let s = Mc(t, e);
    const i = [s];
    for (let a = 0; a < n - 1; a++) s = Mc(s, e), i.push(s);
    return i
  }
  if (t === void 0) {
    let s = Mc(t, e);
    const i = [s];
    for (let a = 0; a < n - 1; a++) s = Mc(t, s), i.push(s);
    return i.reverse(), i
  }
  const r = Math.floor(n / 2),
    o = Mc(t, e);
  return [...qs(t, o, r), o, ...qs(o, e, n - r - 1)]
}

function ou(t, e, n) {
  return qs(t, e, n)
}

function q0(t, e) {
  return qs(t, void 0, e)
}

function j0e(t, e) {
  return qs(void 0, t, e)
}

function Ag(t, e) {
  return qs(t, e, 1)[0]
}

function yi(t) {
  return qs(t, void 0, 1)[0]
}

function gY(t) {
  return qs(void 0, t, 1)[0]
}

function j3(t, e = "a1") {
  return [e, ...qs(e, void 0, t)]
}

function ts(t, e) {
  return t.index < e.index ? -1 : t.index > e.index ? 1 : 0
}

function Dp(t, e, n) {
  if (n.length === 0) return [];
  const r = new Map;
  for (const s of Fe(n.map(i => t.getShape(i)))) {
    const {
      parentId: i
    } = s;
    r.has(i) || r.set(i, {
      children: Fe(t.getSortedChildIdsForParent(i).map(a => t.getShape(a))),
      moving: new Set
    }), r.get(i).moving.add(s)
  }
  const o = [];
  switch (e) {
    case "toBack": {
      r.forEach(({
        moving: s,
        children: i
      }) => mY(s, i, o));
      break
    }
    case "toFront": {
      r.forEach(({
        moving: s,
        children: i
      }) => yY(s, i, o));
      break
    }
    case "forward": {
      r.forEach(({
        moving: s,
        children: i
      }) => vY(s, i, o));
      break
    }
    case "backward": {
      r.forEach(({
        moving: s,
        children: i
      }) => bY(s, i, o));
      break
    }
  }
  return o
}

function mY(t, e, n) {
  const r = e.length;
  if (t.size === r) return;
  let o, s;
  for (let i = 0; i < r; i++) {
    const a = e[i];
    if (t.has(a)) o = a.index, t.delete(a);
    else {
      s = a.index;
      break
    }
  }
  if (t.size !== 0) {
    const i = ou(o, s, t.size);
    n.push(...Array.from(t.values()).sort(ts).map((a, c) => ({
      ...a,
      index: i[c]
    })))
  }
}

function yY(t, e, n) {
  const r = e.length;
  if (t.size === r) return;
  let o, s;
  for (let i = r - 1; i > -1; i--) {
    const a = e[i];
    if (t.has(a)) s = a.index, t.delete(a);
    else {
      o = a.index;
      break
    }
  }
  if (t.size !== 0) {
    const i = ou(o, s, t.size);
    n.push(...Array.from(t.values()).sort(ts).map((a, c) => ({
      ...a,
      index: i[c]
    })))
  }
}

function vY(t, e, n) {
  var s;
  const r = e.length;
  if (t.size === r) return;
  let o = {
    name: "skipping"
  };
  for (let i = 0; i < r; i++) {
    const a = t.has(e[i]);
    switch (o.name) {
      case "skipping": {
        if (!a) continue;
        o = {
          name: "selecting",
          selectIndex: i
        };
        break
      }
      case "selecting": {
        if (a) continue;
        const {
          selectIndex: c
        } = o;
        ou(e[i].index, (s = e[i + 1]) == null ? void 0 : s.index, i - c).forEach((l, u) => n.push({
          ...e[c + u],
          index: l
        })), o = {
          name: "skipping"
        };
        break
      }
    }
  }
}

function bY(t, e, n) {
  var s;
  const r = e.length;
  if (t.size === r) return;
  let o = {
    name: "skipping"
  };
  for (let i = r - 1; i > -1; i--) {
    const a = t.has(e[i]);
    switch (o.name) {
      case "skipping": {
        if (!a) continue;
        o = {
          name: "selecting",
          selectIndex: i
        };
        break
      }
      case "selecting": {
        if (a) continue;
        ou((s = e[i - 1]) == null ? void 0 : s.index, e[i].index, o.selectIndex - i).forEach((c, l) => {
          n.push({
            ...e[i + l + 1],
            index: c
          })
        }), o = {
          name: "skipping"
        };
        break
      }
    }
  }
}

function wY({
  editor: t
}) {
  const e = t.getSelectedShapes(),
    n = t.getSelectionRotation(),
    r = t.getSelectionRotatedPageBounds(),
    {
      inputs: {
        originPagePoint: o
      }
    } = t;
  if (!r) return null;
  const s = r.center.clone().rotWith(r.point, n);
  return {
    selectionPageCenter: s,
    initialCursorAngle: s.angle(o),
    initialSelectionRotation: n,
    shapeSnapshots: e.map(i => ({
      shape: Na(i),
      initialPagePoint: t.getShapePageTransform(i.id).point()
    }))
  }
}

function SY({
  delta: t,
  editor: e,
  snapshot: n,
  stage: r
}) {
  const {
    selectionPageCenter: o,
    shapeSnapshots: s
  } = n;
  e.updateShapes(s.map(({
    shape: a,
    initialPagePoint: c
  }) => {
    const l = yo(a.parentId) ? e.getShapePageTransform(a.parentId) : Ee.Identity(),
      u = T.RotWith(c, o, t),
      d = Ee.applyToPoint(Ee.Inverse(l), u),
      f = br(a.rotation + t);
    return {
      id: a.id,
      type: a.type,
      x: d.x,
      y: d.y,
      rotation: f
    }
  }));
  const i = [];
  s.forEach(({
    shape: a
  }) => {
    var d, f, h;
    const c = e.getShape(a.id);
    if (!c) return;
    const l = e.getShapeUtil(a);
    if (r === "start" || r === "one-off") {
      const m = (d = l.onRotateStart) == null ? void 0 : d.call(l, a);
      m && i.push(m)
    }
    const u = (f = l.onRotate) == null ? void 0 : f.call(l, a, c);
    if (u && i.push(u), r === "end" || r === "one-off") {
      const m = (h = l.onRotateEnd) == null ? void 0 : h.call(l, a, c);
      m && i.push(m)
    }
  }), i.length > 0 && e.updateShapes(i)
}
const _Y = t => {
    const {
      store: e
    } = t, n = e.query.filterHistory("shape"), r = e.query.records("shape", () => ({
      type: {
        eq: "arrow"
      }
    }));

    function o() {
      const s = r.get(),
        i = {};
      for (const a of s) {
        const {
          start: c,
          end: l
        } = a.props;
        if (c.type === "binding") {
          const u = i[c.boundShapeId];
          u ? u.push({
            arrowId: a.id,
            handleId: "start"
          }) : i[c.boundShapeId] = [{
            arrowId: a.id,
            handleId: "start"
          }]
        }
        if (l.type === "binding") {
          const u = i[l.boundShapeId];
          u ? u.push({
            arrowId: a.id,
            handleId: "end"
          }) : i[l.boundShapeId] = [{
            arrowId: a.id,
            handleId: "end"
          }]
        }
      }
      return i
    }
    return Q("arrowBindingsIndex", (s, i) => {
      if (Dl(s)) return o();
      const a = s,
        c = n.getDiffSince(i);
      if (c === Fr) return o();
      let l;

      function u(h) {
        l || (l = {
          ...a
        }), l[h] ? l[h] === a[h] && (l[h] = [...l[h]]) : l[h] = []
      }

      function d(h, m, p) {
        u(h), l[h] = l[h].filter(b => b.arrowId !== m || b.handleId !== p), l[h].length === 0 && delete l[h]
      }

      function f(h, m, p) {
        u(h), l[h].push({
          arrowId: m,
          handleId: p
        })
      }
      for (const h of c) {
        for (const m of Object.values(h.added))
          if (t.isShapeOfType(m, "arrow")) {
            const {
              start: p,
              end: b
            } = m.props;
            p.type === "binding" && f(p.boundShapeId, m.id, "start"), b.type === "binding" && f(b.boundShapeId, m.id, "end")
          } for (const [m, p] of Object.values(h.updated))
          if (!(!t.isShapeOfType(m, "arrow") || !t.isShapeOfType(p, "arrow")))
            for (const b of ["start", "end"]) {
              const w = m.props[b],
                v = p.props[b];
              w.type === "binding" && v.type === "point" ? d(w.boundShapeId, m.id, b) : w.type === "point" && v.type === "binding" ? f(v.boundShapeId, p.id, b) : w.type === "binding" && v.type === "binding" && w.boundShapeId !== v.boundShapeId && (d(w.boundShapeId, m.id, b), f(v.boundShapeId, p.id, b))
            }
        for (const m of Object.values(h.removed))
          if (t.isShapeOfType(m, "arrow")) {
            const {
              start: p,
              end: b
            } = m.props;
            p.type === "binding" && d(p.boundShapeId, m.id, "start"), b.type === "binding" && d(b.boundShapeId, m.id, "end")
          }
      }
      return l ?? a
    })
  },
  xY = t => {
    const e = t.query.ids("shape");

    function n() {
      const r = {},
        o = e.get(),
        s = Array(o.size);
      return o.forEach(i => s.push(t.get(i))), s.sort(ts), s.forEach(i => {
        r[i.parentId] || (r[i.parentId] = []), r[i.parentId].push(i.id)
      }), r
    }
    return Q("parentsToChildrenWithIndexes", (r, o) => {
      if (Dl(r)) return n();
      const s = t.history.getDiffSince(o);
      if (s === Fr) return n();
      if (s.length === 0) return r;
      let i = null;
      const a = u => {
          i || (i = {
            ...r
          }), i[u] ? i[u] === r[u] && (i[u] = [...i[u]]) : i[u] = []
        },
        c = new Set;
      let l;
      for (let u = 0, d = s.length; u < d; u++) {
        l = s[u];
        for (const f of Object.values(l.added)) Ia(f) && (a(f.parentId), i[f.parentId].push(f.id), c.add(i[f.parentId]));
        for (const [f, h] of Object.values(l.updated))
          if (Ia(h) && Ia(f)) {
            if (f.parentId !== h.parentId) a(f.parentId), a(h.parentId), i[f.parentId].splice(i[f.parentId].indexOf(h.id), 1), i[h.parentId].push(h.id), c.add(i[h.parentId]);
            else if (f.index !== h.index) {
              a(h.parentId);
              const m = i[h.parentId].indexOf(h.id);
              i[h.parentId][m] = h.id, c.add(i[h.parentId])
            }
          } for (const f of Object.values(l.removed)) Ia(f) && (a(f.parentId), i[f.parentId].splice(i[f.parentId].indexOf(f.id), 1))
      }
      for (const u of c) {
        const d = Fe(u.map(f => t.get(f)));
        d.sort(ts), u.splice(0, u.length, ...d.map(f => f.id))
      }
      return i ?? r
    })
  },
  X0 = (t, e, n) => {
    for (; !$r(n.parentId);) {
      const r = t.get(n.parentId);
      if (!r) return !1;
      n = r
    }
    return n.parentId === e
  },
  EY = (t, e) => {
    const n = t.query.ids("shape");
    let r = null;

    function o() {
      const s = e();
      return r = s, new Set([...n.get()].filter(i => X0(t, s, t.get(i))))
    }
    return Q("_shapeIdsInCurrentPage", (s, i) => {
      if (Dl(s)) return o();
      const a = e();
      if (a !== r) return o();
      const c = t.history.getDiffSince(i);
      if (c === Fr) return o();
      const l = new Ig(s);
      for (const d of c) {
        for (const f of Object.values(d.added)) Ia(f) && X0(t, a, f) && l.add(f.id);
        for (const [f, h] of Object.values(d.updated)) Ia(h) && (X0(t, a, h) ? l.add(h.id) : l.remove(h.id));
        for (const f of Object.keys(d.removed)) yo(f) && l.remove(f)
      }
      const u = l.get();
      return u ? Td(u.value, u.diff) : s
    })
  },
  kY = 40;
class CY {
  constructor(e) {
    P(this, "_clickId", "");
    P(this, "_clickTimeout");
    P(this, "_clickScreenPoint");
    P(this, "_previousScreenPoint");
    P(this, "_getClickTimeout", (e, n = It()) => {
      this._clickId = n, clearTimeout(this._clickTimeout), this._clickTimeout = setTimeout(() => {
        if (this._clickState === e && this._clickId === n) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break
            }
          }
          this._clickState = "idle"
        }
      }, e === "idle" || e === "pendingDouble" ? xV : EV)
    });
    P(this, "_clickState", "idle");
    P(this, "lastPointerInfo", {});
    P(this, "transformPointerDownEvent", e => {
      if (!this._clickState) return e;
      switch (this._clickScreenPoint = T.From(e.point), this._previousScreenPoint && this._previousScreenPoint.dist(this._clickScreenPoint) > kY && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = e, this._clickState) {
        case "idle":
          return this._clickState = "pendingDouble", this._clickTimeout = this._getClickTimeout(this._clickState), e;
        case "pendingDouble":
          return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
            ...e,
            type: "click",
            name: "double_click",
            phase: "down"
          };
        case "pendingTriple":
          return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
            ...e,
            type: "click",
            name: "triple_click",
            phase: "down"
          };
        case "pendingQuadruple":
          return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
            ...e,
            type: "click",
            name: "quadruple_click",
            phase: "down"
          };
        case "pendingOverflow":
          return this._clickState = "overflow", this._clickTimeout = this._getClickTimeout(this._clickState), e;
        default:
          return this._clickTimeout = this._getClickTimeout(this._clickState), e
      }
    });
    P(this, "transformPointerUpEvent", e => {
      if (!this._clickState) return e;
      switch (this._clickScreenPoint = T.From(e.point), this._clickState) {
        case "pendingTriple":
          return {
            ...this.lastPointerInfo, type: "click", name: "double_click", phase: "up"
          };
        case "pendingQuadruple":
          return {
            ...this.lastPointerInfo, type: "click", name: "triple_click", phase: "up"
          };
        case "pendingOverflow":
          return {
            ...this.lastPointerInfo, type: "click", name: "quadruple_click", phase: "up"
          };
        default:
          return e
      }
    });
    P(this, "cancelDoubleClickTimeout", () => {
      this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle"
    });
    P(this, "handleMove", () => {
      this._clickState !== "idle" && this._clickScreenPoint && this._clickScreenPoint.dist(this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? NS : LS) && this.cancelDoubleClickTimeout()
    });
    this.editor = e
  }
  get clickState() {
    return this._clickState
  }
}
class PY {
  constructor(e) {
    P(this, "isSafari");
    P(this, "isIos");
    P(this, "isChromeForIos");
    P(this, "isFirefox");
    P(this, "isAndroid");
    this.editor = e, typeof window < "u" && "navigator" in window ? (this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i), this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent), this.isFirefox = /firefox/i.test(navigator.userAgent), this.isAndroid = /android/i.test(navigator.userAgent)) : (this.isSafari = !1, this.isIos = !1, this.isChromeForIos = !1, this.isFirefox = !1, this.isAndroid = !1)
  }
}

function pa(t) {
  if (t) {
    let e = _T;
    for (; t.length;) e = e.push(t.pop());
    return e
  }
  return _T
}
class TY {
  constructor() {
    P(this, "length", 0);
    P(this, "head", null);
    P(this, "tail", this)
  }
  push(e) {
    return new $1(e, this)
  }
  toArray() {
    return Ns
  } [Symbol.iterator]() {
    return {
      next() {
        return {
          value: void 0,
          done: !0
        }
      }
    }
  }
}
const _T = new TY;
class $1 {
  constructor(e, n) {
    P(this, "length");
    this.head = e, this.tail = n, this.length = n.length + 1
  }
  push(e) {
    return new $1(e, this)
  }
  toArray() {
    return Array.from(this)
  } [Symbol.iterator]() {
    let e = this;
    return {
      next() {
        if (e.length) {
          const n = e.head;
          return e = e.tail, {
            value: n,
            done: !1
          }
        } else return {
          value: void 0,
          done: !0
        }
      }
    }
  }
}
class $Y {
  constructor(e, n) {
    P(this, "_undos", tr("HistoryManager.undos", pa()));
    P(this, "_redos", tr("HistoryManager.redos", pa()));
    P(this, "_batchDepth", 0);
    P(this, "onBatchComplete", () => {});
    P(this, "_commands", {});
    P(this, "createCommand", (e, n, r) => {
      if (this._commands[e]) throw new Error(`Duplicate command: ${e}`);
      this._commands[e] = r;
      const o = (...s) => {
        if (!this._batchDepth) return this.batch(() => o(...s)), this.ctx;
        const i = n(...s);
        if (!i) return this.ctx;
        const {
          data: a,
          ephemeral: c,
          squashing: l,
          preservesRedoStack: u
        } = i;
        if (this.ignoringUpdates((d, f) => (r.do(a), {
            undos: d,
            redos: f
          })), !c) {
          const d = this._undos.get().head;
          l && d && d.type === "command" && d.name === e && d.preservesRedoStack === u ? this._undos.update(f => f.tail.push({
            ...d,
            id: It(),
            data: r.squash(d.data, a)
          })) : this._undos.update(f => f.push({
            type: "command",
            name: e,
            data: a,
            id: It(),
            preservesRedoStack: u
          })), i.preservesRedoStack || this._redos.set(pa()), this.ctx.emit("change-history", {
            reason: "push"
          })
        }
        return this.ctx
      };
      return o
    });
    P(this, "batch", e => {
      try {
        this._batchDepth++, this._batchDepth === 1 ? Zr(() => {
          var r, o;
          const n = (r = this._undos.get().head) == null ? void 0 : r.id;
          e(), n !== ((o = this._undos.get().head) == null ? void 0 : o.id) && this.onBatchComplete()
        }) : e()
      } catch (n) {
        throw this.annotateError(n), n
      } finally {
        this._batchDepth--
      }
      return this
    });
    P(this, "ignoringUpdates", e => {
      let n = this._undos.get(),
        r = this._redos.get();
      this._undos.set(pa()), this._redos.set(pa());
      try {
        ({
          undos: n,
          redos: r
        } = Zr(() => e(n, r)))
      } finally {
        this._undos.set(n), this._redos.set(r)
      }
    });
    P(this, "_undo", ({
      pushToRedoStack: e,
      toMark: n = void 0
    }) => (this.ignoringUpdates((r, o) => {
      var s;
      if (r.length === 0) return {
        undos: r,
        redos: o
      };
      for (;
        ((s = r.head) == null ? void 0 : s.type) === "STOP";) {
        const i = r.head;
        if (r = r.tail, e && (o = o.push(i)), i.id === n) return this.ctx.emit("change-history", e ? {
          reason: "undo"
        } : {
          reason: "bail",
          markId: n
        }), {
          undos: r,
          redos: o
        }
      }
      if (r.length === 0) return this.ctx.emit("change-history", e ? {
        reason: "undo"
      } : {
        reason: "bail",
        markId: n
      }), {
        undos: r,
        redos: o
      };
      for (; r.head;) {
        const i = r.head;
        if (r = r.tail, e && (o = o.push(i)), i.type === "STOP") {
          if (i.onUndo && (!n || i.id === n)) return this.ctx.emit("change-history", e ? {
            reason: "undo"
          } : {
            reason: "bail",
            markId: n
          }), {
            undos: r,
            redos: o
          }
        } else this._commands[i.name].undo(i.data)
      }
      return this.ctx.emit("change-history", e ? {
        reason: "undo"
      } : {
        reason: "bail",
        markId: n
      }), {
        undos: r,
        redos: o
      }
    }), this));
    P(this, "undo", () => (this._undo({
      pushToRedoStack: !0
    }), this));
    P(this, "redo", () => (this.ignoringUpdates((e, n) => {
      var r;
      if (n.length === 0) return {
        undos: e,
        redos: n
      };
      for (;
        ((r = n.head) == null ? void 0 : r.type) === "STOP";) e = e.push(n.head), n = n.tail;
      if (n.length === 0) return this.ctx.emit("change-history", {
        reason: "redo"
      }), {
        undos: e,
        redos: n
      };
      for (; n.head;) {
        const o = n.head;
        if (e = e.push(n.head), n = n.tail, o.type === "STOP") {
          if (o.onRedo) break
        } else {
          const s = this._commands[o.name];
          s.redo ? s.redo(o.data) : s.do(o.data)
        }
      }
      return this.ctx.emit("change-history", {
        reason: "redo"
      }), {
        undos: e,
        redos: n
      }
    }), this));
    P(this, "bail", () => (this._undo({
      pushToRedoStack: !1
    }), this));
    P(this, "bailToMark", e => (this._undo({
      pushToRedoStack: !1,
      toMark: e
    }), this));
    P(this, "mark", (e = It(), n = !0, r = !0) => {
      const o = this._undos.get().head;
      return o && o.type === "STOP" && o.id === e && o.onUndo === n && o.onRedo === r ? o.id : (this._undos.update(s => s.push({
        type: "STOP",
        id: e,
        onUndo: n,
        onRedo: r
      })), this.ctx.emit("mark-history", {
        id: e
      }), e)
    });
    this.ctx = e, this.annotateError = n
  }
  get numUndos() {
    return this._undos.get().length
  }
  get numRedos() {
    return this._redos.get().length
  }
  clear() {
    this._undos.set(pa()), this._redos.set(pa())
  }
}
class IY {
  constructor(e) {
    P(this, "scribbleItems", new Map);
    P(this, "state", "paused");
    P(this, "addScribble", (e, n = It()) => {
      const r = {
        id: n,
        scribble: {
          id: n,
          size: 20,
          color: "accent",
          opacity: .8,
          delay: 0,
          points: [],
          shrink: .1,
          taper: !0,
          ...e,
          state: "starting"
        },
        timeoutMs: 0,
        delayRemaining: e.delay ?? 0,
        prev: null,
        next: null
      };
      return this.scribbleItems.set(n, r), this.state === "paused" && this.resume(), r
    });
    P(this, "stop", e => {
      const n = this.scribbleItems.get(e);
      if (!n) throw Error(`Scribble with id ${e} not found`);
      return n.delayRemaining = Math.min(n.delayRemaining, 200), n.scribble.state = "stopping", n
    });
    P(this, "addPoint", (e, n, r) => {
      const o = this.scribbleItems.get(e);
      if (!o) throw Error(`Scribble with id ${e} not found`);
      const {
        prev: s
      } = o, i = {
        x: n,
        y: r,
        z: .5
      };
      return (!s || T.Dist(s, i) >= 1) && (o.next = i), o
    });
    P(this, "tick", e => {
      this.editor.batch(() => {
        this.scribbleItems.forEach(n => {
          if (n.scribble.state === "starting") {
            const {
              next: c,
              prev: l
            } = n;
            c && c !== l && (n.prev = c, n.scribble.points.push(c)), n.scribble.points.length > 8 && (n.scribble.state = "active");
            return
          }
          n.delayRemaining > 0 && (n.delayRemaining = Math.max(0, n.delayRemaining - e)), n.timeoutMs += e, n.timeoutMs >= 16 && (n.timeoutMs = 0);
          const {
            delayRemaining: r,
            timeoutMs: o,
            prev: s,
            next: i,
            scribble: a
          } = n;
          switch (a.state) {
            case "active": {
              i && i !== s ? (n.prev = i, a.points.push(i), r === 0 && a.points.length > 8 && a.points.shift()) : o === 0 && (a.points.length > 1 ? a.points.shift() : n.delayRemaining = a.delay);
              break
            }
            case "stopping": {
              if (n.delayRemaining === 0 && o === 0) {
                if (a.points.length === 1) {
                  this.scribbleItems.delete(n.id);
                  return
                }
                a.shrink && (a.size = Math.max(1, a.size * (1 - a.shrink))), a.points.shift()
              }
              break
            }
          }
        }), this.editor.updateInstanceState({
          scribbles: Array.from(this.scribbleItems.values()).map(({
            scribble: n
          }) => ({
            ...n,
            points: [...n.points]
          })).slice(-5)
        }), this.scribbleItems.size === 0 && this.pause()
      })
    });
    this.editor = e
  }
  resume() {
    this.state = "running", this.editor.addListener("tick", this.tick)
  }
  pause() {
    this.editor.removeListener("tick", this.tick), this.state = "paused"
  }
  reset() {
    this.editor.updateInstanceState({
      scribbles: []
    }), this.scribbleItems.clear(), this.pause()
  }
}
class OY {
  constructor(e) {
    P(this, "_beforeCreateHandlers", {});
    P(this, "_afterCreateHandlers", {});
    P(this, "_beforeChangeHandlers", {});
    P(this, "_afterChangeHandlers", {});
    P(this, "_beforeDeleteHandlers", {});
    P(this, "_afterDeleteHandlers", {});
    P(this, "_batchCompleteHandlers", []);
    this.editor = e, e.store.onBeforeCreate = (r, o) => {
      const s = this._beforeCreateHandlers[r.typeName];
      if (s) {
        let i = r;
        for (const a of s) i = a(i, o);
        return i
      }
      return r
    }, e.store.onAfterCreate = (r, o) => {
      const s = this._afterCreateHandlers[r.typeName];
      if (s)
        for (const i of s) i(r, o)
    }, e.store.onBeforeChange = (r, o, s) => {
      const i = this._beforeChangeHandlers[o.typeName];
      if (i) {
        let a = o;
        for (const c of i) a = c(r, a, s);
        return a
      }
      return o
    };
    let n = 0;
    e.store.onAfterChange = (r, o, s) => {
      if (n++, n > 1e3) console.error("[CleanupManager.onAfterChange] Maximum update depth exceeded, bailing out.");
      else {
        const i = this._afterChangeHandlers[o.typeName];
        if (i)
          for (const a of i) a(r, o, s)
      }
      n--
    }, e.store.onBeforeDelete = (r, o) => {
      const s = this._beforeDeleteHandlers[r.typeName];
      if (s) {
        for (const i of s)
          if (i(r, o) === !1) return !1
      }
    }, e.store.onAfterDelete = (r, o) => {
      const s = this._afterDeleteHandlers[r.typeName];
      if (s)
        for (const i of s) i(r, o)
    }, e.history.onBatchComplete = () => {
      this._batchCompleteHandlers.forEach(r => r())
    }
  }
  registerBeforeCreateHandler(e, n) {
    return this._beforeCreateHandlers[e] || (this._beforeCreateHandlers[e] = []), this._beforeCreateHandlers[e].push(n), () => ga(this._beforeCreateHandlers[e], n)
  }
  registerAfterCreateHandler(e, n) {
    return this._afterCreateHandlers[e] || (this._afterCreateHandlers[e] = []), this._afterCreateHandlers[e].push(n), () => ga(this._afterCreateHandlers[e], n)
  }
  registerBeforeChangeHandler(e, n) {
    return this._beforeChangeHandlers[e] || (this._beforeChangeHandlers[e] = []), this._beforeChangeHandlers[e].push(n), () => ga(this._beforeChangeHandlers[e], n)
  }
  registerAfterChangeHandler(e, n) {
    return this._afterChangeHandlers[e] || (this._afterChangeHandlers[e] = []), this._afterChangeHandlers[e].push(n), () => ga(this._afterChangeHandlers[e], n)
  }
  registerBeforeDeleteHandler(e, n) {
    return this._beforeDeleteHandlers[e] || (this._beforeDeleteHandlers[e] = []), this._beforeDeleteHandlers[e].push(n), () => ga(this._beforeDeleteHandlers[e], n)
  }
  registerAfterDeleteHandler(e, n) {
    return this._afterDeleteHandlers[e] || (this._afterDeleteHandlers[e] = []), this._afterDeleteHandlers[e].push(n), () => ga(this._afterDeleteHandlers[e], n)
  }
  registerBatchCompleteHandler(e) {
    return this._batchCompleteHandlers.push(e), () => ga(this._batchCompleteHandlers, e)
  }
}

function ga(t, e) {
  const n = t.indexOf(e);
  n >= 0 && t.splice(n, 1)
}
var RY = Object.defineProperty,
  AY = Object.getOwnPropertyDescriptor,
  dc = (t, e, n, r) => {
    for (var o = r > 1 ? void 0 : r ? AY(e, n) : e, s = t.length - 1, i; s >= 0; s--)(i = t[s]) && (o = (r ? i(e, n, o) : i(o)) || o);
    return r && o && RY(e, n, o), o
  };
const Pe = t => Math.round(t * 10 ** 8) / 10 ** 8;

function ks(t, e, n, r, o) {
  const s = t.filter(a => (r === "forward" ? a.startNode.id === e : a.endNode.id === e) && Pe(a.length) === Pe(n) && So(a.breadthIntersection[0], a.breadthIntersection[1], o[0], o[1]));
  if (s.length === 0) return [];
  const i = new Set;
  return s.forEach(a => {
    const c = r === "forward" ? a.endNode.id : a.startNode.id;
    if (!i.has(c)) {
      i.add(c);
      const l = ks(t, c, n, r, So(a.breadthIntersection[0], a.breadthIntersection[1], o[0], o[1]));
      s.push(...l)
    }
  }), s
}

function MY(t) {
  t.sort((e, n) => n.gaps.length - e.gaps.length);
  for (let e = t.length - 1; e > 0; e--) {
    const n = t[e];
    for (let r = e - 1; r >= 0; r--) {
      const o = t[r];
      if (o.direction === n.direction && n.gaps.every(s => o.gaps.some(i => Pe(s.startEdge[0].x) === Pe(i.startEdge[0].x) && Pe(s.startEdge[0].y) === Pe(i.startEdge[0].y) && Pe(s.startEdge[1].x) === Pe(i.startEdge[1].x) && Pe(s.startEdge[1].y) === Pe(i.startEdge[1].y)) && o.gaps.some(i => Pe(s.endEdge[0].x) === Pe(i.endEdge[0].x) && Pe(s.endEdge[0].y) === Pe(i.endEdge[0].y) && Pe(s.endEdge[1].x) === Pe(i.endEdge[1].x) && Pe(s.endEdge[1].y) === Pe(i.endEdge[1].y)))) {
        t.splice(e, 1);
        break
      }
    }
  }
}
class na {
  constructor(e) {
    P(this, "_snapLines", tr("snapLines", void 0));
    this.editor = e
  }
  get lines() {
    return this._snapLines.get() ?? Ns
  }
  clear() {
    this.lines.length && this._snapLines.set(void 0)
  }
  setLines(e) {
    this._snapLines.set(e)
  }
  get snapPointsCache() {
    const {
      editor: e
    } = this;
    return e.store.createComputedCache("snapPoints", n => {
      const r = e.getShapePageTransform(n.id);
      return r ? this.editor.getShapeGeometry(n).snapPoints.map((s, i) => {
        const {
          x: a,
          y: c
        } = Ee.applyToPoint(r, s);
        return {
          x: a,
          y: c,
          id: `${n.id}:${i}`
        }
      }) : void 0
    })
  }
  get snapThreshold() {
    return 8 / this.editor.zoomLevel
  }
  get snappableShapes() {
    const {
      editor: e
    } = this, {
      renderingBounds: n
    } = e, r = e.getSelectedShapeIds(), o = [], s = i => {
      const a = e.getSortedChildIdsForParent(i);
      for (const c of a) {
        if (r.includes(c)) continue;
        const l = e.getShape(c);
        if (!l || !e.getShapeUtil(l).canSnap(l)) continue;
        const d = e.getShapePageBounds(c);
        if (d && n.includes(d)) {
          if (e.isShapeOfType(l, "group")) {
            s(c);
            continue
          }
          o.push({
            id: c,
            pageBounds: d,
            isClosed: e.getShapeGeometry(l).isClosed
          })
        }
      }
    };
    return s(this.currentCommonAncestor ?? e.currentPageId), o
  }
  get currentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes())
  }
  get snappablePoints() {
    const {
      snappableShapes: e,
      snapPointsCache: n
    } = this, r = [];
    return e.forEach(o => {
      const s = n.get(o.id);
      s && r.push(...s)
    }), r
  }
  get visibleGaps() {
    const e = [],
      n = [];
    let r, o;
    const s = this.snappableShapes.sort((a, c) => a.pageBounds.minX - c.pageBounds.minX);
    for (let a = 0; a < s.length; a++) {
      r = s[a];
      for (let c = a + 1; c < s.length; c++) o = s[c], r.pageBounds.maxX < o.pageBounds.minX && ad(r.pageBounds.minY, r.pageBounds.maxY, o.pageBounds.minY, o.pageBounds.maxY) && e.push({
        startNode: r,
        endNode: o,
        startEdge: [new T(r.pageBounds.maxX, r.pageBounds.minY), new T(r.pageBounds.maxX, r.pageBounds.maxY)],
        endEdge: [new T(o.pageBounds.minX, o.pageBounds.minY), new T(o.pageBounds.minX, o.pageBounds.maxY)],
        length: o.pageBounds.minX - r.pageBounds.maxX,
        breadthIntersection: So(r.pageBounds.minY, r.pageBounds.maxY, o.pageBounds.minY, o.pageBounds.maxY)
      })
    }
    const i = s.sort((a, c) => a.pageBounds.minY - c.pageBounds.minY);
    for (let a = 0; a < i.length; a++) {
      r = i[a];
      for (let c = a + 1; c < i.length; c++) o = i[c], r.pageBounds.maxY < o.pageBounds.minY && ad(r.pageBounds.minX, r.pageBounds.maxX, o.pageBounds.minX, o.pageBounds.maxX) && n.push({
        startNode: r,
        endNode: o,
        startEdge: [new T(r.pageBounds.minX, r.pageBounds.maxY), new T(r.pageBounds.maxX, r.pageBounds.maxY)],
        endEdge: [new T(o.pageBounds.minX, o.pageBounds.minY), new T(o.pageBounds.maxX, o.pageBounds.minY)],
        length: o.pageBounds.minY - r.pageBounds.maxY,
        breadthIntersection: So(r.pageBounds.minX, r.pageBounds.maxX, o.pageBounds.minX, o.pageBounds.maxX)
      })
    }
    return {
      horizontal: e,
      vertical: n
    }
  }
  snapTranslate({
    lockedAxis: e,
    initialSelectionPageBounds: n,
    initialSelectionSnapPoints: r,
    dragDelta: o
  }) {
    var b, w;
    const {
      snappablePoints: s,
      snapThreshold: i
    } = this, a = n.clone().translate(o), c = r.map(({
      x: v,
      y: _
    }, S) => ({
      id: "selection:" + S,
      x: v + o.x,
      y: _ + o.y
    })), l = s, u = [], d = [], f = new T(i, i);
    this.collectPointSnaps({
      minOffset: f,
      nearestSnapsX: u,
      nearestSnapsY: d,
      otherNodeSnapPoints: l,
      selectionSnapPoints: c
    }), this.collectGapSnaps({
      selectionPageBounds: a,
      nearestSnapsX: u,
      nearestSnapsY: d,
      minOffset: f
    });
    const h = new T(e === "x" ? 0 : ((b = u[0]) == null ? void 0 : b.nudge) ?? 0, e === "y" ? 0 : ((w = d[0]) == null ? void 0 : w.nudge) ?? 0);
    f.x = 0, f.y = 0, u.length = 0, d.length = 0, c.forEach(v => {
      v.x += h.x, v.y += h.y
    }), a.translate(h), this.collectPointSnaps({
      minOffset: f,
      nearestSnapsX: u,
      nearestSnapsY: d,
      otherNodeSnapPoints: l,
      selectionSnapPoints: c
    }), this.collectGapSnaps({
      selectionPageBounds: a,
      nearestSnapsX: u,
      nearestSnapsY: d,
      minOffset: f
    });
    const m = this.getPointSnapLines({
        nearestSnapsX: u,
        nearestSnapsY: d
      }),
      p = this.getGapSnapLines({
        selectionPageBounds: a,
        nearestSnapsX: u,
        nearestSnapsY: d
      });
    return this._snapLines.set([...p, ...m]), {
      nudge: h
    }
  }
  get outlinesInPageSpace() {
    return this.snappableShapes.map(({
      id: e,
      isClosed: n
    }) => {
      const r = Ni(this.editor.getShapeGeometry(e).vertices);
      n && r.push(r[0]);
      const o = this.editor.getShapePageTransform(e);
      if (!o) throw Error("No page transform");
      return Ee.applyToPoints(o, r)
    })
  }
  getSnappingHandleDelta({
    handlePoint: e,
    additionalSegments: n
  }) {
    const {
      outlinesInPageSpace: r,
      snapThreshold: o
    } = this;
    let s = o,
      i = null,
      a, c, l, u;
    const d = [...r, ...n];
    for (const f of d)
      for (let h = 0; h < f.length - 1; h++) a = f[h], c = f[h + 1], l = T.NearestPointOnLineSegment(a, c, e), u = T.Dist(e, l), !isNaN(u) && u < s && (s = u, i = l);
    return i ? (this._snapLines.set([{
      id: It(),
      type: "points",
      points: [i]
    }]), T.Sub(i, e)) : null
  }
  snapResize({
    initialSelectionPageBounds: e,
    dragDelta: n,
    handle: r,
    isAspectRatioLocked: o,
    isResizingFromCenter: s
  }) {
    var k, C;
    const {
      snapThreshold: i
    } = this, {
      box: a,
      scaleX: c,
      scaleY: l
    } = Be.Resize(e, r, s ? n.x * 2 : n.x, s ? n.y * 2 : n.y, o);
    let u = r;
    c < 0 && (u = iV(u)), l < 0 && (u = sV(u)), s && (a.center = e.center);
    const d = u === "top" || u === "bottom",
      f = u === "left" || u === "right",
      h = xT(u, a),
      m = this.snappablePoints,
      p = [],
      b = [],
      w = new T(i, i);
    this.collectPointSnaps({
      minOffset: w,
      nearestSnapsX: p,
      nearestSnapsY: b,
      otherNodeSnapPoints: m,
      selectionSnapPoints: h
    });
    const v = new T(d ? 0 : ((k = p[0]) == null ? void 0 : k.nudge) ?? 0, f ? 0 : ((C = b[0]) == null ? void 0 : C.nudge) ?? 0);
    if (o && aV(u) && v.len() !== 0) {
      const $ = p.length && b.length ? Math.abs(v.x) < Math.abs(v.y) ? "x" : "y" : p.length ? "x" : "y",
        I = e.aspectRatio;
      $ === "x" ? (b.length = 0, v.y = v.x / I, (u === "bottom_left" || u === "top_right") && (v.y = -v.y)) : (p.length = 0, v.x = v.y * I, (u === "bottom_left" || u === "top_right") && (v.x = -v.x))
    }
    const _ = T.Add(n, v),
      {
        box: S
      } = Be.Resize(e, r, s ? _.x * 2 : _.x, s ? _.y * 2 : _.y, o);
    s && (S.center = e.center);
    const x = xT("any", S);
    p.length = 0, b.length = 0, w.x = 0, w.y = 0, this.collectPointSnaps({
      minOffset: w,
      nearestSnapsX: p,
      nearestSnapsY: b,
      otherNodeSnapPoints: m,
      selectionSnapPoints: x
    });
    const E = this.getPointSnapLines({
      nearestSnapsX: p,
      nearestSnapsY: b
    });
    return this._snapLines.set([...E]), {
      nudge: v
    }
  }
  collectPointSnaps({
    selectionSnapPoints: e,
    otherNodeSnapPoints: n,
    minOffset: r,
    nearestSnapsX: o,
    nearestSnapsY: s
  }) {
    for (const i of e)
      for (const a of n) {
        const c = T.Sub(i, a),
          l = Math.abs(c.x),
          u = Math.abs(c.y);
        Pe(l) <= Pe(r.x) && (Pe(l) < Pe(r.x) && (o.length = 0), o.push({
          type: "points",
          points: {
            thisPoint: i,
            otherPoint: a
          },
          nudge: a.x - i.x
        }), r.x = l), Pe(u) <= Pe(r.y) && (Pe(u) < Pe(r.y) && (s.length = 0), s.push({
          type: "points",
          points: {
            thisPoint: i,
            otherPoint: a
          },
          nudge: a.y - i.y
        }), r.y = u)
      }
  }
  collectGapSnaps({
    selectionPageBounds: e,
    minOffset: n,
    nearestSnapsX: r,
    nearestSnapsY: o
  }) {
    const {
      horizontal: s,
      vertical: i
    } = this.visibleGaps;
    for (const a of s) {
      if (!ad(a.breadthIntersection[0], a.breadthIntersection[1], e.minY, e.maxY)) continue;
      const l = a.startEdge[0].x + a.length / 2 - e.center.x;
      if (a.length > e.width && Pe(Math.abs(l)) <= Pe(n.x)) {
        Pe(Math.abs(l)) < Pe(n.x) && (r.length = 0), n.x = Math.abs(l);
        const w = {
            type: "gap_center",
            gap: a,
            nudge: l
          },
          v = r.find(({
            type: S
          }) => S === "gap_center"),
          _ = v && So(a.breadthIntersection[0], a.breadthIntersection[1], v.gap.breadthIntersection[0], v.gap.breadthIntersection[1]);
        v && v.gap.length > a.length && _ ? r[r.indexOf(v)] = w : (!v || !_) && r.push(w)
      }
      const d = a.startNode.pageBounds.minX - a.length,
        f = e.maxX,
        h = d - f;
      Pe(Math.abs(h)) <= Pe(n.x) && (Pe(Math.abs(h)) < Pe(n.x) && (r.length = 0), n.x = Math.abs(h), r.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "left",
        nudge: h
      }));
      const m = a.endNode.pageBounds.maxX + a.length,
        p = e.minX,
        b = m - p;
      Pe(Math.abs(b)) <= Pe(n.x) && (Pe(Math.abs(b)) < Pe(n.x) && (r.length = 0), n.x = Math.abs(b), r.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "right",
        nudge: b
      }))
    }
    for (const a of i) {
      if (!ad(a.breadthIntersection[0], a.breadthIntersection[1], e.minX, e.maxX)) continue;
      const l = a.startEdge[0].y + a.length / 2 - e.center.y;
      if (a.length > e.height && Pe(Math.abs(l)) <= Pe(n.y)) {
        Pe(Math.abs(l)) < Pe(n.y) && (o.length = 0), n.y = Math.abs(l);
        const w = {
            type: "gap_center",
            gap: a,
            nudge: l
          },
          v = o.find(({
            type: S
          }) => S === "gap_center"),
          _ = v && ad(v.gap.breadthIntersection[0], v.gap.breadthIntersection[1], a.breadthIntersection[0], a.breadthIntersection[1]);
        v && v.gap.length > a.length && _ ? o[o.indexOf(v)] = w : (!v || !_) && o.push(w);
        continue
      }
      const d = a.startNode.pageBounds.minY - a.length,
        f = e.maxY,
        h = d - f;
      Pe(Math.abs(h)) <= Pe(n.y) && (Pe(Math.abs(h)) < Pe(n.y) && (o.length = 0), n.y = Math.abs(h), o.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "top",
        nudge: h
      }));
      const m = a.endNode.pageBounds.maxY + a.length,
        p = e.minY,
        b = m - p;
      Pe(Math.abs(b)) <= Pe(n.y) && (Pe(Math.abs(b)) < Pe(n.y) && (o.length = 0), n.y = Math.abs(b), o.push({
        type: "gap_duplicate",
        gap: a,
        protrusionDirection: "bottom",
        nudge: b
      }))
    }
  }
  getPointSnapLines({
    nearestSnapsX: e,
    nearestSnapsY: n
  }) {
    const r = {},
      o = {};
    if (e.length > 0) {
      for (const s of e)
        if (s.type === "points") {
          const i = Pe(s.points.otherPoint.x);
          r[i] || (r[i] = []), r[i].push(s.points)
        }
    }
    if (n.length > 0) {
      for (const s of n)
        if (s.type === "points") {
          const i = Pe(s.points.otherPoint.y);
          o[i] || (o[i] = []), o[i].push(s.points)
        }
    }
    return Object.values(r).concat(Object.values(o)).map(s => ({
      id: It(),
      type: "points",
      points: xm(s.map(i => T.From(i.otherPoint)).concat(s.map(i => T.From(i.thisPoint))), (i, a) => i.equals(a))
    }))
  }
  getGapSnapLines({
    selectionPageBounds: e,
    nearestSnapsX: n,
    nearestSnapsY: r
  }) {
    const {
      vertical: o,
      horizontal: s
    } = this.visibleGaps, i = {
      top: e.sides[0],
      right: e.sides[1],
      bottom: [e.corners[3], e.corners[2]],
      left: [e.corners[0], e.corners[3]]
    }, a = [];
    if (n.length > 0)
      for (const c of n) {
        if (c.type === "points") continue;
        const {
          gap: {
            breadthIntersection: l,
            startEdge: u,
            startNode: d,
            endNode: f,
            length: h,
            endEdge: m
          }
        } = c;
        switch (c.type) {
          case "gap_center": {
            const p = (h - e.width) / 2,
              b = So(l[0], l[1], e.minY, e.maxY);
            a.push({
              type: "gaps",
              direction: "horizontal",
              id: It(),
              gaps: [...ks(s, d.id, p, "backward", b), {
                startEdge: u,
                endEdge: i.left
              }, {
                startEdge: i.right,
                endEdge: m
              }, ...ks(s, f.id, p, "forward", b)]
            });
            break
          }
          case "gap_duplicate": {
            const p = So(l[0], l[1], e.minY, e.maxY);
            a.push({
              type: "gaps",
              direction: "horizontal",
              id: It(),
              gaps: c.protrusionDirection === "left" ? [{
                startEdge: i.right,
                endEdge: u.map(b => b.clone().addXY(-d.pageBounds.width, 0))
              }, {
                startEdge: u,
                endEdge: m
              }, ...ks(s, f.id, h, "forward", p)] : [...ks(s, d.id, h, "backward", p), {
                startEdge: u,
                endEdge: m
              }, {
                startEdge: m.map(b => b.clone().addXY(c.gap.endNode.pageBounds.width, 0)),
                endEdge: i.left
              }]
            });
            break
          }
        }
      }
    if (r.length > 0)
      for (const c of r) {
        if (c.type === "points") continue;
        const {
          gap: {
            breadthIntersection: l,
            startEdge: u,
            startNode: d,
            endNode: f,
            length: h,
            endEdge: m
          }
        } = c;
        switch (c.type) {
          case "gap_center": {
            const p = (h - e.height) / 2,
              b = So(l[0], l[1], e.minX, e.maxX);
            a.push({
              type: "gaps",
              direction: "vertical",
              id: It(),
              gaps: [...ks(o, d.id, p, "backward", b), {
                startEdge: u,
                endEdge: i.top
              }, {
                startEdge: i.bottom,
                endEdge: m
              }, ...ks(o, c.gap.endNode.id, p, "forward", b)]
            });
            break
          }
          case "gap_duplicate": {
            const p = So(l[0], l[1], e.minX, e.maxX);
            a.push({
              type: "gaps",
              direction: "vertical",
              id: It(),
              gaps: c.protrusionDirection === "top" ? [{
                startEdge: i.bottom,
                endEdge: u.map(b => b.clone().addXY(0, -d.pageBounds.height))
              }, {
                startEdge: u,
                endEdge: m
              }, ...ks(o, f.id, h, "forward", p)] : [...ks(o, d.id, h, "backward", p), {
                startEdge: u,
                endEdge: m
              }, {
                startEdge: m.map(b => b.clone().addXY(0, f.pageBounds.height)),
                endEdge: i.top
              }]
            })
          }
          break
        }
      }
    return MY(a), a
  }
}
dc([Q], na.prototype, "snapPointsCache", 1);
dc([Q], na.prototype, "snapThreshold", 1);
dc([Q], na.prototype, "snappableShapes", 1);
dc([Q], na.prototype, "currentCommonAncestor", 1);
dc([Q], na.prototype, "snappablePoints", 1);
dc([Q], na.prototype, "visibleGaps", 1);
dc([Q], na.prototype, "outlinesInPageSpace", 1);

function xT(t, e) {
  const {
    minX: n,
    maxX: r,
    minY: o,
    maxY: s
  } = e, i = [];
  switch (t) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      i.push({
        id: "top_left",
        handle: "top_left",
        x: n,
        y: o
      })
  }
  switch (t) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      i.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: o
      })
  }
  switch (t) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      i.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: s
      })
  }
  switch (t) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      i.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: n,
        y: s
      })
  }
  return i
}
const jY = /\r?\n|\r/g;

function ET(t) {
  return t.replace(jY, `
`).split(`
`).map(e => e || " ").join(`
`)
}
const DY = {
    start: "left",
    "start-legacy": "left",
    middle: "center",
    "middle-legacy": "center",
    end: "right",
    "end-legacy": "right"
  },
  NY = /\s/;
class LY {
  constructor(e) {
    P(this, "measureText", (e, n) => {
      const r = this.getTextElement();
      r.setAttribute("dir", "ltr"), r.style.setProperty("font-family", n.fontFamily), r.style.setProperty("font-style", n.fontStyle), r.style.setProperty("font-weight", n.fontWeight), r.style.setProperty("font-size", n.fontSize + "px"), r.style.setProperty("line-height", n.lineHeight * n.fontSize + "px"), r.style.setProperty("max-width", n.maxWidth === null ? null : n.maxWidth + "px"), r.style.setProperty("min-width", n.minWidth ?? null), r.style.setProperty("padding", n.padding), r.textContent = ET(e);
      const o = r.getBoundingClientRect();
      return {
        x: 0,
        y: 0,
        w: o.width,
        h: o.height
      }
    });
    this.editor = e
  }
  getTextElement() {
    const e = document.querySelector(".tl-text-measure");
    e == null || e.remove();
    const n = document.createElement("div");
    return this.editor.getContainer().appendChild(n), n.id = `__textMeasure_${It()}`, n.classList.add("tl-text"), n.classList.add("tl-text-measure"), n.tabIndex = -1, n
  }
  measureElementTextNodeSpans(e, {
    shouldTruncateToFirstLine: n = !1
  } = {}) {
    const r = [],
      o = e.getBoundingClientRect(),
      s = -o.left,
      i = -o.top,
      a = new Range,
      c = e.childNodes[0];
    let l = 0,
      u = null,
      d = null,
      f = 0,
      h = !1;
    for (const m of e.childNodes)
      if (m.nodeType === Node.TEXT_NODE)
        for (const p of m.textContent ?? "") {
          a.setStart(c, l), a.setEnd(c, l + p.length);
          const b = a.getClientRects(),
            w = b[b.length - 1],
            v = w.top + i,
            _ = w.left + s,
            S = w.right + s,
            x = NY.test(p);
          if (x !== d || v !== f || !u) {
            if (u) {
              if (n && v !== f) {
                h = !0;
                break
              }
              r.push(u)
            }
            u = {
              box: {
                x: _,
                y: v,
                w: w.width,
                h: w.height
              },
              text: p
            }
          } else u.box.w = S - u.box.x, u.text += p;
          d = x, f = v, l += p.length
        }
    return u && r.push(u), {
      spans: r,
      didTruncate: h
    }
  }
  measureTextSpans(e, n) {
    if (e === "") return [];
    const r = n.overflow === "truncate-ellipsis" || n.overflow === "truncate-clip",
      o = this.getTextElement(),
      s = Math.ceil(n.width - n.padding * 2);
    o.style.setProperty("width", `${s}px`), o.style.setProperty("height", "min-content"), o.style.setProperty("dir", "ltr"), o.style.setProperty("font-size", `${n.fontSize}px`), o.style.setProperty("font-family", n.fontFamily), o.style.setProperty("font-weight", n.fontWeight), o.style.setProperty("line-height", `${n.lineHeight*n.fontSize}px`), o.style.setProperty("text-align", DY[n.textAlign]), r && (o.style.setProperty("overflow-wrap", "anywhere"), o.style.setProperty("word-break", "break-all")), e = ET(e), o.textContent = e;
    const {
      spans: i,
      didTruncate: a
    } = this.measureElementTextNodeSpans(o, {
      shouldTruncateToFirstLine: r
    });
    if (n.overflow === "truncate-ellipsis" && a) {
      o.textContent = "";
      const c = Math.ceil(this.measureElementTextNodeSpans(o).spans[0].box.w);
      o.style.setProperty("width", `${s-c}px`), o.textContent = e;
      const l = this.measureElementTextNodeSpans(o, {
          shouldTruncateToFirstLine: !0
        }).spans,
        u = l[l.length - 1];
      return l.push({
        text: "",
        box: {
          x: Math.min(u.box.x + u.box.w, n.width - n.padding - c),
          y: u.box.y,
          w: c,
          h: u.box.h
        }
      }), l
    }
    return o.remove(), i
  }
}
class FY {
  constructor(e) {
    P(this, "raf");
    P(this, "isPaused", !0);
    P(this, "last", 0);
    P(this, "t", 0);
    P(this, "start", () => {
      this.isPaused = !1, cancelAnimationFrame(this.raf), this.raf = requestAnimationFrame(this.tick), this.last = Date.now()
    });
    P(this, "tick", () => {
      if (this.isPaused) return;
      const e = Date.now(),
        n = e - this.last;
      if (this.last = e, this.t += n, this.editor.emit("frame", n), this.t < 16) {
        this.raf = requestAnimationFrame(this.tick);
        return
      }
      this.t -= 16, this.updatePointerVelocity(n), this.editor.emit("tick", n), this.raf = requestAnimationFrame(this.tick)
    });
    P(this, "dispose", () => {
      this.isPaused = !0, cancelAnimationFrame(this.raf)
    });
    P(this, "prevPoint", new T);
    P(this, "updatePointerVelocity", e => {
      const {
        prevPoint: n,
        editor: {
          inputs: {
            currentScreenPoint: r,
            pointerVelocity: o
          }
        }
      } = this;
      if (e === 0) return;
      const s = T.Sub(r, n);
      this.prevPoint = r.clone();
      const i = s.len(),
        a = i ? s.div(i) : new T(0, 0),
        c = o.clone().lrp(a.mul(i / e), .5);
      Math.abs(c.x) < .01 && (c.x = 0), Math.abs(c.y) < .01 && (c.y = 0), o.equals(c) || (this.editor.inputs.pointerVelocity = c)
    });
    this.editor = e, this.editor.disposables.add(this.dispose), this.start()
  }
}
var BY = Object.defineProperty,
  UY = Object.getOwnPropertyDescriptor,
  ra = (t, e, n, r) => {
    for (var o = r > 1 ? void 0 : r ? UY(e, n) : e, s = t.length - 1, i; s >= 0; s--)(i = t[s]) && (o = (r ? i(e, n, o) : i(o)) || o);
    return r && o && BY(e, n, o), o
  };
class ri {
  constructor(e, n) {
    P(this, "updateUserPreferences", e => {
      this.user.setUserPreferences({
        ...this.user.userPreferences.get(),
        ...e
      })
    });
    this.user = e, this.inferDarkMode = n
  }
  get userPreferences() {
    return {
      id: this.id,
      name: this.name,
      locale: this.locale,
      color: this.color,
      isDarkMode: this.isDarkMode,
      animationSpeed: this.animationSpeed,
      isSnapMode: this.isSnapMode
    }
  }
  get isDarkMode() {
    return this.user.userPreferences.get().isDarkMode ?? (this.inferDarkMode ? qG() : !1)
  }
  get animationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? ko.animationSpeed
  }
  get id() {
    return this.user.userPreferences.get().id
  }
  get name() {
    return this.user.userPreferences.get().name ?? ko.name
  }
  get locale() {
    return this.user.userPreferences.get().locale ?? ko.locale
  }
  get color() {
    return this.user.userPreferences.get().color ?? ko.color
  }
  get isSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? ko.isSnapMode
  }
}
ra([Q], ri.prototype, "userPreferences", 1);
ra([Q], ri.prototype, "isDarkMode", 1);
ra([Q], ri.prototype, "animationSpeed", 1);
ra([Q], ri.prototype, "id", 1);
ra([Q], ri.prototype, "name", 1);
ra([Q], ri.prototype, "locale", 1);
ra([Q], ri.prototype, "color", 1);
ra([Q], ri.prototype, "isSnapMode", 1);

function ld(t) {
  return Math.abs(t.props.bend) < 8
}

function Nm(t, e) {
  if (e.type === "point") return;
  const n = t.getShape(e.boundShapeId),
    r = t.getShapePageTransform(n),
    o = t.getShapeGeometry(n),
    s = o instanceof C1 ? o.children[0].vertices : o.vertices;
  return {
    shape: n,
    transform: r,
    isClosed: o.isClosed,
    isExact: e.isExact,
    didIntersect: !1,
    outline: s
  }
}

function kT(t, e, n) {
  if (n.type === "point") return T.From(n);
  const r = t.getShape(n.boundShapeId);
  if (r) {
    const {
      point: o,
      size: s
    } = t.getShapeGeometry(r).bounds, i = T.Add(o, T.MulV(n.normalizedAnchor, s)), a = Ee.applyToPoint(t.getShapePageTransform(r), i);
    return Ee.applyToPoint(Ee.Inverse(e), a)
  } else return new T(0, 0)
}

function _a(t, e) {
  const n = t.getShapePageTransform(e),
    r = kT(t, n, e.props.start),
    o = kT(t, n, e.props.end);
  return {
    start: r,
    end: o
  }
}
const yl = 32,
  Lm = 10,
  zY = 10,
  Ti = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  };

function qd(t, e) {
  const {
    start: n,
    end: r,
    arrowheadStart: o,
    arrowheadEnd: s
  } = e.props, i = _a(t, e), a = i.start.clone(), c = i.end.clone(), l = T.Med(a, c);
  if (T.Equals(a, c)) return {
    isStraight: !0,
    start: {
      handle: a,
      point: a,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: c,
      point: c,
      arrowhead: e.props.arrowheadEnd
    },
    middle: l,
    isValid: !1,
    length: 0
  };
  const u = T.Sub(c, a).uni(),
    d = Nm(t, n),
    f = Nm(t, r),
    h = t.getShapePageTransform(e);
  CT(c, i.start, h, f), CT(a, i.end, h, d);
  let m = 0,
    p = 0;
  const b = d && f && d.shape === f.shape;
  d && f && !b && !d.isExact && !f.isExact && (f.didIntersect && !d.didIntersect ? d.isClosed && a.setTo(c.clone().add(u.clone().mul(yl))) : f.didIntersect || f.isClosed && c.setTo(a.clone().sub(u.clone().mul(yl))));
  const w = T.Sub(c, a).uni(),
    v = !T.Equals(w, u);
  b || (d && o !== "none" && !d.isExact && (m = Lm + Ti[e.props.size] / 2 + ("size" in d.shape.props ? Ti[d.shape.props.size] / 2 : 0)), f && s !== "none" && !f.isExact && (p = Lm + Ti[e.props.size] / 2 + ("size" in f.shape.props ? Ti[f.shape.props.size] / 2 : 0)));
  const _ = a.clone().add(w.clone().mul(m * (v ? -1 : 1))),
    S = c.clone().sub(w.clone().mul(p * (v ? -1 : 1))),
    x = T.Dist(_, S);
  x < yl && (m !== 0 && p !== 0 ? (m *= -1.5, p *= -1.5) : m !== 0 ? m *= -2 : p !== 0 ? p *= -2 : x < 10 && (d ? m = -(10 - x) : f && (p = -(10 - x)))), a.add(w.clone().mul(m * (v ? -1 : 1))), c.sub(w.clone().mul(p * (v ? -1 : 1))), v ? (d && f && c.setTo(T.Add(a, w.clone().mul(-yl))), l.setTo(T.Med(i.start, i.end))) : l.setTo(T.Med(a, c));
  const E = T.Dist(a, c);
  return {
    isStraight: !0,
    start: {
      handle: i.start,
      point: a,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: i.end,
      point: c,
      arrowhead: e.props.arrowheadEnd
    },
    middle: l,
    isValid: E > 0,
    length: E
  }
}

function CT(t, e, n, r) {
  if (r === void 0 || r.isExact) return;
  const o = Ee.applyToPoint(n, e),
    s = Ee.applyToPoint(n, t),
    i = Ee.applyToPoint(Ee.Inverse(r.transform), o),
    a = Ee.applyToPoint(Ee.Inverse(r.transform), s),
    c = r.isClosed,
    u = (c ? sY : oY)(i, a, r.outline);
  let d;
  if (u !== null && (d = u.sort((m, p) => T.Dist(m, i) - T.Dist(p, i))[0] ?? (c ? void 0 : a)), d === void 0) return;
  const f = Ee.applyToPoint(r.transform, d),
    h = Ee.applyToPoint(Ee.Inverse(n), f);
  t.setTo(h), r.didIntersect = !0
}

function D0e(t) {
  return D3(t.start.handle, t.end.handle)
}

function N0e(t) {
  return D3(t.start.point, t.end.point)
}

function D3(t, e) {
  return `M${t.x},${t.y}L${e.x},${e.y}`
}

function Z0(t, e, n = 0) {
  const {
    arrowheadEnd: r,
    arrowheadStart: o
  } = e.props, s = e.props.bend + n;
  if (Math.abs(s) > Math.abs(e.props.bend * zY)) return qd(t, e);
  const i = _a(t, e),
    a = T.Med(i.start, i.end),
    c = T.Sub(i.end, i.start).uni(),
    l = T.Add(a, c.per().mul(-s)),
    u = Nm(t, e.props.start),
    d = Nm(t, e.props.end),
    f = i.start.clone(),
    h = i.end.clone(),
    m = l.clone();
  if (T.Equals(f, h)) return {
    isStraight: !0,
    start: {
      handle: f,
      point: f,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: h,
      point: h,
      arrowhead: e.props.arrowheadEnd
    },
    middle: m,
    isValid: !1,
    length: 0
  };
  const p = e.props.bend < 0,
    b = p ? tv : cV,
    w = PT(f, h, m),
    v = T.Angle(w.center, f),
    _ = T.Angle(w.center, h),
    S = b(v, _);
  if (w.length === 0 || w.size === 0 || !VP(w.length) || !VP(w.size)) return qd(t, e);
  const x = f.clone(),
    E = h.clone(),
    k = m.clone(),
    C = t.getShapePageTransform(e);
  let $ = 0,
    I = 0;
  if (u && !u.isExact) {
    const B = Ee.applyToPoint(C, x),
      V = Ee.applyToPoint(C, w.center),
      J = Ee.applyToPoint(C, E),
      ee = Ee.Inverse(u.transform),
      ye = Ee.applyToPoint(ee, B),
      ge = Ee.applyToPoint(ee, V),
      ce = Ee.applyToPoint(ee, J),
      {
        isClosed: Ce
      } = u,
      oe = Ce ? pT : gT;
    let pe, _e = oe(ge, w.radius, u.outline);
    if (_e) {
      const xe = ge.angle(ye),
        Me = ge.angle(ce),
        Le = b(xe, Me);
      _e = _e.filter(Ze => b(xe, ge.angle(Ze)) <= Le);
      const gt = Le * .25;
      _e.sort(Ce ? (Ze, xt) => Math.abs(b(xe, ge.angle(Ze)) - gt) < Math.abs(b(xe, ge.angle(xt)) - gt) ? -1 : 1 : (Ze, xt) => b(xe, ge.angle(Ze)) < b(xe, ge.angle(xt)) ? -1 : 1), pe = _e[0] ?? (Ce ? void 0 : ye)
    } else pe = Ce ? void 0 : ye;
    pe && (x.setTo(t.getPointInShapeSpace(e, Ee.applyToPoint(u.transform, pe))), u.didIntersect = !0, o !== "none" && ($ = Lm + Ti[e.props.size] / 2 + ("size" in u.shape.props ? Ti[u.shape.props.size] / 2 : 0)))
  }
  if (d && !d.isExact) {
    const B = Ee.applyToPoint(C, x),
      V = Ee.applyToPoint(C, E),
      J = Ee.applyToPoint(C, w.center),
      ee = Ee.Inverse(d.transform),
      ye = Ee.applyToPoint(ee, B),
      ge = Ee.applyToPoint(ee, J),
      ce = Ee.applyToPoint(ee, V),
      Ce = d.isClosed,
      oe = Ce ? pT : gT;
    let pe, _e = oe(ge, w.radius, d.outline);
    if (_e) {
      const xe = ge.angle(ye),
        Me = ge.angle(ce),
        Le = b(xe, Me),
        gt = Le * .75;
      _e = _e.filter(Ze => b(xe, ge.angle(Ze)) <= Le), _e.sort(Ce ? (Ze, xt) => Math.abs(b(xe, ge.angle(Ze)) - gt) < Math.abs(b(xe, ge.angle(xt)) - gt) ? -1 : 1 : (Ze, xt) => b(xe, ge.angle(Ze)) < b(xe, ge.angle(xt)) ? -1 : 1), _e[0] ? pe = _e[0] : pe = Ce ? void 0 : ce
    } else pe = Ce ? void 0 : ce;
    pe && (E.setTo(t.getPointInShapeSpace(e, Ee.applyToPoint(d.transform, pe))), d.didIntersect = !0, r !== "none" && (I = Lm + Ti[e.props.size] / 2 + ("size" in d.shape.props ? Ti[d.shape.props.size] / 2 : 0)))
  }
  let R = T.Angle(w.center, x),
    M = T.Angle(w.center, E),
    j = b(R, M),
    A = j * w.radius;
  const D = x.clone(),
    N = E.clone();
  if ($ !== 0) {
    const B = $ / A * (p ? 1 : -1),
      V = T.FromAngle(R + j * B);
    D.setTo(w.center).add(V.mul(w.radius))
  }
  if (I !== 0) {
    const B = I / A * (p ? -1 : 1),
      V = T.FromAngle(M + j * B);
    N.setTo(w.center).add(V.mul(w.radius))
  }
  const q = T.Dist(D, N);
  if (q < yl && ($ !== 0 && I !== 0 ? ($ *= -1.5, I *= -1.5) : $ !== 0 ? $ *= -2 : I !== 0 ? I *= -2 : q < 10 && (u ? $ = -(10 - q) : d && (I = -(10 - q)))), $ !== 0) {
    const B = $ / A * (p ? 1 : -1),
      V = T.FromAngle(R + j * B);
    x.setTo(w.center).add(V.mul(w.radius))
  }
  if (I !== 0) {
    const B = I / A * (p ? -1 : 1),
      V = T.FromAngle(M + j * B);
    E.setTo(w.center).add(V.mul(w.radius))
  }
  if (u && d && !u.isExact && !d.isExact) {
    if (R = T.Angle(w.center, x), M = T.Angle(w.center, E), j = b(R, M), A = j * w.radius, u.shape === d.shape) A < 100 && (x.setTo(f), E.setTo(h), k.setTo(m));
    else if (u && !u.didIntersect && x.setTo(f), d && !d.didIntersect || b(v, R) > b(v, M)) {
      const B = Math.min(.9, yl / A) * (p ? 1 : -1),
        V = T.FromAngle(R + j * B);
      E.setTo(w.center).add(V.mul(w.radius))
    }
  }
  HY(w.center, w.radius, x, E, k, S, p), x.equals(E) && (x.setTo(k.clone().addXY(1, 1)), E.setTo(k.clone().subXY(1, 1))), f.setTo(x), h.setTo(E), m.setTo(k);
  const F = PT(f, h, m);
  return {
    isStraight: !1,
    start: {
      point: f,
      handle: i.start,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      point: h,
      handle: i.end,
      arrowhead: e.props.arrowheadEnd
    },
    middle: m,
    handleArc: w,
    bodyArc: F,
    isValid: F.length !== 0 && isFinite(F.center.x) && isFinite(F.center.y)
  }
}

function L0e(t) {
  const {
    start: e,
    end: n,
    handleArc: {
      radius: r,
      largeArcFlag: o,
      sweepFlag: s
    }
  } = t;
  return `M${e.handle.x},${e.handle.y} A${r} ${r} 0 ${o} ${s} ${n.handle.x},${n.handle.y}`
}

function F0e(t) {
  const {
    start: e,
    end: n,
    bodyArc: {
      radius: r,
      largeArcFlag: o,
      sweepFlag: s
    }
  } = t;
  return `M${e.point.x},${e.point.y} A${r} ${r} 0 ${o} ${s} ${n.point.x},${n.point.y}`
}

function PT(t, e, n) {
  const r = -2 * (t.x * (e.y - n.y) - t.y * (e.x - n.x) + e.x * n.y - n.x * e.y),
    o = {
      x: ((t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y) + (n.x * n.x + n.y * n.y) * (e.y - t.y)) / r,
      y: ((t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x) + (n.x * n.x + n.y * n.y) * (t.x - e.x)) / r
    },
    s = T.Dist(o, t),
    i = +T.Clockwise(t, n, e),
    a = Math.hypot(t.y - e.y, t.x - e.x),
    c = Math.hypot(e.y - n.y, e.x - n.x),
    l = Math.hypot(n.y - t.y, n.x - t.x),
    u = Math.acos((c * c + l * l - a * a) / (2 * c * l)) * 2,
    d = +(Hn > u),
    f = (Rt - u) * (i ? 1 : -1),
    h = f * s;
  return {
    center: o,
    radius: s,
    size: f,
    length: h,
    largeArcFlag: d,
    sweepFlag: i
  }
}

function HY(t, e, n, r, o, s, i) {
  const a = T.Angle(t, n),
    c = T.Angle(t, r);
  let l = tv(a, c);
  i || (l = Rt - l);
  const u = .5 * (i ? 1 : -1),
    d = T.FromAngle(a + l * u);
  if (o.setTo(t).add(d.mul(e)), l > s) {
    o.rotWith(t, Hn);
    const f = r.clone();
    r.setTo(n), n.setTo(f)
  }
}
const VY = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick"
};
var WY = Object.defineProperty,
  KY = Object.getOwnPropertyDescriptor,
  GY = (t, e, n, r) => {
    for (var o = r > 1 ? void 0 : r ? KY(e, n) : e, s = t.length - 1, i; s >= 0; s--)(i = t[s]) && (o = (r ? i(e, n, o) : i(o)) || o);
    return r && o && WY(e, n, o), o
  };
class Xd {
  constructor(e, n) {
    P(this, "path");
    P(this, "id");
    P(this, "current");
    P(this, "type");
    P(this, "shapeType");
    P(this, "initial");
    P(this, "children");
    P(this, "parent");
    P(this, "isActive", !1);
    P(this, "transition", (e, n) => {
      var s;
      const r = e.split(".");
      let o = this;
      for (let i = 0; i < r.length; i++) {
        const a = r[i],
          c = o.current.get(),
          l = (s = o.children) == null ? void 0 : s[a];
        if (!l) throw Error(`${o.id} - no child state exists with the id ${a}.`);
        if ((c == null ? void 0 : c.id) !== l.id && (c == null || c.exit(n, a), o.current.set(l), l.enter(n, (c == null ? void 0 : c.id) || "initial"), !l.isActive)) break;
        o = l
      }
      return this
    });
    P(this, "handleEvent", e => {
      var o;
      const n = VY[e.name],
        r = this.current.get();
      (o = this[n]) == null || o.call(this, e), this.current.get() === r && this.isActive && (r == null || r.handleEvent(e))
    });
    P(this, "enter", (e, n) => {
      var r;
      if (this.isActive = !0, (r = this.onEnter) == null || r.call(this, e, n), this.children && this.initial && this.isActive) {
        const o = this.children[this.initial];
        this.current.set(o), o.enter(e, n)
      }
    });
    P(this, "exit", (e, n) => {
      var r, o;
      this.isActive = !1, (r = this.onExit) == null || r.call(this, e, n), this.isActive || (o = this.current.get()) == null || o.exit(e, n)
    });
    P(this, "_currentToolIdMask", tr("curent tool id mask", void 0));
    P(this, "onWheel");
    P(this, "onPointerDown");
    P(this, "onPointerMove");
    P(this, "onPointerUp");
    P(this, "onDoubleClick");
    P(this, "onTripleClick");
    P(this, "onQuadrupleClick");
    P(this, "onRightClick");
    P(this, "onMiddleClick");
    P(this, "onKeyDown");
    P(this, "onKeyUp");
    P(this, "onKeyRepeat");
    P(this, "onCancel");
    P(this, "onComplete");
    P(this, "onInterrupt");
    P(this, "onEnter");
    P(this, "onExit");
    this.editor = e;
    const {
      id: r,
      children: o,
      initial: s
    } = this.constructor;
    this.id = r, this.current = tr("toolState" + this.id, void 0), this.path = Q("toolPath" + this.id, () => {
      const i = this.current.get();
      return this.id + (i ? `.${i.path.get()}` : "")
    }), this.parent = n ?? {}, this.parent ? o && s ? (this.type = "branch", this.initial = s, this.children = Object.fromEntries(o().map(i => [i.id, new i(this.editor, this)])), this.current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", o && s && (this.initial = s, this.children = Object.fromEntries(o().map(i => [i.id, new i(this.editor, this)])), this.current.set(this.children[this.initial])))
  }
  get currentToolIdMask() {
    return this._currentToolIdMask.get()
  }
  set currentToolIdMask(e) {
    this._currentToolIdMask.set(e)
  }
}
P(Xd, "id"), P(Xd, "initial"), P(Xd, "children");
GY([Q], Xd.prototype, "currentToolIdMask", 1);
class Mg extends Xd {
  constructor() {
    super(...arguments);
    P(this, "onKeyDown", n => {
      var r;
      switch (n.code) {
        case "KeyZ": {
          if (!(n.shiftKey || n.ctrlKey)) {
            const o = this.current.get();
            o && ((r = o.current.get()) == null ? void 0 : r.id) === "idle" && this.children.zoom && this.editor.setCurrentTool("zoom", {
              ...n,
              onInteractionEnd: o.id
            })
          }
          break
        }
      }
    })
  }
}
P(Mg, "id", "root"), P(Mg, "initial", ""), P(Mg, "children", () => []);
var YY = Object.defineProperty,
  qY = Object.getOwnPropertyDescriptor,
  we = (t, e, n, r) => {
    for (var o = r > 1 ? void 0 : r ? qY(e, n) : e, s = t.length - 1, i; s >= 0; s--)(i = t[s]) && (o = (r ? i(e, n, o) : i(o)) || o);
    return r && o && YY(e, n, o), o
  };
class ve extends rY.EventEmitter {
  constructor({
    store: n,
    user: r,
    shapeUtils: o,
    tools: s,
    getContainer: i,
    initialState: a,
    inferDarkMode: c
  }) {
    super();
    P(this, "store");
    P(this, "root");
    P(this, "disposables", new Set);
    P(this, "_tickManager", new FY(this));
    P(this, "snaps");
    P(this, "user");
    P(this, "textMeasure");
    P(this, "environment");
    P(this, "scribbles");
    P(this, "getContainer");
    P(this, "sideEffects");
    P(this, "shapeUtils");
    P(this, "styleProps");
    P(this, "history", new $Y(this, n => {
      this.annotateError(n, {
        origin: "history.batch",
        willCrashApp: !0
      }), this.crash(n)
    }));
    P(this, "_crashingError", null);
    P(this, "_updateInstanceState", this.history.createCommand("updateInstanceState", (n, r) => {
      const o = this.store.get(this.getInstanceState().id),
        s = {
          ...o,
          ...n
        };
      return {
        data: {
          prev: o,
          next: s
        },
        ephemeral: !1,
        squashing: !1,
        ...r
      }
    }, {
      do: ({
        next: n
      }) => {
        this.store.put([n])
      },
      undo: ({
        prev: n
      }) => {
        this.store.put([n])
      },
      squash({
        prev: n
      }, {
        next: r
      }) {
        return {
          prev: n,
          next: r
        }
      }
    }));
    P(this, "_isChangingStyleTimeout", -1);
    P(this, "setCursor", n => (this.updateInstanceState({
      cursor: {
        ...this.getInstanceState().cursor,
        ...n
      }
    }, {
      ephemeral: !0
    }), this));
    P(this, "_setInstancePageState", this.history.createCommand("setInstancePageState", (n, r) => ({
      data: {
        prev: this.store.get(n.id ?? this.getCurrentPageState().id),
        partial: n
      },
      ...r
    }), {
      do: ({
        prev: n,
        partial: r
      }) => {
        this.store.update(n.id, o => ({
          ...o,
          ...r
        }))
      },
      undo: ({
        prev: n
      }) => {
        this.store.update(n.id, () => n)
      }
    }));
    P(this, "_setSelectedShapes", this.history.createCommand("setSelectedShapes", (n, r) => {
      const {
        selectedShapeIds: o
      } = this.getCurrentPageState(), s = new Set(o);
      return n.length === s.size && n.every(i => s.has(i)) ? null : {
        data: {
          selectedShapeIds: n,
          prevSelectedShapeIds: o
        },
        preservesRedoStack: !0,
        ...r
      }
    }, {
      do: ({
        selectedShapeIds: n
      }) => {
        this.store.put([{
          ...this.getCurrentPageState(),
          selectedShapeIds: n
        }])
      },
      undo: ({
        prevSelectedShapeIds: n
      }) => {
        this.store.put([{
          ...this.getCurrentPageState(),
          selectedShapeIds: n
        }])
      },
      squash({
        prevSelectedShapeIds: n
      }, {
        selectedShapeIds: r
      }) {
        return {
          selectedShapeIds: r,
          prevSelectedShapeIds: n
        }
      }
    }));
    P(this, "_setFocusedGroupId", this.history.createCommand("setFocusedGroupId", n => {
      const r = this.getCurrentPageState().focusedGroupId;
      if (r !== n) return {
        data: {
          prev: r,
          next: n
        },
        preservesRedoStack: !0,
        squashing: !0
      }
    }, {
      do: ({
        next: n
      }) => {
        this.store.update(this.getCurrentPageState().id, r => ({
          ...r,
          focusedGroupId: n
        }))
      },
      undo: ({
        prev: n
      }) => {
        this.store.update(this.getCurrentPageState().id, r => ({
          ...r,
          focusedGroupId: n
        }))
      },
      squash({
        prev: n
      }, {
        next: r
      }) {
        return {
          prev: n,
          next: r
        }
      }
    }));
    P(this, "_viewportAnimation", null);
    P(this, "_willSetInitialBounds", !0);
    P(this, "_cameraState", tr("camera state", "idle"));
    P(this, "_cameraStateTimeoutRemaining", 0);
    P(this, "_lastUpdateRenderingBoundsTimestamp", Date.now());
    P(this, "_decayCameraStateTimeout", n => {
      this._cameraStateTimeoutRemaining -= n, this._cameraStateTimeoutRemaining <= 0 && (this.off("tick", this._decayCameraStateTimeout), this._cameraState.set("idle"), this.updateRenderingBounds())
    });
    P(this, "_tickCameraState", () => {
      this._cameraStateTimeoutRemaining = $V;
      const n = Date.now();
      this._cameraState.__unsafe__getWithoutCapture() === "idle" ? (this._lastUpdateRenderingBoundsTimestamp = n, this._cameraState.set("moving"), this.on("tick", this._decayCameraStateTimeout)) : n - this._lastUpdateRenderingBoundsTimestamp > IV && this.updateRenderingBounds()
    });
    P(this, "_renderingBounds", tr("rendering viewport", new Be));
    P(this, "_renderingBoundsExpanded", tr("rendering viewport expanded", new Be));
    P(this, "renderingBoundsMargin", 100);
    P(this, "_currentPageShapeIds");
    P(this, "_setCurrentPageId", this.history.createCommand("setCurrentPage", (n, r) => {
      if (!this.store.has(n)) {
        console.error("Tried to set the current page id to a page that doesn't exist.");
        return
      }
      return this.stopFollowingUser(), {
        data: {
          toId: n,
          fromId: this.currentPageId
        },
        squashing: !0,
        preservesRedoStack: !0,
        ...r
      }
    }, {
      do: ({
        toId: n
      }) => {
        if (this.store.has(n)) {
          if (!this.getPageStates().find(r => r.pageId === n)) {
            const r = Bn.create({
              id: Bn.createId(n)
            });
            this.store.put([r, Un.create({
              id: Un.createId(n),
              pageId: n
            })])
          }
          this.store.put([{
            ...this.getInstanceState(),
            currentPageId: n
          }]), this.updateRenderingBounds()
        }
      },
      undo: ({
        fromId: n
      }) => {
        this.store.has(n) && (this.store.put([{
          ...this.getInstanceState(),
          currentPageId: n
        }]), this.updateRenderingBounds())
      },
      squash: ({
        fromId: n
      }, {
        toId: r
      }) => ({
        toId: r,
        fromId: n
      })
    }));
    P(this, "_updatePage", this.history.createCommand("updatePage", (n, r) => {
      if (this.getInstanceState().isReadonly) return null;
      const o = this.getPage(n.id);
      return o ? {
        data: {
          prev: o,
          partial: n
        },
        ...r
      } : null
    }, {
      do: ({
        partial: n
      }) => {
        this.store.update(n.id, r => ({
          ...r,
          ...n
        }))
      },
      undo: ({
        prev: n,
        partial: r
      }) => {
        this.store.update(r.id, () => n)
      },
      squash(n, r) {
        return {
          prev: {
            ...n.prev,
            ...r.prev
          },
          partial: r.partial
        }
      }
    }));
    P(this, "_createPage", this.history.createCommand("createPage", n => {
      if (this.getInstanceState().isReadonly || this.pages.length >= Rm) return null;
      const {
        pages: r
      } = this, o = fY(n.name ?? "Page", r.map(l => l.name));
      let s = n.index;
      (!s || r.some(l => l.index === s)) && (s = yi(r[r.length - 1].index));
      const i = Ys.create({
          meta: {},
          ...n,
          name: o,
          index: s
        }),
        a = Bn.create({
          id: Bn.createId(i.id)
        }),
        c = Un.create({
          id: Un.createId(i.id),
          pageId: i.id
        });
      return {
        data: {
          newPage: i,
          newTabPageState: c,
          newCamera: a
        }
      }
    }, {
      do: ({
        newPage: n,
        newTabPageState: r,
        newCamera: o
      }) => {
        this.store.put([n, o, r])
      },
      undo: ({
        newPage: n,
        newTabPageState: r,
        newCamera: o
      }) => {
        this.pages.length !== 1 && this.store.remove([r.id, n.id, o.id])
      }
    }));
    P(this, "_deletePage", this.history.createCommand("delete_page", n => {
      if (this.getInstanceState().isReadonly) return null;
      const {
        pages: r
      } = this;
      if (r.length === 1) return null;
      const o = this.getPage(n),
        s = this.getPageStates().filter(i => i.pageId === n);
      if (!o) return null;
      if (n === this.currentPageId) {
        const i = r.findIndex(c => c.id === n),
          a = r[i - 1] ?? r[i + 1];
        this.setCurrentPage(a.id)
      }
      return {
        data: {
          id: n,
          deletedPage: o,
          deletedPageStates: s
        }
      }
    }, {
      do: ({
        deletedPage: n,
        deletedPageStates: r
      }) => {
        const {
          pages: o
        } = this;
        if (o.length !== 1) {
          if (n.id === this.currentPageId) {
            const s = o.findIndex(a => a.id === n.id),
              i = o[s - 1] ?? o[s + 1];
            this.setCurrentPage(i.id)
          }
          this.store.remove(r.map(s => s.id)), this.store.remove([n.id]), this.updateRenderingBounds()
        }
      },
      undo: ({
        deletedPage: n,
        deletedPageStates: r
      }) => {
        this.store.put([n]), this.store.put(r), this.updateRenderingBounds()
      }
    }));
    P(this, "_createAssets", this.history.createCommand("createAssets", n => this.getInstanceState().isReadonly || n.length <= 0 ? null : {
      data: {
        assets: n
      }
    }, {
      do: ({
        assets: n
      }) => {
        this.store.put(n)
      },
      undo: ({
        assets: n
      }) => {
        this.store.remove(n.map(r => r.id))
      }
    }));
    P(this, "_updateAssets", this.history.createCommand("updateAssets", n => this.getInstanceState().isReadonly || n.length <= 0 ? void 0 : {
      data: {
        snapshots: {},
        assets: n
      }
    }, {
      do: ({
        assets: n,
        snapshots: r
      }) => {
        this.store.put(n.map(o => {
          const s = this.store.get(o.id);
          return r[o.id] = s, {
            ...s,
            ...o
          }
        }))
      },
      undo: ({
        snapshots: n
      }) => {
        this.store.put(Object.values(n))
      }
    }));
    P(this, "_deleteAssets", this.history.createCommand("deleteAssets", n => {
      if (this.getInstanceState().isReadonly || n.length <= 0) return;
      const r = Fe(n.map(o => this.store.get(o)));
      return {
        data: {
          ids: n,
          prev: r
        }
      }
    }, {
      do: ({
        ids: n
      }) => {
        this.store.remove(n)
      },
      undo: ({
        prev: n
      }) => {
        this.store.put(n)
      }
    }));
    P(this, "_parentIdsToChildIds");
    P(this, "_childIdsCache", new uY);
    P(this, "_createShapes", this.history.createCommand("createShapes", n => {
      if (this.getInstanceState().isReadonly || n.length <= 0) return null;
      const {
        currentPageShapeIds: r
      } = this;
      if (n.length + r.size > Qo) {
        Np(this);
        return
      }
      return n.length === 0 ? null : {
        data: {
          currentPageId: this.currentPageId,
          partials: n.map(s => s.id ? s : {
            ...s,
            id: is()
          })
        }
      }
    }, {
      do: ({
        partials: n
      }) => {
        var a, c;
        const r = this.getFocusedGroupId(),
          {
            currentPageShapesSorted: o
          } = this;
        n = n.map(l => {
          if (!l.parentId || !(this.store.has(l.parentId) || n.some(u => u.id === l.parentId))) {
            let u = this.getFocusedGroupId();
            for (let f = o.length - 1; f >= 0; f--) {
              const h = o[f];
              if (this.getShapeUtil(h).canReceiveNewChildrenOfType(h, l.type) && this.isPointInShape(h, {
                  x: l.x ?? 0,
                  y: l.y ?? 0
                }, {
                  margin: 0,
                  hitInside: !0
                })) {
                u = h.id;
                break
              }
            }
            const d = l.parentId;
            if (u === l.id && (u = r), u !== d && (l = {
                ...l
              }, l.parentId = u, yo(u))) {
              const f = this.getPointInShapeSpace(this.getShape(u), {
                x: l.x ?? 0,
                y: l.y ?? 0
              });
              l.x = f.x, l.y = f.y, l.rotation = -this.getShapePageTransform(u).rotation() + (l.rotation ?? 0)
            }
          }
          return l
        });
        const s = new Map,
          i = [];
        for (const l of n) {
          const u = this.getShapeUtil(l);
          let d = l.index;
          if (!d) {
            const p = l.parentId ?? r;
            s.has(p) || s.set(p, this.getHighestIndexForParent(p)), d = s.get(p), s.set(p, yi(d))
          }
          const f = u.getDefaultProps();
          for (const [p, b] of this.styleProps[l.type]) f[b] = this.getStyleForNextShape(p);
          let h = this.store.schema.types.shape.create({
            ...l,
            index: d,
            opacity: l.opacity ?? this.getInstanceState().opacityForNextShape,
            parentId: l.parentId ?? r,
            props: "props" in l ? {
              ...f,
              ...l.props
            } : f
          });
          if (h.index === void 0) throw Error("no index!");
          const m = (c = (a = this.getShapeUtil(h)).onBeforeCreate) == null ? void 0 : c.call(a, h);
          m && (h = m), i.push(h)
        }
        i.forEach(l => {
          l.meta = {
            ...this.getInitialMetaForShape(l),
            ...l.meta
          }
        }), this.store.put(i)
      },
      undo: ({
        partials: n
      }) => {
        this.store.remove(n.map(r => r.id))
      }
    }));
    P(this, "animatingShapes", new Map);
    P(this, "_updateShapes", this.history.createCommand("updateShapes", (n, r) => {
      if (this.getInstanceState().isReadonly) return null;
      const o = Fe(n),
        s = Object.fromEntries(Fe(o.map(({
          id: c
        }) => this.getShape(c))).map(c => [c.id, c]));
      if (o.length <= 0) return null;
      const i = Fe(o.map(c => {
          const l = s[c.id];
          if (!l) return null;
          let u = null;
          for (const [d, f] of Object.entries(c))
            if (f !== void 0) switch (d) {
              case "id":
              case "type":
                continue;
              default:
                if (f !== l[d])
                  if (u || (u = {
                      ...l
                    }), d === "props") {
                    const h = {
                      ...l.props
                    };
                    for (const [m, p] of Object.entries(f)) p !== void 0 && (h[m] = p);
                    u.props = h
                  } else if (d === "meta") {
                  const h = {
                    ...l.meta
                  };
                  for (const [m, p] of Object.entries(f)) p !== void 0 && (h[m] = p);
                  u.meta = h
                } else u[d] = f
            }
          return u ?? l
        })),
        a = Object.fromEntries(i.map(c => [c.id, c]));
      return {
        data: {
          snapshots: s,
          updates: a
        },
        ...r
      }
    }, {
      do: ({
        updates: n
      }) => {
        var o, s;
        const r = Object.values(n);
        for (let i = 0; i < r.length; i++) {
          const a = r[i],
            c = this.store.get(a.id);
          if (!c) continue;
          const l = (s = (o = this.getShapeUtil(a)).onBeforeUpdate) == null ? void 0 : s.call(o, c, a);
          l && (r[i] = l)
        }
        this.store.put(r)
      },
      undo: ({
        snapshots: n
      }) => {
        this.store.put(Object.values(n))
      },
      squash(n, r) {
        return {
          snapshots: {
            ...r.snapshots,
            ...n.snapshots
          },
          updates: {
            ...n.updates,
            ...r.updates
          }
        }
      }
    }));
    P(this, "_deleteShapes", this.history.createCommand("delete_shapes", n => {
      if (this.getInstanceState().isReadonly || n.length === 0) return null;
      const r = [...this.getCurrentPageState().selectedShapeIds],
        o = new Set(n);
      for (const l of n) this.visitDescendants(l, u => {
        o.add(u)
      });
      const s = [...o],
        i = this._arrowBindingsIndex.get(),
        a = Fe(s.flatMap(l => {
          const u = this.getShape(l),
            d = i[l];
          return d && d.length > 0 ? d.map(({
            arrowId: f
          }) => this.getShape(f)).concat(u) : u
        })),
        c = r.filter(l => !o.has(l));
      return {
        data: {
          deletedIds: s,
          snapshots: a,
          prevSelectedShapeIds: r,
          postSelectedShapeIds: c
        }
      }
    }, {
      do: ({
        deletedIds: n,
        postSelectedShapeIds: r
      }) => {
        this.store.remove(n), this.store.update(this.getCurrentPageState().id, o => ({
          ...o,
          selectedShapeIds: r
        }))
      },
      undo: ({
        snapshots: n,
        prevSelectedShapeIds: r
      }) => {
        this.store.put(n), this.store.update(this.getCurrentPageState().id, o => ({
          ...o,
          selectedShapeIds: r
        }))
      }
    }));
    P(this, "_selectionSharedStyles", Q("_selectionSharedStyles", () => {
      const n = this.getSelectedShapes(),
        r = new HS;
      for (const o of n) this._extractSharedStyles(o, r);
      return r
    }));
    P(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    });
    P(this, "externalContentHandlers", {
      text: null,
      files: null,
      embed: null,
      "svg-text": null,
      url: null
    });
    P(this, "inputs", {
      originPagePoint: new T,
      originScreenPoint: new T,
      previousPagePoint: new T,
      previousScreenPoint: new T,
      currentPagePoint: new T,
      currentScreenPoint: new T,
      keys: new Set,
      buttons: new Set,
      isPen: !1,
      shiftKey: !1,
      ctrlKey: !1,
      altKey: !1,
      isDragging: !1,
      isPointing: !1,
      isPinching: !1,
      isEditing: !1,
      isPanning: !1,
      pointerVelocity: new T
    });
    P(this, "_clickManager", new CY(this));
    P(this, "_prevCursor", "default");
    P(this, "_shiftKeyTimeout", -1);
    P(this, "_setShiftKeyTimeout", () => {
      this.inputs.shiftKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Shift",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "ShiftLeft"
      })
    });
    P(this, "_altKeyTimeout", -1);
    P(this, "_setAltKeyTimeout", () => {
      this.inputs.altKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Alt",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "AltLeft"
      })
    });
    P(this, "_ctrlKeyTimeout", -1);
    P(this, "_setCtrlKeyTimeout", () => {
      this.inputs.ctrlKey = !1, this.dispatch({
        type: "keyboard",
        name: "key_up",
        key: "Ctrl",
        shiftKey: this.inputs.shiftKey,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        code: "ControlLeft"
      })
    });
    P(this, "_restoreToolId", "select");
    P(this, "_pinchStart", 1);
    P(this, "_didPinch", !1);
    P(this, "_selectedShapeIdsAtPointerDown", []);
    P(this, "capturedPointerId", null);
    P(this, "dispatch", n => {
      if (this.crashingError) return this;
      const {
        inputs: r
      } = this, {
        type: o
      } = n;
      return this.batch(() => {
        if (n.type === "misc") {
          (n.name === "cancel" || n.name === "complete") && (this.inputs.isDragging = !1, this.inputs.isPanning && (this.inputs.isPanning = !1, this.updateInstanceState({
            cursor: {
              type: this._prevCursor,
              rotation: 0
            }
          }))), this.root.handleEvent(n);
          return
        }
        n.shiftKey ? (clearInterval(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, r.shiftKey = !0) : !n.shiftKey && r.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150)), n.altKey ? (clearInterval(this._altKeyTimeout), this._altKeyTimeout = -1, r.altKey = !0) : !n.altKey && r.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150)), n.ctrlKey ? (clearInterval(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, r.ctrlKey = !0) : !n.ctrlKey && r.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150));
        const {
          originPagePoint: s,
          originScreenPoint: i,
          currentPagePoint: a,
          currentScreenPoint: c
        } = r;
        switch (r.isPointing || (r.isDragging = !1), o) {
          case "pinch": {
            if (!this.getInstanceState().canMoveCamera) return;
            switch (this._updateInputsFromEvent(n), n.name) {
              case "pinch_start": {
                if (r.isPinching) return;
                r.isEditing || (this._pinchStart = this.getCamera().z, this._selectedShapeIdsAtPointerDown.length || (this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds()), this._didPinch = !0, r.isPinching = !0, this.interrupt());
                return
              }
              case "pinch": {
                if (!r.isPinching) return;
                const {
                  point: {
                    x: l,
                    y: u,
                    z: d = 1
                  },
                  delta: {
                    x: f,
                    y: h
                  }
                } = n, {
                  x: m,
                  y: p,
                  z: b
                } = this.getCamera(), w = Math.min(qc, Math.max(cd, d));
                this.setCamera({
                  x: m + f / b - l / b + l / w,
                  y: p + h / b - u / b + u / w,
                  z: w
                });
                return
              }
              case "pinch_end": {
                if (!r.isPinching) return this;
                r.isPinching = !1;
                const {
                  _selectedShapeIdsAtPointerDown: l
                } = this;
                this.setSelectedShapes(this._selectedShapeIdsAtPointerDown, {
                  squashing: !0
                }), this._selectedShapeIdsAtPointerDown = [], this._didPinch && (this._didPinch = !1, requestAnimationFrame(() => {
                  this._didPinch || this.setSelectedShapes(l, {
                    squashing: !0
                  })
                }));
                return
              }
            }
          }
          case "wheel": {
            if (!this.getInstanceState().canMoveCamera) return;
            if (this._updateInputsFromEvent(n), !this.getIsMenuOpen()) {
              if (r.ctrlKey) {
                const {
                  x: l,
                  y: u
                } = this.inputs.currentScreenPoint, {
                  x: d,
                  y: f,
                  z: h
                } = this.getCamera(), m = Math.min(qc, Math.max(cd, h + (n.delta.z ?? 0) * h));
                this.setCamera({
                  x: d + (l / m - l) - (l / h - l),
                  y: f + (u / m - u) - (u / h - u),
                  z: m
                });
                return
              }
              this.pan(n.delta), !r.isDragging && r.isPointing && s.dist(a) > (this.getInstanceState().isCoarsePointer ? NS : LS) / this.zoomLevel && (r.isDragging = !0)
            }
            break
          }
          case "pointer": {
            if (r.isPinching) return;
            this._updateInputsFromEvent(n);
            const {
              isPen: l
            } = n;
            switch (n.name) {
              case "pointer_down": {
                if (this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds(), n.button === 0 && (this.capturedPointerId = n.pointerId), r.buttons.add(n.button), r.isPointing = !0, r.isDragging = !1, this.getInstanceState().isPenMode) {
                  if (!l) return
                } else l && this.updateInstanceState({
                  isPenMode: !0
                });
                if (n.button === 5 ? (this._restoreToolId = this.getCurrentToolId(), this.complete(), this.setCurrentTool("eraser")) : n.button === 1 && (this.inputs.isPanning || (this._prevCursor = this.getInstanceState().cursor.type), this.inputs.isPanning = !0), this.inputs.isPanning) return this.stopCameraAnimation(), this.updateInstanceState({
                  cursor: {
                    type: "grabbing",
                    rotation: 0
                  }
                }), this;
                i.setTo(c), s.setTo(a);
                break
              }
              case "pointer_move": {
                if (!l && this.getInstanceState().isPenMode) return;
                if (this.inputs.isPanning && this.inputs.isPointing) {
                  const {
                    currentScreenPoint: u,
                    previousScreenPoint: d
                  } = this.inputs;
                  this.pan(T.Sub(u, d));
                  return
                }!r.isDragging && r.isPointing && s.dist(a) > (this.getInstanceState().isCoarsePointer ? NS : LS) / this.zoomLevel && (r.isDragging = !0);
                break
              }
              case "pointer_up": {
                if (r.buttons.delete(n.button), r.isPointing = !1, r.isDragging = !1, this.getIsMenuOpen() || !l && this.getInstanceState().isPenMode) return;
                this.capturedPointerId === n.pointerId && (this.capturedPointerId = null, n.button = 0), r.isPanning ? n.button === 1 ? this.inputs.keys.has(" ") ? (this.slideCamera({
                  speed: Math.min(2, this.inputs.pointerVelocity.len()),
                  direction: this.inputs.pointerVelocity,
                  friction: V0
                }), this.updateInstanceState({
                  cursor: {
                    type: "grab",
                    rotation: 0
                  }
                })) : (r.isPanning = !1, this.slideCamera({
                  speed: Math.min(2, this.inputs.pointerVelocity.len()),
                  direction: this.inputs.pointerVelocity,
                  friction: V0
                }), this.updateInstanceState({
                  cursor: {
                    type: this._prevCursor,
                    rotation: 0
                  }
                })) : n.button === 0 && (this.slideCamera({
                  speed: Math.min(2, this.inputs.pointerVelocity.len()),
                  direction: this.inputs.pointerVelocity,
                  friction: V0
                }), this.updateInstanceState({
                  cursor: {
                    type: "grab",
                    rotation: 0
                  }
                })) : n.button === 5 && (this.complete(), this.setCurrentTool(this._restoreToolId));
                break
              }
            }
            break
          }
          case "keyboard": {
            switch (n.key === "ShiftRight" && (n.key = "ShiftLeft"), n.key === "AltRight" && (n.key = "AltLeft"), n.code === "ControlRight" && (n.code = "ControlLeft"), n.name) {
              case "key_down": {
                r.keys.add(n.code), !n.ctrlKey && n.code === "Space" && (this.inputs.isPanning || (this._prevCursor = this.getInstanceState().cursor.type), this.inputs.isPanning = !0, this.updateInstanceState({
                  cursor: {
                    type: this.inputs.isPointing ? "grabbing" : "grab",
                    rotation: 0
                  }
                }));
                break
              }
              case "key_up": {
                r.keys.delete(n.code), n.code === "Space" && !this.inputs.buttons.has(1) && (this.inputs.isPanning = !1, this.updateInstanceState({
                  cursor: {
                    type: this._prevCursor,
                    rotation: 0
                  }
                }));
                break
              }
            }
            break
          }
        }
        if (n.type === "pointer" && (n.button === 1 ? n.name = "middle_click" : n.button === 2 && (n.name = "right_click"), n.isPen === this.getInstanceState().isPenMode)) switch (n.name) {
          case "pointer_down": {
            const l = this._clickManager.transformPointerDownEvent(n);
            if (n.name !== l.name) {
              this.root.handleEvent(n), this.emit("event", n), this.root.handleEvent(l), this.emit("event", l);
              return
            }
            break
          }
          case "pointer_up": {
            const l = this._clickManager.transformPointerUpEvent(n);
            if (n.name !== l.name) {
              this.root.handleEvent(n), this.emit("event", n), this.root.handleEvent(l), this.emit("event", l);
              return
            }
            break
          }
          case "pointer_move": {
            this._clickManager.handleMove();
            break
          }
        }
        this.root.handleEvent(n), this.emit("event", n)
      }), this
    });
    this.store = n, this.snaps = new na(this), this.user = new ri(r ?? x3(), c ?? !1), this.getContainer = i ?? (() => document.body), this.textMeasure = new LY(this);
    class l extends Mg {}
    P(l, "initial", a ?? ""), this.root = new l(this), this.root.children = {};
    const u = O3(o),
      d = new Set(Object.keys(n.schema.types.shape.migrations.subTypeMigrations));
    for (const S of u) {
      if (!d.has(S.type)) throw Error(`Editor and store have different shapes: "${S.type}" was passed into the editor but not the schema`);
      d.delete(S.type)
    }
    if (d.size > 0) throw Error(`Editor and store have different shapes: "${[...d][0]}" is present in the store schema but not provided to the editor`);
    const f = {},
      h = {},
      m = new Map;
    for (const S of u) {
      const x = new S(this);
      f[S.type] = x;
      const E = BA(S.props ?? {});
      h[S.type] = E;
      for (const k of E.keys())
        if (!m.has(k.id)) m.set(k.id, k);
        else if (m.get(k.id) !== k) throw Error(`Multiple style props with id "${k.id}" in use. Style prop IDs must be unique.`)
    }
    this.shapeUtils = f, this.styleProps = h;
    for (const S of [...s]) {
      if (Ky(this.root.children, S.id)) throw Error(`Can't override tool with id "${S.id}"`);
      this.root.children[S.id] = new S(this, this.root)
    }
    this.environment = new PY(this), this.scribbles = new IY(this);
    const p = new Set,
      b = S => {
        var F;
        const x = this.getShape(S);
        if (!x) return;
        const {
          start: E,
          end: k
        } = x.props, C = E.type === "binding" ? this.getShape(E.boundShapeId) : void 0, $ = k.type === "binding" ? this.getShape(k.boundShapeId) : void 0, I = this.getAncestorPageId(x);
        if (!I) return;
        let R;
        if (C && $) R = this.findCommonAncestor([C, $]) ?? I;
        else if (C || $) {
          const B = (F = C || $) == null ? void 0 : F.parentId;
          B && B === x.parentId ? R = x.parentId : R = I
        } else return;
        R && R !== x.parentId && this.reparentShapes([S], R);
        const M = this.getShape(S);
        if (!M) throw Error("no reparented arrow");
        const j = this.getShapeNearestSibling(M, C),
          A = this.getShapeNearestSibling(M, $);
        let D;
        if (j && A) D = j.index > A.index ? j : A;
        else if (j && !A) D = j;
        else if (A && !j) D = A;
        else return;
        let N;
        const q = this.getSortedChildIdsForParent(D.parentId).map(B => this.getShape(B)).filter(B => B.index > D.index);
        if (q.length) {
          const B = q.find(V => V.type !== "arrow");
          if (M.index > D.index && (!B || M.index < B.index)) return;
          N = Ag(D.index, q[0].index)
        } else N = yi(D.index);
        N !== M.index && this.updateShapes([{
          id: S,
          type: "arrow",
          index: N
        }])
      },
      w = (S, x) => {
        const {
          x: E,
          y: k
        } = _a(this, S)[x];
        this.store.put([{
          ...S,
          props: {
            ...S.props,
            [x]: {
              type: "point",
              x: E,
              y: k
            }
          }
        }])
      },
      v = S => {
        for (const x of ["start", "end"]) {
          const E = S.props[x];
          if (E.type !== "binding") continue;
          const k = this.getShape(E.boundShapeId),
            C = this.getAncestorPageId(S) === this.getAncestorPageId(k);
          (!k || !C) && w(S, x)
        }
        b(S.id)
      },
      _ = (S, x) => {
        let E = null;
        const k = S.selectedShapeIds.filter(I => !x.has(I));
        k.length !== S.selectedShapeIds.length && (E || (E = {
          ...S
        }), E.selectedShapeIds = k);
        const C = S.erasingShapeIds.filter(I => !x.has(I));
        C.length !== S.erasingShapeIds.length && (E || (E = {
          ...S
        }), E.erasingShapeIds = C), S.hoveredShapeId && x.has(S.hoveredShapeId) && (E || (E = {
          ...S
        }), E.hoveredShapeId = null), S.editingShapeId && x.has(S.editingShapeId) && (E || (E = {
          ...S
        }), E.editingShapeId = null);
        const $ = S.hintingShapeIds.filter(I => !x.has(I));
        return $.length !== S.hintingShapeIds.length && (E || (E = {
          ...S
        }), E.hintingShapeIds = $), S.focusedGroupId && x.has(S.focusedGroupId) && (E || (E = {
          ...S
        }), E.focusedGroupId = null), E
      };
    if (this.sideEffects = new OY(this), this.sideEffects.registerBatchCompleteHandler(() => {
        var S;
        for (const x of p) {
          p.delete(x);
          const E = this.getShape(x);
          if (!E) continue;
          const k = this.getShapeUtil(E),
            C = (S = k.onChildrenChange) == null ? void 0 : S.call(k, E);
          C != null && C.length && this.updateShapes(C, {
            squashing: !0
          })
        }
        this.emit("update")
      }), this.sideEffects.registerBeforeDeleteHandler("shape", S => {
        S.parentId && yo(S.parentId) && p.add(S.parentId);
        const x = this._arrowBindingsIndex.get()[S.id];
        if (x != null && x.length)
          for (const {
              arrowId: C,
              handleId: $
            }
            of x) {
            const I = this.getShape(C);
            I && w(I, $)
          }
        const E = new Set([S.id]),
          k = Fe(this.getPageStates().map(C => _(C, E)));
        k.length && this.store.put(k)
      }), this.sideEffects.registerBeforeDeleteHandler("page", S => {
        var C;
        if (this.getInstanceState().currentPageId !== S.id) return;
        const x = (C = this.pages.find($ => $.id !== S.id)) == null ? void 0 : C.id;
        if (!x) return;
        this.store.put([{
          ...this.getInstanceState(),
          currentPageId: x
        }]);
        const E = Bn.createId(S.id),
          k = Un.createId(S.id);
        this.store.remove([E, k])
      }), this.sideEffects.registerAfterChangeHandler("shape", (S, x) => {
        if (this.isShapeOfType(x, "arrow") && v(x), S.parentId !== x.parentId) {
          const E = k => {
            const C = this._arrowBindingsIndex.get()[k];
            if (C != null && C.length)
              for (const $ of C) b($.arrowId)
          };
          E(x.id), this.visitDescendants(x.id, E)
        }
        if (S.parentId !== x.parentId && $r(x.parentId)) {
          const E = new Set([S.id]);
          this.visitDescendants(S.id, k => {
            E.add(k)
          });
          for (const k of this.getPageStates()) {
            if (k.pageId === x.parentId) continue;
            const C = _(k, E);
            C && this.store.put([C])
          }
        }
        S.parentId && yo(S.parentId) && p.add(S.parentId), x.parentId !== S.parentId && yo(x.parentId) && p.add(x.parentId)
      }), this.sideEffects.registerAfterChangeHandler("instance_page_state", (S, x) => {
        if ((S == null ? void 0 : S.selectedShapeIds) !== (x == null ? void 0 : x.selectedShapeIds)) {
          const E = x.selectedShapeIds.filter(C => {
            var I, R;
            let $ = (I = this.getShape(C)) == null ? void 0 : I.parentId;
            for (; yo($);) {
              if (x.selectedShapeIds.includes($)) return !1;
              $ = (R = this.getShape($)) == null ? void 0 : R.parentId
            }
            return !0
          });
          let k = null;
          if (E.length > 0) {
            const C = this.findCommonAncestor(Fe(E.map($ => this.getShape($))), $ => this.isShapeOfType($, "group"));
            C && (k = C)
          } else x != null && x.focusedGroupId && (k = x.focusedGroupId);
          (E.length !== x.selectedShapeIds.length || k !== x.focusedGroupId) && this.store.put([{
            ...x,
            selectedShapeIds: E,
            focusedGroupId: k ?? null
          }])
        }
      }), this.sideEffects.registerAfterCreateHandler("shape", S => {
        this.isShapeOfType(S, "arrow") && v(S)
      }), this.sideEffects.registerAfterCreateHandler("page", S => {
        const x = Bn.createId(S.id),
          E = Un.createId(S.id);
        this.store.has(x) || this.store.put([Bn.create({
          id: x
        })]), this.store.has(E) || this.store.put([Un.create({
          id: E,
          pageId: S.id
        })])
      }), this._currentPageShapeIds = EY(this.store, () => this.currentPageId), this._parentIdsToChildIds = xY(this.store), this.disposables.add(this.store.listen(S => {
        this.emit("change", S)
      })), this.store.ensureStoreIsUsable(), this._setInstancePageState({
        editingShapeId: null,
        hoveredShapeId: null,
        erasingShapeIds: []
      }, {
        ephemeral: !0
      }), a && this.root.children[a] === void 0) throw Error(`No state found for initialState "${a}".`);
    this.root.enter(void 0, "initial"), this.getInstanceState().followingUserId && this.stopFollowingUser(), this.updateRenderingBounds(), requestAnimationFrame(() => {
      this._tickManager.start()
    })
  }
  dispose() {
    this.disposables.forEach(n => n()), this.disposables.clear()
  }
  getShapeUtil(n) {
    const r = typeof n == "string" ? n : n.type,
      o = Da(this.shapeUtils, r);
    return Xa(o, `No shape util found for type "${r}"`), o
  }
  undo() {
    return this.history.undo(), this
  }
  getCanUndo() {
    return this.history.numUndos > 0
  }
  get canUndo() {
    return this.getCanUndo()
  }
  redo() {
    return this.history.redo(), this
  }
  getCanRedo() {
    return this.history.numRedos > 0
  }
  get canRedo() {
    return this.getCanRedo()
  }
  mark(n, r, o) {
    return this.history.mark(n, r, o), this
  }
  bail() {
    return this.history.bail(), this
  }
  bailToMark(n) {
    return this.history.bailToMark(n), this
  }
  batch(n) {
    return this.history.batch(n), this
  }
  get _arrowBindingsIndex() {
    return _Y(this)
  }
  getArrowsBoundTo(n) {
    return this._arrowBindingsIndex.get()[n] || Ns
  }
  get arrowInfoCache() {
    return this.store.createComputedCache("arrow infoCache", n => ld(n) ? qd(this, n) : Z0(this, n))
  }
  getArrowInfo(n) {
    const r = typeof n == "string" ? n : n.id;
    return this.arrowInfoCache.get(r)
  }
  annotateError(n, {
    origin: r,
    willCrashApp: o,
    tags: s,
    extras: i
  }) {
    const a = this.createErrorAnnotations(r, o);
    return i1(n, {
      tags: {
        ...a.tags,
        ...s
      },
      extras: {
        ...a.extras,
        ...i
      }
    }), o && this.store.markAsPossiblyCorrupted(), this
  }
  createErrorAnnotations(n, r) {
    try {
      const o = this.getEditingShapeId();
      return {
        tags: {
          origin: n,
          willCrashApp: r
        },
        extras: {
          activeStateNode: this.root.path.get(),
          selectedShapes: this.getSelectedShapes(),
          editingShape: o ? this.getShape(o) : void 0,
          inputs: this.inputs
        }
      }
    } catch {
      return {
        tags: {
          origin: n,
          willCrashApp: r
        },
        extras: {}
      }
    }
  }
  get crashingError() {
    return this._crashingError
  }
  crash(n) {
    return this._crashingError = n, this.store.markAsPossiblyCorrupted(), this.emit("crash", {
      error: n
    }), this
  }
  isIn(n) {
    const r = n.split(".").reverse();
    let o = this.root;
    for (; r.length > 0;) {
      const s = r.pop();
      if (!s) return !0;
      const i = o.current.get();
      if ((i == null ? void 0 : i.id) === s) {
        if (r.length === 0) return !0;
        o = i;
        continue
      } else return !1
    }
    return !1
  }
  isInAny(...n) {
    return n.some(r => this.isIn(r))
  }
  setCurrentTool(n, r = {}) {
    return this.root.transition(n, r), this
  }
  getCurrentTool() {
    return this.root.current.get()
  }
  get currentTool() {
    return this.getCurrentTool()
  }
  getCurrentToolId() {
    const n = this.getCurrentTool();
    return n ? n.currentToolIdMask ?? n.id : ""
  }
  get currentToolId() {
    return this.getCurrentToolId()
  }
  getStateDescendant(n) {
    var s;
    const r = n.split(".").reverse();
    let o = this.root;
    for (; r.length > 0;) {
      const i = r.pop();
      if (!i) return o;
      const a = (s = o.children) == null ? void 0 : s[i];
      if (!a) return;
      o = a
    }
    return o
  }
  getDocumentSettings() {
    return this.store.get(jS)
  }
  get documentSettings() {
    return this.getDocumentSettings()
  }
  updateDocumentSettings(n) {
    return this.store.put([{
      ...this.getDocumentSettings(),
      ...n
    }]), this
  }
  getInstanceState() {
    return this.store.get(er)
  }
  get instanceState() {
    return this.getInstanceState()
  }
  updateInstanceState(n, r) {
    return this._updateInstanceState(n, {
      ephemeral: !0,
      squashing: !0,
      ...r
    }), n.isChangingStyle !== void 0 && (clearTimeout(this._isChangingStyleTimeout), n.isChangingStyle === !0 && (this._isChangingStyleTimeout = setTimeout(() => {
      this.updateInstanceState({
        isChangingStyle: !1
      })
    }, 2e3))), this
  }
  getOpenMenus() {
    return this.getInstanceState().openMenus
  }
  get openMenus() {
    return this.getOpenMenus()
  }
  addOpenMenu(n) {
    const r = new Set(this.getOpenMenus());
    return r.has(n) || (r.add(n), this.updateInstanceState({
      openMenus: [...r]
    })), this
  }
  deleteOpenMenu(n) {
    const r = new Set(this.getOpenMenus());
    return r.has(n) && (r.delete(n), this.updateInstanceState({
      openMenus: [...r]
    })), this
  }
  getIsMenuOpen() {
    return this.getOpenMenus().length > 0
  }
  get isMenuOpen() {
    return this.getIsMenuOpen()
  }
  getPageStates() {
    return this._getPageStatesQuery().get()
  }
  get pageStates() {
    return this.getPageStates()
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state")
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId())
  }
  get currentPageState() {
    return this.getCurrentPageState()
  }
  _getCurrentPageStateId() {
    return Un.createId(this.currentPageId)
  }
  updateCurrentPageState(n, r) {
    return this._setInstancePageState(n, r), this
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds
  }
  get selectedShapeIds() {
    return this.getSelectedShapeIds()
  }
  getSelectedShapes() {
    const {
      selectedShapeIds: n
    } = this.getCurrentPageState();
    return Fe(n.map(r => this.store.get(r)))
  }
  get selectedShapes() {
    return this.getSelectedShapes()
  }
  setSelectedShapes(n, r) {
    const o = n.map(s => typeof s == "string" ? s : s.id);
    return this._setSelectedShapes(o, r), this
  }
  isAncestorSelected(n) {
    const r = typeof n == "string" ? n : (n == null ? void 0 : n.id) ?? null,
      o = this.getShape(r);
    if (!o) return !1;
    const s = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(o, i => s.includes(i.id))
  }
  select(...n) {
    const r = typeof n[0] == "string" ? n : n.map(o => o.id);
    return this.setSelectedShapes(r), this
  }
  deselect(...n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id),
      o = this.getSelectedShapeIds();
    return o.length > 0 && r.length > 0 && this.setSelectedShapes(o.filter(s => !r.includes(s))), this
  }
  selectAll() {
    const n = this.getSortedChildIdsForParent(this.currentPageId);
    return n.length <= 0 ? this : (this.setSelectedShapes(this._getUnlockedShapeIds(n)), this)
  }
  selectNone() {
    return this.getSelectedShapeIds().length > 0 && this.setSelectedShapes([]), this
  }
  getOnlySelectedShape() {
    const n = this.getSelectedShapes();
    return n.length === 1 ? n[0] : null
  }
  get onlySelectedShape() {
    return this.getOnlySelectedShape()
  }
  getSelectionPageBounds() {
    const n = this.getCurrentPageState().selectedShapeIds;
    return n.length === 0 ? null : Be.Common(Fe(n.map(r => this.getShapePageBounds(r))))
  }
  get selectionPageBounds() {
    return this.getSelectionPageBounds()
  }
  getSelectionRotation() {
    const n = this.getSelectedShapeIds();
    if (n.length === 0) return 0;
    if (n.length === 1) return this.getShapePageTransform(this.getSelectedShapeIds()[0]).rotation();
    const r = n.map(o => this.getShapePageTransform(o).rotation());
    return r.every(o => Math.abs(o - r[0]) < Math.PI / 180) ? this.getShapePageTransform(n[0]).rotation() : 0
  }
  get selectionRotation() {
    return this.getSelectionRotation()
  }
  getSelectionRotatedPageBounds() {
    const n = this.getSelectedShapeIds();
    if (n.length === 0) return;
    const r = this.getSelectionRotation();
    if (r === 0) return this.getSelectionPageBounds();
    if (n.length === 1) {
      const s = this.getShapeGeometry(n[0]).bounds.clone(),
        i = this.getShapePageTransform(n[0]);
      return s.point = i.applyToPoint(s.point), s
    }
    const o = Be.FromPoints(this.getSelectedShapeIds().flatMap(s => {
      const i = this.getShapePageTransform(s);
      return i ? i.applyToPoints(this.getShapeGeometry(s).vertices) : []
    }).map(s => T.Rot(s, -r)));
    return o.point = o.point.rot(r), o
  }
  get selectionRotatedPageBounds() {
    return this.getSelectionRotatedPageBounds()
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.currentPageId
  }
  get focusedGroupId() {
    return this.getFocusedGroupId()
  }
  getFocusedGroup() {
    const n = this.getFocusedGroupId();
    return n ? this.getShape(n) : void 0
  }
  get focusedGroup() {
    return this.getFocusedGroup()
  }
  setFocusedGroup(n) {
    const r = typeof n == "string" ? n : (n == null ? void 0 : n.id) ?? null;
    if (r !== null) {
      const o = this.getShape(r);
      if (!o) throw Error(`Editor.setFocusedGroup: Shape with id ${r} does not exist`);
      if (!this.isShapeOfType(o, "group")) throw Error(`Editor.setFocusedGroup: Cannot set focused group to shape of type ${o.type}`)
    }
    return r === this.getFocusedGroupId() ? this : (this._setFocusedGroupId(r), this)
  }
  popFocusedGroupId() {
    const n = this.getFocusedGroup();
    if (n) {
      const r = this.findShapeAncestor(n, o => this.isShapeOfType(o, "group"));
      this.setFocusedGroup((r == null ? void 0 : r.id) ?? null), this.select(n.id)
    } else this.setFocusedGroup(null), this.selectNone();
    return this
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId
  }
  get editingShapeId() {
    return this.getEditingShapeId()
  }
  getEditingShape() {
    const n = this.getEditingShapeId();
    return n ? this.getShape(n) : void 0
  }
  get editingShape() {
    return this.getEditingShape()
  }
  setEditingShape(n) {
    const r = typeof n == "string" ? n : (n == null ? void 0 : n.id) ?? null;
    if (r !== this.getEditingShapeId()) {
      if (r) {
        const o = this.getShape(r);
        if (o && this.getShapeUtil(o).canEdit(o)) return this._setInstancePageState({
          editingShapeId: r
        }), this
      }
      this._setInstancePageState({
        editingShapeId: null
      })
    }
    return this
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId
  }
  get hoveredShapeId() {
    return this.getHoveredShapeId()
  }
  getHoveredShape() {
    const n = this.getHoveredShapeId();
    return n ? this.getShape(n) : void 0
  }
  get hoveredShape() {
    return this.getHoveredShape()
  }
  setHoveredShape(n) {
    const r = typeof n == "string" ? n : (n == null ? void 0 : n.id) ?? null;
    return r === this.getHoveredShapeId() ? this : (this.updateCurrentPageState({
      hoveredShapeId: r
    }, {
      ephemeral: !0
    }), this)
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds
  }
  get hintingShapeIds() {
    return this.getHintingShapeIds()
  }
  getHintingShape() {
    const n = this.getHintingShapeIds();
    return Fe(n.map(r => this.getShape(r)))
  }
  get hintingShape() {
    return this.getHintingShape()
  }
  setHintingShapes(n) {
    const r = typeof n[0] == "string" ? n : n.map(o => o.id);
    return this.updateCurrentPageState({
      hintingShapeIds: xm(r)
    }, {
      ephemeral: !0
    }), this
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds
  }
  get erasingShapeIds() {
    return this.getErasingShapeIds()
  }
  getErasingShapes() {
    const n = this.getErasingShapeIds();
    return Fe(n.map(r => this.getShape(r)))
  }
  get erasingShapes() {
    return this.getErasingShapes()
  }
  setErasingShapes(n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id);
    r.sort();
    const o = this.getErasingShapeIds();
    if (r.length === o.length) {
      for (let s = 0; s < r.length; s++)
        if (r[s] !== o[s]) {
          this._setInstancePageState({
            erasingShapeIds: r
          }, {
            ephemeral: !0
          });
          break
        }
    } else this._setInstancePageState({
      erasingShapeIds: r
    }, {
      ephemeral: !0
    });
    return this
  }
  get croppingShapeId() {
    return this.getCurrentPageState().croppingShapeId
  }
  setCroppingShape(n) {
    const r = typeof n == "string" ? n : (n == null ? void 0 : n.id) ?? null;
    if (r !== this.croppingShapeId)
      if (!r) this.updateCurrentPageState({
        croppingShapeId: null
      });
      else {
        const o = this.getShape(r),
          s = this.getShapeUtil(o);
        o && s.canCrop(o) && this.updateCurrentPageState({
          croppingShapeId: r
        })
      } return this
  }
  getCameraId() {
    return Bn.createId(this.currentPageId)
  }
  getCamera() {
    return this.store.get(this.getCameraId())
  }
  get zoomLevel() {
    return this.getCamera().z
  }
  _setCamera(n) {
    const r = this.getCamera();
    return r.x === n.x && r.y === n.y && r.z === n.z ? this : (this.batch(() => {
      this.store.put([{
        ...r,
        ...n
      }]);
      const {
        currentScreenPoint: o
      } = this.inputs;
      this.dispatch({
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        point: o,
        pointerId: GP.CAMERA_MOVE,
        ctrlKey: this.inputs.ctrlKey,
        altKey: this.inputs.altKey,
        shiftKey: this.inputs.shiftKey,
        button: 0,
        isPen: this.getInstanceState().isPenMode ?? !1
      }), this._tickCameraState()
    }), this)
  }
  setCamera(n, r) {
    const o = Number.isFinite(n.x) ? n.x : 0,
      s = Number.isFinite(n.y) ? n.y : 0,
      i = Number.isFinite(n.z) ? n.z : this.zoomLevel;
    if (this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser(), r) {
      const {
        width: a,
        height: c
      } = this.viewportScreenBounds;
      return this._animateToViewport(new Be(-o, -s, a / i, c / i), r)
    } else this._setCamera({
      x: o,
      y: s,
      z: i
    });
    return this
  }
  centerOnPoint(n, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      viewportPageBounds: {
        width: o,
        height: s
      }
    } = this;
    return this.setCamera({
      x: -(n.x - o / 2),
      y: -(n.y - s / 2),
      z: this.getCamera().z
    }, r), this
  }
  zoomToContent() {
    const n = this.getSelectionPageBounds() ?? this.currentPageBounds;
    return n && this.zoomToBounds(n, Math.min(1, this.zoomLevel), {
      duration: 220
    }), this
  }
  zoomToFit(n) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const r = [...this.currentPageShapeIds];
    if (r.length <= 0) return this;
    const o = Be.Common(Fe(r.map(s => this.getShapePageBounds(s))));
    return this.zoomToBounds(o, void 0, n), this
  }
  resetZoom(n = this.viewportScreenCenter, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      x: o,
      y: s,
      z: i
    } = this.getCamera(), {
      x: a,
      y: c
    } = n;
    return this.setCamera({
      x: o + (a / 1 - a) - (a / i - a),
      y: s + (c / 1 - c) - (c / i - c),
      z: 1
    }, r), this
  }
  zoomIn(n = this.viewportScreenCenter, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      x: o,
      y: s,
      z: i
    } = this.getCamera();
    let a = qc;
    for (let u = 1; u < Ic.length; u++) {
      const d = Ic[u - 1],
        f = Ic[u];
      if (!(f - i <= (f - d) / 2)) {
        a = f;
        break
      }
    }
    const {
      x: c,
      y: l
    } = n;
    return this.setCamera({
      x: o + (c / a - c) - (c / i - c),
      y: s + (l / a - l) - (l / i - l),
      z: a
    }, r), this
  }
  zoomOut(n = this.viewportScreenCenter, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      x: o,
      y: s,
      z: i
    } = this.getCamera();
    let a = cd;
    for (let u = Ic.length - 1; u > 0; u--) {
      const d = Ic[u - 1],
        f = Ic[u];
      if (!(f - i >= (f - d) / 2)) {
        a = d;
        break
      }
    }
    const {
      x: c,
      y: l
    } = n;
    return this.setCamera({
      x: o + (c / a - c) - (c / i - c),
      y: s + (l / a - l) - (l / i - l),
      z: a
    }, r), this
  }
  zoomToSelection(n) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const r = this.getSelectionPageBounds();
    return r ? (this.zoomToBounds(r, Math.max(1, this.zoomLevel), n), this) : this
  }
  panZoomIntoView(n, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    if (n.length <= 0) return this;
    const o = Be.Common(Fe(n.map(i => this.getShapePageBounds(i)))),
      {
        viewportPageBounds: s
      } = this;
    if (s.h < o.h || s.w < o.w) return this.zoomToBounds(o, this.getCamera().z, r), this;
    {
      const i = this.viewportPageBounds.clone().expandBy(-32 / this.zoomLevel);
      let a = 0,
        c = 0;
      i.maxY < o.maxY ? c = i.maxY - o.maxY : i.minY > o.minY && (c = i.minY - o.minY), i.maxX < o.maxX ? a = i.maxX - o.maxX : i.minX > o.minX && (a = i.minX - o.minX);
      const l = this.getCamera();
      this.setCamera({
        x: l.x + a,
        y: l.y + c,
        z: l.z
      }, r)
    }
    return this
  }
  zoomToBounds(n, r, o) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      viewportScreenBounds: s
    } = this, i = Math.min(256, s.width * .28);
    let a = eo(Math.min((s.width - i) / n.width, (s.height - i) / n.height), cd, qc);
    return r !== void 0 && (a = Math.min(r, a)), this.setCamera({
      x: -n.minX + (s.width - n.width * a) / 2 / a,
      y: -n.minY + (s.height - n.height * a) / 2 / a,
      z: a
    }, o), this
  }
  pan(n, r) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const {
      x: o,
      y: s,
      z: i
    } = this.getCamera();
    return this.setCamera({
      x: o + n.x / i,
      y: s + n.y / i,
      z: i
    }, r), this
  }
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this
  }
  _animateViewport(n) {
    if (!this._viewportAnimation) return;
    const r = () => {
      this.removeListener("tick", this._animateViewport), this.removeListener("stop-camera-animation", r), this._viewportAnimation = null
    };
    this.once("stop-camera-animation", r), this._viewportAnimation.elapsed += n;
    const {
      elapsed: o,
      easing: s,
      duration: i,
      start: a,
      end: c
    } = this._viewportAnimation;
    if (o > i) {
      this._setCamera({
        x: -c.x,
        y: -c.y,
        z: this.viewportScreenBounds.width / c.width
      }), r();
      return
    }
    const l = i - o,
      u = s(1 - l / i),
      d = a.minX + (c.minX - a.minX) * u,
      f = a.minY + (c.minY - a.minY) * u,
      h = a.maxX + (c.maxX - a.maxX) * u;
    this._setCamera({
      x: -d,
      y: -f,
      z: this.viewportScreenBounds.width / (h - d)
    })
  }
  _animateToViewport(n, r = {}) {
    const {
      duration: o = 0,
      easing: s = Vi.easeInOutCubic
    } = r, {
      user: {
        animationSpeed: i
      },
      viewportPageBounds: a
    } = this;
    return this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser(), o === 0 || i === 0 ? this._setCamera({
      x: -n.x,
      y: -n.y,
      z: this.viewportScreenBounds.width / n.width
    }) : (this._viewportAnimation = {
      elapsed: 0,
      duration: o / i,
      easing: s,
      start: a.clone(),
      end: n.clone()
    }, this.addListener("tick", this._animateViewport), this)
  }
  slideCamera(n = {}) {
    if (!this.getInstanceState().canMoveCamera) return this;
    this.stopCameraAnimation();
    const {
      animationSpeed: r
    } = this.user;
    if (r === 0) return this;
    const {
      speed: o,
      friction: s,
      direction: i,
      speedThreshold: a = .01
    } = n;
    let c = Math.min(o, 1);
    const l = () => {
      this.removeListener("tick", u), this.removeListener("stop-camera-animation", l)
    };
    this.once("stop-camera-animation", l);
    const u = d => {
      const {
        x: f,
        y: h,
        z: m
      } = this.getCamera(), p = T.Mul(i, c * d / m);
      c *= 1 - s, c < a ? l() : this._setCamera({
        x: f + p.x,
        y: h + p.y,
        z: m
      })
    };
    return this.addListener("tick", u), this
  }
  animateToUser(n) {
    const o = [...this.store.query.records("instance_presence", () => ({
      userId: {
        eq: n
      }
    })).get()].sort((s, i) => s.lastActivityTimestamp - i.lastActivityTimestamp).pop();
    return o ? (this.batch(() => {
      this.getInstanceState().followingUserId !== null && this.stopFollowingUser();
      const s = o.currentPageId === this.currentPageId;
      s || this.setCurrentPage(o.currentPageId);
      const i = s ? {
        duration: 500
      } : void 0;
      this.centerOnPoint(o.cursor, i);
      const {
        highlightedUserIds: a
      } = this.getInstanceState();
      this.updateInstanceState({
        highlightedUserIds: [...a, n]
      }), setTimeout(() => {
        const c = [...this.getInstanceState().highlightedUserIds],
          l = c.indexOf(n);
        l < 0 || (c.splice(l, 1), this.updateInstanceState({
          highlightedUserIds: c
        }))
      }, XA)
    }), this) : this
  }
  animateToShape(n, r = CV) {
    if (!this.getInstanceState().canMoveCamera) return this;
    const o = this.viewportScreenBounds.clone().expandBy(-32),
      s = o.width / o.height,
      i = this.getShapePageBounds(n);
    if (!i) return this;
    const a = i.width / i.height,
      c = i.clone(),
      l = i.width / o.width;
    return c.width += (o.minX + o.maxX) * l, c.height += (o.minY + o.maxY) * l, c.x -= o.minX * l, c.y -= o.minY * l, a > s ? (c.height = i.width / s, c.y -= (c.height - i.height) / 2) : (c.width = i.height * s, c.x -= (c.width - i.width) / 2), this._animateToViewport(c, r)
  }
  updateViewportScreenBounds(n = !1) {
    const r = this.getContainer();
    if (!r) return this;
    const o = r.getBoundingClientRect(),
      s = new Be(o.left || o.x, o.top || o.y, Math.max(o.width, 1), Math.max(o.height, 1)),
      i = s.equals(this.viewportScreenBounds),
      {
        _willSetInitialBounds: a
      } = this;
    if (i) this._willSetInitialBounds = !1;
    else if (a) this._willSetInitialBounds = !1, this.updateInstanceState({
      screenBounds: s.toJson()
    }, {
      squashing: !0,
      ephemeral: !0
    });
    else if (n && !this.getInstanceState().followingUserId) {
      const c = this.viewportPageCenter;
      this.updateInstanceState({
        screenBounds: s.toJson()
      }, {
        squashing: !0,
        ephemeral: !0
      }), this.centerOnPoint(c)
    } else this.updateInstanceState({
      screenBounds: s.toJson()
    }, {
      squashing: !0,
      ephemeral: !0
    });
    return this._tickCameraState(), this.updateRenderingBounds(), this
  }
  get viewportScreenBounds() {
    const {
      x: n,
      y: r,
      w: o,
      h: s
    } = this.getInstanceState().screenBounds;
    return new Be(n, r, o, s)
  }
  get viewportScreenCenter() {
    return this.viewportScreenBounds.center
  }
  get viewportPageBounds() {
    const {
      w: n,
      h: r
    } = this.viewportScreenBounds, {
      x: o,
      y: s,
      z: i
    } = this.getCamera();
    return new Be(-o, -s, n / i, r / i)
  }
  get viewportPageCenter() {
    return this.viewportPageBounds.center
  }
  screenToPage(n) {
    const {
      screenBounds: r
    } = this.store.unsafeGetWithoutCapture(er), {
      x: o,
      y: s,
      z: i = 1
    } = this.getCamera();
    return {
      x: (n.x - r.x) / i - o,
      y: (n.y - r.y) / i - s,
      z: n.z ?? .5
    }
  }
  pageToScreen(n) {
    const {
      screenBounds: r
    } = this.store.unsafeGetWithoutCapture(er), {
      x: o,
      y: s,
      z: i = 1
    } = this.getCamera();
    return {
      x: (n.x + o) * i + r.x,
      y: (n.y + s) * i + r.y,
      z: n.z ?? .5
    }
  }
  startFollowingUser(n) {
    const r = this.store.query.records("instance_presence", () => ({
        userId: {
          eq: n
        }
      })),
      o = this.user.id;
    if (o || console.warn("You should set the userId for the current instance before following a user"), r.get().some(c => c.followingUserId === o)) return this;
    Zr(() => {
      this.stopFollowingUser(), this.updateInstanceState({
        followingUserId: n
      }, {
        ephemeral: !0
      })
    });
    const s = () => {
      this.removeListener("frame", a), this.removeListener("stop-following", s)
    };
    let i = !1;
    const a = () => {
      const c = [...r.get()].sort((j, A) => j.lastActivityTimestamp - A.lastActivityTimestamp).pop();
      if (!c) {
        this.stopFollowingUser();
        return
      }
      const l = c.currentPageId === this.currentPageId,
        u = l ? vV : 1;
      if (!l) {
        this.stopFollowingUser(), this.setCurrentPage(c.currentPageId), this.startFollowingUser(n);
        return
      }
      const {
        center: d,
        width: f,
        height: h
      } = this.viewportPageBounds, m = Be.From(c.screenBounds), p = m.width / c.camera.z, b = m.height / c.camera.z, w = new T(p / 2 - c.camera.x, b / 2 - c.camera.y), v = c.followingUserId === o, _ = f + (p - f) * u, S = h + (b - h) * u, x = v ? h / S : Math.min(f / _, h / S), E = eo(this.getCamera().z * x, cd, qc), k = this.viewportScreenBounds.w / E, C = this.viewportScreenBounds.h / E, $ = w.sub(d), I = T.Add(d, T.Mul($, u)), R = T.Sub(I, d).len(), M = Math.abs(E - this.getCamera().z);
      if (R < bV && M < SV) {
        i = !0;
        return
      }
      i && R < wV && M < _V || (i = !1, this.stopCameraAnimation(), this._setCamera({
        x: -(I.x - k / 2),
        y: -(I.y - C / 2),
        z: E
      }))
    };
    return this.once("stop-following", s), this.addListener("frame", a), this
  }
  stopFollowingUser() {
    return this.updateInstanceState({
      followingUserId: null
    }, {
      ephemeral: !0
    }), this.emit("stop-following"), this
  }
  get cameraState() {
    return this._cameraState.get()
  }
  getUnorderedRenderingShapes(n) {
    const r = [];
    let o = Qo * 2,
      s = Qo;
    const i = this.getEditingShapeId(),
      a = this.getSelectedShapeIds(),
      c = this.getErasingShapeIds(),
      l = this.renderingBoundsExpanded,
      u = Number.isFinite(this.renderingBoundsMargin),
      d = (f, h, m) => {
        const p = this.getShape(f);
        if (!p) return;
        h *= p.opacity;
        let b = !1,
          w = !1;
        const v = this.getShapeUtil(p),
          _ = this.getShapeMaskedPageBounds(f);
        n && (w = !m && c.includes(f), w && (h *= .32), b = u && v.canUnmount(p) && i !== f && (_ === void 0 || !l.includes(_) && !a.includes(f))), r.push({
          id: f,
          shape: p,
          util: v,
          index: o,
          backgroundIndex: s,
          opacity: h,
          isCulled: b,
          maskedPageBounds: _
        }), o += 1, s += 1;
        const S = this.getSortedChildIdsForParent(f);
        if (!S.length) return;
        let x = null;
        v.providesBackgroundForChildren(p) && (x = s, s = o, o += Qo);
        for (const E of S) d(E, h, m || w);
        x !== null && (s = x)
      };
    for (const f of this.getSortedChildIdsForParent(this.currentPageId)) d(f, 1, !1);
    return r
  }
  get renderingShapes() {
    return this.getUnorderedRenderingShapes(!0).sort(Pz)
  }
  get renderingBounds() {
    return this._renderingBounds.get()
  }
  get renderingBoundsExpanded() {
    return this._renderingBoundsExpanded.get()
  }
  updateRenderingBounds() {
    const {
      viewportPageBounds: n
    } = this;
    return n.equals(this._renderingBounds.__unsafe__getWithoutCapture()) ? this : (this._renderingBounds.set(n.clone()), Number.isFinite(this.renderingBoundsMargin) ? this._renderingBoundsExpanded.set(n.clone().expandBy(this.renderingBoundsMargin / this.zoomLevel)) : this._renderingBoundsExpanded.set(n), this)
  }
  get _pages() {
    return this.store.query.records("page")
  }
  get pages() {
    return this._pages.get().sort(ts)
  }
  get currentPage() {
    return this.getPage(this.currentPageId)
  }
  get currentPageId() {
    return this.getInstanceState().currentPageId
  }
  getPage(n) {
    return this.store.get(typeof n == "string" ? n : n.id)
  }
  get currentPageShapeIds() {
    return this._currentPageShapeIds.get()
  }
  getPageShapeIds(n) {
    const r = typeof n == "string" ? n : n.id,
      o = this.store.query.exec("shape", {
        parentId: {
          eq: r
        }
      });
    return this.getShapeAndDescendantIds(o.map(s => s.id))
  }
  setCurrentPage(n, r) {
    const o = typeof n == "string" ? n : n.id;
    return this._setCurrentPageId(o, r), this
  }
  updatePage(n, r) {
    return this._updatePage(n, r), this
  }
  createPage(n) {
    return this._createPage(n), this
  }
  deletePage(n) {
    const r = typeof n == "string" ? n : n.id;
    return this._deletePage(r), this
  }
  duplicatePage(n, r = Ys.createId()) {
    if (this.pages.length >= Rm) return this;
    const o = typeof n == "string" ? n : n.id,
      s = this.getPage(o);
    if (!s) return this;
    const i = {
        ...this.getCamera()
      },
      a = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(s.id));
    return this.batch(() => {
      var u;
      const {
        pages: c
      } = this, l = Ag(s.index, (u = c[c.indexOf(s) + 1]) == null ? void 0 : u.index);
      if (this.createPage({
          name: s.name + " Copy",
          id: r,
          index: l
        }), this.setCurrentPage(r), this.setCamera(i), a) return this.putContentOntoCurrentPage(a)
    }), this
  }
  renamePage(n, r, o) {
    const s = typeof n == "string" ? n : n.id;
    return this.getInstanceState().isReadonly ? this : (this.updatePage({
      id: s,
      name: r
    }, o), this)
  }
  get _assets() {
    return this.store.query.records("asset")
  }
  get assets() {
    return this._assets.get()
  }
  createAssets(n) {
    return this._createAssets(n), this
  }
  updateAssets(n) {
    return this._updateAssets(n), this
  }
  deleteAssets(n) {
    const r = typeof n[0] == "string" ? n : n.map(o => o.id);
    return this._deleteAssets(r), this
  }
  getAsset(n) {
    return this.store.get(typeof n == "string" ? n : n.id)
  }
  get _shapeGeometryCache() {
    return this.store.createComputedCache("bounds", n => this.getShapeUtil(n).getGeometry(n), (n, r) => n.props === r.props)
  }
  getShapeGeometry(n) {
    return this._shapeGeometryCache.get(typeof n == "string" ? n : n.id)
  }
  get _shapeOutlineSegmentsCache() {
    return this.store.createComputedCache("outline-segments", n => this.getShapeUtil(n).getOutlineSegments(n))
  }
  getShapeOutlineSegments(n) {
    return this._shapeOutlineSegmentsCache.get(typeof n == "string" ? n : n.id) ?? Ns
  }
  get _shapeHandlesCache() {
    return this.store.createComputedCache("handles", n => {
      var r, o;
      return (o = (r = this.getShapeUtil(n)).getHandles) == null ? void 0 : o.call(r, n)
    })
  }
  getShapeHandles(n) {
    return this._shapeHandlesCache.get(typeof n == "string" ? n : n.id)
  }
  getShapeLocalTransform(n) {
    const r = typeof n == "string" ? n : n.id,
      o = this.getShape(r);
    if (!o) throw Error("Editor.getTransform: shape not found");
    return Ee.Identity().translate(o.x, o.y).rotate(o.rotation)
  }
  get _shapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", n => {
      if ($r(n.parentId)) return this.getShapeLocalTransform(n);
      const r = this._shapePageTransformCache.get(n.parentId) ?? Ee.Identity();
      return Ee.Compose(r, this.getShapeLocalTransform(n))
    })
  }
  getShapeParentTransform(n) {
    const r = typeof n == "string" ? n : n.id,
      o = this.getShape(r);
    return !o || $r(o.parentId) ? Ee.Identity() : this._shapePageTransformCache.get(o.parentId) ?? Ee.Identity()
  }
  getShapePageTransform(n) {
    const r = typeof n == "string" ? n : this.getShape(n).id;
    return this._shapePageTransformCache.get(r) ?? Ee.Identity()
  }
  get _shapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", n => {
      const r = this._shapePageTransformCache.get(n.id);
      return r ? Be.FromPoints(Ee.applyToPoints(r, this.getShapeGeometry(n).vertices)) : new Be
    })
  }
  getShapePageBounds(n) {
    return this._shapePageBoundsCache.get(typeof n == "string" ? n : n.id)
  }
  get _shapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", n => {
      const r = this._shapeMaskCache.get(n.id);
      if (!r) return;
      if (r.length === 0) return "polygon(0px 0px, 0px 0px, 0px 0px)";
      const o = this._shapePageTransformCache.get(n.id);
      return o ? `polygon(${Ee.applyToPoints(Ee.Inverse(o),r).map(i=>`${i.x}px ${i.y}px`).join(",")})` : void 0
    })
  }
  getShapeClipPath(n) {
    return this._shapeClipPathCache.get(typeof n == "string" ? n : n.id)
  }
  get _shapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", n => {
      if ($r(n.parentId)) return;
      const r = this.getShapeAncestors(n.id).filter(s => this.isShapeOfType(s, "frame"));
      return r.length === 0 ? void 0 : r.map(s => this._shapePageTransformCache.get(s.id).applyToPoints(this.getShapeGeometry(s).vertices)).reduce((s, i) => {
        if (!(i && s)) return;
        const a = zS(s, i);
        return a ? a.map(T.Cast) : []
      })
    })
  }
  getShapeMask(n) {
    return this._shapeMaskCache.get(typeof n == "string" ? n : n.id)
  }
  getShapeMaskedPageBounds(n) {
    typeof n != "string" && (n = n.id);
    const r = this._shapePageBoundsCache.get(n);
    if (!r) return;
    const o = this._shapeMaskCache.get(n);
    if (o) {
      if (o.length === 0) return;
      const {
        corners: s
      } = r;
      if (s.every((a, c) => T.Equals(a, o[c]))) return r.clone();
      const i = zS(o, s);
      return i ? Be.FromPoints(i) : void 0
    }
    return r
  }
  getShapeAncestors(n, r = []) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getShape(o);
    if (!s) return r;
    const i = s.parentId;
    if ($r(i)) return r.reverse(), r;
    const a = this.store.get(i);
    return a ? (r.push(a), this.getShapeAncestors(a, r)) : r
  }
  findShapeAncestor(n, r) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getShape(o);
    if (!s) return;
    const i = s.parentId;
    if ($r(i)) return;
    const a = this.getShape(i);
    if (a) return r(a) ? a : this.findShapeAncestor(a, r)
  }
  hasAncestor(n, r) {
    const o = typeof n == "string" ? n : n == null ? void 0 : n.id,
      s = o && this.getShape(o);
    return s ? s.parentId === r ? !0 : this.hasAncestor(this.getShapeParent(s), r) : !1
  }
  findCommonAncestor(n, r) {
    var l;
    if (n.length === 0) return;
    const o = typeof n[0] == "string" ? n : n.map(u => u.id),
      s = Fe(o.map(u => this.getShape(u)));
    if (s.length === 1) {
      const u = s[0].parentId;
      return $r(u) ? void 0 : r ? (l = this.findShapeAncestor(s[0], r)) == null ? void 0 : l.id : u
    }
    const [i, ...a] = s;
    let c = this.getShapeParent(i);
    for (; c;) {
      if (r && !r(c)) {
        c = this.getShapeParent(c);
        continue
      }
      if (a.every(u => this.hasAncestor(u, c.id))) return c.id;
      c = this.getShapeParent(c)
    }
  }
  isShapeOrAncestorLocked(n) {
    const r = typeof n == "string" ? this.getShape(n) : n;
    return r === void 0 ? !1 : r.isLocked ? !0 : this.isShapeOrAncestorLocked(this.getShapeParent(r))
  }
  get currentPageBounds() {
    let n;
    return this.currentPageShapeIds.forEach(r => {
      const o = this.getShapeMaskedPageBounds(r);
      o && (n ? n = n.expand(o) : n = o.clone())
    }), n
  }
  getSelectedShapeAtPoint(n) {
    const r = this.getSelectedShapeIds();
    return this.currentPageShapesSorted.filter(o => o.type !== "group" && r.includes(o.id)).reverse().find(o => this.isPointInShape(o, n, {
      hitInside: !0,
      margin: 0
    }))
  }
  getShapeAtPoint(n, r = {}) {
    const {
      viewportPageBounds: o,
      zoomLevel: s
    } = this, {
      filter: i,
      margin: a = 0,
      hitLabels: c = !1,
      hitInside: l = !1,
      hitFrameInside: u = !1
    } = r;
    let d = 1 / 0,
      f = null,
      h = 1 / 0,
      m = null;
    const p = (r.renderingOnly ? this.currentPageRenderingShapesSorted : this.currentPageShapesSorted).filter(b => {
      if (this.isShapeOfType(b, "group")) return !1;
      const w = this.getShapeMask(b);
      return w && !ru(n, w) ? !1 : i ? i(b) : !0
    });
    for (let b = p.length - 1; b >= 0; b--) {
      const w = p[b],
        v = this.getShapeGeometry(w),
        _ = v instanceof C1,
        S = this.getPointInShapeSpace(w, n);
      if ((this.isShapeOfType(w, "arrow") || this.isShapeOfType(w, "geo") && w.props.fill === "none") && w.props.text.trim()) {
        for (const E of v.children)
          if (E.isLabel && E.isPointInBounds(S)) return w
      }
      if (this.isShapeOfType(w, "frame")) {
        const E = v.distanceToPoint(S, l);
        if (Math.abs(E) <= a) return m || w;
        if (v.hitTestPoint(S, 0, !0)) return m || f || (u ? w : void 0);
        continue
      }
      let x;
      if (_) {
        let E = 1 / 0;
        for (const k of v.children) {
          if (k.isLabel && !c) continue;
          const C = k.distanceToPoint(S, l);
          C < E && (E = C)
        }
        x = E
      } else a === 0 && (v.bounds.w < 1 || v.bounds.h < 1) || v.bounds.containsPoint(S, a) ? x = v.distanceToPoint(S, l) : x = 1 / 0;
      if (v.isClosed) {
        if (x <= a) {
          if (v.isFilled || _ && v.children[0].isFilled) return m || w;
          if (this.getShapePageBounds(w).contains(o)) continue;
          if (Math.abs(x) < a) Math.abs(x) < h && (h = Math.abs(x), m = w);
          else if (!m) {
            const {
              area: E
            } = v;
            E < d && (d = E, f = w)
          }
        }
      } else if (x < OV / s) return w
    }
    return m || f || void 0
  }
  getShapesAtPoint(n, r = {}) {
    return this.currentPageShapes.filter(o => this.isPointInShape(o, n, r))
  }
  isPointInShape(n, r, o = {}) {
    const {
      hitInside: s = !1,
      margin: i = 0
    } = o, a = typeof n == "string" ? n : n.id, c = this.getShapeMask(a);
    return c && !ru(r, c) ? !1 : this.getShapeGeometry(a).hitTestPoint(this.getPointInShapeSpace(n, r), i, s)
  }
  getPointInShapeSpace(n, r) {
    const o = typeof n == "string" ? n : n.id;
    return this._shapePageTransformCache.get(o).clone().invert().applyToPoint(r)
  }
  getPointInParentSpace(n, r) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getShape(o);
    if (!s) return new T(0, 0);
    if ($r(s.parentId)) return T.From(r);
    const i = this.getShapePageTransform(s.parentId);
    return i ? i.clone().invert().applyToPoint(r) : T.From(r)
  }
  get currentPageShapes() {
    return Array.from(this.currentPageShapeIds, n => this.store.get(n))
  }
  get currentPageShapesSorted() {
    const n = new Set(this.currentPageShapes.sort(ts)),
      r = [];

    function o(s) {
      r.push(s), n.delete(s), n.forEach(i => {
        i.parentId === s.id && o(i)
      })
    }
    return n.forEach(s => {
      const i = this.getShape(s.parentId);
      Ia(i) || o(s)
    }), r
  }
  get currentPageRenderingShapesSorted() {
    return this.renderingShapes.filter(({
      isCulled: n
    }) => !n).sort((n, r) => n.index - r.index).map(({
      shape: n
    }) => n)
  }
  isShapeOfType(n, r) {
    return (typeof n == "string" ? this.getShape(n) : n).type === r
  }
  getShape(n) {
    const r = typeof n == "string" ? n : n.id;
    if (yo(r)) return this.store.get(r)
  }
  getShapeParent(n) {
    const r = typeof n == "string" ? n : n == null ? void 0 : n.id;
    if (!r) return;
    const o = this.getShape(r);
    if (!(o === void 0 || !yo(o.parentId))) return this.store.get(o.parentId)
  }
  getShapeNearestSibling(n, r) {
    return r ? r.parentId === n.parentId ? r : this.findShapeAncestor(r, s => s.parentId === n.parentId) : void 0
  }
  isShapeInPage(n, r = this.currentPageId) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getShape(o);
    if (!s) return !1;
    let i = !1;
    if (s.parentId === r) i = !0;
    else {
      let a = this.getShape(s.parentId);
      e: for (; a;) {
        if (a.parentId === r) {
          i = !0;
          break e
        }
        a = this.getShape(a.parentId)
      }
    }
    return i
  }
  getAncestorPageId(n) {
    const r = typeof n == "string" ? n : n == null ? void 0 : n.id,
      o = r && this.getShape(r);
    if (o) return $r(o.parentId) ? o.parentId : this.getAncestorPageId(this.getShape(o.parentId))
  }
  reparentShapes(n, r, o) {
    const s = typeof n[0] == "string" ? n : n.map(m => m.id),
      i = [],
      a = $r(r) ? Ee.Identity() : this.getShapePageTransform(r),
      c = a.rotation();
    let l = [];
    const u = Fe(this.getSortedChildIdsForParent(r).map(m => this.getShape(m)));
    if (o) {
      const m = u.find(p => p.index === o);
      if (m) {
        const p = u[u.indexOf(m) + 1];
        p ? l = ou(o, p.index, s.length) : l = q0(o, s.length)
      } else {
        const p = u.sort(ts).find(b => b.index > o);
        p ? l = ou(o, p.index, s.length) : l = q0(o, s.length)
      }
    } else {
      const m = u.length && u[u.length - 1];
      l = m ? q0(m.index, s.length) : j3(s.length)
    }
    const d = a.clone().invert(),
      f = Fe(s.map(m => this.getShape(m))),
      h = f.filter(m => m.isLocked);
    h.length && this.updateShapes(h.map(({
      id: m,
      type: p
    }) => ({
      id: m,
      type: p,
      isLocked: !1
    })));
    for (let m = 0; m < f.length; m++) {
      const p = f[m],
        b = this.getShapePageTransform(p);
      if (!b) continue;
      const w = b.point();
      if (!w) continue;
      const v = d.applyToPoint(w),
        _ = b.rotation() - c;
      i.push({
        id: p.id,
        type: p.type,
        parentId: r,
        x: v.x,
        y: v.y,
        rotation: _,
        index: l[m],
        isLocked: p.isLocked
      })
    }
    return this.updateShapes(i), this
  }
  getHighestIndexForParent(n) {
    const r = typeof n == "string" ? n : n.id,
      o = this._parentIdsToChildIds.get()[r];
    if (!o || o.length === 0) return "a1";
    const s = this.getShape(o[o.length - 1]);
    return yi(s.index)
  }
  getSortedChildIdsForParent(n) {
    const r = typeof n == "string" ? n : n.id,
      o = this._parentIdsToChildIds.get()[r];
    return o ? this._childIdsCache.get(o, () => o) : Ns
  }
  visitDescendants(n, r) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getSortedChildIdsForParent(o);
    for (const i of s) r(i) !== !1 && this.visitDescendants(i, r);
    return this
  }
  getShapeAndDescendantIds(n) {
    const r = new Set,
      o = [...n];
    for (; o.length > 0;) {
      const s = o.pop();
      if (!s) break;
      if (!r.has(s)) {
        r.add(s);
        for (const i of this.getSortedChildIdsForParent(s)) o.push(i)
      }
    }
    return r
  }
  getDroppingOverShape(n, r = []) {
    const {
      currentPageShapesSorted: o
    } = this;
    for (let s = o.length - 1; s >= 0; s--) {
      const i = o[s];
      if (!this.getShapeUtil(i).canDropShapes(i, r) || r.find(c => c.id === i.id || this.hasAncestor(i, c.id))) continue;
      const a = this.getShapeMaskedPageBounds(i.id);
      if (a && a.containsPoint(n) && this.getShapeGeometry(i).hitTestPoint(this.getPointInShapeSpace(i, n), 0, !0)) return i
    }
  }
  getOutermostSelectableShape(n, r) {
    const o = typeof n == "string" ? n : n.id,
      s = this.getShape(o);
    let i = s,
      a = s;
    const c = this.getFocusedGroup();
    for (; a;) {
      if (this.isShapeOfType(a, "group") && (c == null ? void 0 : c.id) !== a.id && !this.hasAncestor(c, a.id) && ((r == null ? void 0 : r(a)) ?? !0)) i = a;
      else if ((c == null ? void 0 : c.id) === a.id) break;
      a = this.getShapeParent(a)
    }
    return i
  }
  rotateShapesBy(n, r) {
    if ((typeof n[0] == "string" ? n : n.map(i => i.id)).length <= 0) return this;
    const s = wY({
      editor: this
    });
    return s ? (SY({
      delta: r,
      snapshot: s,
      editor: this,
      stage: "one-off"
    }), this) : this
  }
  nudgeShapes(n, r, o) {
    var a, c;
    const s = typeof n[0] == "string" ? n : n.map(l => l.id);
    if (s.length <= 0) return this;
    const i = [];
    for (const l of s) {
      const u = this.getShape(l);
      if (!u) throw Error(`Could not find a shape with the id ${l}.`);
      const d = T.Cast(r),
        f = this.getShapeParentTransform(u);
      f && d.rot(-f.rotation());
      const h = (c = (a = this.getShapeUtil(u)).onTranslateStart) == null ? void 0 : c.call(a, u);
      i.push(h ? {
        ...h,
        x: u.x + d.x,
        y: u.y + d.y
      } : {
        id: l,
        x: u.x + d.x,
        y: u.y + d.y,
        type: u.type
      })
    }
    return this.updateShapes(i, {
      squashing: !0,
      ...o
    }), this
  }
  duplicateShapes(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(u => u.id);
    if (o.length <= 0) return this;
    const s = new Set(o),
      i = [],
      a = [...o];
    for (; a.length > 0;) {
      const u = a.pop();
      if (!u) break;
      i.push(u), this.getSortedChildIdsForParent(u).forEach(d => a.push(d))
    }
    i.reverse();
    const c = new Map(i.map(u => [u, is()])),
      l = Fe(i.map(u => {
        const d = this.getShape(u);
        if (!d) return null;
        const f = c.get(u);
        let h = 0,
          m = 0;
        if (r && s.has(u)) {
          const E = this.getShapeParentTransform(d),
            k = new T(r.x, r.y).rot(-E.rotation());
          h = k.x, m = k.y
        }
        const p = d.parentId ?? this.currentPageId,
          b = this.getSortedChildIdsForParent(p),
          w = b.indexOf(d.id),
          v = b[w + 1],
          _ = v ? this.getShape(v) : null,
          S = _ ? Ag(d.index, _.index) : yi(d.index);
        let x = Ni(d);
        if (this.isShapeOfType(d, "arrow") && this.isShapeOfType(x, "arrow")) {
          const E = this.getArrowInfo(d);
          let k, C;
          if (d.props.start.type === "binding" && (k = c.get(d.props.start.boundShapeId), !k))
            if (E != null && E.isValid) {
              const {
                x: I,
                y: R
              } = E.start.point;
              x.props.start = {
                type: "point",
                x: I,
                y: R
              }
            } else {
              const {
                start: I
              } = _a(this, d);
              x.props.start = {
                type: "point",
                x: I.x,
                y: I.y
              }
            } if (d.props.end.type === "binding" && (C = c.get(d.props.end.boundShapeId), !C))
            if (E != null && E.isValid) {
              const {
                x: I,
                y: R
              } = E.end.point;
              x.props.end = {
                type: "point",
                x: I,
                y: R
              }
            } else {
              const {
                end: I
              } = _a(this, d);
              x.props.start = {
                type: "point",
                x: I.x,
                y: I.y
              }
            } const $ = ld(x) ? qd(this, x) : Z0(this, x);
          if (E != null && E.isValid && ($ != null && $.isValid) && !ld(d)) {
            const I = T.Med(E.start.handle, E.end.handle),
              R = T.Dist(E.middle, I),
              M = T.Dist($.middle, I);
            x.props.bend < 0 ? x.props.bend += M - R : x.props.bend -= M - R
          }
          x.props.start.type === "binding" && k && (x.props.start.boundShapeId = k), x.props.end.type === "binding" && C && (x.props.end.boundShapeId = C)
        }
        return x = {
          ...x,
          id: f,
          x: d.x + h,
          y: d.y + m,
          index: S
        }, x
      }));
    return l.forEach(u => {
      yo(u.parentId) && c.has(u.parentId) && (u.parentId = c.get(u.parentId))
    }), this.history.batch(() => {
      const u = l.length + this.currentPageShapeIds.size > Qo;
      u && Np(this);
      const d = u ? l.slice(0, Qo - this.currentPageShapeIds.size) : l,
        f = d.map(h => h.id);
      if (this.createShapes(d), this.setSelectedShapes(f), r !== void 0) {
        const h = this.getSelectionPageBounds(),
          {
            viewportPageBounds: m
          } = this;
        h && !m.contains(h) && this.centerOnPoint(h.center, {
          duration: Os
        })
      }
    }), this
  }
  moveShapesToPage(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(c => c.id);
    if (o.length === 0) return this;
    if (this.getInstanceState().isReadonly) return this;
    const {
      currentPageId: s
    } = this;
    if (r === s) return this;
    if (!this.store.has(r)) return this;
    const i = this.getContentFromCurrentPage(o);
    if (!i) return this;
    if (this.getPageShapeIds(r).size + i.shapes.length > Qo) return Np(this, r), this;
    const a = this.getCamera().z;
    return this.history.batch(() => {
      this.deleteShapes(o), this.setCurrentPage(r), this.setFocusedGroup(null), this.selectNone(), this.putContentOntoCurrentPage(i, {
        select: !0,
        preserveIds: !0,
        preservePosition: !0
      }), this.setCamera({
        ...this.getCamera(),
        z: a
      }), this.centerOnPoint(this.getSelectionRotatedPageBounds().center)
    }), this
  }
  toggleLock(n) {
    const r = typeof n[0] == "string" ? n : n.map(a => a.id);
    if (this.getInstanceState().isReadonly || r.length === 0) return this;
    let o = !0,
      s = !0;
    const i = [];
    for (const a of r) {
      const c = this.getShape(a);
      c && (i.push(c), c.isLocked ? s = !1 : o = !1)
    }
    return this.batch(() => {
      s ? (this.updateShapes(i.map(a => ({
        id: a.id,
        type: a.type,
        isLocked: !0
      }))), this.setSelectedShapes([])) : o ? this.updateShapes(i.map(a => ({
        id: a.id,
        type: a.type,
        isLocked: !1
      }))) : this.updateShapes(i.map(a => ({
        id: a.id,
        type: a.type,
        isLocked: !0
      })))
    }), this
  }
  sendToBack(n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id),
      o = Dp(this, "toBack", r);
    return o && this.updateShapes(o), this
  }
  sendBackward(n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id),
      o = Dp(this, "backward", r);
    return o && this.updateShapes(o), this
  }
  bringForward(n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id),
      o = Dp(this, "forward", r);
    return o && this.updateShapes(o), this
  }
  bringToFront(n) {
    const r = typeof n[0] == "string" ? n : n.map(s => s.id),
      o = Dp(this, "toFront", r);
    return o && this.updateShapes(o), this
  }
  flipShapes(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(a => a.id);
    if (this.getInstanceState().isReadonly) return this;
    let s = Fe(o.map(a => this.getShape(a)));
    if (!s.length) return this;
    s = Fe(s.map(a => this.isShapeOfType(a, "group") ? this.getSortedChildIdsForParent(a.id).map(c => this.getShape(c)) : a).flat());
    const i = Be.Common(Fe(s.map(a => this.getShapePageBounds(a)))).center;
    return this.batch(() => {
      for (const a of s) {
        const c = this.getShapeGeometry(a).bounds,
          l = this.getShapePageTransform(a.id);
        l && this.resizeShape(a.id, {
          x: r === "horizontal" ? -1 : 1,
          y: r === "vertical" ? -1 : 1
        }, {
          initialBounds: c,
          initialPageTransform: l,
          initialShape: a,
          mode: "scale_shape",
          scaleOrigin: i,
          scaleAxisRotation: 0
        })
      }
    }), this
  }
  stackShapes(n, r, o) {
    const s = typeof n[0] == "string" ? n : n.map(b => b.id);
    if (this.getInstanceState().isReadonly) return this;
    const i = Fe(s.map(b => this.getShape(b)).filter(b => !(!b || this.isShapeOfType(b, "arrow") && (b.props.start.type === "binding" || b.props.end.type === "binding")))),
      a = i.length;
    if (o === 0 && a < 3 || a < 2) return this;
    const c = Object.fromEntries(i.map(b => [b.id, this.getShapePageBounds(b)]));
    let l, u, d, f;
    r === "horizontal" ? (l = "x", u = "minX", d = "maxX", f = "width") : (l = "y", u = "minY", d = "maxY", f = "height");
    let h;
    if (o === 0) {
      const b = [];
      i.sort((v, _) => c[v.id][u] - c[_.id][u]);
      for (let v = 0; v < a - 1; v++) {
        const _ = i[v],
          S = i[v + 1],
          x = c[_.id],
          k = c[S.id][u] - x[d],
          C = b.find($ => $.gap === k);
        C ? C.count++ : b.push({
          gap: k,
          count: 1
        })
      }
      let w = 0;
      b.forEach(v => {
        v.count > w && (w = v.count, h = v.gap)
      }), w === 1 && (h = Math.max(0, b.reduce((v, _) => v + _.gap * _.count, 0) / (a - 1)))
    } else h = o;
    const m = [];
    let p = c[i[0].id][d];
    return i.forEach((b, w) => {
      var E, k;
      if (w === 0) return;
      const v = {
        x: 0,
        y: 0
      };
      v[l] = p + h - c[b.id][l];
      const _ = this.getShapeParent(b),
        S = _ ? T.Rot(v, -this.getShapePageTransform(_).decompose().rotation) : v,
        x = (k = (E = this.getShapeUtil(b)).onTranslateStart) == null ? void 0 : k.call(E, b);
      m.push(x ? {
        ...x,
        [l]: b[l] + S[l]
      } : {
        id: b.id,
        type: b.type,
        [l]: b[l] + S[l]
      }), p += c[b.id][f] + h
    }), this.updateShapes(m), this
  }
  packShapes(n, r) {
    var k, C;
    const o = typeof n[0] == "string" ? n : n.map($ => $.id);
    if (this.getInstanceState().isReadonly) return this;
    if (o.length < 2) return this;
    const s = Fe(o.map($ => this.getShape($)).filter($ => !(!$ || this.isShapeOfType($, "arrow") && ($.props.start.type === "binding" || $.props.end.type === "binding")))),
      i = {},
      a = {};
    let c, l, u = 0;
    for (let $ = 0; $ < s.length; $++) c = s[$], l = this.getShapePageBounds(c), i[c.id] = l, a[c.id] = l.clone(), u += l.width * l.height;
    const d = Be.Common(Fe(Object.values(i))),
      f = d.width;
    s.sort(($, I) => i[I.id].height - i[$.id].height);
    const h = Math.max(Math.ceil(Math.sqrt(u / .95)), f),
      m = [new Be(d.x, d.y, h, 1 / 0)];
    let p = 0,
      b = 0,
      w, v;
    for (let $ = 0; $ < s.length; $++) {
      c = s[$], l = a[c.id];
      for (let I = m.length - 1; I >= 0; I--)
        if (w = m[I], !(l.width > w.width || l.height > w.height)) {
          l.x = w.x, l.y = w.y, b = Math.max(b, l.maxY), p = Math.max(p, l.maxX), l.width === w.width && l.height === w.height ? (v = m.pop(), I < m.length && (m[I] = v)) : l.height === w.height ? (w.x += l.width + r, w.width -= l.width + r) : l.width === w.width ? (w.y += l.height + r, w.height -= l.height + r) : (m.push(new Be(w.x + (l.width + r), w.y, w.width - (l.width + r), l.height)), w.y += l.height + r, w.height -= l.height + r);
          break
        }
    }
    const _ = Be.Common(Object.values(a)),
      S = T.Sub(d.center, _.center);
    let x;
    const E = [];
    for (let $ = 0; $ < s.length; $++) {
      c = s[$], l = i[c.id], x = a[c.id];
      const I = T.Sub(x.point, l.point).add(S),
        R = this.getShapeParentTransform(c);
      R && I.rot(-R.rotation());
      const M = {
          id: c.id,
          type: c.type,
          x: c.x + I.x,
          y: c.y + I.y
        },
        j = (C = (k = this.getShapeUtil(c)).onTranslateStart) == null ? void 0 : C.call(k, {
          ...c,
          ...M
        });
      j ? E.push({
        ...M,
        ...j
      }) : E.push(M)
    }
    return E.length && this.updateShapes(E), this
  }
  alignShapes(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(l => l.id);
    if (this.getInstanceState().isReadonly) return this;
    if (o.length < 2) return this;
    const s = Fe(o.map(l => this.getShape(l))),
      i = Object.fromEntries(s.map(l => [l.id, this.getShapePageBounds(l)])),
      a = Be.Common(Fe(Object.values(i))),
      c = [];
    return s.forEach(l => {
      var p, b;
      const u = i[l.id];
      if (!u) return;
      const d = {
        x: 0,
        y: 0
      };
      switch (r) {
        case "top": {
          d.y = a.minY - u.minY;
          break
        }
        case "center-vertical": {
          d.y = a.midY - u.minY - u.height / 2;
          break
        }
        case "bottom": {
          d.y = a.maxY - u.minY - u.height;
          break
        }
        case "left": {
          d.x = a.minX - u.minX;
          break
        }
        case "center-horizontal": {
          d.x = a.midX - u.minX - u.width / 2;
          break
        }
        case "right": {
          d.x = a.maxX - u.minX - u.width;
          break
        }
      }
      const f = this.getShapeParent(l),
        h = f ? T.Rot(d, -this.getShapePageTransform(f).decompose().rotation) : d,
        m = (b = (p = this.getShapeUtil(l)).onTranslateStart) == null ? void 0 : b.call(p, l);
      c.push(m ? {
        ...m,
        x: l.x + h.x,
        y: l.y + h.y
      } : {
        id: l.id,
        type: l.type,
        x: l.x + h.x,
        y: l.y + h.y
      })
    }), this.updateShapes(c), this
  }
  distributeShapes(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(_ => _.id);
    if (this.getInstanceState().isReadonly) return this;
    if (o.length < 3) return this;
    const s = o.length,
      i = Fe(o.map(_ => this.getShape(_))),
      a = Object.fromEntries(i.map(_ => [_.id, this.getShapePageBounds(_)]));
    let c, l, u, d, f;
    r === "horizontal" ? (c = "x", l = "minX", u = "maxX", d = "midX", f = "width") : (c = "y", l = "minY", u = "maxY", d = "midY", f = "height");
    const h = [],
      m = i.sort((_, S) => a[_.id][l] - a[S.id][l])[0],
      p = i.sort((_, S) => a[S.id][u] - a[_.id][u])[0],
      b = a[m.id][d],
      w = (a[p.id][d] - b) / (s - 1),
      v = b + w;
    return i.filter(_ => _ !== m && _ !== p).sort((_, S) => a[_.id][d] - a[S.id][d]).forEach((_, S) => {
      var $, I;
      const x = {
        x: 0,
        y: 0
      };
      x[c] = v + w * S - a[_.id][f] / 2 - a[_.id][c];
      const E = this.getShapeParent(_),
        k = E ? T.Rot(x, -this.getShapePageTransform(E).rotation()) : x,
        C = (I = ($ = this.getShapeUtil(_)).onTranslateStart) == null ? void 0 : I.call($, _);
      h.push(C ? {
        ...C,
        [c]: _[c] + k[c]
      } : {
        id: _.id,
        type: _.type,
        [c]: _[c] + k[c]
      })
    }), this.updateShapes(h), this
  }
  stretchShapes(n, r) {
    const o = typeof n[0] == "string" ? n : n.map(l => l.id);
    if (this.getInstanceState().isReadonly) return this;
    if (o.length < 2) return this;
    const s = Fe(o.map(l => this.getShape(l))),
      i = Object.fromEntries(o.map(l => [l, this.getShapeGeometry(l).bounds])),
      a = Object.fromEntries(o.map(l => [l, this.getShapePageBounds(l)])),
      c = Be.Common(Fe(Object.values(a)));
    switch (r) {
      case "vertical": {
        this.batch(() => {
          for (const l of s) {
            if (this.getShapePageTransform(l).rotation() % Rt) continue;
            const d = i[l.id],
              f = a[l.id],
              h = new T(0, c.minY - f.minY),
              m = this.getShapeParentTransform(l);
            m && h.rot(-m.rotation());
            const {
              x: p,
              y: b
            } = T.Add(h, l);
            this.updateShapes([{
              id: l.id,
              type: l.type,
              x: p,
              y: b
            }], {
              squashing: !0
            });
            const w = new T(1, c.height / f.height);
            this.resizeShape(l.id, w, {
              initialBounds: d,
              scaleOrigin: new T(f.center.x, c.minY),
              scaleAxisRotation: 0
            })
          }
        });
        break
      }
      case "horizontal": {
        this.batch(() => {
          for (const l of s) {
            const u = i[l.id],
              d = a[l.id];
            if (this.getShapePageTransform(l).rotation() % Rt) continue;
            const h = new T(c.minX - d.minX, 0),
              m = this.getShapeParentTransform(l);
            m && h.rot(-m.rotation());
            const {
              x: p,
              y: b
            } = T.Add(h, l);
            this.updateShapes([{
              id: l.id,
              type: l.type,
              x: p,
              y: b
            }], {
              squashing: !0
            });
            const w = new T(c.width / d.width, 1);
            this.resizeShape(l.id, w, {
              initialBounds: u,
              scaleOrigin: new T(c.minX, d.center.y),
              scaleAxisRotation: 0
            })
          }
        });
        break
      }
    }
    return this
  }
  resizeShape(n, r, o = {}) {
    var h;
    const s = typeof n == "string" ? n : n.id;
    if (this.getInstanceState().isReadonly) return this;
    Number.isFinite(r.x) || (r = new T(1, r.y)), Number.isFinite(r.y) || (r = new T(r.x, 1));
    const i = o.initialShape ?? this.getShape(s);
    if (!i) return this;
    const a = o.scaleOrigin ?? ((h = this.getShapePageBounds(s)) == null ? void 0 : h.center);
    if (!a) return this;
    const c = o.initialPageTransform ? Ee.Cast(o.initialPageTransform) : this.getShapePageTransform(s);
    if (!c) return this;
    const l = c.rotation();
    if (l == null) return this;
    const u = o.scaleAxisRotation ?? l,
      d = o.initialBounds ?? this.getShapeGeometry(s).bounds;
    if (!d) return this;
    if (!dV(l, u)) return this._resizeUnalignedShape(s, r, {
      ...o,
      initialBounds: d,
      scaleOrigin: a,
      scaleAxisRotation: u,
      initialPageTransform: c,
      initialShape: i
    });
    const f = this.getShapeUtil(i);
    if (f.isAspectRatioLocked(i) && (Math.abs(r.x) > Math.abs(r.y) ? r = new T(r.x, Math.sign(r.y) * Math.abs(r.x)) : r = new T(Math.sign(r.x) * Math.abs(r.y), r.y)), f.onResize && f.canResize(i)) {
      const m = this._scalePagePoint(Ee.applyToPoint(c, new T(0, 0)), a, r, u),
        p = this.getPointInParentSpace(i.id, m),
        b = new T(r.x, r.y),
        w = Gd((l - u) % Math.PI, 0);
      b.x = w ? r.x : r.y, b.y = w ? r.y : r.x;
      const v = Ee.applyToPoint(c, new T),
        {
          x: _,
          y: S
        } = this.getPointInParentSpace(i.id, v);
      this.updateShapes([{
        id: s,
        type: i.type,
        x: p.x,
        y: p.y,
        ...f.onResize({
          ...i,
          x: _,
          y: S
        }, {
          newPoint: p,
          handle: o.dragHandle ?? "bottom_right",
          mode: o.mode ?? "scale_shape",
          scaleX: b.x,
          scaleY: b.y,
          initialBounds: d,
          initialShape: i
        })
      }], {
        squashing: !0
      })
    } else {
      const m = Ee.applyToPoint(c, d.center),
        p = this._scalePagePoint(m, a, r, u),
        b = this.getPointInParentSpace(i.id, m),
        w = this.getPointInParentSpace(i.id, p),
        v = T.Sub(w, b);
      this.updateShapes([{
        id: s,
        type: i.type,
        x: i.x + v.x,
        y: i.y + v.y
      }], {
        squashing: !0
      })
    }
    return this
  }
  _scalePagePoint(n, r, o, s) {
    const i = T.RotWith(n, r, -s).sub(r),
      a = T.MulV(i, o);
    return T.Add(a, r).rotWith(r, s)
  }
  _resizeUnalignedShape(n, r, o) {
    const {
      type: s
    } = o.initialShape, i = new T(r.x, r.y);
    if (Math.abs(r.x) > Math.abs(r.y) ? i.x = Math.sign(r.x) * Math.abs(r.y) : i.y = Math.sign(r.y) * Math.abs(r.x), this.resizeShape(n, i, {
        initialShape: o.initialShape,
        initialBounds: o.initialBounds
      }), Math.sign(r.x) * Math.sign(r.y) < 0) {
      let {
        rotation: w
      } = Ee.Decompose(o.initialPageTransform);
      w -= 2 * w, this.updateShapes([{
        id: n,
        type: s,
        rotation: w
      }], {
        squashing: !0
      })
    }
    const a = Ee.applyToPoint(o.initialPageTransform, o.initialBounds.center),
      c = this._scalePagePoint(a, o.scaleOrigin, r, o.scaleAxisRotation),
      l = this.getShapePageBounds(n),
      u = this.getShapePageTransform(n),
      d = l.center,
      f = u.point();
    if (!d || !f) return this;
    const h = T.Sub(c, d),
      m = T.Add(f, h),
      {
        x: p,
        y: b
      } = this.getPointInParentSpace(n, m);
    return this.updateShapes([{
      id: n,
      type: s,
      x: p,
      y: b
    }], {
      squashing: !0
    }), this
  }
  getInitialMetaForShape(n) {
    return {}
  }
  createShape(n) {
    return this._createShapes([n]), this
  }
  createShapes(n) {
    if (!Array.isArray(n)) throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    return this._createShapes(n), this
  }
  animateShape(n, r) {
    return this.animateShapes([n], r)
  }
  animateShapes(n, r = {}) {
    const {
      duration: o = 500,
      easing: s = Vi.linear
    } = r, i = It();
    let a = o,
      c;
    const l = [];
    n.forEach(f => {
      if (!f) return;
      const h = {
          partial: f,
          values: []
        },
        m = this.getShape(f.id);
      if (m) {
        for (const p of ["x", "y", "rotation"]) f[p] !== void 0 && m[p] !== f[p] && h.values.push({
          prop: p,
          from: m[p],
          to: f[p]
        });
        l.push(h), this.animatingShapes.set(m.id, i)
      }
    });
    let u;
    const d = f => {
      if (a -= f, a < 0) {
        const {
          animatingShapes: m
        } = this, p = n.filter(b => b && m.get(b.id) === i);
        p.length && this.updateShapes(p, {
          squashing: !1
        }), this.removeListener("tick", d);
        return
      }
      c = s(1 - a / o);
      const {
        animatingShapes: h
      } = this;
      try {
        const m = [];
        for (let p = 0; p < l.length; p++) u = l[p], h.get(u.partial.id) === i && m.push({
          id: u.partial.id,
          type: u.partial.type,
          ...u.values.reduce((b, {
            prop: w,
            from: v,
            to: _
          }) => (b[w] = v + (_ - v) * c, b), {})
        });
        this._updateShapes(m, {
          squashing: !0
        })
      } catch {}
    };
    return this.addListener("tick", d), this
  }
  groupShapes(n, r = is()) {
    var h;
    if (!Array.isArray(n)) throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    if (this.getInstanceState().isReadonly) return this;
    const o = typeof n[0] == "string" ? n : n.map(m => m.id);
    if (o.length <= 1) return this;
    const s = Fe(this._getUnlockedShapeIds(o).map(m => this.getShape(m))),
      i = s.sort(ts).map(m => m.id),
      a = Be.Common(Fe(s.map(m => this.getShapePageBounds(m)))),
      {
        x: c,
        y: l
      } = a.point,
      u = this.findCommonAncestor(s) ?? this.currentPageId;
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const d = s.filter(m => m.parentId === u).sort(ts),
      f = (h = d[d.length - 1]) == null ? void 0 : h.index;
    return this.batch(() => {
      this.createShapes([{
        id: r,
        type: "group",
        parentId: u,
        index: f,
        x: c,
        y: l,
        opacity: 1,
        props: {}
      }]), this.reparentShapes(i, r), this.select(r)
    }), this
  }
  ungroupShapes(n) {
    const r = typeof n[0] == "string" ? n : n.map(a => a.id);
    if (this.getInstanceState().isReadonly) return this;
    if (r.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const o = new Set,
      s = Fe(r.map(a => this.getShape(a))),
      i = [];
    return s.forEach(a => {
      this.isShapeOfType(a, "group") ? i.push(a) : o.add(a.id)
    }), i.length === 0 ? this : (this.batch(() => {
      let a;
      for (let c = 0, l = i.length; c < l; c++) {
        a = i[c];
        const u = this.getSortedChildIdsForParent(a.id);
        for (let d = 0, f = u.length; d < f; d++) o.add(u[d]);
        this.reparentShapes(u, a.parentId, a.index)
      }
      this.deleteShapes(i.map(c => c.id)), this.select(...o)
    }), this)
  }
  updateShape(n, r) {
    return this.updateShapes([n], r), this
  }
  updateShapes(n, r) {
    let o = Fe(n);
    return this.animatingShapes.size > 0 && o.forEach(s => this.animatingShapes.delete(s.id)), o = o.filter(s => {
      const i = this.getShape(s.id);
      return !(!i || this.isShapeOrAncestorLocked(i) && !Object.hasOwn(s, "isLocked"))
    }), this._updateShapes(o, r), this
  }
  _getUnlockedShapeIds(n) {
    return n.filter(r => {
      var o;
      return !((o = this.getShape(r)) != null && o.isLocked)
    })
  }
  deleteShapes(n) {
    if (!Array.isArray(n)) throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    return this._deleteShapes(this._getUnlockedShapeIds(typeof n[0] == "string" ? n : n.map(r => r.id))), this
  }
  deleteShape(n) {
    return this.deleteShapes([typeof n == "string" ? n : n.id]), this
  }
  _extractSharedStyles(n, r) {
    if (this.isShapeOfType(n, "group")) {
      const o = this._parentIdsToChildIds.get()[n.id];
      if (!o) return;
      for (let s = 0, i = o.length; s < i; s++) this._extractSharedStyles(this.getShape(o[s]), r)
    } else
      for (const [o, s] of this.styleProps[n.type]) r.applyValue(o, Da(n.props, s))
  }
  getStyleForNextShape(n) {
    const r = this.getInstanceState().stylesForNextShape[n.id];
    return r === void 0 ? n.defaultValue : r
  }
  getShapeStyleIfExists(n, r) {
    const o = this.styleProps[n.type].get(r);
    if (o !== void 0) return Da(n.props, o)
  }
  get sharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) return this._selectionSharedStyles.get();
    const n = this.root.current.get(),
      r = new HS;
    if (n.shapeType)
      for (const o of this.styleProps[n.shapeType].keys()) r.applyValue(o, this.getStyleForNextShape(o));
    return r
  }
  get sharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const n = [],
        r = s => {
          const i = this.getShape(s);
          if (i)
            if (this.isShapeOfType(i, "group"))
              for (const a of this.getSortedChildIdsForParent(i.id)) r(a);
            else n.push(i)
        };
      for (const s of this.getSelectedShapeIds()) r(s);
      let o = null;
      for (const s of n)
        if (o === null) o = s.opacity;
        else if (o !== s.opacity) return {
        type: "mixed"
      };
      if (o !== null) return {
        type: "shared",
        value: o
      }
    }
    return {
      type: "shared",
      value: this.getInstanceState().opacityForNextShape
    }
  }
  setOpacityForNextShapes(n, r) {
    return this.updateInstanceState({
      opacityForNextShape: n
    }, r), this
  }
  setOpacityForSelectedShapes(n, r) {
    const o = this.getSelectedShapes();
    if (o.length > 0) {
      const s = [],
        i = a => {
          if (this.isShapeOfType(a, "group")) {
            const c = this.getSortedChildIdsForParent(a);
            for (const l of c) i(this.getShape(l))
          } else s.push(a)
        };
      for (const a of o) i(a);
      this.updateShapes(s.map(a => ({
        id: a.id,
        type: a.type,
        opacity: n
      })), r)
    }
    return this
  }
  setStyleForNextShapes(n, r, o) {
    const s = this.getInstanceState().stylesForNextShape;
    return this.updateInstanceState({
      stylesForNextShape: {
        ...s,
        [n.id]: r
      }
    }, o), this
  }
  setStyleForSelectedShapes(n, r, o) {
    const s = this.getSelectedShapes();
    if (s.length > 0) {
      const i = [],
        a = c => {
          if (this.isShapeOfType(c, "group")) {
            const l = this.getSortedChildIdsForParent(c.id);
            for (const u of l) a(this.getShape(u))
          } else {
            const l = this.getShapeUtil(c),
              u = this.styleProps[c.type].get(n);
            if (u) {
              const d = {
                id: c.id,
                type: c.type,
                props: {
                  [u]: r
                }
              };
              i.push({
                util: l,
                originalShape: c,
                updatePartial: d
              })
            }
          }
        };
      for (const c of s) a(c);
      this.updateShapes(i.map(({
        updatePartial: c
      }) => c), o)
    }
    return this
  }
  registerExternalAssetHandler(n, r) {
    return this.externalAssetContentHandlers[n] = r, this
  }
  async getAssetForExternalContent(n) {
    var r, o;
    return await ((o = (r = this.externalAssetContentHandlers)[n.type]) == null ? void 0 : o.call(r, n))
  }
  registerExternalContentHandler(n, r) {
    return this.externalContentHandlers[n] = r, this
  }
  async putExternalContent(n) {
    var r, o;
    return (o = (r = this.externalContentHandlers)[n.type]) == null ? void 0 : o.call(r, n)
  }
  getContentFromCurrentPage(n) {
    const r = typeof n[0] == "string" ? n : n.map(c => c.id);
    if (!r || r.length === 0) return;
    const o = {};
    let s = xm(r.map(c => this.getShape(c)).sort(ts).flatMap(c => {
      const l = [c];
      return this.visitDescendants(c.id, u => {
        l.push(this.getShape(u))
      }), l
    }));
    s = s.map(c => {
      if (o[c.id] = this.getShapePageTransform(c.id), c = Na(c), this.isShapeOfType(c, "arrow")) {
        const l = c.props.start.type === "binding" ? c.props.start.boundShapeId : void 0,
          u = c.props.end.type === "binding" ? c.props.end.boundShapeId : void 0,
          d = this.getArrowInfo(c);
        if (c.props.start.type === "binding" && !s.some(h => h.id === l))
          if (d != null && d.isValid) {
            const {
              x: h,
              y: m
            } = d.start.point;
            c.props.start = {
              type: "point",
              x: h,
              y: m
            }
          } else {
            const {
              start: h
            } = _a(this, c);
            c.props.start = {
              type: "point",
              x: h.x,
              y: h.y
            }
          } if (c.props.end.type === "binding" && !s.some(h => h.id === u))
          if (d != null && d.isValid) {
            const {
              x: h,
              y: m
            } = d.end.point;
            c.props.end = {
              type: "point",
              x: h,
              y: m
            }
          } else {
            const {
              end: h
            } = _a(this, c);
            c.props.end = {
              type: "point",
              x: h.x,
              y: h.y
            }
          } const f = ld(c) ? qd(this, c) : Z0(this, c);
        if (d != null && d.isValid && (f != null && f.isValid) && !ld(c)) {
          const h = T.Med(d.start.handle, d.end.handle),
            m = T.Dist(d.middle, h),
            p = T.Dist(f.middle, h);
          c.props.bend < 0 ? c.props.bend += p - m : c.props.bend -= p - m
        }
        return c
      }
      return c
    });
    const i = [];
    s.forEach(c => {
      if (s.find(l => l.id === c.parentId) === void 0) {
        const l = this.getShapePageTransform(c.id),
          u = l.point(),
          d = l.rotation();
        c.x = u.x, c.y = u.y, c.rotation = d, c.parentId = this.currentPageId, i.push(c.id)
      }
    });
    const a = new Set;
    return s.forEach(c => {
      "assetId" in c.props && c.props.assetId !== null && a.add(c.props.assetId)
    }), {
      shapes: s,
      rootShapeIds: i,
      schema: this.store.schema.serialize(),
      assets: Fe(Array.from(a).map(c => this.getAsset(c)))
    }
  }
  putContentOntoCurrentPage(n, r = {}) {
    if (this.getInstanceState().isReadonly) return this;
    if (!n.schema) throw Error(`Could not put content:
content is missing a schema.`);
    const {
      select: o = !1,
      preserveIds: s = !1,
      preservePosition: i = !1
    } = r;
    let {
      point: a = void 0
    } = r;
    const {
      currentPageId: c
    } = this, {
      assets: l,
      shapes: u,
      rootShapeIds: d
    } = n, f = new Map(u.map(x => [x.id, is()]));
    let h = this.currentPageId,
      m = 1 / 0,
      p = [];
    for (const x of this.getSelectedShapes()) {
      if (m === 0) break;
      const E = this.isShapeOfType(x, "frame"),
        k = this.getShapeAncestors(x);
      E && k.push(x);
      const C = E ? k.length + 1 : k.length;
      if (C < m) m = C, p = k, h = E ? x.id : x.parentId;
      else if (C === m) {
        if (p.length !== k.length) throw Error(`Ancestors: ${p.length} !== ${k.length}`);
        if (p.length === 0) {
          h = c;
          break
        } else {
          h = c;
          for (let $ = 0; $ < p.length && k[$] === p[$]; $++) h = k[$].id
        }
      }
    }
    let b = !1;
    if (!$r(h)) {
      const x = this.getShape(h);
      if (x) {
        if (!this.viewportPageBounds.includes(this.getShapePageBounds(x))) h = c;
        else if (d.length === 1) {
          const E = u.find(k => k.id === d[0]);
          this.isShapeOfType(x, "frame") && this.isShapeOfType(E, "frame") && E.props.w === (x == null ? void 0 : x.props.w) && E.props.h === (x == null ? void 0 : x.props.h) && (b = !0)
        }
      } else h = c
    }
    b || (b = f.has(h)), b && (h = this.getShape(h).parentId);
    let w = this.getHighestIndexForParent(h);
    const v = [],
      _ = u.map(x => {
        let E;
        if (s) E = Ni(x), f.set(x.id, x.id);
        else {
          const k = f.get(x.id);
          E = Ni({
            ...x,
            id: k
          })
        }
        if (d.includes(x.id) && (E.parentId = c, v.push(E)), f.has(E.parentId) ? E.parentId = f.get(x.parentId) : (d.push(E.id), E.index = w, w = yi(w)), this.isShapeOfType(E, "arrow")) {
          if (E.props.start.type === "binding") {
            const k = f.get(E.props.start.boundShapeId);
            E.props.start = k ? {
              ...E.props.start,
              boundShapeId: k
            } : {
              type: "point",
              x: 0,
              y: 0
            }
          }
          if (E.props.end.type === "binding") {
            const k = f.get(E.props.end.boundShapeId);
            E.props.end = k ? {
              ...E.props.end,
              boundShapeId: k
            } : {
              type: "point",
              x: 0,
              y: 0
            }
          }
        }
        return E
      });
    if (_.length + this.currentPageShapeIds.size > Qo) return Np(this), this;
    let S = [];
    if (l) {
      for (let E = 0; E < l.length; E++) {
        const k = l[E],
          C = this.store.schema.migratePersistedRecord(k, n.schema);
        if (C.type === "success") l[E] = C.value;
        else throw Error(`Could not put content:
could not migrate content for asset:
${k.id}
${k.type}
reason:${C.reason}`)
      }
      const x = [];
      S = l.filter(E => !this.store.has(E.id)).map(E => {
        var k;
        return (E.type === "image" || E.type === "video") && (E.props.src && ((k = E.props.src) != null && k.startsWith("data:image")) ? (x.push(Na(E)), E.props.src = null) : x.push(Na(E))), E
      }), Promise.allSettled(x.map(async E => {
        const k = await dY(E.props.src, E.props.name, E.props.mimeType ?? "image/png"),
          C = await this.getAssetForExternalContent({
            type: "file",
            file: k
          });
        return C ? [E, C] : null
      })).then(E => {
        this.updateAssets(Fe(E.map(k => k.status === "fulfilled" && k.value ? {
          ...k.value[1],
          id: k.value[0].id
        } : void 0)))
      })
    }
    for (let x = 0; x < _.length; x++) {
      const E = _[x],
        k = this.store.schema.migratePersistedRecord(E, n.schema);
      if (k.type === "success") _[x] = k.value;
      else throw Error(`Could not put content:
could not migrate content for shape:
${E.id}, ${E.type}
reason:${k.reason}`)
    }
    return this.batch(() => {
      S.length > 0 && this.createAssets(S), this.createShapes(_), o && this.select(...v.map($ => $.id)), h !== c && this.reparentShapes(v.map($ => $.id), h);
      const x = _.map($ => this.getShape($.id)),
        E = Be.Common(x.map($ => this.getShapePageBounds($)));
      if (a === void 0)
        if ($r(h)) {
          const {
            viewportPageBounds: $
          } = this;
          i || $.includes(Be.From(E)) ? a = E.center : a = $.center
        } else {
          const $ = this.getShape(h);
          a = Ee.applyToPoint(this.getShapePageTransform($), this.getShapeGeometry($).bounds.center)
        } if (v.length === 1) {
        const $ = v[0];
        if (this.isShapeOfType($, "frame"))
          for (; this.getShapesAtPoint(a).some(I => this.isShapeOfType(I, "frame") && I.props.w === $.props.w && I.props.h === $.props.h);) a.x += E.w + 16
      }
      const k = Be.Common(Fe(v.map(({
          id: $
        }) => this.getShapePageBounds($)))).center,
        C = T.Sub(a, k);
      this.updateShapes(v.map(({
        id: $
      }) => {
        const I = this.getShape($),
          R = this.getShapeParentTransform($).decompose().rotation,
          M = T.Rot(C, -R);
        return {
          id: I.id,
          type: I.type,
          x: I.x + M.x,
          y: I.y + M.y
        }
      }))
    }), this
  }
  async getSvg(n, r = {}) {
    var x, E;
    const o = typeof n[0] == "string" ? n : n.map(k => k.id);
    if (o.length === 0) return;
    if (!window.document) throw Error("No document");
    const {
      scale: s = 1,
      background: i = !1,
      padding: a = kV,
      preserveAspectRatio: c = !1
    } = r, l = wh({
      isDarkMode: this.user.isDarkMode
    }), u = this.getShapeAndDescendantIds(o), d = this.getUnorderedRenderingShapes(!1).filter(({
      id: k
    }) => u.has(k));
    let f = null;
    for (const {
        maskedPageBounds: k
      }
      of d) k && (f ? f.union(k) : f = k.clone());
    if (!f) return;
    const h = o.length === 1 && this.isShapeOfType(this.getShape(o[0]), "frame") ? o[0] : null;
    h || f.expandBy(a);
    const m = f.width * s,
      p = f.height * s,
      b = window.document.createElementNS("http://www.w3.org/2000/svg", "svg");
    c && b.setAttribute("preserveAspectRatio", c), b.setAttribute("direction", "ltr"), b.setAttribute("width", m + ""), b.setAttribute("height", p + ""), b.setAttribute("viewBox", `${f.minX} ${f.minY} ${f.width} ${f.height}`), b.setAttribute("stroke-linecap", "round"), b.setAttribute("stroke-linejoin", "round"), i ? h ? b.style.setProperty("background", l.solid) : b.style.setProperty("background-color", l.background) : b.style.setProperty("background-color", "transparent");
    try {
      (E = (x = document.body).focus) == null || E.call(x)
    } catch {}
    const w = window.document.createElementNS("http://www.w3.org/2000/svg", "defs");
    b.append(w);
    const v = new Map,
      _ = {
        addExportDef: k => {
          if (v.has(k.key)) return;
          const C = (async () => {
            const $ = await k.getElement();
            if (!$) return;
            const I = document.createComment(`def: ${k.key}`);
            w.appendChild(I);
            for (const R of Array.isArray($) ? $ : [$]) w.appendChild(R)
          })();
          v.set(k.key, C)
        }
      },
      S = (await Promise.all(d.map(async ({
        id: k,
        opacity: C,
        index: $,
        backgroundIndex: I
      }) => {
        var F, B;
        if (k === h) return [];
        const R = this.getShape(k);
        if (this.isShapeOfType(R, "group")) return [];
        const M = this.getShapeUtil(R);
        let j = await ((F = M.toSvg) == null ? void 0 : F.call(M, R, _)),
          A = await ((B = M.toBackgroundSvg) == null ? void 0 : B.call(M, R, _));
        if (j) {
          const V = document.createElementNS("http://www.w3.org/2000/svg", "g");
          V.appendChild(j), j = V
        }
        if (A) {
          const V = document.createElementNS("http://www.w3.org/2000/svg", "g");
          V.appendChild(A), A = V
        }
        if (!j && !A) {
          const V = this.getShapePageBounds(R),
            J = window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
          J.setAttribute("width", V.width + ""), J.setAttribute("height", V.height + ""), J.setAttribute("fill", l.solid), J.setAttribute("stroke", l.grey.pattern), J.setAttribute("stroke-width", "1"), j = J
        }
        let D = this.getShapePageTransform(R).toCssString();
        "scale" in R.props && R.props.scale !== 1 && (D = `${D} scale(${R.props.scale}, ${R.props.scale})`), j == null || j.setAttribute("transform", D), A == null || A.setAttribute("transform", D), j == null || j.setAttribute("opacity", C + ""), A == null || A.setAttribute("opacity", C + "");
        const N = this.getShapeMask(R.id);
        if (N) {
          const V = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
          w.appendChild(V);
          const J = It();
          V.id = J;
          const ee = document.createElementNS("http://www.w3.org/2000/svg", "path");
          if (ee.setAttribute("d", `M${N.map(({x:ye,y:ge})=>`
              $ {
                ye
              }, $ {
                ge
              }
              `).join("L")}Z`), V.appendChild(ee), j) {
            const ye = document.createElementNS("http://www.w3.org/2000/svg", "g");
            ye.setAttribute("clip-path", `url(#${J})`), ye.appendChild(j), j = ye
          }
          if (A) {
            const ye = document.createElementNS("http://www.w3.org/2000/svg", "g");
            ye.setAttribute("clip-path", `url(#${J})`), ye.appendChild(A), A = ye
          }
        }
        const q = [];
        return j && q.push({
          zIndex: $,
          element: j
        }), A && q.push({
          zIndex: I,
          element: A
        }), q
      }))).flat();
    await Promise.all(v.values());
    for (const {
        element: k
      }
      of S.sort((C, $) => C.zIndex - $.zIndex)) b.appendChild(k);
    return b
  }
  _updateInputsFromEvent(n) {
    var m;
    const {
      previousScreenPoint: r,
      previousPagePoint: o,
      currentScreenPoint: s,
      currentPagePoint: i
    } = this.inputs, {
      screenBounds: a
    } = this.store.unsafeGetWithoutCapture(er), {
      x: c,
      y: l,
      z: u
    } = n.point, {
      x: d,
      y: f,
      z: h
    } = this.getCamera();
    r.setTo(s), o.setTo(i), s.set(c, l), i.set((c - a.x) / h - d, (l - a.y) / h - f, u ?? .5), this.inputs.isPen = n.type === "pointer" && n.isPen, n.name === "pointer_down" && this.inputs.pointerVelocity.set(0, 0), this.store.put([{
      id: Cm,
      typeName: "pointer",
      x: i.x,
      y: i.y,
      lastActivityTimestamp: n.type === "pointer" && n.pointerId === GP.CAMERA_MOVE ? ((m = this.store.get(Cm)) == null ? void 0 : m.lastActivityTimestamp) ?? Date.now() : Date.now(),
      meta: {}
    }])
  }
  cancel() {
    return this.dispatch({
      type: "misc",
      name: "cancel"
    }), this
  }
  interrupt() {
    return this.dispatch({
      type: "misc",
      name: "interrupt"
    }), this
  }
  complete() {
    return this.dispatch({
      type: "misc",
      name: "complete"
    }), this
  }
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout()
  }
}
we([Q], ve.prototype, "getCanUndo", 1);
we([Q], ve.prototype, "getCanRedo", 1);
we([Q], ve.prototype, "_arrowBindingsIndex", 1);
we([Q], ve.prototype, "arrowInfoCache", 1);
we([Q], ve.prototype, "getCurrentTool", 1);
we([Q], ve.prototype, "getCurrentToolId", 1);
we([Q], ve.prototype, "getDocumentSettings", 1);
we([Q], ve.prototype, "getInstanceState", 1);
we([Q], ve.prototype, "getOpenMenus", 1);
we([Q], ve.prototype, "getIsMenuOpen", 1);
we([Q], ve.prototype, "getPageStates", 1);
we([Q], ve.prototype, "_getPageStatesQuery", 1);
we([Q], ve.prototype, "getCurrentPageState", 1);
we([Q], ve.prototype, "_getCurrentPageStateId", 1);
we([Q], ve.prototype, "getSelectedShapeIds", 1);
we([Q], ve.prototype, "getSelectedShapes", 1);
we([Q], ve.prototype, "getOnlySelectedShape", 1);
we([Q], ve.prototype, "getSelectionPageBounds", 1);
we([Q], ve.prototype, "getSelectionRotation", 1);
we([Q], ve.prototype, "getSelectionRotatedPageBounds", 1);
we([Q], ve.prototype, "getFocusedGroupId", 1);
we([Q], ve.prototype, "getFocusedGroup", 1);
we([Q], ve.prototype, "getEditingShapeId", 1);
we([Q], ve.prototype, "getEditingShape", 1);
we([Q], ve.prototype, "getHoveredShapeId", 1);
we([Q], ve.prototype, "getHoveredShape", 1);
we([Q], ve.prototype, "getHintingShapeIds", 1);
we([Q], ve.prototype, "getHintingShape", 1);
we([Q], ve.prototype, "getErasingShapeIds", 1);
we([Q], ve.prototype, "getErasingShapes", 1);
we([Q], ve.prototype, "getCameraId", 1);
we([Q], ve.prototype, "getCamera", 1);
we([Q], ve.prototype, "zoomLevel", 1);
we([Q], ve.prototype, "viewportScreenBounds", 1);
we([Q], ve.prototype, "viewportScreenCenter", 1);
we([Q], ve.prototype, "viewportPageBounds", 1);
we([Q], ve.prototype, "viewportPageCenter", 1);
we([Q], ve.prototype, "cameraState", 1);
we([Q], ve.prototype, "renderingShapes", 1);
we([Q], ve.prototype, "renderingBounds", 1);
we([Q], ve.prototype, "renderingBoundsExpanded", 1);
we([Q], ve.prototype, "_pages", 1);
we([Q], ve.prototype, "pages", 1);
we([Q], ve.prototype, "_assets", 1);
we([Q], ve.prototype, "_shapeGeometryCache", 1);
we([Q], ve.prototype, "_shapeOutlineSegmentsCache", 1);
we([Q], ve.prototype, "_shapeHandlesCache", 1);
we([Q], ve.prototype, "_shapePageTransformCache", 1);
we([Q], ve.prototype, "_shapePageBoundsCache", 1);
we([Q], ve.prototype, "_shapeClipPathCache", 1);
we([Q], ve.prototype, "_shapeMaskCache", 1);
we([Q], ve.prototype, "currentPageBounds", 1);
we([Q], ve.prototype, "currentPageShapes", 1);
we([Q], ve.prototype, "currentPageShapesSorted", 1);
we([Q], ve.prototype, "currentPageRenderingShapesSorted", 1);
we([Q({
  isEqual: (t, e) => t.equals(e)
})], ve.prototype, "sharedStyles", 1);
we([Q], ve.prototype, "sharedOpacity", 1);

function Np(t, e = t.currentPageId) {
  const n = t.getPage(e).name;
  t.emit("max-shapes", {
    name: n,
    pageId: e,
    count: Qo
  })
}

function sv() {
  const t = Y();
  return te("isDarkMode", () => t.user.isDarkMode, [t])
}
const XY = '<path d="m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" fill="white"/><path d="m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" fill="white"/><path d="m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" fill="black"/><path d="m13 10.814v11.188l2.969-2.866.428-.139h4.768z" fill="black"/>',
  ZY = '<path d="m13.3315 21.3799c-.284-.359-.629-1.093-1.243-1.984-.348-.504-1.211-1.453-1.468-1.935-.223-.426-.199-.617-.146-.97.094-.628.738-1.117 1.425-1.051.519.049.959.392 1.355.716.239.195.533.574.71.788.163.196.203.277.377.509.23.307.302.459.214.121-.071-.496-.187-1.343-.355-2.092-.128-.568-.159-.657-.281-1.093-.129-.464-.195-.789-.316-1.281-.084-.348-.235-1.059-.276-1.459-.057-.547-.087-1.439.264-1.849.275-.321.906-.418 1.297-.22.512.259.803 1.003.936 1.3.239.534.387 1.151.516 1.961.164 1.031.466 2.462.476 2.763.024-.369-.068-1.146-.004-1.5.058-.321.328-.694.666-.795.286-.085.621-.116.916-.055.313.064.643.288.766.499.362.624.369 1.899.384 1.831.086-.376.071-1.229.284-1.584.14-.234.497-.445.687-.479.294-.052.655-.068.964-.008.249.049.586.345.677.487.218.344.342 1.317.379 1.658.015.141.074-.392.293-.736.406-.639 1.843-.763 1.898.639.025.654.02.624.02 1.064 0 .517-.012.828-.04 1.202-.031.4-.117 1.304-.242 1.742-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.191 1.813-.118.562-.079.566-.102.965-.023.398.121.922.121.922s-.802.104-1.234.035c-.391-.063-.875-.841-1-1.079-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.031-3.139.02 0 0 .185-1.011-.227-1.358-.305-.259-.83-.784-1.144-1.06z" fill="white"/><g stroke="black" stroke-linecap="round" stroke-width=".75"><path d="m13.3315 21.3799c-.284-.359-.629-1.093-1.243-1.984-.348-.504-1.211-1.453-1.468-1.935-.223-.426-.199-.617-.146-.97.094-.628.738-1.117 1.425-1.051.519.049.959.392 1.355.716.239.195.533.574.71.788.163.196.203.277.377.509.23.307.302.459.214.121-.071-.496-.187-1.343-.355-2.092-.128-.568-.159-.657-.281-1.093-.129-.464-.195-.789-.316-1.281-.084-.348-.235-1.059-.276-1.459-.057-.547-.087-1.439.264-1.849.275-.321.906-.418 1.297-.22.512.259.803 1.003.936 1.3.239.534.387 1.151.516 1.961.164 1.031.466 2.462.476 2.763.024-.369-.068-1.146-.004-1.5.058-.321.328-.694.666-.795.286-.085.621-.116.916-.055.313.064.643.288.766.499.362.624.369 1.899.384 1.831.086-.376.071-1.229.284-1.584.14-.234.497-.445.687-.479.294-.052.655-.068.964-.008.249.049.586.345.677.487.218.344.342 1.317.379 1.658.015.141.074-.392.293-.736.406-.639 1.843-.763 1.898.639.025.654.02.624.02 1.064 0 .517-.012.828-.04 1.202-.031.4-.117 1.304-.242 1.742-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.191 1.813-.118.562-.079.566-.102.965-.023.398.121.922.121.922s-.802.104-1.234.035c-.391-.063-.875-.841-1-1.079-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.031-3.139.02 0 0 .185-1.011-.227-1.358-.305-.259-.83-.784-1.144-1.06z" stroke-linejoin="round"/><path d="m21.5664 21.7344v-3.459"/><path d="m19.5508 21.7461-.016-3.473"/><path d="m17.5547 18.3047.021 3.426"/></g>',
  JY = '<path d="m25 16h-6.01v-6h-2.98v6h-6.01v3h6.01v6h2.98v-6h6.01z" fill="white"/><path d="m23.9902 17.0103h-6v-6.01h-.98v6.01h-6v.98h6v6.01h.98v-6.01h6z" fill="%23231f1f"/>',
  QY = '<path d="m19 14h1v1h-1zm1 6h-1v-1h1zm-5-5h-1v-1h1zm0 5h-1v-1h1zm2-10.987-7.985 7.988 5.222 5.221 2.763 2.763 7.984-7.985z" fill="white"/><g fill="black"><path d="m23.5664 16.9971-2.557-2.809v1.829h-4.009-4.001v-1.829l-2.571 2.809 2.572 2.808-.001-1.808h4.001 4.009l-.001 1.808z"/><path d="m17.9873 17h.013v-4.001l1.807.001-2.807-2.571-2.809 2.57h1.809v4.001h.008v4.002l-1.828-.001 2.807 2.577 2.805-2.576h-1.805z"/></g>',
  TT = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>",
  $T = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>",
  Lp = '<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>',
  eq = '<path fill="white" d="M7.94 0a5.25 5.25 0 0 0-3.47 1.17A5.27 5.27 0 0 0 1 0H0v3h1c1.41 0 1.85.7 2 1v3.94H2v3h1v3c-.13.3-.57 1-2 1H0v3h1a5.27 5.27 0 0 0 3.47-1.17c.98.8 2.21 1.21 3.47 1.17h1v-3h-1c-1.41 0-1.85-.7-2-1v-3H7v-3H6V4c.13-.3.57-1 2-1h1V0H7.94z"/><path fill="black" d="M7.94 2V1a4 4 0 0 0-3.47 1.64A4 4 0 0 0 1 1v1c1.3-.17 2.56.6 3 1.84v5.1H3v1h1v4.16c-.45 1.24-1.7 2-3 1.84v1a4.05 4.05 0 0 0 3.47-1.63 4.05 4.05 0 0 0 3.47 1.63v-1A2.82 2.82 0 0 1 5 14.1V9.93h1v-1H5V3.85A2.81 2.81 0 0 1 7.94 2z"/>',
  tq = "<path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042' fill='white'/><g stroke='black' stroke-width='.75'><path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042z' stroke-linejoin='round'/><path d='m20.5664 19.7344v-3.459' stroke-linecap='round'/><path d='m18.5508 19.7461-.016-3.473' stroke-linecap='round'/><path d='m16.5547 16.3047.021 3.426' stroke-linecap='round'/></g>",
  nq = '<path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" fill="white"/><g stroke="black" stroke-linecap="round" stroke-width=".75"><path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" stroke-linejoin="round"/><path d="m20.5664 21.7344v-3.459"/><path d="m18.5508 21.7461-.016-3.473"/><path d="m16.5547 18.3047.021 3.426"/></g>',
  rq = '<path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5" fill="white"/><path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5z" stroke="black"/><g fill="black"><path d="m18 14h-2v-2h-2v2h-2v1.98h2v2.02h2v-2.02h2z"/><path d="m23.5859 25 1.414-1.414-5.449-5.449-1.414 1.414z"/></g>',
  oq = '<path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5" fill="white"/><path d="m20.5 15c0 3.038-2.462 5.5-5.5 5.5s-5.5-2.462-5.5-5.5 2.462-5.5 5.5-5.5 5.5 2.462 5.5 5.5z" stroke="black"/><g fill="black"><path d="m18 16h-5.98v-1.98h5.98z"/><path d="m23.5859 25 1.414-1.414-5.449-5.449-1.414 1.414z"/></g>';

function _n(t, e, n, r, o, s = 16, i = 16) {
  const a = (-n - e) * (Hn / 180),
    c = Math.sin(a),
    l = Math.cos(a),
    u = 1 * l - 1 * c,
    d = 1 * c + 1 * l;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${o};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${u}' dy='${d}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${e+n} 16 16)${r?" scale(-1,-1) translate(0, -32)":""}' filter='url(%23shadow)'>` + t.replaceAll('"', "'") + `</g></svg>") ${s} ${i}, pointer`
}
const sq = {
  none: () => "none",
  default: (t, e, n) => _n(XY, t, 0, e, n, 12, 8),
  pointer: (t, e, n) => _n(ZY, t, 0, e, n, 14, 10),
  cross: (t, e, n) => _n(JY, t, 0, e, n),
  move: (t, e, n) => _n(QY, t, 0, e, n),
  grab: (t, e, n) => _n(nq, t, 0, e, n),
  grabbing: (t, e, n) => _n(tq, t, 0, e, n),
  text: (t, e, n) => _n(eq, t, 0, e, n, 4, 10),
  "ew-resize": (t, e, n) => _n($T, t, 0, e, n),
  "ns-resize": (t, e, n) => _n($T, t, 90, e, n),
  "nesw-resize": (t, e, n) => _n(TT, t, 0, e, n),
  "nwse-resize": (t, e, n) => _n(TT, t, 90, e, n),
  "nwse-rotate": (t, e, n) => _n(Lp, t, 0, e, n),
  "nesw-rotate": (t, e, n) => _n(Lp, t, 90, e, n),
  "senw-rotate": (t, e, n) => _n(Lp, t, 180, e, n),
  "swne-rotate": (t, e, n) => _n(Lp, t, 270, e, n),
  "zoom-in": (t, e, n) => _n(rq, t, 0, e, n),
  "zoom-out": (t, e, n) => _n(oq, t, 0, e, n)
};

function Ir(t, e = 0, n = "black") {
  return sq[t](fV(e), !1, n)
}
const iq = ["default", "pointer", "cross", "move", "grab", "grabbing", "text"];

function aq() {
  const t = Y(),
    e = Rn(),
    n = sv();
  ja("useCursor", () => {
    const {
      type: r,
      rotation: o
    } = t.getInstanceState().cursor;
    if (iq.includes(r)) {
      e.style.setProperty("--tl-cursor", `var(--tl-cursor-${r})`);
      return
    }
    e.style.setProperty("--tl-cursor", Ir(r, o, n ? "white" : "black"))
  }, [t, e, n])
}

function cq() {
  const t = Y(),
    e = Rn(),
    n = sv(),
    r = te(Nt.forceSrgb);
  se.useEffect(() => {
    n ? (e.setAttribute("data-color-mode", "dark"), e.classList.remove("tl-theme__light"), e.classList.add("tl-theme__dark")) : (e.setAttribute("data-color-mode", "light"), e.classList.remove("tl-theme__dark"), e.classList.add("tl-theme__light")), r ? e.classList.add("tl-theme__force-sRGB") : e.classList.remove("tl-theme__force-sRGB")
  }, [t, e, r, n])
}

function lq(t) {
  const e = g.useRef();
  return g.useLayoutEffect(() => {
    e.current = t
  }), g.useDebugValue(t), g.useCallback((...n) => {
    const r = e.current;
    return Xa(r, "fn does not exist"), r(...n)
  }, [])
}

function uq(t) {
  const e = Y(),
    n = Rn();
  g.useLayoutEffect(() => {
    t ? (e.getInstanceState().isFocused || e.updateInstanceState({
      isFocused: !0
    }), e.getContainer().focus()) : e.getInstanceState().isFocused && e.updateInstanceState({
      isFocused: !1
    })
  }, [e, n, t])
}

function dq() {
  const [t, e] = g.useState(0);
  g.useEffect(() => e(n => n + 1), [])
}
const Fl = "TLDRAW_TAB_ID_v2",
  Pn = globalThis.window;

function fq() {
  return Pn ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(Pn.navigator.platform) || Pn.navigator.userAgent.includes("Mac") && "ontouchend" in document : !1
}
const Fm = (Pn == null ? void 0 : Pn[Fl]) ?? (Pn == null ? void 0 : Pn.sessionStorage[Fl]) ?? "TLDRAW_INSTANCE_STATE_V1_" + It();
Pn && (Pn[Fl] = Fm, fq() ? Pn.sessionStorage[Fl] = Fm : delete Pn.sessionStorage[Fl]);
Pn == null || Pn.addEventListener("beforeunload", () => {
  Pn.sessionStorage[Fl] = Fm
});
const hq = {
    Initial: 0
  },
  jf = hq.Initial,
  N3 = tt({
    version: Oe,
    currentPageId: Tf,
    isFocusMode: Je,
    exportBackground: Je,
    isDebugMode: Je,
    isToolLocked: Je,
    isGridMode: Je,
    pageStates: Vn(tt({
      pageId: Tf,
      camera: tt({
        x: Oe,
        y: Oe,
        z: Oe
      }),
      selectedShapeIds: Vn(wo),
      focusedGroupId: wo.nullable()
    }))
  }),
  pq = ht({
    currentVersion: jf
  });

function gq(t) {
  if (!t || typeof t != "object") return console.warn("Invalid instance state"), null;
  if (!("version" in t) || typeof t.version != "number") return console.warn("No version in instance state"), null;
  const e = u1({
    value: t,
    fromVersion: t.version,
    toVersion: jf,
    migrations: pq
  });
  if (e.type === "error") return console.warn(e.reason), null;
  const n = {
    ...e.value,
    version: jf
  };
  try {
    N3.validate(n)
  } catch (r) {
    return console.warn(r), null
  }
  return n
}

function mq(t) {
  const e = t.query.ids("page");
  return Q("sessionStateSnapshot", () => {
    const n = t.get(er);
    if (!n) return null;
    const r = [...e.get()];
    return {
      version: jf,
      currentPageId: n.currentPageId,
      exportBackground: n.exportBackground,
      isFocusMode: n.isFocusMode,
      isDebugMode: n.isDebugMode,
      isToolLocked: n.isToolLocked,
      isGridMode: n.isGridMode,
      pageStates: r.map(o => {
        const s = t.get(Un.createId(o)),
          i = t.get(Bn.createId(o));
        return {
          pageId: o,
          camera: {
            x: (i == null ? void 0 : i.x) ?? 0,
            y: (i == null ? void 0 : i.y) ?? 0,
            z: (i == null ? void 0 : i.z) ?? 1
          },
          selectedShapeIds: (s == null ? void 0 : s.selectedShapeIds) ?? [],
          focusedGroupId: (s == null ? void 0 : s.focusedGroupId) ?? null
        }
      })
    }
  })
}

function yq(t, e) {
  const n = gq(e);
  if (!n) return;
  const r = t.allRecords().filter(i => i.typeName === "instance_page_state" || i.typeName === "camera"),
    o = {
      added: {},
      updated: {},
      removed: {
        ...TA(r.map(i => [i.id, i]))
      }
    };
  t.has(er) && (o.removed[er] = t.get(er));
  const s = {
    removed: {},
    updated: {},
    added: {
      [er]: t.schema.types.instance.create({
        id: er,
        currentPageId: n.currentPageId,
        isDebugMode: n.isDebugMode,
        isFocusMode: n.isFocusMode,
        isToolLocked: n.isToolLocked,
        isGridMode: n.isGridMode,
        exportBackground: n.exportBackground
      })
    }
  };
  for (const i of n.pageStates) {
    const a = Bn.createId(i.pageId),
      c = Un.createId(i.pageId);
    s.added[a] = Bn.create({
      id: Bn.createId(i.pageId),
      x: i.camera.x,
      y: i.camera.y,
      z: i.camera.z
    }), s.added[c] = Un.create({
      id: Un.createId(i.pageId),
      pageId: i.pageId,
      selectedShapeIds: i.selectedShapeIds,
      focusedGroupId: i.focusedGroupId
    })
  }
  Zr(() => {
    t.applyDiff(Gy([o, s])), t.ensureStoreIsUsable()
  })
}

function vq(t) {
  var o;
  const e = [];
  for (const s of Object.values(t))(o = s.typeName) != null && o.match(/^(instance.*|pointer|camera)$/) && e.push(s);
  const n = e.filter(s => s.typeName === "instance" && s.id !== er)[0];
  if (!n) return null;
  const r = {
    version: jf,
    currentPageId: n.currentPageId,
    exportBackground: !!n.exportBackground,
    isFocusMode: !!n.isFocusMode,
    isDebugMode: !!n.isDebugMode,
    isToolLocked: !!n.isToolLocked,
    isGridMode: !1,
    pageStates: e.filter(s => s.typeName === "instance_page_state" && s.instanceId === n.id).map(s => {
      const i = t[s.cameraId] ?? {
        x: 0,
        y: 0,
        z: 1
      };
      return {
        pageId: s.pageId,
        camera: {
          x: i.x,
          y: i.y,
          z: i.z
        },
        selectedShapeIds: s.selectedShapeIds,
        focusedGroupId: s.focusedGroupId
      }
    })
  };
  try {
    return N3.validate(r), r
  } catch {
    return null
  }
}

function bq() {
  window.alert(`Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
 If your hard disk is full, try clearing up some space and then reload the page.`)
}

function wq() {
  window.alert(`Oops! We could not access your browser's storageand the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`)
}
const Sq = (t, e) => e.some(n => t instanceof n);
let IT, OT;

function _q() {
  return IT || (IT = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function xq() {
  return OT || (OT = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const L3 = new WeakMap,
  VS = new WeakMap,
  F3 = new WeakMap,
  J0 = new WeakMap,
  I1 = new WeakMap;

function Eq(t) {
  const e = new Promise((n, r) => {
    const o = () => {
        t.removeEventListener("success", s), t.removeEventListener("error", i)
      },
      s = () => {
        n(Fs(t.result)), o()
      },
      i = () => {
        r(t.error), o()
      };
    t.addEventListener("success", s), t.addEventListener("error", i)
  });
  return e.then(n => {
    n instanceof IDBCursor && L3.set(n, t)
  }).catch(() => {}), I1.set(e, t), e
}

function kq(t) {
  if (VS.has(t)) return;
  const e = new Promise((n, r) => {
    const o = () => {
        t.removeEventListener("complete", s), t.removeEventListener("error", i), t.removeEventListener("abort", i)
      },
      s = () => {
        n(), o()
      },
      i = () => {
        r(t.error || new DOMException("AbortError", "AbortError")), o()
      };
    t.addEventListener("complete", s), t.addEventListener("error", i), t.addEventListener("abort", i)
  });
  VS.set(t, e)
}
let WS = {
  get(t, e, n) {
    if (t instanceof IDBTransaction) {
      if (e === "done") return VS.get(t);
      if (e === "objectStoreNames") return t.objectStoreNames || F3.get(t);
      if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
    }
    return Fs(t[e])
  },
  set(t, e, n) {
    return t[e] = n, !0
  },
  has(t, e) {
    return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
  }
};

function Cq(t) {
  WS = t(WS)
}

function Pq(t) {
  return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
    const r = t.call(Q0(this), e, ...n);
    return F3.set(r, e.sort ? e.sort() : [e]), Fs(r)
  } : xq().includes(t) ? function(...e) {
    return t.apply(Q0(this), e), Fs(L3.get(this))
  } : function(...e) {
    return Fs(t.apply(Q0(this), e))
  }
}

function Tq(t) {
  return typeof t == "function" ? Pq(t) : (t instanceof IDBTransaction && kq(t), Sq(t, _q()) ? new Proxy(t, WS) : t)
}

function Fs(t) {
  if (t instanceof IDBRequest) return Eq(t);
  if (J0.has(t)) return J0.get(t);
  const e = Tq(t);
  return e !== t && (J0.set(t, e), I1.set(e, t)), e
}
const Q0 = t => I1.get(t);

function $q(t, e, {
  blocked: n,
  upgrade: r,
  blocking: o,
  terminated: s
} = {}) {
  const i = indexedDB.open(t, e),
    a = Fs(i);
  return r && i.addEventListener("upgradeneeded", c => {
    r(Fs(i.result), c.oldVersion, c.newVersion, Fs(i.transaction), c)
  }), n && i.addEventListener("blocked", c => n(c.oldVersion, c.newVersion, c)), a.then(c => {
    s && c.addEventListener("close", () => s()), o && c.addEventListener("versionchange", l => o(l.oldVersion, l.newVersion, l))
  }).catch(() => {}), a
}

function Iq(t, {
  blocked: e
} = {}) {
  const n = indexedDB.deleteDatabase(t);
  return e && n.addEventListener("blocked", r => e(r.oldVersion, r)), Fs(n).then(() => {})
}
const Oq = ["get", "getKey", "getAll", "getAllKeys", "count"],
  Rq = ["put", "add", "delete", "clear"],
  eb = new Map;

function RT(t, e) {
  if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
  if (eb.get(e)) return eb.get(e);
  const n = e.replace(/FromIndex$/, ""),
    r = e !== n,
    o = Rq.includes(n);
  if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(o || Oq.includes(n))) return;
  const s = async function(i, ...a) {
    const c = this.transaction(i, o ? "readwrite" : "readonly");
    let l = c.store;
    return r && (l = l.index(a.shift())), (await Promise.all([l[n](...a), o && c.done]))[0]
  };
  return eb.set(e, s), s
}
Cq(t => ({
  ...t,
  get: (e, n, r) => RT(e, n) || t.get(e, n, r),
  has: (e, n) => !!RT(e, n) || t.has(e, n)
}));
const iv = "TLDRAW_DOCUMENT_v2",
  B3 = "TLDRAW_DB_NAME_INDEX_v2",
  yt = {
    Records: "records",
    Schema: "schema",
    SessionState: "session_state"
  };
async function av(t, e) {
  Nq(t);
  const n = await $q(t, 3, {
    upgrade(r) {
      r.objectStoreNames.contains(yt.Records) || r.createObjectStore(yt.Records), r.objectStoreNames.contains(yt.Schema) || r.createObjectStore(yt.Schema), r.objectStoreNames.contains(yt.SessionState) || r.createObjectStore(yt.SessionState)
    }
  });
  try {
    return await e(n)
  } finally {
    n.close()
  }
}
async function Aq({
  persistenceKey: t,
  sessionId: e,
  didCancel: n
}) {
  const r = iv + t;
  if (O1().includes(r)) return await Dq({
    persistenceKey: t,
    didCancel: n
  }), await av(r, async o => {
    var d, f;
    if (n != null && n()) return;
    const s = o.transaction([yt.Records, yt.Schema, yt.SessionState], "readonly"),
      i = s.objectStore(yt.Records),
      a = s.objectStore(yt.Schema),
      c = s.objectStore(yt.SessionState);
    let l = e ? (d = await c.get(e)) == null ? void 0 : d.snapshot : null;
    l || (l = (f = (await c.getAll()).sort((m, p) => m.updatedAt - p.updatedAt).pop()) == null ? void 0 : f.snapshot);
    const u = {
      records: await i.getAll(),
      schema: await a.get(yt.Schema),
      sessionStateSnapshot: l
    };
    if (n != null && n()) {
      s.abort();
      return
    }
    return await s.done, u
  })
}
async function Mq({
  persistenceKey: t,
  schema: e,
  changes: n,
  sessionId: r,
  sessionStateSnapshot: o,
  didCancel: s
}) {
  const i = iv + t;
  await av(i, async a => {
    const c = a.transaction([yt.Records, yt.Schema, yt.SessionState], "readwrite"),
      l = c.objectStore(yt.Records),
      u = c.objectStore(yt.Schema),
      d = c.objectStore(yt.SessionState);
    for (const [f, h] of Object.entries(n.added)) await l.put(h, f);
    for (const [f, h] of Object.values(n.updated)) await l.put(h, h.id);
    for (const f of Object.keys(n.removed)) await l.delete(f);
    if (u.put(e.serialize(), yt.Schema), o && r ? d.put({
        snapshot: o,
        updatedAt: Date.now(),
        id: r
      }, r) : (o || r) && console.error("sessionStateSnapshot and instanceId must be provided together"), s != null && s()) return c.abort();
    await c.done
  })
}
async function jq({
  persistenceKey: t,
  schema: e,
  snapshot: n,
  sessionId: r,
  sessionStateSnapshot: o,
  didCancel: s
}) {
  const i = iv + t;
  await av(i, async a => {
    const c = a.transaction([yt.Records, yt.Schema, yt.SessionState], "readwrite"),
      l = c.objectStore(yt.Records),
      u = c.objectStore(yt.Schema),
      d = c.objectStore(yt.SessionState);
    await l.clear();
    for (const [f, h] of Object.entries(n)) await l.put(h, f);
    if (u.put(e.serialize(), yt.Schema), o && r ? d.put({
        snapshot: o,
        updatedAt: Date.now(),
        id: r
      }, r) : (o || r) && console.error("sessionStateSnapshot and instanceId must be provided together"), s != null && s()) return c.abort();
    await c.done
  })
}
async function Dq({
  persistenceKey: t,
  didCancel: e
}) {
  await av(iv + t, async n => {
    const r = n.transaction([yt.SessionState], "readwrite"),
      o = r.objectStore(yt.SessionState),
      s = (await o.getAll()).sort((a, c) => a.updatedAt - c.updatedAt);
    if (s.length < 10) {
      await r.done;
      return
    }
    const i = s.slice(0, s.length - 10);
    for (const {
        id: a
      }
      of i) await o.delete(a);
    if (e != null && e()) return r.abort();
    await r.done
  })
}

function O1() {
  const t = JSON.parse((window == null ? void 0 : window.localStorage.getItem(B3)) || "[]") ?? [];
  return Array.isArray(t) ? t : []
}

function Nq(t) {
  const e = new Set(O1());
  e.add(t), window == null || window.localStorage.setItem(B3, JSON.stringify([...e]))
}
const Lq = 350,
  Fq = 1e4,
  AT = Symbol("UPDATE_INSTANCE_STATE"),
  Bq = t => t;
class Uq {
  constructor(e) {
    P(this, "onmessage")
  }
  postMessage(e) {}
  close() {}
}
const zq = typeof BroadcastChannel > "u" ? Uq : BroadcastChannel;
class Hq {
  constructor(e, {
    persistenceKey: n,
    sessionId: r = Fm,
    onLoad: o,
    onLoadError: s
  }, i = new zq(`tldraw-tab-sync-${n}`)) {
    P(this, "disposables", new Set);
    P(this, "diffQueue", []);
    P(this, "didDispose", !1);
    P(this, "shouldDoFullDBWrite", !0);
    P(this, "isReloading", !1);
    P(this, "persistenceKey");
    P(this, "sessionId");
    P(this, "serializedSchema");
    P(this, "isDebugging", !1);
    P(this, "documentTypes");
    P(this, "$sessionStateSnapshot");
    P(this, "initTime", Date.now());
    P(this, "isPersisting", !1);
    P(this, "didLastWriteError", !1);
    P(this, "scheduledPersistTimeout", null);
    this.store = e, this.channel = i, typeof window < "u" && (window.tlsync = this), this.persistenceKey = n, this.sessionId = r, this.serializedSchema = this.store.schema.serialize(), this.$sessionStateSnapshot = mq(this.store), this.disposables.add(e.listen(({
      changes: a
    }) => {
      this.diffQueue.push(a), this.channel.postMessage(Bq({
        type: "diff",
        storeId: this.store.id,
        changes: a,
        schema: this.serializedSchema
      })), this.schedulePersist()
    }, {
      source: "user",
      scope: "document"
    })), this.disposables.add(e.listen(() => {
      this.diffQueue.push(AT), this.schedulePersist()
    }, {
      scope: "session"
    })), this.connect(o, s), this.documentTypes = new Set(Object.values(this.store.schema.types).filter(a => a.scope === "document").map(a => a.typeName))
  }
  debug(...e) {
    this.isDebugging && console.debug(...e)
  }
  async connect(e, n) {
    this.debug("connecting");
    let r;
    try {
      r = await Aq({
        persistenceKey: this.persistenceKey,
        sessionId: this.sessionId,
        didCancel: () => this.didDispose
      })
    } catch (o) {
      n(o), wq(), typeof window < "u" && window.location.reload();
      return
    }
    if (this.debug("loaded data from store", r, "didDispose", this.didDispose), !this.didDispose) try {
      if (r) {
        const o = Object.fromEntries(r.records.map(a => [a.id, a])),
          s = r.sessionStateSnapshot ?? vq(o),
          i = this.store.schema.migrateStoreSnapshot({
            store: o,
            schema: r.schema ?? this.store.schema.serializeEarliestVersion()
          });
        if (i.type === "error") {
          console.error("failed to migrate store", i), n(new Error(`Failed to migrate store: ${i.reason}`));
          return
        }
        this.store.mergeRemoteChanges(() => {
          this.store.put(Object.values(i.value).filter(a => this.documentTypes.has(a.typeName)), "initialize")
        }), s && yq(this.store, s)
      }
      this.channel.onmessage = ({
        data: o
      }) => {
        var a, c;
        this.debug("got message", o);
        const s = o,
          i = Lz(this.serializedSchema, s.schema ?? this.store.schema.serializeEarliestVersion());
        if (i === -1) {
          if (Date.now() - this.initTime < 5e3) {
            n(new Error("Schema mismatch, please close other tabs and reload the page"));
            return
          }
          this.debug("reloading"), this.isReloading = !0, (c = (a = window == null ? void 0 : window.location) == null ? void 0 : a.reload) == null || c.call(a);
          return
        } else if (i === 1) {
          this.debug("telling them to reload"), this.channel.postMessage({
            type: "announce",
            schema: this.serializedSchema
          }), this.shouldDoFullDBWrite = !0, this.persistIfNeeded();
          return
        }
        s.type === "diff" && (this.debug("applying diff"), Zr(() => {
          this.store.mergeRemoteChanges(() => {
            this.store.applyDiff(s.changes), this.store.ensureStoreIsUsable()
          })
        }))
      }, this.channel.postMessage({
        type: "announce",
        schema: this.serializedSchema
      }), this.disposables.add(() => {
        this.channel.close()
      }), e(this)
    } catch (o) {
      if (this.debug("error loading data from store", o), this.didDispose) return;
      n(o);
      return
    }
  }
  close() {
    this.debug("closing"), this.didDispose = !0, this.disposables.forEach(e => e())
  }
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout), !this.scheduledPersistTimeout && (this.scheduledPersistTimeout = setTimeout(() => {
      this.scheduledPersistTimeout = null, this.persistIfNeeded()
    }, this.didLastWriteError ? Fq : Lq))
  }
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    }), this.scheduledPersistTimeout && (clearTimeout(this.scheduledPersistTimeout), this.scheduledPersistTimeout = null), !this.isPersisting && (this.isReloading || this.store.isPossiblyCorrupted() || (this.shouldDoFullDBWrite || this.diffQueue.length > 0) && this.doPersist())
  }
  async doPersist() {
    Xa(!this.isPersisting, "persist already in progress"), this.isPersisting = !0, this.debug("doPersist start");
    const e = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite) this.shouldDoFullDBWrite = !1, await jq({
        persistenceKey: this.persistenceKey,
        schema: this.store.schema,
        snapshot: this.store.serialize(),
        didCancel: () => this.didDispose,
        sessionId: this.sessionId,
        sessionStateSnapshot: this.$sessionStateSnapshot.get()
      });
      else {
        const n = Gy(e.filter(r => r !== AT));
        await Mq({
          persistenceKey: this.persistenceKey,
          changes: n,
          schema: this.store.schema,
          didCancel: () => this.didDispose,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        })
      }
      this.didLastWriteError = !1
    } catch (n) {
      this.shouldDoFullDBWrite = !0, this.didLastWriteError = !0, console.error("failed to store changes in indexed db", n), bq(), typeof window < "u" && window.location.reload()
    }
    this.isPersisting = !1, this.debug("doPersist end"), this.schedulePersist()
  }
}

function KS({
  initialData: t,
  defaultName: e = "",
  ...n
}) {
  const r = "schema" in n && n.schema ? n.schema : PH({
    shapes: Vq(O3("shapeUtils" in n && n.shapeUtils ? n.shapeUtils : []))
  });
  return new l1({
    schema: r,
    initialData: t,
    props: {
      defaultName: e
    }
  })
}

function Vq(t) {
  return Object.fromEntries(t.map(e => [e.type, {
    props: e.props,
    migrations: e.migrations
  }]))
}

function Wq(t) {
  const [e, n] = g.useState(() => {
    const o = KS(t);
    return t.snapshot && o.loadSnapshot(t.snapshot), o
  }), r = g.useRef(t);
  if (g.useEffect(() => void(r.current = t)), Object.keys(r.current).some(o => r.current[o] !== t[o])) {
    const o = KS(t);
    return t.snapshot && o.loadSnapshot(t.snapshot), n(o), o
  }
  return e
}

function Kq({
  persistenceKey: t,
  sessionId: e,
  ...n
}) {
  const [r, o] = g.useState(null), s = Wq(n);
  return g.useEffect(() => {
    const i = It();
    if (!t) {
      o({
        id: i,
        storeWithStatus: {
          status: "not-synced",
          store: s
        }
      });
      return
    }
    o({
      id: i,
      storeWithStatus: {
        status: "loading"
      }
    });
    const a = l => {
        o(u => (u == null ? void 0 : u.id) === i ? {
          id: i,
          storeWithStatus: l
        } : u)
      },
      c = new Hq(s, {
        sessionId: e,
        persistenceKey: t,
        onLoad() {
          a({
            store: s,
            status: "synced-local"
          })
        },
        onLoadError(l) {
          a({
            status: "error",
            error: l
          })
        }
      });
    return () => {
      o(l => (l == null ? void 0 : l.id) === i ? null : l), c.close()
    }
  }, [t, s, e]), (r == null ? void 0 : r.storeWithStatus) ?? {
    status: "loading"
  }
}
let U3 = !1;
if (typeof window < "u") {
  const t = window.navigator.userAgent,
    e = !!t.match(/iPad/i) || !!t.match(/iPhone/i),
    n = !!t.match(/WebKit/i);
  U3 = e && n && !t.match(/CriOS/i)
}

function Gq() {
  const t = Y();
  g.useEffect(() => {
    if (!U3) return;

    function e(n) {
      (n.target instanceof HTMLInputElement && n.target.type === "text" || n.target instanceof HTMLTextAreaElement) && t.complete()
    }
    return document.addEventListener("focusout", e), () => document.removeEventListener("focusout", e)
  }, [t])
}

function Yq() {
  const t = Y(),
    e = Rn();
  g.useEffect(() => {
    const n = s => e.style.setProperty("--tl-zoom", s.toString()),
      r = CA(n, 100),
      o = new vh("useZoomCss", () => {
        t.currentPageShapeIds.size < 300 ? n(t.zoomLevel) : r(t.zoomLevel)
      });
    return o.attach(), o.execute(), () => {
      o.detach()
    }
  }, [t, e])
}
const qq = [],
  Xq = [],
  B0e = g.memo(function({
    store: e,
    components: n,
    className: r,
    user: o,
    ...s
  }) {
    const [i, a] = se.useState(null), c = g.useMemo(() => o ?? x3(), [o]), l = (n == null ? void 0 : n.ErrorFallback) === void 0 ? b1 : n == null ? void 0 : n.ErrorFallback, u = {
      ...s,
      shapeUtils: s.shapeUtils ?? qq,
      tools: s.tools ?? Xq
    };
    return y.jsx("div", {
      ref: a,
      draggable: !1,
      className: ae("tl-container tl-theme__light", r),
      onPointerDown: Wn,
      tabIndex: -1,
      children: y.jsx(Rf, {
        fallback: l,
        onError: d => i1(d, {
          tags: {
            origin: "react.tldraw-before-app"
          }
        }),
        children: i && y.jsx(qH, {
          container: i,
          children: y.jsx(WV, {
            overrides: n,
            children: e ? e instanceof l1 ? y.jsx(H3, {
              ...u,
              store: e,
              user: c
            }) : y.jsx(z3, {
              ...u,
              store: e,
              user: c
            }) : y.jsx(Zq, {
              ...u,
              store: e,
              user: c
            })
          })
        })
      })
    })
  });

function Zq(t) {
  const {
    defaultName: e,
    snapshot: n,
    initialData: r,
    shapeUtils: o,
    persistenceKey: s,
    sessionId: i,
    user: a
  } = t, c = Kq({
    shapeUtils: o,
    initialData: r,
    persistenceKey: s,
    sessionId: i,
    defaultName: e,
    snapshot: n
  });
  return y.jsx(z3, {
    ...t,
    store: c,
    user: a
  })
}
const z3 = g.memo(function({
  store: e,
  user: n,
  ...r
}) {
  const o = Rn();
  switch (g.useLayoutEffect(() => {
      n.userPreferences.get().isDarkMode && (o.classList.remove("tl-theme__light"), o.classList.add("tl-theme__dark"))
    }, [o, n]), e.status) {
    case "error":
      throw e.error;
    case "loading":
      return y.jsx(eX, {
        children: "Connecting..."
      })
  }
  return y.jsx(H3, {
    ...r,
    store: e.store,
    user: n
  })
});

function H3({
  onMount: t,
  children: e,
  store: n,
  tools: r,
  shapeUtils: o,
  user: s,
  initialState: i,
  autoFocus: a = !0,
  inferDarkMode: c
}) {
  const {
    ErrorFallback: l
  } = yn(), u = Rn(), [d, f] = g.useState(null);
  g.useLayoutEffect(() => {
    const m = new ve({
      store: n,
      shapeUtils: o,
      tools: r,
      getContainer: () => u,
      user: s,
      initialState: i,
      inferDarkMode: c
    });
    return window.app = m, window.editor = m, f(m), () => {
      m.dispose()
    }
  }, [u, o, r, n, s, i, c]);
  const h = g.useSyncExternalStore(g.useCallback(m => d ? (d.on("crash", m), () => d.off("crash", m)) : () => {}, [d]), () => (d == null ? void 0 : d.crashingError) ?? null);
  return d ? y.jsx(Rf, {
    fallback: l,
    onError: m => d.annotateError(m, {
      origin: "react.tldraw",
      willCrashApp: !0
    }),
    children: h ? y.jsx(Qq, {
      crashingError: h
    }) : y.jsx(y1.Provider, {
      value: d,
      children: y.jsx(Jq, {
        autoFocus: a,
        onMount: t,
        children: e
      })
    })
  }) : null
}

function Jq({
  children: t,
  onMount: e,
  autoFocus: n
}) {
  return Yq(), aq(), cq(), Gq(), dq(), uq(n), tX(e), _G(), Y().updateViewportScreenBounds(), t ?? y.jsx(y3, {})
}

function Qq({
  crashingError: t
}) {
  throw t
}

function eX({
  children: t
}) {
  const {
    Spinner: e
  } = yn();
  return y.jsxs("div", {
    className: "tl-loading",
    children: [e ? y.jsx(e, {}) : null, t]
  })
}

function U0e({
  children: t
}) {
  return y.jsx("div", {
    className: "tl-loading",
    children: t
  })
}

function tX(t) {
  const e = Y(),
    n = lq(r => {
      const o = t == null ? void 0 : t(r);
      return r.emit("mount"), window.tldrawReady = !0, o
    });
  se.useLayoutEffect(() => {
    if (e) return n == null ? void 0 : n(e)
  }, [e, n])
}

function V3({
  children: t,
  className: e = "",
  ...n
}) {
  return y.jsx("div", {
    ...n,
    className: `tl-html-container ${e}`,
    children: t
  })
}
const z0e = pt(function({
  x: e = 0,
  y: n = 0,
  rotation: r = 0,
  ...o
}) {
  const s = Y(),
    i = g.useRef(null),
    a = s.getCamera();
  return g.useLayoutEffect(() => {
    const {
      x: c,
      y: l,
      z: u
    } = s.getCamera(), d = i.current;
    d && c !== void 0 && (d.style.transform = `translate(${c}px, ${l}px) scale(${u}) rotate(${r}rad) translate(${e}px, ${n}px)`)
  }, [a, s, e, n, r]), y.jsx("div", {
    ref: i,
    ...o,
    className: ae("tl-positioned", o.className)
  })
});

function nX(t, e, n = {}) {
  const {
    newPoint: r,
    handle: o,
    scaleX: s,
    scaleY: i
  } = e, {
    minWidth: a = 1,
    maxWidth: c = 1 / 0,
    minHeight: l = 1,
    maxHeight: u = 1 / 0
  } = n;
  let d = t.props.w * s,
    f = t.props.h * i;
  const h = new T(0, 0);
  if (d > 0) {
    if (d < a) {
      switch (o) {
        case "top_left":
        case "left":
        case "bottom_left": {
          h.x = d - a;
          break
        }
        case "top":
        case "bottom": {
          h.x = (d - a) / 2;
          break
        }
        default:
          h.x = 0
      }
      d = a
    }
  } else if (h.x = d, d = -d, d < a) {
    switch (o) {
      case "top_left":
      case "left":
      case "bottom_left": {
        h.x = -d;
        break
      }
      default:
        h.x = -a
    }
    d = a
  }
  if (f > 0) {
    if (f < l) {
      switch (o) {
        case "top_left":
        case "top":
        case "top_right": {
          h.y = f - l;
          break
        }
        case "right":
        case "left": {
          h.y = (f - l) / 2;
          break
        }
        default:
          h.y = 0
      }
      f = l
    }
  } else if (h.y = f, f = -f, f < l) {
    switch (o) {
      case "top_left":
      case "top":
      case "top_right": {
        h.y = -f;
        break
      }
      default:
        h.y = -l
    }
    f = l
  }
  const {
    x: m,
    y: p
  } = h.rot(t.rotation).add(r);
  return {
    x: m,
    y: p,
    props: {
      w: Math.min(c, d),
      h: Math.min(u, f)
    }
  }
}
class R1 extends Yd {
  constructor() {
    super(...arguments);
    P(this, "onResize", (n, r) => nX(n, r))
  }
  getGeometry(n) {
    return new T1({
      width: n.props.w,
      height: n.props.h,
      isFilled: !0
    })
  }
}

function W3(t) {
  const e = Y();
  return te("isEditing", () => e.getEditingShapeId() === t, [e, t])
}

function es(t) {
  const e = Y();
  return g.useMemo(function() {
    const o = l => {
      if (l.isKilled) return;
      if (l.button === 2) {
        e.dispatch({
          type: "pointer",
          target: "selection",
          handle: t,
          name: "right_click",
          ...gr(l)
        });
        return
      }
      if (l.button !== 0) return;
      const u = Om(l.currentTarget);

      function d() {
        u.removeEventListener("pointerup", d), _h(u, l)
      }
      Sh(u, l), u.addEventListener("pointerup", d), e.dispatch({
        name: "pointer_down",
        type: "pointer",
        target: "selection",
        handle: t,
        ...gr(l)
      }), Wn(l)
    };
    let s, i;

    function a(l) {
      l.isKilled || l.button === 0 && (l.clientX === s && l.clientY === i || (s = l.clientX, i = l.clientY, e.dispatch({
        name: "pointer_move",
        type: "pointer",
        target: "selection",
        handle: t,
        ...gr(l)
      })))
    }
    return {
      onPointerDown: o,
      onPointerMove: a,
      onPointerUp: l => {
        l.isKilled || l.button === 0 && e.dispatch({
          name: "pointer_up",
          type: "pointer",
          target: "selection",
          handle: t,
          ...gr(l)
        })
      }
    }
  }, [e, t])
}
async function rX({
  shouldReload: t = !0
} = {}) {
  sessionStorage.clear(), await Promise.all(O1().map(e => Iq(e))), localStorage.clear(), t && window.location.reload()
}
typeof window < "u" && (window.__tldraw__hardReset = rX);

function oX(t, e = "_blank") {
  nv.openWindow(t, e)
}
var Fp = function(t) {
    return t && t.Math == Math && t
  },
  xr = Fp(typeof globalThis == "object" && globalThis) || Fp(typeof window == "object" && window) || Fp(typeof self == "object" && self) || Fp(typeof hn == "object" && hn) || function() {
    return this
  }() || hn || Function("return this")(),
  A1 = {},
  cr = function(t) {
    try {
      return !!t()
    } catch {
      return !0
    }
  },
  sX = cr,
  oa = !sX(function() {
    return Object.defineProperty({}, 1, {
      get: function() {
        return 7
      }
    })[1] != 7
  }),
  iX = cr,
  cv = !iX(function() {
    var t = (function() {}).bind();
    return typeof t != "function" || t.hasOwnProperty("prototype")
  }),
  aX = cv,
  Bp = Function.prototype.call,
  sa = aX ? Bp.bind(Bp) : function() {
    return Bp.apply(Bp, arguments)
  },
  K3 = {},
  G3 = {}.propertyIsEnumerable,
  Y3 = Object.getOwnPropertyDescriptor,
  cX = Y3 && !G3.call({
    1: 2
  }, 1);
K3.f = cX ? function(e) {
  var n = Y3(this, e);
  return !!n && n.enumerable
} : G3;
var q3 = function(t, e) {
    return {
      enumerable: !(t & 1),
      configurable: !(t & 2),
      writable: !(t & 4),
      value: e
    }
  },
  X3 = cv,
  Z3 = Function.prototype,
  GS = Z3.call,
  lX = X3 && Z3.bind.bind(GS, GS),
  vn = X3 ? lX : function(t) {
    return function() {
      return GS.apply(t, arguments)
    }
  },
  J3 = vn,
  uX = J3({}.toString),
  dX = J3("".slice),
  ku = function(t) {
    return dX(uX(t), 8, -1)
  },
  fX = vn,
  hX = cr,
  pX = ku,
  tb = Object,
  gX = fX("".split),
  mX = hX(function() {
    return !tb("z").propertyIsEnumerable(0)
  }) ? function(t) {
    return pX(t) == "String" ? gX(t, "") : tb(t)
  } : tb,
  lv = function(t) {
    return t == null
  },
  yX = lv,
  vX = TypeError,
  Cu = function(t) {
    if (yX(t)) throw vX("Can't call method on " + t);
    return t
  },
  bX = mX,
  wX = Cu,
  uv = function(t) {
    return bX(wX(t))
  },
  YS = typeof document == "object" && document.all,
  SX = typeof YS > "u" && YS !== void 0,
  Q3 = {
    all: YS,
    IS_HTMLDDA: SX
  },
  eM = Q3,
  _X = eM.all,
  lr = eM.IS_HTMLDDA ? function(t) {
    return typeof t == "function" || t === _X
  } : function(t) {
    return typeof t == "function"
  },
  MT = lr,
  tM = Q3,
  xX = tM.all,
  fc = tM.IS_HTMLDDA ? function(t) {
    return typeof t == "object" ? t !== null : MT(t) || t === xX
  } : function(t) {
    return typeof t == "object" ? t !== null : MT(t)
  },
  nb = xr,
  EX = lr,
  kX = function(t) {
    return EX(t) ? t : void 0
  },
  dv = function(t, e) {
    return arguments.length < 2 ? kX(nb[t]) : nb[t] && nb[t][e]
  },
  CX = vn,
  nM = CX({}.isPrototypeOf),
  PX = typeof navigator < "u" && String(navigator.userAgent) || "",
  rM = xr,
  rb = PX,
  jT = rM.process,
  DT = rM.Deno,
  NT = jT && jT.versions || DT && DT.version,
  LT = NT && NT.v8,
  Co, Bm;
LT && (Co = LT.split("."), Bm = Co[0] > 0 && Co[0] < 4 ? 1 : +(Co[0] + Co[1]));
!Bm && rb && (Co = rb.match(/Edge\/(\d+)/), (!Co || Co[1] >= 74) && (Co = rb.match(/Chrome\/(\d+)/), Co && (Bm = +Co[1])));
var TX = Bm,
  FT = TX,
  $X = cr,
  IX = xr,
  OX = IX.String,
  oM = !!Object.getOwnPropertySymbols && !$X(function() {
    var t = Symbol();
    return !OX(t) || !(Object(t) instanceof Symbol) || !Symbol.sham && FT && FT < 41
  }),
  RX = oM,
  sM = RX && !Symbol.sham && typeof Symbol.iterator == "symbol",
  AX = dv,
  MX = lr,
  jX = nM,
  DX = sM,
  NX = Object,
  iM = DX ? function(t) {
    return typeof t == "symbol"
  } : function(t) {
    var e = AX("Symbol");
    return MX(e) && jX(e.prototype, NX(t))
  },
  LX = String,
  FX = function(t) {
    try {
      return LX(t)
    } catch {
      return "Object"
    }
  },
  BX = lr,
  UX = FX,
  zX = TypeError,
  M1 = function(t) {
    if (BX(t)) return t;
    throw zX(UX(t) + " is not a function")
  },
  HX = M1,
  VX = lv,
  j1 = function(t, e) {
    var n = t[e];
    return VX(n) ? void 0 : HX(n)
  },
  ob = sa,
  sb = lr,
  ib = fc,
  WX = TypeError,
  KX = function(t, e) {
    var n, r;
    if (e === "string" && sb(n = t.toString) && !ib(r = ob(n, t)) || sb(n = t.valueOf) && !ib(r = ob(n, t)) || e !== "string" && sb(n = t.toString) && !ib(r = ob(n, t))) return r;
    throw WX("Can't convert object to primitive value")
  },
  aM = {
    exports: {}
  },
  BT = xr,
  GX = Object.defineProperty,
  D1 = function(t, e) {
    try {
      GX(BT, t, {
        value: e,
        configurable: !0,
        writable: !0
      })
    } catch {
      BT[t] = e
    }
    return e
  },
  YX = xr,
  qX = D1,
  UT = "__core-js_shared__",
  XX = YX[UT] || qX(UT, {}),
  N1 = XX,
  zT = N1;
(aM.exports = function(t, e) {
  return zT[t] || (zT[t] = e !== void 0 ? e : {})
})("versions", []).push({
  version: "3.31.1",
  mode: "global",
  copyright: " 2014-2023 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var L1 = aM.exports,
  ZX = Cu,
  JX = Object,
  Ch = function(t) {
    return JX(ZX(t))
  },
  QX = vn,
  eZ = Ch,
  tZ = QX({}.hasOwnProperty),
  ia = Object.hasOwn || function(e, n) {
    return tZ(eZ(e), n)
  },
  nZ = vn,
  rZ = 0,
  oZ = Math.random(),
  sZ = nZ(1 .toString),
  cM = function(t) {
    return "Symbol(" + (t === void 0 ? "" : t) + ")_" + sZ(++rZ + oZ, 36)
  },
  iZ = xr,
  aZ = L1,
  HT = ia,
  cZ = cM,
  lZ = oM,
  uZ = sM,
  vl = iZ.Symbol,
  ab = aZ("wks"),
  dZ = uZ ? vl.for || vl : vl && vl.withoutSetter || cZ,
  oi = function(t) {
    return HT(ab, t) || (ab[t] = lZ && HT(vl, t) ? vl[t] : dZ("Symbol." + t)), ab[t]
  },
  fZ = sa,
  VT = fc,
  WT = iM,
  hZ = j1,
  pZ = KX,
  gZ = oi,
  mZ = TypeError,
  yZ = gZ("toPrimitive"),
  vZ = function(t, e) {
    if (!VT(t) || WT(t)) return t;
    var n = hZ(t, yZ),
      r;
    if (n) {
      if (e === void 0 && (e = "default"), r = fZ(n, t, e), !VT(r) || WT(r)) return r;
      throw mZ("Can't convert object to primitive value")
    }
    return e === void 0 && (e = "number"), pZ(t, e)
  },
  bZ = vZ,
  wZ = iM,
  lM = function(t) {
    var e = bZ(t, "string");
    return wZ(e) ? e : e + ""
  },
  SZ = xr,
  KT = fc,
  qS = SZ.document,
  _Z = KT(qS) && KT(qS.createElement),
  uM = function(t) {
    return _Z ? qS.createElement(t) : {}
  },
  xZ = oa,
  EZ = cr,
  kZ = uM,
  dM = !xZ && !EZ(function() {
    return Object.defineProperty(kZ("div"), "a", {
      get: function() {
        return 7
      }
    }).a != 7
  }),
  CZ = oa,
  PZ = sa,
  TZ = K3,
  $Z = q3,
  IZ = uv,
  OZ = lM,
  RZ = ia,
  AZ = dM,
  GT = Object.getOwnPropertyDescriptor;
A1.f = CZ ? GT : function(e, n) {
  if (e = IZ(e), n = OZ(n), AZ) try {
    return GT(e, n)
  } catch {}
  if (RZ(e, n)) return $Z(!PZ(TZ.f, e, n), e[n])
};
var Pu = {},
  MZ = oa,
  jZ = cr,
  fM = MZ && jZ(function() {
    return Object.defineProperty(function() {}, "prototype", {
      value: 42,
      writable: !1
    }).prototype != 42
  }),
  DZ = fc,
  NZ = String,
  LZ = TypeError,
  hc = function(t) {
    if (DZ(t)) return t;
    throw LZ(NZ(t) + " is not an object")
  },
  FZ = oa,
  BZ = dM,
  UZ = fM,
  Up = hc,
  YT = lM,
  zZ = TypeError,
  cb = Object.defineProperty,
  HZ = Object.getOwnPropertyDescriptor,
  lb = "enumerable",
  ub = "configurable",
  db = "writable";
Pu.f = FZ ? UZ ? function(e, n, r) {
  if (Up(e), n = YT(n), Up(r), typeof e == "function" && n === "prototype" && "value" in r && db in r && !r[db]) {
    var o = HZ(e, n);
    o && o[db] && (e[n] = r.value, r = {
      configurable: ub in r ? r[ub] : o[ub],
      enumerable: lb in r ? r[lb] : o[lb],
      writable: !1
    })
  }
  return cb(e, n, r)
} : cb : function(e, n, r) {
  if (Up(e), n = YT(n), Up(r), BZ) try {
    return cb(e, n, r)
  } catch {}
  if ("get" in r || "set" in r) throw zZ("Accessors not supported");
  return "value" in r && (e[n] = r.value), e
};
var VZ = oa,
  WZ = Pu,
  KZ = q3,
  F1 = VZ ? function(t, e, n) {
    return WZ.f(t, e, KZ(1, n))
  } : function(t, e, n) {
    return t[e] = n, t
  },
  hM = {
    exports: {}
  },
  XS = oa,
  GZ = ia,
  pM = Function.prototype,
  YZ = XS && Object.getOwnPropertyDescriptor,
  B1 = GZ(pM, "name"),
  qZ = B1 && (function() {}).name === "something",
  XZ = B1 && (!XS || XS && YZ(pM, "name").configurable),
  ZZ = {
    EXISTS: B1,
    PROPER: qZ,
    CONFIGURABLE: XZ
  },
  JZ = vn,
  QZ = lr,
  ZS = N1,
  eJ = JZ(Function.toString);
QZ(ZS.inspectSource) || (ZS.inspectSource = function(t) {
  return eJ(t)
});
var gM = ZS.inspectSource,
  tJ = xr,
  nJ = lr,
  qT = tJ.WeakMap,
  rJ = nJ(qT) && /native code/.test(String(qT)),
  oJ = L1,
  sJ = cM,
  XT = oJ("keys"),
  mM = function(t) {
    return XT[t] || (XT[t] = sJ(t))
  },
  U1 = {},
  iJ = rJ,
  yM = xr,
  aJ = fc,
  cJ = F1,
  fb = ia,
  hb = N1,
  lJ = mM,
  uJ = U1,
  ZT = "Object already initialized",
  JS = yM.TypeError,
  dJ = yM.WeakMap,
  Um, Df, zm, fJ = function(t) {
    return zm(t) ? Df(t) : Um(t, {})
  },
  hJ = function(t) {
    return function(e) {
      var n;
      if (!aJ(e) || (n = Df(e)).type !== t) throw JS("Incompatible receiver, " + t + " required");
      return n
    }
  };
if (iJ || hb.state) {
  var Zo = hb.state || (hb.state = new dJ);
  Zo.get = Zo.get, Zo.has = Zo.has, Zo.set = Zo.set, Um = function(t, e) {
    if (Zo.has(t)) throw JS(ZT);
    return e.facade = t, Zo.set(t, e), e
  }, Df = function(t) {
    return Zo.get(t) || {}
  }, zm = function(t) {
    return Zo.has(t)
  }
} else {
  var jc = lJ("state");
  uJ[jc] = !0, Um = function(t, e) {
    if (fb(t, jc)) throw JS(ZT);
    return e.facade = t, cJ(t, jc, e), e
  }, Df = function(t) {
    return fb(t, jc) ? t[jc] : {}
  }, zm = function(t) {
    return fb(t, jc)
  }
}
var vM = {
    set: Um,
    get: Df,
    has: zm,
    enforce: fJ,
    getterFor: hJ
  },
  z1 = vn,
  pJ = cr,
  gJ = lr,
  zp = ia,
  QS = oa,
  mJ = ZZ.CONFIGURABLE,
  yJ = gM,
  bM = vM,
  vJ = bM.enforce,
  bJ = bM.get,
  JT = String,
  jg = Object.defineProperty,
  wJ = z1("".slice),
  SJ = z1("".replace),
  _J = z1([].join),
  xJ = QS && !pJ(function() {
    return jg(function() {}, "length", {
      value: 8
    }).length !== 8
  }),
  EJ = String(String).split("String"),
  kJ = hM.exports = function(t, e, n) {
    wJ(JT(e), 0, 7) === "Symbol(" && (e = "[" + SJ(JT(e), /^Symbol\(([^)]*)\)/, "$1") + "]"), n && n.getter && (e = "get " + e), n && n.setter && (e = "set " + e), (!zp(t, "name") || mJ && t.name !== e) && (QS ? jg(t, "name", {
      value: e,
      configurable: !0
    }) : t.name = e), xJ && n && zp(n, "arity") && t.length !== n.arity && jg(t, "length", {
      value: n.arity
    });
    try {
      n && zp(n, "constructor") && n.constructor ? QS && jg(t, "prototype", {
        writable: !1
      }) : t.prototype && (t.prototype = void 0)
    } catch {}
    var r = vJ(t);
    return zp(r, "source") || (r.source = _J(EJ, typeof e == "string" ? e : "")), t
  };
Function.prototype.toString = kJ(function() {
  return gJ(this) && bJ(this).source || yJ(this)
}, "toString");
var CJ = hM.exports,
  PJ = lr,
  TJ = Pu,
  $J = CJ,
  IJ = D1,
  wM = function(t, e, n, r) {
    r || (r = {});
    var o = r.enumerable,
      s = r.name !== void 0 ? r.name : e;
    if (PJ(n) && $J(n, s, r), r.global) o ? t[e] = n : IJ(e, n);
    else {
      try {
        r.unsafe ? t[e] && (o = !0) : delete t[e]
      } catch {}
      o ? t[e] = n : TJ.f(t, e, {
        value: n,
        enumerable: !1,
        configurable: !r.nonConfigurable,
        writable: !r.nonWritable
      })
    }
    return t
  },
  SM = {},
  OJ = Math.ceil,
  RJ = Math.floor,
  AJ = Math.trunc || function(e) {
    var n = +e;
    return (n > 0 ? RJ : OJ)(n)
  },
  MJ = AJ,
  pc = function(t) {
    var e = +t;
    return e !== e || e === 0 ? 0 : MJ(e)
  },
  jJ = pc,
  DJ = Math.max,
  NJ = Math.min,
  LJ = function(t, e) {
    var n = jJ(t);
    return n < 0 ? DJ(n + e, 0) : NJ(n, e)
  },
  FJ = pc,
  BJ = Math.min,
  _M = function(t) {
    return t > 0 ? BJ(FJ(t), 9007199254740991) : 0
  },
  UJ = _M,
  Ph = function(t) {
    return UJ(t.length)
  },
  zJ = uv,
  HJ = LJ,
  VJ = Ph,
  QT = function(t) {
    return function(e, n, r) {
      var o = zJ(e),
        s = VJ(o),
        i = HJ(r, s),
        a;
      if (t && n != n) {
        for (; s > i;)
          if (a = o[i++], a != a) return !0
      } else
        for (; s > i; i++)
          if ((t || i in o) && o[i] === n) return t || i || 0;
      return !t && -1
    }
  },
  WJ = {
    includes: QT(!0),
    indexOf: QT(!1)
  },
  KJ = vn,
  pb = ia,
  GJ = uv,
  YJ = WJ.indexOf,
  qJ = U1,
  e2 = KJ([].push),
  xM = function(t, e) {
    var n = GJ(t),
      r = 0,
      o = [],
      s;
    for (s in n) !pb(qJ, s) && pb(n, s) && e2(o, s);
    for (; e.length > r;) pb(n, s = e[r++]) && (~YJ(o, s) || e2(o, s));
    return o
  },
  H1 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"],
  XJ = xM,
  ZJ = H1,
  JJ = ZJ.concat("length", "prototype");
SM.f = Object.getOwnPropertyNames || function(e) {
  return XJ(e, JJ)
};
var EM = {};
EM.f = Object.getOwnPropertySymbols;
var QJ = dv,
  eQ = vn,
  tQ = SM,
  nQ = EM,
  rQ = hc,
  oQ = eQ([].concat),
  sQ = QJ("Reflect", "ownKeys") || function(e) {
    var n = tQ.f(rQ(e)),
      r = nQ.f;
    return r ? oQ(n, r(e)) : n
  },
  t2 = ia,
  iQ = sQ,
  aQ = A1,
  cQ = Pu,
  lQ = function(t, e, n) {
    for (var r = iQ(e), o = cQ.f, s = aQ.f, i = 0; i < r.length; i++) {
      var a = r[i];
      !t2(t, a) && !(n && t2(n, a)) && o(t, a, s(e, a))
    }
  },
  uQ = cr,
  dQ = lr,
  fQ = /#|\.prototype\./,
  Th = function(t, e) {
    var n = pQ[hQ(t)];
    return n == mQ ? !0 : n == gQ ? !1 : dQ(e) ? uQ(e) : !!e
  },
  hQ = Th.normalize = function(t) {
    return String(t).replace(fQ, ".").toLowerCase()
  },
  pQ = Th.data = {},
  gQ = Th.NATIVE = "N",
  mQ = Th.POLYFILL = "P",
  yQ = Th,
  gb = xr,
  vQ = A1.f,
  bQ = F1,
  wQ = wM,
  SQ = D1,
  _Q = lQ,
  xQ = yQ,
  Tu = function(t, e) {
    var n = t.target,
      r = t.global,
      o = t.stat,
      s, i, a, c, l, u;
    if (r ? i = gb : o ? i = gb[n] || SQ(n, {}) : i = (gb[n] || {}).prototype, i)
      for (a in e) {
        if (l = e[a], t.dontCallGetSet ? (u = vQ(i, a), c = u && u.value) : c = i[a], s = xQ(r ? a : n + (o ? "." : "#") + a, t.forced), !s && c !== void 0) {
          if (typeof l == typeof c) continue;
          _Q(l, c)
        }(t.sham || c && c.sham) && bQ(l, "sham", !0), wQ(i, a, l, t)
      }
  },
  kM = {},
  EQ = xM,
  kQ = H1,
  CQ = Object.keys || function(e) {
    return EQ(e, kQ)
  },
  PQ = oa,
  TQ = fM,
  $Q = Pu,
  IQ = hc,
  OQ = uv,
  RQ = CQ;
kM.f = PQ && !TQ ? Object.defineProperties : function(e, n) {
  IQ(e);
  for (var r = OQ(n), o = RQ(n), s = o.length, i = 0, a; s > i;) $Q.f(e, a = o[i++], r[a]);
  return e
};
var AQ = dv,
  MQ = AQ("document", "documentElement"),
  jQ = hc,
  DQ = kM,
  n2 = H1,
  NQ = U1,
  LQ = MQ,
  FQ = uM,
  BQ = mM,
  r2 = ">",
  o2 = "<",
  e_ = "prototype",
  t_ = "script",
  CM = BQ("IE_PROTO"),
  mb = function() {},
  PM = function(t) {
    return o2 + t_ + r2 + t + o2 + "/" + t_ + r2
  },
  s2 = function(t) {
    t.write(PM("")), t.close();
    var e = t.parentWindow.Object;
    return t = null, e
  },
  UQ = function() {
    var t = FQ("iframe"),
      e = "java" + t_ + ":",
      n;
    return t.style.display = "none", LQ.appendChild(t), t.src = String(e), n = t.contentWindow.document, n.open(), n.write(PM("document.F=Object")), n.close(), n.F
  },
  Hp, Dg = function() {
    try {
      Hp = new ActiveXObject("htmlfile")
    } catch {}
    Dg = typeof document < "u" ? document.domain && Hp ? s2(Hp) : UQ() : s2(Hp);
    for (var t = n2.length; t--;) delete Dg[e_][n2[t]];
    return Dg()
  };
NQ[CM] = !0;
var TM = Object.create || function(e, n) {
    var r;
    return e !== null ? (mb[e_] = jQ(e), r = new mb, mb[e_] = null, r[CM] = e) : r = Dg(), n === void 0 ? r : DQ.f(r, n)
  },
  zQ = oi,
  HQ = TM,
  VQ = Pu.f,
  n_ = zQ("unscopables"),
  r_ = Array.prototype;
r_[n_] == null && VQ(r_, n_, {
  configurable: !0,
  value: HQ(null)
});
var V1 = function(t) {
    r_[n_][t] = !0
  },
  WQ = Tu,
  KQ = Ch,
  GQ = Ph,
  YQ = pc,
  qQ = V1;
WQ({
  target: "Array",
  proto: !0
}, {
  at: function(e) {
    var n = KQ(this),
      r = GQ(n),
      o = YQ(e),
      s = o >= 0 ? o : r + o;
    return s < 0 || s >= r ? void 0 : n[s]
  }
});
qQ("at");
var XQ = xr,
  ZQ = vn,
  $h = function(t, e) {
    return ZQ(XQ[t].prototype[e])
  },
  JQ = $h;
JQ("Array", "at");
var QQ = ku,
  $M = Array.isArray || function(e) {
    return QQ(e) == "Array"
  },
  eee = TypeError,
  tee = 9007199254740991,
  nee = function(t) {
    if (t > tee) throw eee("Maximum allowed index exceeded");
    return t
  },
  ree = ku,
  oee = vn,
  IM = function(t) {
    if (ree(t) === "Function") return oee(t)
  },
  i2 = IM,
  see = M1,
  iee = cv,
  aee = i2(i2.bind),
  cee = function(t, e) {
    return see(t), e === void 0 ? t : iee ? aee(t, e) : function() {
      return t.apply(e, arguments)
    }
  },
  lee = $M,
  uee = Ph,
  dee = nee,
  fee = cee,
  OM = function(t, e, n, r, o, s, i, a) {
    for (var c = o, l = 0, u = i ? fee(i, a) : !1, d, f; l < r;) l in n && (d = u ? u(n[l], l, e) : n[l], s > 0 && lee(d) ? (f = uee(d), c = OM(t, e, d, f, c, s - 1) - 1) : (dee(c + 1), t[c] = d), c++), l++;
    return c
  },
  RM = OM,
  hee = oi,
  pee = hee("toStringTag"),
  AM = {};
AM[pee] = "z";
var gee = String(AM) === "[object z]",
  mee = gee,
  yee = lr,
  Ng = ku,
  vee = oi,
  bee = vee("toStringTag"),
  wee = Object,
  See = Ng(function() {
    return arguments
  }()) == "Arguments",
  _ee = function(t, e) {
    try {
      return t[e]
    } catch {}
  },
  MM = mee ? Ng : function(t) {
    var e, n, r;
    return t === void 0 ? "Undefined" : t === null ? "Null" : typeof(n = _ee(e = wee(t), bee)) == "string" ? n : See ? Ng(e) : (r = Ng(e)) == "Object" && yee(e.callee) ? "Arguments" : r
  },
  xee = vn,
  Eee = cr,
  jM = lr,
  kee = MM,
  Cee = dv,
  Pee = gM,
  DM = function() {},
  Tee = [],
  NM = Cee("Reflect", "construct"),
  W1 = /^\s*(?:class|function)\b/,
  $ee = xee(W1.exec),
  Iee = !W1.exec(DM),
  ud = function(e) {
    if (!jM(e)) return !1;
    try {
      return NM(DM, Tee, e), !0
    } catch {
      return !1
    }
  },
  LM = function(e) {
    if (!jM(e)) return !1;
    switch (kee(e)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1
    }
    try {
      return Iee || !!$ee(W1, Pee(e))
    } catch {
      return !0
    }
  };
LM.sham = !0;
var Oee = !NM || Eee(function() {
    var t;
    return ud(ud.call) || !ud(Object) || !ud(function() {
      t = !0
    }) || t
  }) ? LM : ud,
  a2 = $M,
  Ree = Oee,
  Aee = fc,
  Mee = oi,
  jee = Mee("species"),
  c2 = Array,
  Dee = function(t) {
    var e;
    return a2(t) && (e = t.constructor, Ree(e) && (e === c2 || a2(e.prototype)) ? e = void 0 : Aee(e) && (e = e[jee], e === null && (e = void 0))), e === void 0 ? c2 : e
  },
  Nee = Dee,
  FM = function(t, e) {
    return new(Nee(t))(e === 0 ? 0 : e)
  },
  Lee = Tu,
  Fee = RM,
  Bee = Ch,
  Uee = Ph,
  zee = pc,
  Hee = FM;
Lee({
  target: "Array",
  proto: !0
}, {
  flat: function() {
    var e = arguments.length ? arguments[0] : void 0,
      n = Bee(this),
      r = Uee(n),
      o = Hee(n, 0);
    return o.length = Fee(o, n, n, r, 0, e === void 0 ? 1 : zee(e)), o
  }
});
var Vee = V1;
Vee("flat");
var Wee = $h;
Wee("Array", "flat");
var Kee = Tu,
  Gee = RM,
  Yee = M1,
  qee = Ch,
  Xee = Ph,
  Zee = FM;
Kee({
  target: "Array",
  proto: !0
}, {
  flatMap: function(e) {
    var n = qee(this),
      r = Xee(n),
      o;
    return Yee(e), o = Zee(n, 0), o.length = Gee(o, n, n, r, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), o
  }
});
var Jee = V1;
Jee("flatMap");
var Qee = $h;
Qee("Array", "flatMap");
var ete = MM,
  tte = String,
  Ih = function(t) {
    if (ete(t) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
    return tte(t)
  },
  nte = Tu,
  rte = vn,
  ote = Cu,
  ste = pc,
  ite = Ih,
  ate = cr,
  cte = rte("".charAt),
  lte = ate(function() {
    return "".at(-2) !== "\uD842"
  });
nte({
  target: "String",
  proto: !0,
  forced: lte
}, {
  at: function(e) {
    var n = ite(ote(this)),
      r = n.length,
      o = ste(e),
      s = o >= 0 ? o : r + o;
    return s < 0 || s >= r ? void 0 : cte(n, s)
  }
});
var ute = $h;
ute("String", "at");
var dte = hc,
  BM = function() {
    var t = dte(this),
      e = "";
    return t.hasIndices && (e += "d"), t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.unicodeSets && (e += "v"), t.sticky && (e += "y"), e
  },
  K1 = cr,
  fte = xr,
  G1 = fte.RegExp,
  Y1 = K1(function() {
    var t = G1("a", "y");
    return t.lastIndex = 2, t.exec("abcd") != null
  }),
  hte = Y1 || K1(function() {
    return !G1("a", "y").sticky
  }),
  pte = Y1 || K1(function() {
    var t = G1("^r", "gy");
    return t.lastIndex = 2, t.exec("str") != null
  }),
  gte = {
    BROKEN_CARET: pte,
    MISSED_STICKY: hte,
    UNSUPPORTED_Y: Y1
  },
  mte = cr,
  yte = xr,
  vte = yte.RegExp,
  bte = mte(function() {
    var t = vte(".", "s");
    return !(t.dotAll && t.exec(`
`) && t.flags === "s")
  }),
  wte = cr,
  Ste = xr,
  _te = Ste.RegExp,
  xte = wte(function() {
    var t = _te("(?<a>b)", "g");
    return t.exec("b").groups.a !== "b" || "b".replace(t, "$<a>c") !== "bc"
  }),
  bl = sa,
  fv = vn,
  Ete = Ih,
  kte = BM,
  Cte = gte,
  Pte = L1,
  Tte = TM,
  $te = vM.get,
  Ite = bte,
  Ote = xte,
  Rte = Pte("native-string-replace", String.prototype.replace),
  Hm = RegExp.prototype.exec,
  o_ = Hm,
  Ate = fv("".charAt),
  Mte = fv("".indexOf),
  jte = fv("".replace),
  yb = fv("".slice),
  s_ = function() {
    var t = /a/,
      e = /b*/g;
    return bl(Hm, t, "a"), bl(Hm, e, "a"), t.lastIndex !== 0 || e.lastIndex !== 0
  }(),
  UM = Cte.BROKEN_CARET,
  i_ = /()??/.exec("")[1] !== void 0,
  Dte = s_ || i_ || UM || Ite || Ote;
Dte && (o_ = function(e) {
  var n = this,
    r = $te(n),
    o = Ete(e),
    s = r.raw,
    i, a, c, l, u, d, f;
  if (s) return s.lastIndex = n.lastIndex, i = bl(o_, s, o), n.lastIndex = s.lastIndex, i;
  var h = r.groups,
    m = UM && n.sticky,
    p = bl(kte, n),
    b = n.source,
    w = 0,
    v = o;
  if (m && (p = jte(p, "y", ""), Mte(p, "g") === -1 && (p += "g"), v = yb(o, n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && Ate(o, n.lastIndex - 1) !== `
`) && (b = "(?: " + b + ")", v = " " + v, w++), a = new RegExp("^(?:" + b + ")", p)), i_ && (a = new RegExp("^" + b + "$(?!\\s)", p)), s_ && (c = n.lastIndex), l = bl(Hm, m ? a : n, v), m ? l ? (l.input = yb(l.input, w), l[0] = yb(l[0], w), l.index = n.lastIndex, n.lastIndex += l[0].length) : n.lastIndex = 0 : s_ && l && (n.lastIndex = n.global ? l.index + l[0].length : c), i_ && l && l.length > 1 && bl(Rte, l[0], a, function() {
      for (u = 1; u < arguments.length - 2; u++) arguments[u] === void 0 && (l[u] = void 0)
    }), l && h)
    for (l.groups = d = Tte(null), u = 0; u < h.length; u++) f = h[u], d[f[0]] = l[f[1]];
  return l
});
var q1 = o_,
  Nte = Tu,
  l2 = q1;
Nte({
  target: "RegExp",
  proto: !0,
  forced: /./.exec !== l2
}, {
  exec: l2
});
var Lte = cv,
  zM = Function.prototype,
  u2 = zM.apply,
  d2 = zM.call,
  Fte = typeof Reflect == "object" && Reflect.apply || (Lte ? d2.bind(u2) : function() {
    return d2.apply(u2, arguments)
  }),
  f2 = IM,
  h2 = wM,
  Bte = q1,
  p2 = cr,
  HM = oi,
  Ute = F1,
  zte = HM("species"),
  vb = RegExp.prototype,
  Hte = function(t, e, n, r) {
    var o = HM(t),
      s = !p2(function() {
        var l = {};
        return l[o] = function() {
          return 7
        }, "" [t](l) != 7
      }),
      i = s && !p2(function() {
        var l = !1,
          u = /a/;
        return t === "split" && (u = {}, u.constructor = {}, u.constructor[zte] = function() {
          return u
        }, u.flags = "", u[o] = /./ [o]), u.exec = function() {
          return l = !0, null
        }, u[o](""), !l
      });
    if (!s || !i || n) {
      var a = f2(/./ [o]),
        c = e(o, "" [t], function(l, u, d, f, h) {
          var m = f2(l),
            p = u.exec;
          return p === Bte || p === vb.exec ? s && !h ? {
            done: !0,
            value: a(u, d, f)
          } : {
            done: !0,
            value: m(d, u, f)
          } : {
            done: !1
          }
        });
      h2(String.prototype, t, c[0]), h2(vb, o, c[1])
    }
    r && Ute(vb[o], "sham", !0)
  },
  X1 = vn,
  Vte = pc,
  Wte = Ih,
  Kte = Cu,
  Gte = X1("".charAt),
  g2 = X1("".charCodeAt),
  Yte = X1("".slice),
  m2 = function(t) {
    return function(e, n) {
      var r = Wte(Kte(e)),
        o = Vte(n),
        s = r.length,
        i, a;
      return o < 0 || o >= s ? t ? "" : void 0 : (i = g2(r, o), i < 55296 || i > 56319 || o + 1 === s || (a = g2(r, o + 1)) < 56320 || a > 57343 ? t ? Gte(r, o) : i : t ? Yte(r, o, o + 2) : (i - 55296 << 10) + (a - 56320) + 65536)
    }
  },
  qte = {
    codeAt: m2(!1),
    charAt: m2(!0)
  },
  Xte = qte.charAt,
  Zte = function(t, e, n) {
    return e + (n ? Xte(t, e).length : 1)
  },
  Z1 = vn,
  Jte = Ch,
  Qte = Math.floor,
  bb = Z1("".charAt),
  ene = Z1("".replace),
  wb = Z1("".slice),
  tne = /\$([$&'`]|\d{1,2}|<[^>]*>)/g,
  nne = /\$([$&'`]|\d{1,2})/g,
  VM = function(t, e, n, r, o, s) {
    var i = n + t.length,
      a = r.length,
      c = nne;
    return o !== void 0 && (o = Jte(o), c = tne), ene(s, c, function(l, u) {
      var d;
      switch (bb(u, 0)) {
        case "$":
          return "$";
        case "&":
          return t;
        case "`":
          return wb(e, 0, n);
        case "'":
          return wb(e, i);
        case "<":
          d = o[wb(u, 1, -1)];
          break;
        default:
          var f = +u;
          if (f === 0) return l;
          if (f > a) {
            var h = Qte(f / 10);
            return h === 0 ? l : h <= a ? r[h - 1] === void 0 ? bb(u, 1) : r[h - 1] + bb(u, 1) : l
          }
          d = r[f - 1]
      }
      return d === void 0 ? "" : d
    })
  },
  y2 = sa,
  rne = hc,
  one = lr,
  sne = ku,
  ine = q1,
  ane = TypeError,
  cne = function(t, e) {
    var n = t.exec;
    if (one(n)) {
      var r = y2(n, t, e);
      return r !== null && rne(r), r
    }
    if (sne(t) === "RegExp") return y2(ine, t, e);
    throw ane("RegExp#exec called on incompatible receiver")
  },
  lne = Fte,
  v2 = sa,
  hv = vn,
  une = Hte,
  dne = cr,
  fne = hc,
  hne = lr,
  pne = lv,
  gne = pc,
  mne = _M,
  Dc = Ih,
  yne = Cu,
  vne = Zte,
  bne = j1,
  wne = VM,
  Sne = cne,
  _ne = oi,
  a_ = _ne("replace"),
  xne = Math.max,
  Ene = Math.min,
  kne = hv([].concat),
  Sb = hv([].push),
  b2 = hv("".indexOf),
  w2 = hv("".slice),
  Cne = function(t) {
    return t === void 0 ? t : String(t)
  },
  Pne = function() {
    return "a".replace(/./, "$0") === "$0"
  }(),
  S2 = function() {
    return /./ [a_] ? /./ [a_]("a", "$0") === "" : !1
  }(),
  Tne = !dne(function() {
    var t = /./;
    return t.exec = function() {
      var e = [];
      return e.groups = {
        a: "7"
      }, e
    }, "".replace(t, "$<a>") !== "7"
  });
une("replace", function(t, e, n) {
  var r = S2 ? "$" : "$0";
  return [function(s, i) {
    var a = yne(this),
      c = pne(s) ? void 0 : bne(s, a_);
    return c ? v2(c, s, a, i) : v2(e, Dc(a), s, i)
  }, function(o, s) {
    var i = fne(this),
      a = Dc(o);
    if (typeof s == "string" && b2(s, r) === -1 && b2(s, "$<") === -1) {
      var c = n(e, i, a, s);
      if (c.done) return c.value
    }
    var l = hne(s);
    l || (s = Dc(s));
    var u = i.global;
    if (u) {
      var d = i.unicode;
      i.lastIndex = 0
    }
    for (var f = [];;) {
      var h = Sne(i, a);
      if (h === null || (Sb(f, h), !u)) break;
      var m = Dc(h[0]);
      m === "" && (i.lastIndex = vne(a, mne(i.lastIndex), d))
    }
    for (var p = "", b = 0, w = 0; w < f.length; w++) {
      h = f[w];
      for (var v = Dc(h[0]), _ = xne(Ene(gne(h.index), a.length), 0), S = [], x = 1; x < h.length; x++) Sb(S, Cne(h[x]));
      var E = h.groups;
      if (l) {
        var k = kne([v], S, _, a);
        E !== void 0 && Sb(k, E);
        var C = Dc(lne(s, void 0, k))
      } else C = wne(v, a, _, S, E, s);
      _ >= b && (p += w2(a, b, _) + C, b = _ + v.length)
    }
    return p + w2(a, b)
  }]
}, !Tne || !Pne || S2);
var $ne = fc,
  Ine = ku,
  One = oi,
  Rne = One("match"),
  Ane = function(t) {
    var e;
    return $ne(t) && ((e = t[Rne]) !== void 0 ? !!e : Ine(t) == "RegExp")
  },
  Mne = sa,
  jne = ia,
  Dne = nM,
  Nne = BM,
  _2 = RegExp.prototype,
  Lne = function(t) {
    var e = t.flags;
    return e === void 0 && !("flags" in _2) && !jne(t, "flags") && Dne(_2, t) ? Mne(Nne, t) : e
  },
  Fne = Tu,
  Bne = sa,
  J1 = vn,
  x2 = Cu,
  Une = lr,
  zne = lv,
  Hne = Ane,
  dd = Ih,
  Vne = j1,
  Wne = Lne,
  Kne = VM,
  Gne = oi,
  Yne = Gne("replace"),
  qne = TypeError,
  WM = J1("".indexOf);
J1("".replace);
var E2 = J1("".slice),
  Xne = Math.max,
  k2 = function(t, e, n) {
    return n > t.length ? -1 : e === "" ? n : WM(t, e, n)
  };
Fne({
  target: "String",
  proto: !0
}, {
  replaceAll: function(e, n) {
    var r = x2(this),
      o, s, i, a, c, l, u, d, f, h = 0,
      m = 0,
      p = "";
    if (!zne(e)) {
      if (o = Hne(e), o && (s = dd(x2(Wne(e))), !~WM(s, "g"))) throw qne("`.replaceAll` does not allow non-global regexes");
      if (i = Vne(e, Yne), i) return Bne(i, e, r, n)
    }
    for (a = dd(r), c = dd(e), l = Une(n), l || (n = dd(n)), u = c.length, d = Xne(1, u), h = k2(a, c, 0); h !== -1;) f = l ? dd(n(c, h, a)) : Kne(c, a, h, [], void 0, n), p += E2(a, m, h) + f, m = h + u, h = k2(a, c, h + d);
    return m < a.length && (p += E2(a, m)), p
  }
});
var Zne = $h;
Zne("String", "replaceAll");
const {
  PI: Jne
} = Math, Nc = Jne + 1e-4;

function Qne(t, e = {}) {
  const {
    size: n = 16,
    smoothing: r = .5,
    start: o = {},
    end: s = {},
    last: i = !1
  } = e, {
    cap: a = !0
  } = o, {
    cap: c = !0
  } = s;
  if (t.length === 0 || n <= 0) return [];
  const l = t[0],
    u = t[t.length - 1],
    d = u.runningLength,
    f = o.taper === !1 ? 0 : o.taper === !0 ? Math.max(n, d) : o.taper,
    h = s.taper === !1 ? 0 : s.taper === !0 ? Math.max(n, d) : s.taper,
    m = Math.pow(n * r, 2),
    p = [],
    b = [];
  let w = t[0].vector,
    v = t[0].point,
    _ = v,
    S = v,
    x = _,
    E = !1,
    k;
  for (let j = 0; j < t.length; j++) {
    k = t[j];
    const {
      point: A,
      vector: D
    } = t[j], N = k.vector.dpr(w), q = (j < t.length - 1 ? t[j + 1] : t[j]).vector, F = j < t.length - 1 ? q.dpr(k.vector) : 1, B = N < 0 && !E, V = F !== null && F < .2;
    if (B || V) {
      if (F > -.62 && d - k.runningLength > k.radius) {
        const ee = w.clone().mul(k.radius);
        w.clone().cpr(q) < 0 ? (S = T.Add(A, ee), x = T.Sub(A, ee)) : (S = T.Sub(A, ee), x = T.Add(A, ee)), p.push(S), b.push(x)
      } else {
        const ee = w.clone().mul(k.radius).per(),
          ye = T.Sub(k.input, ee);
        for (let ge = 1 / 13, ce = 0; ce < 1; ce += ge) S = T.RotWith(ye, k.input, Nc * ce), p.push(S), x = T.RotWith(ye, k.input, Nc + Nc * -ce), b.push(x)
      }
      v = S, _ = x, V && (E = !0);
      continue
    }
    if (E = !1, k === l || k === u) {
      const ee = T.Per(D).mul(k.radius);
      p.push(T.Sub(A, ee)), b.push(T.Add(A, ee));
      continue
    }
    const J = T.Lrp(q, D, F).per().mul(k.radius);
    S = T.Sub(A, J), (j <= 1 || T.Dist2(v, S) > m) && (p.push(S), v = S), x = T.Add(A, J), (j <= 1 || T.Dist2(_, x) > m) && (b.push(x), _ = x), w = D
  }
  const C = l.point,
    $ = t.length > 1 ? t[t.length - 1].point : T.AddXY(l.point, 1, 1);
  if (t.length === 1 && (!(f || h) || i)) {
    const j = T.Add(C, T.Sub(C, $).uni().per().mul(-l.radius)),
      A = [];
    for (let D = 1 / 13, N = D; N <= 1; N += D) A.push(T.RotWith(j, C, Nc * 2 * N));
    return A
  }
  const I = [];
  if (!(f || h && t.length === 1))
    if (a)
      for (let j = 1 / 8, A = j; A <= 1; A += j) {
        const D = T.RotWith(b[0], C, Nc * A);
        I.push(D)
      } else {
        const j = T.Sub(p[0], b[0]),
          A = T.Mul(j, .5),
          D = T.Mul(j, .51);
        I.push(T.Sub(C, A), T.Sub(C, D), T.Add(C, D), T.Add(C, A))
      }
  const R = [],
    M = u.vector.clone().per().neg();
  if (h || f && t.length === 1) R.push($);
  else if (c) {
    const j = T.Add($, T.Mul(M, u.radius));
    for (let A = 1 / 29, D = A; D < 1; D += A) R.push(T.RotWith(j, $, Nc * 3 * D))
  } else R.push(T.Add($, T.Mul(M, u.radius)), T.Add($, T.Mul(M, u.radius * .99)), T.Sub($, T.Mul(M, u.radius * .99)), T.Sub($, T.Mul(M, u.radius)));
  return p.concat(R, b.reverse(), I)
}
const ere = .025,
  tre = .01;

function nre(t, e = {}) {
  var b;
  const {
    streamline: n = .5,
    size: r = 16,
    simulatePressure: o = !1
  } = e;
  if (t.length === 0) return [];
  const s = .15 + (1 - n) * .85;
  let i = t.map(T.From),
    a = 0;
  if (!o) {
    let w = i[0];
    for (; w && !(w.z >= ere);) i.shift(), w = i[0]
  }
  if (!o) {
    let w = i[i.length - 1];
    for (; w && !(w.z >= tre);) i.pop(), w = i[i.length - 1]
  }
  if (i.length === 0) return [{
    point: T.From(t[0]),
    input: T.From(t[0]),
    pressure: o ? .5 : .15,
    vector: new T(1, 1),
    distance: 0,
    runningLength: 0,
    radius: 1
  }];
  let c = i[1];
  for (; c && !(T.Dist(c, i[0]) > r / 3);) i[0].z = Math.max(i[0].z, c.z), i.splice(1, 1), c = i[1];
  const l = i.pop();
  for (c = i[i.length - 1]; c && !(T.Dist(c, l) > r / 3);) i.pop(), c = i[i.length - 1], a++;
  i.push(l);
  const u = e.last || !e.simulatePressure || i.length > 1 && T.Dist(i[i.length - 1], i[i.length - 2]) < r || a > 0;
  if (i.length === 2 && e.simulatePressure) {
    const w = i[1];
    i = i.slice(0, -1);
    for (let v = 1; v < 5; v++) {
      const _ = T.Lrp(i[0], w, v / 4);
      _.z = (i[0].z + (w.z - i[0].z)) * v / 4, i.push(_)
    }
  }
  const d = [{
    point: i[0],
    input: i[0],
    pressure: o ? .5 : i[0].z,
    vector: new T(1, 1),
    distance: 0,
    runningLength: 0,
    radius: 1
  }];
  let f = 0,
    h = d[0],
    m, p;
  u && n > 0 && i.push(i[i.length - 1].clone());
  for (let w = 1, v = i.length; w < v; w++) m = !s || e.last && w === v - 1 ? i[w].clone() : i[w].clone().lrp(h.point, 1 - s), !h.point.equals(m) && (p = T.Dist(m, h.point), f += p, !(w < 4 && f < r) && (h = {
    input: i[w],
    point: m,
    pressure: o ? .5 : i[w].z,
    vector: T.Sub(h.point, m).uni(),
    distance: p,
    runningLength: f,
    radius: 1
  }, d.push(h)));
  if ((b = d[1]) != null && b.vector && (d[0].vector = d[1].vector.clone()), f < 1) {
    const w = Math.max(.5, ...d.map(v => v.pressure));
    d.forEach(v => v.pressure = w)
  }
  return d
}
const {
  min: ui
} = Math, _b = .275;

function rre(t, e) {
  const {
    size: n = 16,
    thinning: r = .5,
    simulatePressure: o = !0,
    easing: s = b => b,
    start: i = {},
    end: a = {}
  } = e, {
    easing: c = Vi.easeOutQuad
  } = i, {
    easing: l = Vi.easeOutCubic
  } = a, u = t[t.length - 1].runningLength;
  let d, f = t[0].pressure,
    h;
  if (!o && u < n) {
    const b = t.reduce((w, v) => Math.max(w, v.pressure), .5);
    return t.forEach(w => {
      w.pressure = b, w.radius = n * s(.5 - r * (.5 - w.pressure))
    }), t
  } else {
    let b;
    for (let w = 0, v = t.length; w < v && (h = t[w], !(h.runningLength > n * 5)); w++) {
      const _ = ui(1, h.distance / n);
      if (o) {
        const S = ui(1, 1 - _);
        b = ui(1, f + (S - f) * (_ * _b))
      } else b = ui(1, f + (h.pressure - f) * .5);
      f = f + (b - f) * .5
    }
    for (let w = 0; w < t.length; w++) {
      if (h = t[w], r) {
        let {
          pressure: v
        } = h;
        const _ = ui(1, h.distance / n);
        if (o) {
          const S = ui(1, 1 - _);
          v = ui(1, f + (S - f) * (_ * _b))
        } else v = ui(1, f + (v - f) * (_ * _b));
        h.radius = n * s(.5 - r * (.5 - v)), f = v
      } else h.radius = n / 2;
      d === void 0 && (d = h.radius)
    }
  }
  const m = i.taper === !1 ? 0 : i.taper === !0 ? Math.max(n, u) : i.taper,
    p = a.taper === !1 ? 0 : a.taper === !0 ? Math.max(n, u) : a.taper;
  if (m || p)
    for (let b = 0; b < t.length; b++) {
      h = t[b];
      const {
        runningLength: w
      } = h, v = w < m ? c(w / m) : 1, _ = u - w < p ? l((u - w) / p) : 1;
      h.radius = Math.max(.01, h.radius * Math.min(v, _))
    }
  return t
}

function lo() {
  const t = Y();
  return te("isReadonlyMode", () => t.getInstanceState().isReadonly, [t])
}

function ore({
  size: t,
  width: e,
  height: n,
  hideAlternateHandles: r
}) {
  const o = U(t / 3),
    s = o / 2;
  return y.jsxs("svg", {
    className: "tl-overlays__item",
    children: [y.jsx("polyline", {
      className: "tl-corner-crop-handle",
      points: `
						${U(0-s)},${U(t)} 
						${U(0-s)},${U(0-s)} 
						${U(t)},${U(0-s)}`,
      strokeWidth: o,
      "data-testid": "selection.crop.top_left",
      "aria-label": "top_left handle"
    }), y.jsx("line", {
      className: ae("tl-corner-crop-edge-handle", {
        "tl-hidden": r
      }),
      x1: U(e / 2 - t),
      y1: U(0 - s),
      x2: U(e / 2 + t),
      y2: U(0 - s),
      strokeWidth: o,
      "data-testid": "selection.crop.top",
      "aria-label": "top handle"
    }), y.jsx("polyline", {
      className: ae("tl-corner-crop-handle", {
        "tl-hidden": r
      }),
      points: `
						${U(e-t)},${U(0-s)} 
						${U(e+s)},${U(0-s)} 
						${U(e+s)},${U(t)}`,
      strokeWidth: o,
      "data-testid": "selection.crop.top_right",
      "aria-label": "top_right handle"
    }), y.jsx("line", {
      className: ae("tl-corner-crop-edge-handle", {
        "tl-hidden": r
      }),
      x1: U(e + s),
      y1: U(n / 2 - t),
      x2: U(e + s),
      y2: U(n / 2 + t),
      strokeWidth: o,
      "data-testid": "selection.crop.right",
      "aria-label": "right handle"
    }), y.jsx("polyline", {
      className: "tl-corner-crop-handle",
      points: `
						${U(e+s)},${U(n-t)} 
						${U(e+s)},${U(n+s)}
						${U(e-t)},${U(n+s)}`,
      strokeWidth: o,
      "data-testid": "selection.crop.bottom_right",
      "aria-label": "bottom_right handle"
    }), y.jsx("line", {
      className: ae("tl-corner-crop-edge-handle", {
        "tl-hidden": r
      }),
      x1: U(e / 2 - t),
      y1: U(n + s),
      x2: U(e / 2 + t),
      y2: U(n + s),
      strokeWidth: o,
      "data-testid": "selection.crop.bottom",
      "aria-label": "bottom handle"
    }), y.jsx("polyline", {
      className: ae("tl-corner-crop-handle", {
        "tl-hidden": r
      }),
      points: `
						${U(0+t)},${U(n+s)} 
						${U(0-s)},${U(n+s)}
						${U(0-s)},${U(n-t)}`,
      strokeWidth: o,
      "data-testid": "selection.crop.bottom_left",
      "aria-label": "bottom_left handle"
    }), y.jsx("line", {
      className: ae("tl-corner-crop-edge-handle", {
        "tl-hidden": r
      }),
      x1: U(0 - s),
      y1: U(n / 2 - t),
      x2: U(0 - s),
      y2: U(n / 2 + t),
      strokeWidth: o,
      "data-testid": "selection.crop.left",
      "aria-label": "left handle"
    })]
  })
}
const H0e = pt(function({
    bounds: e,
    rotation: n
  }) {
    const r = Y(),
      o = g.useRef(null),
      s = lo(),
      i = es("top"),
      a = es("right"),
      c = es("bottom"),
      l = es("left"),
      u = es("top_left"),
      d = es("top_right"),
      f = es("bottom_right"),
      h = es("bottom_left"),
      m = !r.getIsMenuOpen() && r.getInstanceState().cursor.type === "default",
      p = r.getInstanceState().isCoarsePointer,
      b = r.getSelectedShapes(),
      w = r.getOnlySelectedShape(),
      v = w && r.isShapeOrAncestorLocked(w),
      _ = w ? r.getShapeUtil(w).expandSelectionOutlinePx(w) : 0;
    if (_u(o, e == null ? void 0 : e.x, e == null ? void 0 : e.y, 1, r.getSelectionRotation(), {
        x: -_,
        y: -_
      }), !e) return null;
    e = e.clone().expandBy(_).zeroFix();
    const S = r.zoomLevel,
      x = r.getInstanceState().isChangingStyle,
      E = e.width,
      k = e.height,
      C = 8 / S,
      $ = E < C * 2,
      I = k < C * 2,
      R = E < C * 4,
      M = k < C * 4,
      j = E < C * 5,
      A = k < C * 5,
      D = p ? 1.75 : 1,
      N = 6 / S * D,
      q = (R ? N / 2 : N) * (D * .75),
      F = (M ? N / 2 : N) * (D * .75),
      B = (w ? !r.getShapeUtil(w).hideSelectionBoundsFg(w) : !0) && !x;
    let V = B && r.isInAny("select.idle", "select.brushing", "select.scribble_brushing", "select.pointing_canvas", "select.pointing_selection", "select.pointing_shape", "select.crop.idle", "select.crop.pointing_crop", "select.pointing_resize_handle", "select.pointing_crop_handle") || B && r.isIn("select.resizing") && w && r.isShapeOfType(w, "text");
    w && V && r.environment.isFirefox && r.isShapeOfType(w, "embed") && (V = !1);
    const J = r.isInAny("select.pointing_crop_handle", "select.crop.idle", "select.crop.pointing_crop") && !x && !s,
      ee = r.isInAny("select.idle", "select.pointing_selection", "select.pointing_shape", "select.crop.idle") && !x && !s,
      ye = !p && !($ || I) && (ee || J) && (w ? !r.getShapeUtil(w).hideRotateHandle(w) : !0) && !v,
      ge = p && (!R || !M) && (ee || J) && (w ? !r.getShapeUtil(w).hideRotateHandle(w) : !0) && !v,
      ce = ee && (w ? r.getShapeUtil(w).canResize(w) && !r.getShapeUtil(w).hideResizeHandles(w) : !0) && !J && !v,
      Ce = $ || I,
      oe = $ && I,
      pe = j || A,
      _e = ce || J,
      xe = !ye,
      Me = !ee || !ge,
      Le = !ee || !_e,
      gt = !ee || !_e || Ce,
      Ze = !ee || !_e || Ce,
      xt = !ee || !_e || oe && !J;
    let An = p;
    An && b.every(Zn => r.getShapeUtil(Zn).isAspectRatioLocked(Zn)) && (An = !1);
    let ln = !0;
    J ? ln = pe : ce && (ln = Ce || oe || An);
    const bn = Math.min(24 / S, k - F * 3),
      Go = ee && p && w && r.isShapeOfType(w, "text") && bn * S >= 4;
    return y.jsx("svg", {
      className: "tl-overlays__item tl-selection__fg tl-svg-context",
      "data-testid": "selection-foreground",
      children: y.jsxs("g", {
        ref: o,
        children: [V && y.jsx("rect", {
          className: ae("tl-selection__fg__outline"),
          width: U(E),
          height: U(k)
        }), y.jsx(Vp, {
          "data-testid": "selection.rotate.top-left",
          cx: 0,
          cy: 0,
          targetSize: N,
          corner: "top_left_rotate",
          cursor: m ? Ir("nwse-rotate", n) : void 0,
          isHidden: xe
        }), y.jsx(Vp, {
          "data-testid": "selection.rotate.top-right",
          cx: E + N * 3,
          cy: 0,
          targetSize: N,
          corner: "top_right_rotate",
          cursor: m ? Ir("nesw-rotate", n) : void 0,
          isHidden: xe
        }), y.jsx(Vp, {
          "data-testid": "selection.rotate.bottom-left",
          cx: 0,
          cy: k + N * 3,
          targetSize: N,
          corner: "bottom_left_rotate",
          cursor: m ? Ir("swne-rotate", n) : void 0,
          isHidden: xe
        }), y.jsx(Vp, {
          "data-testid": "selection.rotate.bottom-right",
          cx: E + N * 3,
          cy: k + N * 3,
          targetSize: N,
          corner: "bottom_right_rotate",
          cursor: m ? Ir("senw-rotate", n) : void 0,
          isHidden: xe
        }), y.jsx(ire, {
          "data-testid": "selection.rotate.mobile",
          cx: R ? -N * 1.5 : E / 2,
          cy: R ? k / 2 : -N * 1.5,
          size: C,
          isHidden: Me
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": ln
          }),
          "data-testid": "selection.resize.top",
          "aria-label": "top target",
          pointerEvents: "all",
          x: 0,
          y: U(0 - (M ? F * 2 : F)),
          width: U(E),
          height: U(Math.max(1, F * 2)),
          style: m ? {
            cursor: Ir("ns-resize", n)
          } : void 0,
          ...i
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": ln
          }),
          "data-testid": "selection.resize.right",
          "aria-label": "right target",
          pointerEvents: "all",
          x: U(E - (R ? 0 : q)),
          y: 0,
          height: U(k),
          width: U(Math.max(1, q * 2)),
          style: m ? {
            cursor: Ir("ew-resize", n)
          } : void 0,
          ...a
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": ln
          }),
          "data-testid": "selection.resize.bottom",
          "aria-label": "bottom target",
          pointerEvents: "all",
          x: 0,
          y: U(k - (M ? 0 : F)),
          width: U(E),
          height: U(Math.max(1, F * 2)),
          style: m ? {
            cursor: Ir("ns-resize", n)
          } : void 0,
          ...c
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": ln
          }),
          "data-testid": "selection.resize.left",
          "aria-label": "left target",
          pointerEvents: "all",
          x: U(0 - (R ? q * 2 : q)),
          y: 0,
          height: U(k),
          width: U(Math.max(1, q * 2)),
          style: m ? {
            cursor: Ir("ew-resize", n)
          } : void 0,
          ...l
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": Le
          }),
          "data-testid": "selection.target.top-left",
          "aria-label": "top-left target",
          pointerEvents: "all",
          x: U(0 - (R ? q * 2 : q * 1.5)),
          y: U(0 - (M ? F * 2 : F * 1.5)),
          width: U(q * 3),
          height: U(F * 3),
          style: m ? {
            cursor: Ir("nwse-resize", n)
          } : void 0,
          ...u
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": gt
          }),
          "data-testid": "selection.target.top-right",
          "aria-label": "top-right target",
          pointerEvents: "all",
          x: U(E - (R ? 0 : q * 1.5)),
          y: U(0 - (M ? F * 2 : F * 1.5)),
          width: U(q * 3),
          height: U(F * 3),
          style: m ? {
            cursor: Ir("nesw-resize", n)
          } : void 0,
          ...d
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": xt
          }),
          "data-testid": "selection.target.bottom-right",
          "aria-label": "bottom-right target",
          pointerEvents: "all",
          x: U(E - (R ? q : q * 1.5)),
          y: U(k - (M ? F : F * 1.5)),
          width: U(q * 3),
          height: U(F * 3),
          style: m ? {
            cursor: Ir("nwse-resize", n)
          } : void 0,
          ...f
        }), y.jsx("rect", {
          className: ae("tl-transparent", {
            "tl-hidden": Ze
          }),
          "data-testid": "selection.target.bottom-left",
          "aria-label": "bottom-left target",
          pointerEvents: "all",
          x: U(0 - (R ? q * 3 : q * 1.5)),
          y: U(k - (M ? 0 : F * 1.5)),
          width: U(q * 3),
          height: U(F * 3),
          style: m ? {
            cursor: Ir("nesw-resize", n)
          } : void 0,
          ...h
        }), ce && y.jsxs(y.Fragment, {
          children: [y.jsx("rect", {
            "data-testid": "selection.resize.top-left",
            className: ae("tl-corner-handle", {
              "tl-hidden": Le
            }),
            "aria-label": "top_left handle",
            x: U(0 - C / 2),
            y: U(0 - C / 2),
            width: U(C),
            height: U(C)
          }), y.jsx("rect", {
            "data-testid": "selection.resize.top-right",
            className: ae("tl-corner-handle", {
              "tl-hidden": gt
            }),
            "aria-label": "top_right handle",
            x: U(E - C / 2),
            y: U(0 - C / 2),
            width: U(C),
            height: U(C)
          }), y.jsx("rect", {
            "data-testid": "selection.resize.bottom-right",
            className: ae("tl-corner-handle", {
              "tl-hidden": xt
            }),
            "aria-label": "bottom_right handle",
            x: U(E - C / 2),
            y: U(k - C / 2),
            width: U(C),
            height: U(C)
          }), y.jsx("rect", {
            "data-testid": "selection.resize.bottom-left",
            className: ae("tl-corner-handle", {
              "tl-hidden": Ze
            }),
            "aria-label": "bottom_left handle",
            x: U(0 - C / 2),
            y: U(k - C / 2),
            width: U(C),
            height: U(C)
          })]
        }), Go && y.jsxs(y.Fragment, {
          children: [y.jsx("rect", {
            "data-testid": "selection.text-resize.left.handle",
            className: "tl-text-handle",
            "aria-label": "bottom_left handle",
            x: U(0 - C / 4),
            y: U(k / 2 - bn / 2),
            rx: C / 4,
            width: U(C / 2),
            height: U(bn)
          }), y.jsx("rect", {
            "data-testid": "selection.text-resize.right.handle",
            className: "tl-text-handle",
            "aria-label": "bottom_left handle",
            rx: C / 4,
            x: U(E - C / 4),
            y: U(k / 2 - bn / 2),
            width: U(C / 2),
            height: U(bn)
          })]
        }), J && y.jsx(ore, {
          size: C,
          width: E,
          height: k,
          hideAlternateHandles: pe
        })]
      })
    })
  }),
  Vp = function({
    cx: e,
    cy: n,
    targetSize: r,
    corner: o,
    cursor: s,
    isHidden: i,
    "data-testid": a
  }) {
    const c = es(o);
    return y.jsx("rect", {
      className: ae("tl-transparent", "tl-rotate-corner", {
        "tl-hidden": i
      }),
      "data-testid": a,
      "aria-label": `${o} target`,
      pointerEvents: "all",
      x: U(e - r * 3),
      y: U(n - r * 3),
      width: U(Math.max(1, r * 3)),
      height: U(Math.max(1, r * 3)),
      cursor: s,
      ...c
    })
  },
  sre = Math.sqrt(Math.PI),
  ire = function({
    cx: e,
    cy: n,
    size: r,
    isHidden: o,
    "data-testid": s
  }) {
    const i = es("mobile_rotate"),
      a = Y(),
      c = te("zoom level", () => a.zoomLevel, [a]),
      l = Math.max(14 * (1 / c), 20 / Math.max(1, c));
    return y.jsxs("g", {
      children: [y.jsx("circle", {
        "data-testid": s,
        pointerEvents: "all",
        className: ae("tl-transparent", "tl-mobile-rotate__bg", {
          "tl-hidden": o
        }),
        cx: e,
        cy: n,
        r: l,
        ...i
      }), y.jsx("circle", {
        className: ae("tl-mobile-rotate__fg", {
          "tl-hidden": o
        }),
        cx: e,
        cy: n,
        r: r / sre
      })]
    })
  },
  c_ = {
    lineHeight: 1.35,
    fontWeight: "normal",
    fontVariant: "normal",
    fontStyle: "normal",
    padding: "0px"
  },
  V0e = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  },
  W0e = {
    s: 18,
    m: 24,
    l: 36,
    xl: 44
  },
  C2 = {
    s: 18,
    m: 22,
    l: 26,
    xl: 32
  },
  P2 = {
    s: 18,
    m: 20,
    l: 24,
    xl: 28
  },
  K0e = {
    draw: "var(--tl-font-draw)",
    sans: "var(--tl-font-sans)",
    serif: "var(--tl-font-serif)",
    mono: "var(--tl-font-mono)"
  };
var KM = {
  exports: {}
};
(function(t) {
  (function(e, n) {
    t.exports ? t.exports = n() : e.downscale = n()
  })(hn, function() {
    function e(C, w, v, _, S, x, E, k) {
      var C = document.createElement("canvas");
      C.width = v, C.height = _;
      var $ = C.getContext("2d");
      return $.mozImageSmoothingEnabled = !0, $.imageSmoothingQuality = "high", $.webkitImageSmoothingEnabled = !0, $.msImageSmoothingEnabled = !0, $.imageSmoothingEnabled = !0, $.drawImage(w, S, x, E, k, 0, 0, v, _), C
    }

    function n(b) {
      return b + .49 << 0
    }

    function r(b, w, v, _, S, x, E) {
      for (var k = new ImageData(w, v), C = new Int32Array(b.data.buffer), $ = b.width, I = new Int32Array(k.data.buffer), R = k.width, M = w / x, j = v / E, A = n(1 / M), D = n(1 / j), N = A * D, q = 0; q < k.height; q++)
        for (var F = 0; F < R; F++) {
          for (var B = _ + n(F / M) + (S + n(q / j)) * $, V = 0, J = 0, ee = 0, ye = 0, ge = 0; ge < D; ge++)
            for (var ce = 0; ce < A; ce++) {
              var Ce = C[B + ce + ge * $];
              V += Ce << 24 >>> 24, J += Ce << 16 >>> 24, ee += Ce << 8 >>> 24, ye += Ce >>> 24
            }
          V = n(V / N), J = n(J / N), ee = n(ee / N), ye = n(ye / N), I[F + q * R] = ye << 24 | ee << 16 | J << 8 | V
        }
      return k
    }

    function o(b, w, v, _) {
      var S = new Date,
        x = {},
        E = S,
        k = "01";
      return {
        mark: b ? function(C) {
          C = k + ". " + (C || "..."), x[C] = {
            "time (ms)": new Date - E
          }, E = new Date, k = ("0" + ((k >> 0) + 1)).substr(-2)
        } : new Function,
        finish: b ? function() {
          x[k + " TOTAL"] = {
            "time (ms)": new Date - S
          }, console.log("IMAGE SOURCE:", w), console.log("DOWNSCALE TO:", v + "x" + _), console.table(x)
        } : new Function
      }
    }

    function s() {
      var b = [],
        w = [],
        v = [],
        _ = new Object;
      return {
        createSetter: function(S) {
          if (!this.get(S)) {
            var x = b.push(S) - 1;
            return w.push(_), v.push([]),
              function(E) {
                w[x] = E, v[x] = v[x].reduce(function(k, C) {
                  C(E)
                }, [])
              }
          }
        },
        get: function(S, x) {
          var E = b.indexOf(S);
          if (~E) {
            if (w[E] === _) {
              v[E].push(x);
              return
            }
            x(w[E])
          }
        },
        has: function(S) {
          return !!~b.indexOf(S)
        }
      }
    }

    function i(b, w, v, _) {
      b.width = v, b.height = _;
      var S = b.getContext("2d");
      return S.drawImage(w, 0, 0), S.getImageData(0, 0, v, _)
    }

    function a(b, w) {
      b.width = w.width, b.height = w.height;
      var v = b.getContext("2d");
      return v.putImageData(w, 0, 0), b
    }

    function c(b, w, I, R, S, x) {
      var E = S,
        k = x,
        C = S / x;
      b === 0 && (b = w * C >> 0), w === 0 && (w = b / C >> 0);
      var $ = b / w;
      $ > C ? x = S / $ >> 0 : S = x * $ >> 0;
      var I = I || (E - S) / 2 >> 0,
        R = R || (k - x) / 2 >> 0;
      return {
        destWidth: b,
        destHeight: w,
        sourceX: I,
        sourceY: R,
        sourceWidth: S,
        sourceHeight: x
      }
    }

    function l(b, w, v) {
      if (w.returnCanvas) {
        v(b);
        return
      }
      if (w.returnBlob) {
        b.toBlob(v, "image/" + (w.imageType || "jpeg"), w.quality || .85);
        return
      }
      var _ = b.toDataURL("image/" + (w.imageType || "jpeg"), w.quality || .85);
      v(_)
    }

    function u(b, w) {
      var v = new XMLHttpRequest;
      v.open("GET", b), v.responseType = "arraybuffer", v.addEventListener("load", function() {
        w(this.response)
      }), v.send()
    }

    function d(b, w) {
      b.complete ? w() : b.addEventListener("load", w)
    }

    function f(b, w) {
      b.readyState > 1 ? w() : b.addEventListener("loadeddata", w)
    }

    function h(b) {
      if (b instanceof File) return "File";
      if (b instanceof HTMLImageElement) return "HTMLImageElement";
      if (b instanceof HTMLVideoElement) return "HTMLVideoElement";
      if (typeof b == "string") return "URL"
    }

    function m(b) {
      if (b.length < 3) return new TypeError("3 arguments required, but only " + b.length + " present.");
      if (!h(b[0])) return new TypeError("First argument should be HTMLImageElement, HTMLVideoElement, File of String");
      if (typeof b[1] != "number") return new TypeError("Second argument should be a number");
      if (typeof b[2] != "number") return new TypeError("Third argument should be a number")
    }

    function p(b, w, v, _) {
      var S = o(_ && _.debug || !1, b, w, v),
        x = m(arguments);
      if (x instanceof TypeError) return Promise.reject(x);
      _ = _ || {};
      var E, k = new Promise(function(j, A) {
        E = j
      });
      p.canvas = p.canvas || document.createElement("canvas"), p.cache = p.cache || s();
      var C = p.canvas,
        $ = p.cache;
      if ($.has(b)) return S.mark(), $.get(b, function(j) {
        S.mark("PENDING CACHE");
        var A = j[0],
          D = j[1],
          N = c(w, v, _.sourceX, _.sourceY, D.width, D.height);
        if (N.sourceWidth / N.destWidth >= 2 && N.sourceHeight / N.destHeight >= 2) {
          S.mark();
          var q = r(D, N.destWidth, N.destHeight, N.sourceX, N.sourceY, N.sourceWidth, N.sourceHeight);
          S.mark("DOWNSCALE"), C = a(C, q)
        } else C = e(C, A, N.destWidth, N.destHeight, N.sourceX, N.sourceY, N.sourceWidth, N.sourceHeight), S.mark("RESIZE WITH CANVAS");
        l(C, _, function(F) {
          S.mark("PRODUCE RESULT"), E(F), S.finish()
        })
      }), k;
      var I = function(j, A, D) {
          var N = c(w, v, _.sourceX, _.sourceY, A, D);
          if (N.sourceWidth / N.destWidth >= 2 && N.sourceHeight / N.destHeight >= 2) {
            S.mark();
            var q = i(C, j, A, D);
            S.mark("GET IMAGE DATA");
            var F = r(q, N.destWidth, N.destHeight, N.sourceX, N.sourceY, N.sourceWidth, N.sourceHeight);
            S.mark("DOWNSCALE"), C = a(C, F), h(j) !== "HTMLVideoElement" && $.createSetter(j)([j, q])
          } else C = e(C, j, N.destWidth, N.destHeight, N.sourceX, N.sourceY, N.sourceWidth, N.sourceHeight), S.mark("RESIZE WITH CANVAS");
          l(C, _, function(B) {
            S.mark("PRODUCE RESULT"), E(B), S.finish()
          })
        },
        R = window.URL || window.webkitURL;
      switch (h(b)) {
        case "File":
          var M = document.createElement("img");
          S.mark(), M.src = R.createObjectURL(b), S.mark("READ FILE"), d(M, function() {
            S.mark("LOAD IMAGE"), I(M, M.naturalWidth, M.naturalHeight)
          });
          break;
        case "HTMLImageElement":
          S.mark(), d(b, function() {
            S.mark("LOAD IMAGE"), I(b, b.naturalWidth, b.naturalHeight)
          });
          break;
        case "HTMLVideoElement":
          f(b, function() {
            I(b, b.videoWidth, b.videoHeight)
          });
          break;
        case "URL":
          S.mark(), setTimeout(function() {
            u(b, function(j) {
              S.mark("LOAD ARRAY BUFFER");
              var A = new Uint8Array(j),
                D = new Blob([A], {
                  type: "image/jpeg"
                }),
                N = document.createElement("img");
              N.src = R.createObjectURL(D), S.mark(), d(N, function() {
                S.mark("LOAD IMAGE"), I(N, N.naturalWidth, N.naturalHeight)
              })
            })
          });
          break
      }
      return k
    }
    return p
  })
})(KM);
var are = KM.exports;
const G0e = co(are);
/*!
 * canvas-size
 * v1.2.6
 * https://github.com/jhildenbiddle/canvas-size
 * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>
 * MIT license
 */
function cre(t, e) {
  var n = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (n != null) {
    var r, o, s, i, a = [],
      c = !0,
      l = !1;
    try {
      if (s = (n = n.call(t)).next, e === 0) {
        if (Object(n) !== n) return;
        c = !1
      } else
        for (; !(c = (r = s.call(n)).done) && (a.push(r.value), a.length !== e); c = !0);
    } catch (u) {
      l = !0, o = u
    } finally {
      try {
        if (!c && n.return != null && (i = n.return(), Object(i) !== i)) return
      } finally {
        if (l) throw o
      }
    }
    return a
  }
}

function T2(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable
    })), n.push.apply(n, r)
  }
  return n
}

function Or(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? T2(Object(n), !0).forEach(function(r) {
      lre(t, r, n[r])
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : T2(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r))
    })
  }
  return t
}

function lre(t, e, n) {
  return e = vre(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t
}

function ure(t, e) {
  if (t == null) return {};
  var n = {},
    r = Object.keys(t),
    o, s;
  for (s = 0; s < r.length; s++) o = r[s], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n
}

function dre(t, e) {
  if (t == null) return {};
  var n = ure(t, e),
    r, o;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    for (o = 0; o < s.length; o++) r = s[o], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r])
  }
  return n
}

function $2(t, e) {
  return hre(t) || cre(t, e) || GM(t, e) || mre()
}

function Wp(t) {
  return fre(t) || pre(t) || GM(t) || gre()
}

function fre(t) {
  if (Array.isArray(t)) return l_(t)
}

function hre(t) {
  if (Array.isArray(t)) return t
}

function pre(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t)
}

function GM(t, e) {
  if (t) {
    if (typeof t == "string") return l_(t, e);
    var n = Object.prototype.toString.call(t).slice(8, -1);
    if (n === "Object" && t.constructor && (n = t.constructor.name), n === "Map" || n === "Set") return Array.from(t);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return l_(t, e)
  }
}

function l_(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var n = 0, r = new Array(e); n < e; n++) r[n] = t[n];
  return r
}

function gre() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function mre() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function yre(t, e) {
  if (typeof t != "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.")
  }
  return (e === "string" ? String : Number)(t)
}

function vre(t) {
  var e = yre(t, "string");
  return typeof e == "symbol" ? e : String(e)
}

function Zd(t) {
  var e = t.sizes.shift(),
    n = Math.max(Math.ceil(e[0]), 1),
    r = Math.max(Math.ceil(e[1]), 1),
    o = [n - 1, r - 1, 1, 1],
    s = Date.now(),
    i = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope,
    a, c;
  i ? (a = new OffscreenCanvas(1, 1), c = new OffscreenCanvas(n, r)) : (a = document.createElement("canvas"), a.width = 1, a.height = 1, c = document.createElement("canvas"), c.width = n, c.height = r);
  var l = a.getContext("2d"),
    u = c.getContext("2d");
  u && (u.fillRect.apply(u, o), l.drawImage(c, n - 1, r - 1, 1, 1, 0, 0, 1, 1));
  var d = l && l.getImageData(0, 0, 1, 1).data[3] !== 0,
    f = Date.now() - s;
  return [a, c].forEach(function(h) {
    h.height = 0, h.width = 0
  }), i ? (postMessage({
    width: n,
    height: r,
    benchmark: f,
    isTestPass: d
  }), !d && t.sizes.length && Zd(t)) : d ? t.onSuccess(n, r, f) : (t.onError(n, r, f), t.sizes.length && Zd(t)), d
}
var xb = {
    area: [16384, 14188, 11402, 11180, 10836, 8192, 4096, 1],
    height: [8388607, 65535, 32767, 16384, 8192, 4096, 1],
    width: [4194303, 65535, 32767, 16384, 8192, 4096, 1]
  },
  bre = ["onError", "onSuccess"],
  wl = {
    max: null,
    min: 1,
    sizes: [],
    step: 1024,
    usePromise: !1,
    useWorker: !1,
    onError: Function.prototype,
    onSuccess: Function.prototype
  },
  fd = {};

function Eb(t) {
  var e = t.width === t.height,
    n = t.height === 1,
    r = t.width === 1,
    o = [];
  if (!t.width || !t.height) t.sizes.forEach(function(u) {
    var d = e || n ? u : 1,
      f = e || r ? u : 1;
    o.push([d, f])
  });
  else
    for (var s = t.min || wl.min, i = t.step || wl.step, a = Math.max(t.width, t.height); a >= s;) {
      var c = e || n ? a : 1,
        l = e || r ? a : 1;
      o.push([c, l]), a -= i
    }
  return o
}

function Kp(t) {
  var e = window && "HTMLCanvasElement" in window,
    n = window && "OffscreenCanvas" in window,
    r = Date.now(),
    o = t.onError,
    s = t.onSuccess,
    i = dre(t, bre),
    a = null;
  if (!e) return !1;
  if (t.useWorker && n) {
    var c = `
            var canvasTest = `.concat(Zd.toString(), `;
            onmessage = function(e) {
                canvasTest(e.data);
            };
        `),
      l = new Blob([c], {
        type: "application/javascript"
      }),
      u = URL.createObjectURL(l);
    a = new Worker(u), URL.revokeObjectURL(u), a.onmessage = function(d) {
      var f = d.data,
        h = f.width,
        m = f.height,
        p = f.benchmark,
        b = f.isTestPass;
      b ? (fd[r].onSuccess(h, m, p), delete fd[r]) : fd[r].onError(h, m, p)
    }
  }
  if (t.usePromise) return new Promise(function(d, f) {
    var h = Or(Or({}, t), {}, {
      onError: function(w, v, _) {
        var S;
        if (t.sizes.length === 0) S = !0;
        else {
          var x = t.sizes.slice(-1),
            E = $2(x, 1),
            k = $2(E[0], 2),
            C = k[0],
            $ = k[1];
          S = w === C && v === $
        }
        o(w, v, _), S && f({
          width: w,
          height: v,
          benchmark: _
        })
      },
      onSuccess: function(w, v, _) {
        s(w, v, _), d({
          width: w,
          height: v,
          benchmark: _
        })
      }
    });
    if (a) {
      var m = h.onError,
        p = h.onSuccess;
      fd[r] = {
        onError: m,
        onSuccess: p
      }, a.postMessage(i)
    } else Zd(h)
  });
  if (a) fd[r] = {
    onError: o,
    onSuccess: s
  }, a.postMessage(i);
  else return Zd(t)
}
var kb = {
  maxArea: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = Eb({
        width: e.max,
        height: e.max,
        min: e.min,
        step: e.step,
        sizes: Wp(xb.area)
      }),
      r = Or(Or(Or({}, wl), e), {}, {
        sizes: n
      });
    return Kp(r)
  },
  maxHeight: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = Eb({
        width: 1,
        height: e.max,
        min: e.min,
        step: e.step,
        sizes: Wp(xb.height)
      }),
      r = Or(Or(Or({}, wl), e), {}, {
        sizes: n
      });
    return Kp(r)
  },
  maxWidth: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = Eb({
        width: e.max,
        height: 1,
        min: e.min,
        step: e.step,
        sizes: Wp(xb.width)
      }),
      r = Or(Or(Or({}, wl), e), {}, {
        sizes: n
      });
    return Kp(r)
  },
  test: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      n = Or(Or({}, wl), e);
    return n.sizes = Wp(n.sizes), n.width && n.height && (n.sizes = [
      [n.width, n.height]
    ]), Kp(n)
  }
};
let Cb = null;

function wre() {
  return Cb || (Cb = Sre()), Cb
}
async function Sre() {
  const t = await kb.maxWidth({
      usePromise: !0
    }),
    e = await kb.maxHeight({
      usePromise: !0
    }),
    n = await kb.maxArea({
      usePromise: !0
    });
  return {
    maxWidth: t.width,
    maxHeight: e.height,
    maxArea: n.width * n.height
  }
}

function _re(t) {
  if (typeof t != "string") throw new TypeError("Expected a string");
  return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")
}

function xre(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of nu)
    if (YM(n.hostnames, e)) {
      const r = n.fromEmbedUrl(t);
      if (r) return {
        definition: n,
        url: r,
        embedUrl: t
      }
    }
}
const Ere = t => t.split("*").map(e => _re(e)).join(".+"),
  YM = (t, e) => !!t.find(n => {
    const r = new RegExp(Ere(n));
    return e.match(r)
  });

function kre(t) {
  const e = new URL(t).host.replace("www.", "");
  for (const n of nu)
    if (YM(n.hostnames, e)) {
      const r = n.toEmbedUrl(t);
      if (r) return {
        definition: n,
        embedUrl: r,
        url: t
      }
    }
}

function Cre(t) {
  return kre(t) ?? xre(t)
}

function Q1(t) {
  try {
    return Cre(t)
  } catch (e) {
    console.error(e)
  }
}
const Sl = "  ",
  Jn = class Jn {
    static insertTextFirefox(e, n) {
      e.setRangeText(n, e.selectionStart || 0, e.selectionEnd || 0, "end"), e.dispatchEvent(new InputEvent("input", {
        data: n,
        inputType: "insertText",
        isComposing: !1
      }))
    }
    static insert(e, n) {
      const r = e.ownerDocument,
        o = r.activeElement;
      o !== e && e.focus(), r.execCommand("insertText", !1, n) || Jn.insertTextFirefox(e, n), o === r.body ? e.blur() : o instanceof HTMLElement && o !== e && o.focus()
    }
    static set(e, n) {
      e.select(), Jn.insert(e, n)
    }
    static getSelection(e) {
      const {
        selectionStart: n,
        selectionEnd: r
      } = e;
      return e.value.slice(n || void 0, r || void 0)
    }
    static wrapSelection(e, n, r) {
      const {
        selectionStart: o,
        selectionEnd: s
      } = e, i = Jn.getSelection(e);
      Jn.insert(e, n + i + (r ?? n)), e.selectionStart = (o || 0) + n.length, e.selectionEnd = (s || 0) + n.length
    }
    static replace(e, n, r) {
      let o = 0;
      e.value.replace(n, (...s) => {
        const i = o + s[s.length - 2],
          a = s[0].length;
        e.selectionStart = i, e.selectionEnd = i + a;
        const c = typeof r == "string" ? r : r(...s);
        return Jn.insert(e, c), e.selectionStart = i, o += c.length - a, c
      })
    }
    static findLineEnd(e, n) {
      const r = e.lastIndexOf(`
`, n - 1) + 1;
      return e.charAt(r) !== "	" ? n : r + 1
    }
    static indent(e) {
      var a;
      const {
        selectionStart: n,
        selectionEnd: r,
        value: o
      } = e, s = o.slice(n, r), i = (a = /\n/g.exec(s)) == null ? void 0 : a.length;
      if (i && i > 0) {
        const c = o.lastIndexOf(`
`, n - 1) + 1,
          l = e.value.slice(c, r - 1),
          u = l.replace(/^|\n/g, `$&${Sl}`),
          d = u.length - l.length;
        e.setSelectionRange(c, r - 1), Jn.insert(e, u), e.setSelectionRange(n + 1, r + d)
      } else Jn.insert(e, Sl)
    }
    static unindent(e) {
      const {
        selectionStart: n,
        selectionEnd: r,
        value: o
      } = e, s = o.lastIndexOf(`
`, n - 1) + 1, i = Jn.findLineEnd(o, r), a = e.value.slice(s, i), c = a.replace(/(^|\n)(\t| {1,2})/g, "$1"), l = a.length - c.length;
      e.setSelectionRange(s, i), Jn.insert(e, c);
      const u = /\t| {1,2}/.exec(o.slice(s, n)),
        d = u ? u[0].length : 0,
        f = n - d;
      e.setSelectionRange(n - d, Math.max(f, r - l))
    }
    static indentCE(e) {
      var c;
      const n = window.getSelection(),
        r = e.innerText,
        o = Gp(e) ?? 0,
        s = Gp(e) ?? 0,
        i = r.slice(o, s),
        a = (c = /\n/g.exec(i)) == null ? void 0 : c.length;
      if (a && a > 0) {
        const l = r.lastIndexOf(`
`, o - 1) + 1,
          u = r.slice(l, s - 1),
          f = u.replace(/^|\n/g, `$&${Sl}`).length - u.length;
        n && n.setBaseAndExtent(e, o + 1, e, s + f)
      } else {
        const l = window.getSelection();
        e.innerText = r.slice(0, o) + Sl + r.slice(o), l == null || l.setBaseAndExtent(e, o + 1, e, o + 2)
      }
    }
    static unindentCE(e) {
      const n = window.getSelection(),
        r = e.innerText,
        o = Gp(e) ?? 0,
        s = Gp(e) ?? 0,
        i = r.lastIndexOf(`
`, o - 1) + 1,
        a = Jn.findLineEnd(r, s),
        c = r.slice(i, a),
        l = c.replace(/(^|\n)(\t| {1,2})/g, "$1"),
        u = c.length - l.length;
      if (n) {
        n.setBaseAndExtent(e, i, e, a);
        const d = /\t| {1,2}/.exec(r.slice(i, o)),
          f = d ? d[0].length : 0,
          h = o - f;
        n.setBaseAndExtent(e, o - f, e, Math.max(h, s - u))
      }
    }
    static normalizeText(e) {
      return e.replace(Jn.fixNewLines, `
`)
    }
    static normalizeTextForDom(e) {
      return e.replace(Jn.fixNewLines, `
`).split(`
`).map(n => n || " ").join(`
`)
    }
  };
P(Jn, "fixNewLines", /\r?\n|\r/g);
let Li = Jn;

function Gp(t) {
  if (typeof window.getSelection > "u") return;
  const e = window.getSelection();
  if (!e) return;
  let n = 0;
  if (e.rangeCount !== 0) {
    const r = e.getRangeAt(0),
      o = r.cloneRange();
    o.selectNodeContents(t), o.setEnd(r.endContainer, r.endOffset), n = o.toString().length
  }
  return n
}
const Pre = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;

function Y0e(t) {
  return Pre.test(t)
}

function Tre(t) {
  return t.replace(/\t/g, Sl)
}

function $re(t) {
  const e = t.split(`
`);
  for (; e[0] && e[0].trim().length === 0;) e.shift();
  let n = 1 / 0;
  for (const r of e)
    if (r.trim().length > 0) {
      const o = r.length - r.trimStart().length;
      n = Math.min(n, o)
    } return e.map(r => r.slice(n)).join(`
`)
}

function Ire(t) {
  return t.replace(/[ \t]+$/gm, "").replace(/\n+$/, "")
}

function q0e(t) {
  return Ire($re(Tre(t)))
}
const Pb = (t, e) => t.length <= e ? t : t.substring(0, e - 3) + "...";

function Hr() {
  return wh({
    isDarkMode: sv()
  })
}
const Uo = se.memo(function({
    theme: e,
    d: n,
    color: r,
    fill: o
  }) {
    switch (o) {
      case "none":
        return null;
      case "solid":
        return y.jsx("path", {
          fill: e[r].semi,
          d: n
        });
      case "semi":
        return y.jsx("path", {
          fill: e.solid,
          d: n
        });
      case "pattern":
        return y.jsx(Ore, {
          theme: e,
          color: r,
          fill: o,
          d: n
        })
    }
  }),
  Ore = function({
    d: e,
    color: n,
    theme: r
  }) {
    const o = Y(),
      s = te("zoomLevel", () => o.zoomLevel, [o]),
      i = Math.ceil(s),
      a = o.zoomLevel <= .18;
    return y.jsxs(y.Fragment, {
      children: [y.jsx("path", {
        fill: r[n].pattern,
        d: e
      }), y.jsx("path", {
        fill: a ? r[n].semi : `url(#${FS[`${i}_${r.id}`]})`,
        d: e
      })]
    })
  };

function zo({
  d: t,
  color: e,
  fill: n,
  theme: r
}) {
  if (n === "none") return;
  if (n === "pattern") {
    const s = document.createElementNS("http://www.w3.org/2000/svg", "g"),
      i = document.createElementNS("http://www.w3.org/2000/svg", "path");
    i.setAttribute("d", t), i.setAttribute("fill", r[e].pattern);
    const a = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return a.setAttribute("d", t), a.setAttribute("fill", "url(#hash_pattern)"), s.appendChild(i), s.appendChild(a), s
  }
  const o = document.createElementNS("http://www.w3.org/2000/svg", "path");
  switch (o.setAttribute("d", t), n) {
    case "semi": {
      o.setAttribute("fill", r.solid);
      break
    }
    case "solid": {
      o.setAttribute("fill", r[e].semi);
      break
    }
  }
  return o
}

function Ho(t, e) {
  if (e) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "g");
    return n.appendChild(e), n.appendChild(t), n
  } else return t
}

function Rre(t) {
  return t.replace(/\s/g, " ")
}

function Are(t, e, n) {
  const {
    padding: r = 0
  } = n, o = document.createElementNS("http://www.w3.org/2000/svg", "text");
  if (o.setAttribute("font-size", n.fontSize + "px"), o.setAttribute("font-family", n.fontFamily), o.setAttribute("font-style", n.fontStyle), o.setAttribute("font-weight", n.fontWeight), o.setAttribute("line-height", n.lineHeight * n.fontSize + "px"), o.setAttribute("dominant-baseline", "mathematical"), o.setAttribute("alignment-baseline", "mathematical"), e.length === 0) return o;
  const s = Be.From(e[0].box);
  for (const {
      box: l
    }
    of e) s.union(l);
  const i = r + (n.offsetX ?? 0),
    a = (n.offsetY ?? 0) + n.fontSize / 2 + (n.verticalTextAlign === "start" ? r : n.verticalTextAlign === "end" ? n.height - r - s.height : (Math.ceil(n.height) - s.height) / 2);
  let c = null;
  for (const {
      text: l,
      box: u
    }
    of e) {
    if (c !== null && u.y > c) {
      const m = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      m.setAttribute("alignment-baseline", "mathematical"), m.setAttribute("x", i + "px"), m.setAttribute("y", u.y + a + "px"), m.textContent = `
`, o.appendChild(m)
    }
    const f = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    f.setAttribute("alignment-baseline", "mathematical"), f.setAttribute("x", u.x + i + "px"), f.setAttribute("y", u.y + a + "px");
    const h = Rre(l);
    f.textContent = h, o.appendChild(f), c = u.y
  }
  return n.stroke && n.strokeWidth && (o.setAttribute("stroke", n.stroke), o.setAttribute("stroke-width", n.strokeWidth + "px")), n.fill && o.setAttribute("fill", n.fill), o
}

function ds(t, e, n = {}) {
  const {
    closed: r = !1,
    snap: o = 1,
    start: s = "outset",
    end: i = "outset",
    lengthRatio: a = 2,
    style: c = "dashed"
  } = n;
  let l = 0,
    u = 0,
    d = 1,
    f = 0,
    h = 0;
  switch (c) {
    case "dashed": {
      d = 1, l = Math.min(e * a, t / 4);
      break
    }
    case "dotted": {
      d = 100, l = e / d;
      break
    }
    default:
      return {
        strokeDasharray: "none", strokeDashoffset: "none"
      }
  }
  return r || (s === "outset" ? (t += l / 2, h += l / 2) : s === "skip" && (t -= l, h -= l), i === "outset" ? t += l / 2 : i === "skip" && (t -= l)), u = Math.floor(t / l / (2 * d)), u -= u % o, u < 3 && c === "dashed" ? t / e < 5 ? (l = t, u = 1, f = 0) : (l = t * .333, f = t * .333) : (u = Math.max(u, 3), l = t / u / (2 * d), r ? (h = l / 2, f = (t - u * l) / u) : f = (t - u * l) / Math.max(1, u - 1)), {
    strokeDasharray: [l, f].join(" "),
    strokeDashoffset: h.toString()
  }
}

function qM(t, e, n) {
  const r = Y(),
    o = g.useRef(null),
    s = g.useRef(!1),
    i = g.useRef(),
    a = te("isEditing", () => r.getEditingShapeId() === t, [r, t]);
  g.useEffect(() => {
    const p = o.current;
    p && a && document.activeElement !== p && p.focus()
  }, [a]);
  const c = g.useCallback(() => {
      const p = s.current;
      s.current = !1, requestAnimationFrame(() => {
        const b = o.current;
        if (!b) return;
        const w = r.getShape(t);
        w && (b.value = w.props.text, b.value.length && !p && b.select())
      })
    }, [r, t]),
    l = g.useCallback(() => {
      const p = i.current;
      requestAnimationFrame(() => {
        var v;
        const b = o.current,
          w = r.getEditingShapeId();
        if (b && w) {
          if (w === t)
            if (p)
              if (!p.length) b.focus();
              else {
                s.current = !0, b.focus();
                const _ = window.getSelection();
                _ && p.forEach(S => _.addRange(S))
              }
          else b.focus()
        } else(v = window.getSelection()) == null || v.removeAllRanges(), r.complete()
      })
    }, [r, t]),
    u = g.useCallback(p => {
      if (a) switch ((p.ctrlKey || p.metaKey) && Wn(p), p.key) {
        case "Enter": {
          (p.ctrlKey || p.metaKey) && r.complete();
          break
        }
        case "Tab": {
          at(p), p.shiftKey ? Li.unindent(p.currentTarget) : Li.indent(p.currentTarget);
          break
        }
      }
    }, [r, a]),
    d = g.useCallback(p => {
      if (!a) return;
      let b = Li.normalizeText(p.currentTarget.value);
      const w = b.replace(/\t/g, Sl);
      if (w !== b) {
        const v = p.currentTarget.selectionStart;
        p.currentTarget.value = w, p.currentTarget.selectionStart = v + (w.length - b.length), p.currentTarget.selectionEnd = v + (w.length - b.length), b = w
      }
      r.updateShapes([{
        id: t,
        type: e,
        props: {
          text: b
        }
      }])
    }, [r, t, e, a]),
    f = n.trim().length === 0;
  g.useEffect(() => {
    if (!a) return;
    if (o.current) {
      let b = function() {
        var v, _;
        const w = (v = window.getSelection) == null ? void 0 : v.call(window);
        if (w && w.type !== "None") {
          const S = [];
          if (w)
            for (let x = 0; x < w.rangeCount; x++) S.push((_ = w.getRangeAt) == null ? void 0 : _.call(w, x));
          i.current = S
        }
      };
      return document.addEventListener("selectionchange", b), () => {
        document.removeEventListener("selectionchange", b)
      }
    }
  }, [a]);
  const h = g.useCallback(p => {
    r.dispatch({
      ...gr(p),
      type: "pointer",
      name: "pointer_down",
      target: "shape",
      shape: r.getShape(t)
    }), Wn(p)
  }, [r, t]);
  return {
    rInput: o,
    isEditing: a,
    handleFocus: c,
    handleBlur: l,
    handleKeyDown: u,
    handleChange: d,
    handleInputPointerDown: h,
    handleDoubleClick: Wn,
    isEmpty: f
  }
}
const X0e = g.memo(function({
    id: e,
    text: n,
    size: r,
    font: o,
    position: s,
    width: i,
    labelColor: a
  }) {
    const {
      rInput: c,
      isEditing: l,
      handleFocus: u,
      handleBlur: d,
      handleKeyDown: f,
      handleChange: h,
      isEmpty: m,
      handleInputPointerDown: p,
      handleDoubleClick: b
    } = qM(e, "arrow", n), v = Li.normalizeTextForDom(n).trim().length > 0;
    return !l && !v ? null : y.jsx("div", {
      className: "tl-arrow-label",
      "data-font": o,
      "data-align": "center",
      "data-hastext": !m,
      "data-isediting": l,
      style: {
        textAlign: "center",
        fontSize: P2[r],
        lineHeight: P2[r] * c_.lineHeight + "px",
        transform: `translate(${s.x}px, ${s.y}px)`,
        color: a
      },
      children: y.jsxs("div", {
        className: "tl-arrow-label__inner",
        children: [y.jsx("p", {
          style: {
            width: i || "9px"
          },
          children: n ? Li.normalizeTextForDom(n) : " "
        }), l && y.jsx("textarea", {
          ref: c,
          className: "tl-text tl-text-input",
          name: "text",
          tabIndex: -1,
          autoComplete: "false",
          autoCapitalize: "false",
          autoCorrect: "false",
          autoSave: "false",
          autoFocus: !0,
          placeholder: "",
          spellCheck: "true",
          wrap: "off",
          dir: "auto",
          datatype: "wysiwyg",
          defaultValue: n,
          onFocus: u,
          onChange: h,
          onKeyDown: f,
          onBlur: d,
          onContextMenu: Wn,
          onPointerDown: p,
          onDoubleClick: b
        })]
      })
    })
  }),
  Mre = [{
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  }, {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }];

function jre(t) {
  return Mre.map(n => {
    const {
      offsetX: r,
      offsetY: o,
      blur: s,
      spread: i,
      color: a
    } = n, c = new T(r, o), {
      x: l,
      y: u
    } = c.rot(-t);
    return `${l}px ${u}px ${s}px ${i}px ${a}`
  }).join(", ")
}
const I2 = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";

function XM({
  url: t,
  zoomLevel: e
}) {
  return y.jsx("a", {
    className: ae("tl-hyperlink-button", {
      "tl-hyperlink-button__hidden": e < .32
    }),
    href: t,
    target: "_blank",
    rel: "noopener noreferrer",
    onPointerDown: Wn,
    onPointerUp: Wn,
    title: t,
    draggable: !1,
    children: y.jsx("div", {
      className: "tl-hyperlink-button__icon",
      style: {
        mask: `url("${I2}") center 100% / 100% no-repeat`,
        WebkitMask: `url("${I2}") center 100% / 100% no-repeat`
      }
    })
  })
}
class Tb extends R1 {
  constructor() {
    super(...arguments);
    P(this, "canResize", () => !1);
    P(this, "hideSelectionBoundsFg", () => !0);
    P(this, "onBeforeCreate", n => {
      O2(this.editor, n)
    });
    P(this, "onBeforeUpdate", (n, r) => {
      if (n.props.url !== r.props.url)
        if (AS(r.props.url)) O2(this.editor, r);
        else return {
          ...r,
          props: {
            ...r.props,
            url: n.props.url
          }
        }
    })
  }
  getDefaultProps() {
    return {
      url: "",
      w: 300,
      h: 320,
      assetId: null
    }
  }
  component(n) {
    const r = n.props.assetId ? this.editor.getAsset(n.props.assetId) : null,
      o = this.editor.getShapePageTransform(n).rotation(),
      s = Dre(n);
    return y.jsx(V3, {
      children: y.jsxs("div", {
        className: "tl-bookmark__container",
        style: {
          boxShadow: jre(o)
        },
        children: [y.jsxs("div", {
          className: "tl-bookmark__image_container",
          children: [r != null && r.props.image ? y.jsx("img", {
            className: "tl-bookmark__image",
            draggable: !1,
            src: r == null ? void 0 : r.props.image,
            alt: (r == null ? void 0 : r.props.title) || ""
          }) : y.jsx("div", {
            className: "tl-bookmark__placeholder"
          }), y.jsx(XM, {
            url: n.props.url,
            zoomLevel: this.editor.zoomLevel
          })]
        }), y.jsxs("div", {
          className: "tl-bookmark__copy_container",
          children: [(r == null ? void 0 : r.props.title) && y.jsx("h2", {
            className: "tl-bookmark__heading",
            children: Pb((r == null ? void 0 : r.props.title) || "", 54)
          }), (r == null ? void 0 : r.props.description) && y.jsx("p", {
            className: "tl-bookmark__description",
            children: Pb((r == null ? void 0 : r.props.description) || "", 128)
          }), y.jsx("a", {
            className: "tl-bookmark__link",
            href: n.props.url || "",
            target: "_blank",
            rel: "noopener noreferrer",
            onPointerDown: Wn,
            onPointerUp: Wn,
            onClick: Wn,
            children: Pb(s, 45)
          })]
        })]
      })
    })
  }
  indicator(n) {
    return y.jsx("rect", {
      width: U(n.props.w),
      height: U(n.props.h),
      rx: "8",
      ry: "8"
    })
  }
}
P(Tb, "type", "bookmark"), P(Tb, "props", TH), P(Tb, "migrations", $H);
const Dre = t => {
  try {
    const e = new URL(t.props.url),
      n = e.pathname.replace(/\/*$/, "");
    return `${e.hostname}${n}`
  } catch {
    return t.props.url
  }
};

function O2(t, e) {
  const {
    url: n
  } = e.props, r = $f.createId(PA(n));
  t.getAsset(r) ? e.props.assetId !== r && t.updateShapes([{
    id: e.id,
    type: e.type,
    props: {
      assetId: r
    }
  }]) : (t.updateShapes([{
    id: e.id,
    type: e.type,
    props: {
      assetId: null
    }
  }]), Nre(t, e))
}
const Nre = CA(async (t, e) => {
  const {
    url: n
  } = e.props, r = await t.getAssetForExternalContent({
    type: "url",
    url: n
  });
  r && t.batch(() => {
    t.createAssets([r]), t.updateShapes([{
      id: e.id,
      type: e.type,
      props: {
        assetId: r.id
      }
    }])
  })
}, 500);

function Lre(t, e = !1) {
  const n = t.length;
  if (n < 2) return "";
  let r = t[0].point,
    o = t[1].point;
  if (n === 2) return `M${Jr(r)}L${Jr(o)}`;
  let s = "";
  for (let i = 2, a = n - 1; i < a; i++) r = t[i].point, o = t[i + 1].point, s += Qr(r, o);
  return e ? `M${Qr(t[0].point,t[1].point)}Q${Jr(t[1].point)}${Qr(t[1].point,t[2].point)}T${s}${Qr(t[n-1].point,t[0].point)}${Qr(t[0].point,t[1].point)}Z` : `M${Jr(t[0].point)}Q${Jr(t[1].point)}${Qr(t[1].point,t[2].point)}${t.length>3?"T":""}${s}L${Jr(t[n-1].point)}`
}
const Fre = g.forwardRef(({
    id: t,
    name: e,
    isEditing: n
  }, r) => {
    const o = Y(),
      s = g.useCallback(c => {
        c.key === "Enter" && !c.nativeEvent.isComposing && (Wn(c), c.currentTarget.blur(), o.setEditingShape(null))
      }, [o]),
      i = g.useCallback(c => {
        const l = o.getShape(t);
        if (!l) return;
        const u = l.props.name,
          d = c.currentTarget.value.trim();
        u !== d && o.updateShapes([{
          id: t,
          type: "frame",
          props: {
            name: d
          }
        }], {
          squashing: !0
        })
      }, [t, o]),
      a = g.useCallback(c => {
        const l = o.getShape(t);
        if (!l) return;
        const u = l.props.name,
          d = c.currentTarget.value;
        u !== d && o.updateShapes([{
          id: t,
          type: "frame",
          props: {
            name: d
          }
        }], {
          squashing: !0
        })
      }, [t, o]);
    return y.jsxs("div", {
      className: `tl-frame-label ${n?"tl-frame-label__editing":""}`,
      children: [y.jsx("input", {
        className: "tl-frame-name-input",
        ref: r,
        style: {
          display: n ? void 0 : "none"
        },
        value: e,
        autoFocus: !0,
        onKeyDown: s,
        onBlur: i,
        onChange: a
      }), ZM(e, "Frame") + String.fromCharCode(8203)]
    })
  }),
  Bre = function({
    id: e,
    name: n,
    width: r,
    height: o
  }) {
    const s = Y(),
      i = te("shape rotation", () => br(s.getShapePageTransform(e).rotation()), [s, e]),
      a = W3(e),
      c = g.useRef(null),
      l = g.useCallback(m => {
        const p = gr(m);
        s.getEditingShapeId() !== e && (s.dispatch({
          type: "pointer",
          name: "pointer_down",
          target: "shape",
          shape: s.getShape(e),
          ...p
        }), m.preventDefault())
      }, [s, e]);
    g.useEffect(() => {
      const m = c.current;
      m && a && (m.focus(), m.select(), requestAnimationFrame(() => {
        document.activeElement !== m && (m.focus(), m.select())
      }))
    }, [c, a]);
    const d = ((i + Math.PI / 4) * (2 / Math.PI) + 4) % 4,
      f = ["top", "left", "bottom", "right"][Math.floor(d)];
    let h;
    switch (f) {
      case "top":
        h = "";
        break;
      case "right":
        h = `translate(${U(r)}px, 0px) rotate(90deg)`;
        break;
      case "bottom":
        h = `translate(${U(r)}px, ${U(o)}px) rotate(180deg)`;
        break;
      case "left":
        h = `translate(0px, ${U(o)}px) rotate(270deg)`;
        break
    }
    return y.jsx("div", {
      className: "tl-frame-heading",
      style: {
        overflow: a ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${Math.ceil(f==="top"||f==="bottom"?r:o)}px + var(--space-5))`,
        bottom: "100%",
        transform: `${h} scale(var(--tl-scale)) translateX(calc(-1 * var(--space-3))`
      },
      onPointerDown: l,
      children: y.jsx("div", {
        className: "tl-frame-heading-hit-area",
        children: y.jsx(Fre, {
          ref: c,
          id: e,
          name: n,
          isEditing: a
        })
      })
    })
  };

function ZM(t, e) {
  return t.match(/^\s*$/) ? e : t
}
class $b extends R1 {
  constructor() {
    super(...arguments);
    P(this, "canBind", () => !0);
    P(this, "canEdit", () => !0);
    P(this, "canReceiveNewChildrenOfType", (n, r) => !n.isLocked);
    P(this, "canDropShapes", (n, r) => !n.isLocked);
    P(this, "onDragShapesOver", (n, r) => r.every(o => o.parentId === n.id) ? {
      shouldHint: !1
    } : (this.editor.reparentShapes(r.map(o => o.id), n.id), {
      shouldHint: !0
    }));
    P(this, "onDragShapesOut", (n, r) => {
      const o = this.editor.getShape(n.parentId);
      o && this.editor.isShapeOfType(o, "group") ? this.editor.reparentShapes(r, o.id) : this.editor.reparentShapes(r, this.editor.currentPageId)
    });
    P(this, "onResizeEnd", n => {
      const r = this.editor.getShapePageBounds(n),
        o = this.editor.getSortedChildIdsForParent(n.id),
        s = [];
      for (const i of o) {
        const a = this.editor.getShapePageBounds(i);
        r.includes(a) || s.push(i)
      }
      s.length > 0 && this.editor.reparentShapes(s, this.editor.currentPageId)
    })
  }
  getDefaultProps() {
    return {
      w: 160 * 2,
      h: 90 * 2,
      name: ""
    }
  }
  getGeometry(n) {
    return new T1({
      width: n.props.w,
      height: n.props.h,
      isFilled: !1
    })
  }
  component(n) {
    const r = this.editor.getShapeGeometry(n).bounds,
      o = Hr();
    return y.jsxs(y.Fragment, {
      children: [y.jsx(k3, {
        children: y.jsx("rect", {
          className: "tl-frame__body",
          width: r.width,
          height: r.height,
          fill: o.solid,
          stroke: o.text
        })
      }), y.jsx(Bre, {
        id: n.id,
        name: n.props.name,
        width: r.width,
        height: r.height
      })]
    })
  }
  toSvg(n) {
    const r = wh({
        isDarkMode: this.editor.user.isDarkMode
      }),
      o = document.createElementNS("http://www.w3.org/2000/svg", "g"),
      s = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    s.setAttribute("width", n.props.w.toString()), s.setAttribute("height", n.props.h.toString()), s.setAttribute("fill", r.solid), s.setAttribute("stroke", r.black.solid), s.setAttribute("stroke-width", "1"), s.setAttribute("rx", "1"), s.setAttribute("ry", "1"), o.appendChild(s);
    const c = ((br(this.editor.getShapePageTransform(n.id).rotation()) + Math.PI / 4) * (2 / Math.PI) + 4) % 4,
      l = ["top", "left", "bottom", "right"][Math.floor(c)];
    let u;
    switch (l) {
      case "top":
        u = "";
        break;
      case "right":
        u = `translate(${U(n.props.w)}px, 0px) rotate(90deg)`;
        break;
      case "bottom":
        u = `translate(${U(n.props.w)}px, ${U(n.props.h)}px) rotate(180deg)`;
        break;
      case "left":
        u = `translate(0px, ${U(n.props.h)}px) rotate(270deg)`;
        break;
      default:
        u = ""
    }
    const d = {
        fontSize: 12,
        fontFamily: "Inter, sans-serif",
        textAlign: "start",
        width: n.props.w,
        height: 32,
        padding: 0,
        lineHeight: 1,
        fontStyle: "normal",
        fontWeight: "normal",
        overflow: "truncate-ellipsis",
        verticalTextAlign: "middle"
      },
      f = this.editor.textMeasure.measureTextSpans(ZM(n.props.name, "Frame") + String.fromCharCode(8203), d),
      h = f[0],
      m = bz(f),
      p = m.box.w + m.box.x - h.box.x,
      b = Are(this.editor, f, {
        offsetY: -d.height - 2,
        ...d
      });
    b.style.setProperty("transform", u);
    const w = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    return w.setAttribute("x", "-8px"), w.setAttribute("y", -d.height - 4 + "px"), w.setAttribute("width", p + 16 + "px"), w.setAttribute("height", `${d.height}px`), w.setAttribute("rx", "4px"), w.setAttribute("ry", "4px"), w.setAttribute("fill", r.background), o.appendChild(w), o.appendChild(b), o
  }
  indicator(n) {
    const r = this.editor.getShapeGeometry(n).bounds;
    return y.jsx("rect", {
      width: U(r.width),
      height: U(r.height),
      className: "tl-frame-indicator"
    })
  }
  providesBackgroundForChildren() {
    return !0
  }
}
P($b, "type", "frame"), P($b, "props", IH), P($b, "migrations", OH);

function Z0e(t, e, n, r) {
  if ((t === "start-legacy" || t === "end-legacy") && n.length !== 0) {
    const o = Be.From(n[0].box);
    for (const {
        box: s
      }
      of n) o.union(s);
    if (t === "start-legacy") return (r - 2 * e - o.width) / 2;
    if (t === "end-legacy") return -(r - 2 * e - o.width) / 2
  }
}

function Ure(t) {
  return t === "start-legacy" || t === "middle-legacy" || t === "end-legacy"
}
const J0e = se.memo(function({
  id: e,
  type: n,
  text: r,
  size: o,
  labelColor: s,
  font: i,
  align: a,
  verticalAlign: c,
  wrap: l,
  bounds: u
}) {
  const {
    rInput: d,
    isEmpty: f,
    isEditing: h,
    handleFocus: m,
    handleChange: p,
    handleKeyDown: b,
    handleBlur: w,
    handleInputPointerDown: v,
    handleDoubleClick: _
  } = qM(e, n, r), S = Li.normalizeTextForDom(r), x = S.length > 0, E = Ure(a), k = Hr();
  return !h && !x ? null : y.jsx("div", {
    className: "tl-text-label",
    "data-font": i,
    "data-align": a,
    "data-hastext": !f,
    "data-isediting": h,
    "data-textwrap": !!l,
    style: {
      justifyContent: a === "middle" || E ? "center" : a,
      alignItems: c === "middle" ? "center" : c,
      ...u ? {
        top: u.minY,
        left: u.minX,
        width: u.width,
        height: u.height,
        position: "absolute"
      } : {}
    },
    children: y.jsxs("div", {
      className: "tl-text-label__inner",
      style: {
        fontSize: C2[o],
        lineHeight: C2[o] * c_.lineHeight + "px",
        minHeight: c_.lineHeight + 32,
        minWidth: 0,
        color: k[s].solid
      },
      children: [y.jsx("div", {
        className: "tl-text tl-text-content",
        dir: "ltr",
        children: S
      }), h && y.jsx("textarea", {
        ref: d,
        className: "tl-text tl-text-input",
        name: "text",
        tabIndex: -1,
        autoComplete: "false",
        autoCapitalize: "false",
        autoCorrect: "false",
        autoSave: "false",
        autoFocus: !0,
        placeholder: "",
        spellCheck: "true",
        wrap: "off",
        dir: "auto",
        datatype: "wysiwyg",
        defaultValue: r,
        onFocus: m,
        onChange: p,
        onKeyDown: b,
        onBlur: w,
        onContextMenu: Wn,
        onPointerDown: v,
        onDoubleClick: _
      })]
    })
  })
});

function Nn(t) {
  return `${U(t.x)},${U(t.y)} `
}

function JM(t = "") {
  let e = 0,
    n = 0,
    r = 0,
    o = 0;

  function s() {
    const i = e ^ e << 11;
    return e = n, n = r, r = o, o ^= (o >>> 19 ^ i ^ i >>> 8) >>> 0, o / 4294967296 * 2
  }
  for (let i = 0; i < t.length + 64; i++) e ^= t.charCodeAt(i) | 0, s();
  return s
}

function Vm(t) {
  let e = "M";
  const n = t.length;
  let r, o, s;
  for (let i = 0, a = n; i < a; i += 3) r = t[i], o = t[i + 1], s = t[i + 2], e += `${Nn(r)}L${Nn(o)}Q${Nn(s)}`;
  return e += `${Nn(t[0])}`, e
}

function Wm(t, e, n, r, o) {
  const s = [],
    i = JM(t);
  let a = e[0],
    c;
  const l = e.length;
  for (let u = 0, d = l * o; u < d; u++) {
    c = T.AddXY(e[(u + 1) % l], i() * n, i() * n);
    const f = T.Sub(c, a),
      h = T.Len(f),
      m = T.Div(f, h).mul(Math.min(h / 4, r));
    s.push(T.Add(a, m), T.Add(c, m.neg()), c), a = c
  }
  return s
}

function Q0e(t, e, n) {
  let r = `M ${Nn(e[0])}L`,
    o = `M ${Nn(e[0])}L`;
  const s = n / 3,
    i = n * 2,
    a = JM(t);
  let c = e[0],
    l, u = e[0],
    d;
  const f = e.length;
  for (let h = 0, m = f - 1; h < m; h++) {
    l = e[h + 1], d = T.AddXY(e[h + 1], a() * s, a() * s);
    const p = T.Sub(l, c),
      b = T.Len(p),
      w = T.Div(p, b).mul(Math.min(b / 4, i)),
      v = T.Add(c, w),
      _ = T.Add(l, w.neg()),
      S = T.Sub(d, u),
      x = T.Len(S),
      E = T.Div(S, x).mul(Math.min(x / 4, i)),
      k = T.Add(u, E),
      C = T.Add(d, E.neg());
    h === m - 1 ? (r += `${Nn(v)}L ${Nn(l)}`, o += `${Nn(k)}L ${Nn(d)}`) : (r += `${Nn(v)}L ${Nn(_)}Q ${Nn(l)}`, o += `${Nn(k)}L ${Nn(C)}Q ${Nn(d)}`, c = l, u = d)
  }
  return [r, r + o]
}

function R2(t, e) {
  const n = Math.min(t, e) / 2,
    r = Math.max(t, e) - n * 2;
  return Math.PI * (n * 2) + 2 * r
}

function zre(t, e, n) {
  const r = Math.min(t, e) / 2,
    o = Math.max(t, e) - r * 2,
    i = (Math.PI * (r * 2) + 2 * o) / n,
    a = t > e ? [{
      type: "straight",
      start: new T(r, 0),
      delta: new T(1, 0)
    }, {
      type: "arc",
      center: new T(t - r, r),
      startAngle: -Hn / 2
    }, {
      type: "straight",
      start: new T(t - r, e),
      delta: new T(-1, 0)
    }, {
      type: "arc",
      center: new T(r, r),
      startAngle: Hn / 2
    }] : [{
      type: "straight",
      start: new T(t, r),
      delta: new T(0, 1)
    }, {
      type: "arc",
      center: new T(r, e - r),
      startAngle: 0
    }, {
      type: "straight",
      start: new T(0, e - r),
      delta: new T(0, -1)
    }, {
      type: "arc",
      center: new T(r, r),
      startAngle: Hn
    }];
  let c = 0;
  const l = [];
  for (let u = 0; u < n; u++) {
    const d = a[0];
    d.type === "straight" ? l.push(T.Add(d.start, T.Mul(d.delta, c))) : l.push(YA(d.center.x, d.center.y, r, d.startAngle + c / r)), c += i;
    let f = d.type === "straight" ? o : Hn * r;
    for (; c > f;) c -= f, a.push(a.shift()), f = a[0].type === "straight" ? o : Hn * r
  }
  return l
}
const Hre = (t, e, n, r, o) => {
  switch (t) {
    case "s":
      return e;
    case "m":
      return n;
    case "l":
      return r;
    case "xl":
      return o
  }
};

function Oh(t, e, n, r) {
  const o = a1(n),
    s = R2(t, e),
    i = Math.max(Math.ceil(s / Hre(r, 50, 70, 100, 130)), 6, Math.ceil(s / Math.min(t, e))),
    a = s / i * .2,
    c = Math.max(t - a * 2, 1),
    l = Math.max(e - a * 2, 1),
    u = (t - c) / 2,
    d = (e - l) / 2,
    f = R2(c, l) / i,
    h = zre(c, l, i).map(v => v.addXY(u, d)),
    m = t < 20 ? 0 : a * .3,
    p = e < 20 ? 0 : a * .3,
    b = h.slice(0);
  for (let v = 0; v < Math.floor(i / 2); v++) b[v] = T.AddXY(b[v], o() * m, o() * p), b[i - v - 1] = T.AddXY(b[i - v - 1], o() * m, o() * p);
  const w = [];
  for (let v = 0; v < b.length; v++) {
    const _ = v === b.length - 1 ? 0 : v + 1,
      S = b[v],
      x = b[_],
      E = h[v],
      k = h[_],
      C = T.Average([E, k]),
      $ = T.Angle(E, k) - Math.PI / 2,
      I = T.Dist(E, k),
      R = f - I,
      j = T.Dist(S, x) / I,
      A = (Math.max(u, d) + R) * j,
      D = T.Add(C, T.FromAngle($, A));
    D.x < 0 ? D.x = 0 : D.x > t && (D.x = t), D.y < 0 ? D.y = 0 : D.y > e && (D.y = e);
    const N = QM(S, x, D),
      q = T.Dist(N || T.Average([S, x]), S);
    w.push({
      leftPoint: S,
      rightPoint: x,
      arcPoint: D,
      center: N,
      radius: q
    })
  }
  return w
}

function QM(t, e, n) {
  const r = t.x * (e.y - n.y) - t.y * (e.x - n.x) + e.x * n.y - n.x * e.y,
    o = (t.x * t.x + t.y * t.y) * (n.y - e.y) + (e.x * e.x + e.y * e.y) * (t.y - n.y) + (n.x * n.x + n.y * n.y) * (e.y - t.y),
    s = (t.x * t.x + t.y * t.y) * (e.x - n.x) + (e.x * e.x + e.y * e.y) * (n.x - t.x) + (n.x * n.x + n.y * n.y) * (t.x - e.x),
    i = -o / (2 * r),
    a = -s / (2 * r);
  return !Number.isFinite(i) || !Number.isFinite(a) ? null : new T(i, a)
}

function ebe(t, e, n, r) {
  const o = [],
    s = Oh(t, e, n, r);
  for (const {
      center: i,
      radius: a,
      leftPoint: c,
      rightPoint: l
    }
    of s) o.push(...Vre(c, l, i, a, 10));
  return o
}

function pv(t, e, n, r) {
  const o = Oh(t, e, n, r);
  let s = `M${U(o[0].leftPoint.x)},${U(o[0].leftPoint.y)}`;
  for (const {
      leftPoint: i,
      rightPoint: a,
      radius: c,
      center: l
    }
    of o) {
    if (l === null) {
      s += ` L${U(a.x)},${U(a.y)}`;
      continue
    }
    const u = tj(i, a, l) ? "0" : "1";
    s += ` A${U(c)},${U(c)} 0 ${u},1 ${U(a.x)},${U(a.y)}`
  }
  return s += " Z", s
}

function ej(t, e, n, r) {
  const o = a1(n),
    s = r === "s" ? .5 : r === "m" ? .7 : r === "l" ? .9 : 1.6,
    i = m => m + o() * s * 2,
    a = Oh(t, e, n, r),
    u = a.reduce((m, p) => m + T.Dist(p.leftPoint, p.rightPoint), 0) / a.length > s * 15 ? m => new T(i(m.x), i(m.y)) : m => m;
  let d = `M${U(a[0].leftPoint.x)},${U(a[0].leftPoint.y)}`,
    f = u(a[0].leftPoint),
    h = `M${U(f.x)},${U(f.y)}`;
  for (const {
      leftPoint: m,
      center: p,
      rightPoint: b,
      radius: w,
      arcPoint: v
    }
    of a) {
    if (p === null) {
      d += ` L${U(b.x)},${U(b.y)}`;
      const C = u(b);
      h += ` L${U(C.x)},${U(C.y)}`, f = C;
      continue
    }
    const _ = tj(m, b, p) ? "0" : "1";
    d += ` A${U(w)},${U(w)} 0 ${_},1 ${U(b.x)},${U(b.y)}`;
    const S = u(b),
      x = u(v),
      E = QM(f, S, x);
    if (!E) {
      h += ` L${U(S.x)},${U(S.y)}`, f = S;
      continue
    }
    const k = Math.abs(T.Dist(E, f));
    h += ` A${U(k)},${U(k)} 0 ${_},1 ${U(S.x)},${U(S.y)}`, f = S
  }
  return d + h + " Z"
}

function Vre(t, e, n, r, o) {
  if (n === null) return [T.From(t), T.From(e)];
  const s = [],
    i = T.Angle(n, t),
    a = T.Angle(n, e),
    c = tv(i, a);
  for (let l = 0; l < o; l++) {
    const u = l / (o - 1),
      d = i + c * u,
      f = YA(n.x, n.y, r, d);
    s.push(f)
  }
  return s
}

function tj(t, e, n) {
  return (e.x - t.x) * (n.y - t.y) - (e.y - t.y) * (n.x - t.x) > 0
}
const tbe = g.memo(function({
  dash: e,
  fill: n,
  color: r,
  strokeWidth: o,
  w: s,
  h: i,
  id: a,
  size: c
}) {
  const l = Hr(),
    u = pv(s, i, a, c),
    d = Oh(s, i, a, c);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: l,
      d: u,
      fill: n,
      color: r
    }), y.jsx("g", {
      strokeWidth: o,
      stroke: l[r].solid,
      fill: "none",
      pointerEvents: "all",
      children: d.map(({
        leftPoint: f,
        rightPoint: h,
        center: m,
        radius: p
      }, b) => {
        const w = m ? p * br(br(T.Angle(m, h)) - br(T.Angle(m, f))) : T.Dist(f, h),
          {
            strokeDasharray: v,
            strokeDashoffset: _
          } = ds(w, o, {
            style: e,
            start: "outset",
            end: "outset"
          });
        return y.jsx("path", {
          d: m ? `M${f.x},${f.y}A${p},${p},0,0,1,${h.x},${h.y}` : `M${f.x},${f.y}L${h.x},${h.y}`,
          strokeDasharray: v,
          strokeDashoffset: _
        }, b)
      })
    })]
  })
});

function nbe({
  dash: t,
  fill: e,
  color: n,
  theme: r,
  strokeWidth: o,
  w: s,
  h: i,
  id: a,
  size: c
}) {
  const l = pv(s, i, a, c),
    u = Oh(s, i, a, c),
    d = document.createElementNS("http://www.w3.org/2000/svg", "g");
  d.setAttribute("stroke-width", o.toString()), d.setAttribute("stroke", r[n].solid), d.setAttribute("fill", "none");
  for (const {
      leftPoint: h,
      rightPoint: m,
      center: p,
      radius: b
    }
    of u) {
    const w = p ? b * br(br(T.Angle(p, m)) - br(T.Angle(p, h))) : T.Dist(h, m),
      {
        strokeDasharray: v,
        strokeDashoffset: _
      } = ds(w, o, {
        style: t,
        start: "outset",
        end: "outset"
      }),
      S = document.createElementNS("http://www.w3.org/2000/svg", "path");
    S.setAttribute("d", p ? `M${h.x},${h.y}A${b},${b},0,0,1,${m.x},${m.y}` : `M${h.x},${h.y}L${m.x},${m.y}`), S.setAttribute("stroke-dasharray", v.toString()), S.setAttribute("stroke-dashoffset", _.toString()), d.appendChild(S)
  }
  const f = zo({
    d: l,
    fill: e,
    color: n,
    theme: r
  });
  return Ho(d, f)
}
const rbe = g.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: o,
  color: s,
  fill: i
}) {
  const a = Hr(),
    c = e / 2,
    l = n / 2,
    u = Math.max(0, c),
    d = Math.max(0, l),
    f = Af(u, d),
    {
      strokeDasharray: h,
      strokeDashoffset: m
    } = ds(f < 64 ? f * 2 : f, r, {
      style: o,
      snap: 4,
      closed: !0
    }),
    p = `M${c-u},${l}a${u},${d},0,1,1,${u*2},0a${u},${d},0,1,1,-${u*2},0`;
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: a,
      d: p,
      color: s,
      fill: i
    }), y.jsx("path", {
      d: p,
      strokeWidth: r,
      width: U(e),
      height: U(n),
      fill: "none",
      stroke: a[s].solid,
      strokeDasharray: h,
      strokeDashoffset: m,
      pointerEvents: "all"
    })]
  })
});

function obe({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: o,
  theme: s,
  fill: i
}) {
  const a = t / 2,
    c = e / 2,
    l = Math.max(0, a - n / 2),
    u = Math.max(0, c - n / 2),
    d = Af(l, u),
    {
      strokeDasharray: f,
      strokeDashoffset: h
    } = ds(d < 64 ? d * 2 : d, n, {
      style: r,
      snap: 4,
      closed: !0
    }),
    m = `M${a-l},${c}a${l},${u},0,1,1,${l*2},0a${l},${u},0,1,1,-${l*2},0`,
    p = document.createElementNS("http://www.w3.org/2000/svg", "path");
  p.setAttribute("d", m), p.setAttribute("stroke-width", n.toString()), p.setAttribute("width", t.toString()), p.setAttribute("height", e.toString()), p.setAttribute("fill", "none"), p.setAttribute("stroke", s[o].solid), p.setAttribute("stroke-dasharray", f), p.setAttribute("stroke-dashoffset", h);
  const b = zo({
    d: m,
    fill: i,
    color: o,
    theme: s
  });
  return Ho(p, b)
}

function nj(t, e) {
  if (e > t) {
    const r = t / 2;
    return `
    M0,${r}
    a${r},${r},0,1,1,${r*2},0
    L${t},${e-r}
    a${r},${r},0,1,1,-${r*2},0
    Z`
  }
  const n = e / 2;
  return `
    M${n},0
    L${t-n},0
    a${n},${n},0,1,1,0,${n*2}
    L${n},${e}
    a${n},${n},0,1,1,0,${-n*2}
    Z`
}

function rj(t, e) {
  if (t > e) {
    const r = e / 2;
    return Af(r, r) + (t - r * 2) * 2
  }
  const n = t / 2;
  return Af(n, n) + (e - n * 2) * 2
}
const sbe = g.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  dash: o,
  color: s,
  fill: i
}) {
  const a = Hr(),
    c = nj(e, n),
    l = rj(e, n),
    {
      strokeDasharray: u,
      strokeDashoffset: d
    } = ds(l < 64 ? l * 2 : l, r, {
      style: o,
      snap: 4,
      start: "outset",
      end: "outset",
      closed: !0
    });
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: a,
      d: c,
      color: s,
      fill: i
    }), y.jsx("path", {
      d: c,
      strokeWidth: r,
      width: U(e),
      height: U(n),
      fill: "none",
      stroke: a[s].solid,
      strokeDasharray: u,
      strokeDashoffset: d,
      pointerEvents: "all"
    })]
  })
});

function ibe({
  w: t,
  h: e,
  strokeWidth: n,
  dash: r,
  color: o,
  theme: s,
  fill: i
}) {
  const a = nj(t, e),
    c = rj(t, e),
    {
      strokeDasharray: l,
      strokeDashoffset: u
    } = ds(c < 64 ? c * 2 : c, n, {
      style: r,
      snap: 4,
      closed: !0
    }),
    d = document.createElementNS("http://www.w3.org/2000/svg", "path");
  d.setAttribute("d", a), d.setAttribute("stroke-width", n.toString()), d.setAttribute("width", t.toString()), d.setAttribute("height", e.toString()), d.setAttribute("fill", "none"), d.setAttribute("stroke", s[o].solid), d.setAttribute("stroke-dasharray", l), d.setAttribute("stroke-dashoffset", u);
  const f = zo({
    d: a,
    fill: i,
    color: o,
    theme: s
  });
  return Ho(d, f)
}
const abe = g.memo(function({
  dash: e,
  fill: n,
  color: r,
  strokeWidth: o,
  outline: s,
  lines: i
}) {
  const a = Hr(),
    c = "M" + s[0] + "L" + s.slice(1) + "Z";
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: a,
      d: c,
      fill: n,
      color: r
    }), y.jsxs("g", {
      strokeWidth: o,
      stroke: a[r].solid,
      fill: "none",
      pointerEvents: "all",
      children: [Array.from(Array(s.length)).map((l, u) => {
        const d = s[u],
          f = s[(u + 1) % s.length],
          h = T.Dist(d, f),
          {
            strokeDasharray: m,
            strokeDashoffset: p
          } = ds(h, o, {
            style: e,
            start: "outset",
            end: "outset"
          });
        return y.jsx("line", {
          x1: d.x,
          y1: d.y,
          x2: f.x,
          y2: f.y,
          strokeDasharray: m,
          strokeDashoffset: p
        }, u)
      }), i && i.map(([l, u], d) => {
        const f = T.Dist(l, u),
          {
            strokeDasharray: h,
            strokeDashoffset: m
          } = ds(f, o, {
            style: e,
            start: "skip",
            end: "outset",
            snap: e === "dotted" ? 4 : void 0
          });
        return y.jsx("path", {
          d: `M${l.x},${l.y}L${u.x},${u.y}`,
          stroke: a[r].solid,
          strokeWidth: o,
          fill: "none",
          strokeDasharray: h,
          strokeDashoffset: m
        }, `line_fg_${d}`)
      })]
    })]
  })
});

function cbe({
  dash: t,
  fill: e,
  color: n,
  theme: r,
  strokeWidth: o,
  outline: s,
  lines: i
}) {
  const a = document.createElementNS("http://www.w3.org/2000/svg", "g");
  if (a.setAttribute("stroke-width", o.toString()), a.setAttribute("stroke", r[n].solid), a.setAttribute("fill", "none"), Array.from(Array(s.length)).forEach((l, u) => {
      const d = s[u],
        f = s[(u + 1) % s.length],
        h = T.Dist(d, f),
        {
          strokeDasharray: m,
          strokeDashoffset: p
        } = ds(h, o, {
          style: t
        }),
        b = document.createElementNS("http://www.w3.org/2000/svg", "line");
      b.setAttribute("x1", d.x.toString()), b.setAttribute("y1", d.y.toString()), b.setAttribute("x2", f.x.toString()), b.setAttribute("y2", f.y.toString()), b.setAttribute("stroke-dasharray", m.toString()), b.setAttribute("stroke-dashoffset", p.toString()), a.appendChild(b)
    }), i)
    for (const [l, u] of i) {
      const d = T.Dist(l, u),
        {
          strokeDasharray: f,
          strokeDashoffset: h
        } = ds(d, o, {
          style: t,
          start: "skip",
          end: "skip",
          snap: t === "dotted" ? 4 : 2
        }),
        m = document.createElementNS("http://www.w3.org/2000/svg", "line");
      m.setAttribute("x1", l.x.toString()), m.setAttribute("y1", l.y.toString()), m.setAttribute("x2", u.x.toString()), m.setAttribute("y2", u.y.toString()), m.setAttribute("stroke-dasharray", f.toString()), m.setAttribute("stroke-dashoffset", h.toString()), a.appendChild(m)
    }
  const c = zo({
    d: "M" + s[0] + "L" + s.slice(1) + "Z",
    fill: e,
    color: n,
    theme: r
  });
  return Ho(a, c)
}
const lbe = g.memo(function({
  fill: e,
  color: n,
  strokeWidth: r,
  w: o,
  h: s,
  id: i,
  size: a
}) {
  const c = Hr(),
    l = ej(o, s, i, a);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: c,
      d: l,
      fill: e,
      color: n
    }), y.jsx("path", {
      d: l,
      stroke: c[n].solid,
      strokeWidth: r,
      fill: "none"
    })]
  })
});

function ube({
  fill: t,
  color: e,
  strokeWidth: n,
  theme: r,
  w: o,
  h: s,
  id: i,
  size: a
}) {
  const c = ej(o, s, i, a),
    l = document.createElementNS("http://www.w3.org/2000/svg", "path");
  l.setAttribute("d", c), l.setAttribute("stroke-width", n.toString()), l.setAttribute("stroke", r[e].solid), l.setAttribute("fill", "none");
  const u = zo({
    d: c,
    fill: t,
    color: e,
    theme: r
  });
  return Ho(l, u)
}
g.memo(function({
  id: e,
  w: n,
  h: r,
  strokeWidth: o,
  fill: s,
  color: i
}) {
  const a = Hr(),
    c = aj(e, n, r, o),
    l = ij(e, n, r, o);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: a,
      d: c,
      color: i,
      fill: s
    }), y.jsx("path", {
      d: l,
      fill: a[i].solid,
      strokeWidth: 0,
      pointerEvents: "all"
    })]
  })
});

function dbe({
  id: t,
  w: e,
  h: n,
  strokeWidth: r,
  fill: o,
  color: s,
  theme: i
}) {
  const a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  a.setAttribute("d", ij(t, e, n, r)), a.setAttribute("fill", i[s].solid);
  const c = zo({
    d: aj(t, e, n, r),
    fill: o,
    color: s,
    theme: i
  });
  return Ho(a, c)
}

function oj(t) {
  return {
    size: 1 + t,
    thinning: .25,
    end: {
      taper: t
    },
    start: {
      taper: t
    },
    streamline: 0,
    smoothing: 1,
    simulatePressure: !1
  }
}

function sj(t, e, n, r) {
  const o = a1(t),
    s = e / 2,
    i = n / 2,
    a = Af(s, i),
    c = [],
    l = Rt * o(),
    u = Rt + hr / 2 + Math.abs(o()) * hr,
    d = Math.max(16, a / 10);
  for (let f = 0; f < d; f++) {
    const h = f / (d - 1),
      m = l + h * u,
      p = Math.cos(m),
      b = Math.sin(m);
    c.push(new T(s * p + e * .5 + .05 * o(), i * b + n / 2 + .05 * o(), Math.min(1, .5 + Math.abs(.5 - (o() > 0 ? Vi.easeInOutSine(h) : Vi.easeInExpo(h))) / 2)))
  }
  return nre(c, oj(r))
}

function ij(t, e, n, r) {
  const o = oj(r);
  return ZA(Qne(rre(sj(t, e, n, r), o), o))
}

function aj(t, e, n, r) {
  return Lre(sj(t, e, n, r))
}
const fbe = g.memo(function({
  id: e,
  outline: n,
  lines: r,
  fill: o,
  color: s,
  strokeWidth: i
}) {
  const a = Hr(),
    c = Wm(e, n, i / 3, i * 2, 2);
  let l = Vm(c);
  if (r)
    for (const [f, h] of r) l += `M${f.x},${f.y}L${h.x},${h.y}`;
  const u = Wm(e, n, 0, i * 2, 1),
    d = Vm(u);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      d,
      fill: o,
      color: s,
      theme: a
    }), y.jsx("path", {
      d: l,
      stroke: a[s].solid,
      strokeWidth: i,
      fill: "none"
    })]
  })
});

function hbe({
  id: t,
  outline: e,
  lines: n,
  fill: r,
  color: o,
  theme: s,
  strokeWidth: i
}) {
  const a = Wm(t, e, i / 3, i * 2, 2);
  let c = Vm(a);
  if (n)
    for (const [h, m] of n) c += `M${h.x},${h.y}L${m.x},${m.y}`;
  const l = Wm(t, e, 0, i * 2, 1),
    u = Vm(l),
    d = document.createElementNS("http://www.w3.org/2000/svg", "path");
  d.setAttribute("d", c), d.setAttribute("fill", "none"), d.setAttribute("stroke", s[o].solid), d.setAttribute("stroke-width", i.toString());
  const f = zo({
    d: u,
    fill: r,
    color: o,
    theme: s
  });
  return Ho(d, f)
}
const pbe = g.memo(function({
  fill: e,
  color: n,
  strokeWidth: r,
  w: o,
  h: s,
  id: i,
  size: a
}) {
  const c = Hr(),
    l = pv(o, s, i, a);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      theme: c,
      d: l,
      fill: e,
      color: n
    }), y.jsx("path", {
      d: l,
      stroke: c[n].solid,
      strokeWidth: r,
      fill: "none"
    })]
  })
});

function gbe({
  fill: t,
  color: e,
  strokeWidth: n,
  theme: r,
  w: o,
  h: s,
  id: i,
  size: a
}) {
  const c = pv(o, s, i, a),
    l = document.createElementNS("http://www.w3.org/2000/svg", "path");
  l.setAttribute("d", c), l.setAttribute("stroke-width", n.toString()), l.setAttribute("stroke", r[e].solid), l.setAttribute("fill", "none");
  const u = zo({
    d: c,
    fill: t,
    color: e,
    theme: r
  });
  return Ho(l, u)
}
const mbe = g.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: o,
  color: s
}) {
  const i = Hr(),
    a = e / 2,
    c = n / 2,
    l = Math.max(0, a),
    u = Math.max(0, c),
    d = `M${a-l},${c}a${l},${u},0,1,1,${l*2},0a${l},${u},0,1,1,-${l*2},0`;
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      d,
      color: s,
      fill: o,
      theme: i
    }), y.jsx("path", {
      d,
      stroke: i[s].solid,
      strokeWidth: r,
      fill: "none"
    })]
  })
});

function ybe({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: o,
  theme: s
}) {
  const i = t / 2,
    a = e / 2,
    c = Math.max(0, i),
    l = Math.max(0, a),
    u = `M${i-c},${a}a${c},${l},0,1,1,${c*2},0a${c},${l},0,1,1,-${c*2},0`,
    d = document.createElementNS("http://www.w3.org/2000/svg", "path");
  d.setAttribute("d", u), d.setAttribute("stroke-width", n.toString()), d.setAttribute("width", t.toString()), d.setAttribute("height", e.toString()), d.setAttribute("fill", "none"), d.setAttribute("stroke", s[o].solid);
  const f = zo({
    d: u,
    fill: r,
    color: o,
    theme: s
  });
  return Ho(d, f)
}
const vbe = g.memo(function({
  w: e,
  h: n,
  strokeWidth: r,
  fill: o,
  color: s
}) {
  const i = Hr(),
    a = cj(e, n);
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      d: a,
      color: s,
      fill: o,
      theme: i
    }), y.jsx("path", {
      d: a,
      stroke: i[s].solid,
      strokeWidth: r,
      fill: "none"
    })]
  })
});

function bbe({
  w: t,
  h: e,
  strokeWidth: n,
  fill: r,
  color: o,
  theme: s
}) {
  const i = cj(t, e),
    a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  a.setAttribute("d", i), a.setAttribute("stroke-width", n.toString()), a.setAttribute("width", t.toString()), a.setAttribute("height", e.toString()), a.setAttribute("fill", "none"), a.setAttribute("stroke", s[o].solid);
  const c = zo({
    d: i,
    fill: r,
    color: o,
    theme: s
  });
  return Ho(a, c)
}

function cj(t, e) {
  let n;
  if (e > t) {
    const r = t / 2;
    n = `
    M0,${r}
    a${r},${r},0,1,1,${r*2},0
    L${t},${e-r}
    a${r},${r},0,1,1,-${r*2},0
    Z`
  } else {
    const r = e / 2;
    n = `
    M${r},0
    L${t-r},0
    a${r},${r},0,1,1,0,${r*2}
    L${r},${e}
    a${r},${r},0,1,1,0,${-r*2}
    Z`
  }
  return n
}
const wbe = g.memo(function({
  outline: e,
  lines: n,
  fill: r,
  color: o,
  strokeWidth: s
}) {
  const i = Hr();
  let a = "M" + e[0] + "L" + e.slice(1) + "Z";
  if (n)
    for (const [c, l] of n) a += `M${c.x},${c.y}L${l.x},${l.y}`;
  return y.jsxs(y.Fragment, {
    children: [y.jsx(Uo, {
      d: a,
      fill: r,
      color: o,
      theme: i
    }), y.jsx("path", {
      d: a,
      stroke: i[o].solid,
      strokeWidth: s,
      fill: "none"
    })]
  })
});

function Sbe({
  outline: t,
  lines: e,
  fill: n,
  color: r,
  strokeWidth: o,
  theme: s
}) {
  const i = "M" + t[0] + "L" + t.slice(1) + "Z",
    a = i;
  let c = i;
  if (e)
    for (const [d, f] of e) c += `M${d.x},${d.y}L${f.x},${f.y}`;
  const l = document.createElementNS("http://www.w3.org/2000/svg", "path");
  l.setAttribute("d", c), l.setAttribute("stroke-width", o.toString()), l.setAttribute("stroke", s[r].solid), l.setAttribute("fill", "none");
  const u = zo({
    d: a,
    fill: n,
    color: r,
    theme: s
  });
  return Ho(l, u)
}

function Wre() {
  const [t, e] = g.useState(!1);
  return g.useEffect(() => {
    const n = window.matchMedia("(prefers-reduced-motion: reduce)"),
      r = () => {
        e(n.matches)
      };
    return r(), n.addEventListener("change", r), () => n.removeEventListener("change", r)
  }, []), t
}
class Ib extends R1 {
  constructor() {
    super(...arguments);
    P(this, "canEdit", () => !0);
    P(this, "isAspectRatioLocked", () => !0)
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: !0,
      url: ""
    }
  }
  component(n) {
    return y.jsx(Gre, {
      shape: n,
      videoUtil: this
    })
  }
  indicator(n) {
    return y.jsx("rect", {
      width: U(n.props.w),
      height: U(n.props.h)
    })
  }
  toSvg(n) {
    const r = document.createElementNS("http://www.w3.org/2000/svg", "g"),
      o = document.createElementNS("http://www.w3.org/2000/svg", "image");
    return o.setAttributeNS("http://www.w3.org/1999/xlink", "href", Kre(n.id)), o.setAttribute("width", n.props.w.toString()), o.setAttribute("height", n.props.h.toString()), r.appendChild(o), r
  }
}
P(Ib, "type", "video"), P(Ib, "props", NH), P(Ib, "migrations", LH);

function Kre(t) {
  const e = t.split(":")[1],
    n = document.querySelector(`.tl-video-shape-${e}`);
  if (n) {
    const r = document.createElement("canvas");
    return r.width = n.videoWidth, r.height = n.videoHeight, r.getContext("2d").drawImage(n, 0, 0), r.toDataURL("image/png")
  } else throw new Error("Video with id " + e + " not found")
}
const Gre = pt(function(e) {
  const {
    shape: n,
    videoUtil: r
  } = e, o = r.editor.getShapeGeometry(n).bounds.w * r.editor.zoomLevel >= 110, s = n.props.assetId ? r.editor.getAsset(n.props.assetId) : null, {
    time: i,
    playing: a
  } = n.props, c = W3(n.id), l = Wre(), u = se.useRef(null), d = se.useCallback(w => {
    const v = w.currentTarget;
    r.editor.updateShapes([{
      type: "video",
      id: n.id,
      props: {
        playing: !0,
        time: v.currentTime
      }
    }])
  }, [n.id, r.editor]), f = se.useCallback(w => {
    const v = w.currentTarget;
    r.editor.updateShapes([{
      type: "video",
      id: n.id,
      props: {
        playing: !1,
        time: v.currentTime
      }
    }])
  }, [n.id, r.editor]), h = se.useCallback(w => {
    const v = w.currentTarget;
    c && r.editor.updateShapes([{
      type: "video",
      id: n.id,
      props: {
        time: v.currentTime
      }
    }])
  }, [c, n.id, r.editor]), [m, p] = se.useState(!1), b = se.useCallback(w => {
    const v = w.currentTarget;
    i !== v.currentTime && (v.currentTime = i), a || v.pause(), p(!0)
  }, [a, i]);
  return se.useEffect(() => {
    const w = u.current;
    w && (m && !c && i !== w.currentTime && (w.currentTime = i), c && document.activeElement !== w && w.focus())
  }, [c, m, i]), se.useEffect(() => {
    if (l) {
      const w = u.current;
      w.pause(), w.currentTime = 0
    }
  }, [u, l]), y.jsxs(y.Fragment, {
    children: [y.jsx(V3, {
      id: n.id,
      children: y.jsx("div", {
        className: "tl-counter-scaled",
        children: s != null && s.props.src ? y.jsx("video", {
          ref: u,
          style: c ? {
            pointerEvents: "all"
          } : void 0,
          className: `tl-video tl-video-shape-${n.id.split(":")[1]}`,
          width: "100%",
          height: "100%",
          draggable: !1,
          playsInline: !0,
          autoPlay: !0,
          muted: !0,
          loop: !0,
          disableRemotePlayback: !0,
          disablePictureInPicture: !0,
          controls: c && o,
          onPlay: d,
          onPause: f,
          onTimeUpdate: h,
          onLoadedData: b,
          hidden: !m,
          children: y.jsx("source", {
            src: s.props.src
          })
        }) : null
      })
    }), "url" in n.props && n.props.url && y.jsx(XM, {
      url: n.props.url,
      zoomLevel: r.editor.zoomLevel
    })]
  })
});

function G() {
  return G = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
    }
    return t
  }, G.apply(this, arguments)
}

function ie(t, e, {
  checkForDefaultPrevented: n = !0
} = {}) {
  return function(o) {
    if (t == null || t(o), n === !1 || !o.defaultPrevented) return e == null ? void 0 : e(o)
  }
}

function Yre(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e)
}

function gv(...t) {
  return e => t.forEach(n => Yre(n, e))
}

function rt(...t) {
  return g.useCallback(gv(...t), t)
}

function Vo(t, e = []) {
  let n = [];

  function r(s, i) {
    const a = g.createContext(i),
      c = n.length;
    n = [...n, i];

    function l(d) {
      const {
        scope: f,
        children: h,
        ...m
      } = d, p = (f == null ? void 0 : f[t][c]) || a, b = g.useMemo(() => m, Object.values(m));
      return g.createElement(p.Provider, {
        value: b
      }, h)
    }

    function u(d, f) {
      const h = (f == null ? void 0 : f[t][c]) || a,
        m = g.useContext(h);
      if (m) return m;
      if (i !== void 0) return i;
      throw new Error(`\`${d}\` must be used within \`${s}\``)
    }
    return l.displayName = s + "Provider", [l, u]
  }
  const o = () => {
    const s = n.map(i => g.createContext(i));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || s;
      return g.useMemo(() => ({
        [`__scope${t}`]: {
          ...a,
          [t]: c
        }
      }), [a, c])
    }
  };
  return o.scopeName = t, [r, qre(o, ...e)]
}

function qre(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map(o => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(s) {
      const i = r.reduce((a, {
        useScope: c,
        scopeName: l
      }) => {
        const d = c(s)[`__scope${l}`];
        return {
          ...a,
          ...d
        }
      }, {});
      return g.useMemo(() => ({
        [`__scope${e.scopeName}`]: i
      }), [i])
    }
  };
  return n.scopeName = e.scopeName, n
}
const Wi = g.forwardRef((t, e) => {
  const {
    children: n,
    ...r
  } = t, o = g.Children.toArray(n), s = o.find(Zre);
  if (s) {
    const i = s.props.children,
      a = o.map(c => c === s ? g.Children.count(i) > 1 ? g.Children.only(null) : g.isValidElement(i) ? i.props.children : null : c);
    return g.createElement(u_, G({}, r, {
      ref: e
    }), g.isValidElement(i) ? g.cloneElement(i, void 0, a) : null)
  }
  return g.createElement(u_, G({}, r, {
    ref: e
  }), n)
});
Wi.displayName = "Slot";
const u_ = g.forwardRef((t, e) => {
  const {
    children: n,
    ...r
  } = t;
  return g.isValidElement(n) ? g.cloneElement(n, {
    ...Jre(r, n.props),
    ref: e ? gv(e, n.ref) : n.ref
  }) : g.Children.count(n) > 1 ? g.Children.only(null) : null
});
u_.displayName = "SlotClone";
const Xre = ({
  children: t
}) => g.createElement(g.Fragment, null, t);

function Zre(t) {
  return g.isValidElement(t) && t.type === Xre
}

function Jre(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const o = t[r],
      s = e[r];
    /^on[A-Z]/.test(r) ? o && s ? n[r] = (...a) => {
      s(...a), o(...a)
    } : o && (n[r] = o) : r === "style" ? n[r] = {
      ...o,
      ...s
    } : r === "className" && (n[r] = [o, s].filter(Boolean).join(" "))
  }
  return {
    ...t,
    ...n
  }
}

function mv(t) {
  const e = t + "CollectionProvider",
    [n, r] = Vo(e),
    [o, s] = n(e, {
      collectionRef: {
        current: null
      },
      itemMap: new Map
    }),
    i = h => {
      const {
        scope: m,
        children: p
      } = h, b = se.useRef(null), w = se.useRef(new Map).current;
      return se.createElement(o, {
        scope: m,
        itemMap: w,
        collectionRef: b
      }, p)
    },
    a = t + "CollectionSlot",
    c = se.forwardRef((h, m) => {
      const {
        scope: p,
        children: b
      } = h, w = s(a, p), v = rt(m, w.collectionRef);
      return se.createElement(Wi, {
        ref: v
      }, b)
    }),
    l = t + "CollectionItemSlot",
    u = "data-radix-collection-item",
    d = se.forwardRef((h, m) => {
      const {
        scope: p,
        children: b,
        ...w
      } = h, v = se.useRef(null), _ = rt(m, v), S = s(l, p);
      return se.useEffect(() => (S.itemMap.set(v, {
        ref: v,
        ...w
      }), () => void S.itemMap.delete(v))), se.createElement(Wi, {
        [u]: "",
        ref: _
      }, b)
    });

  function f(h) {
    const m = s(t + "CollectionConsumer", h);
    return se.useCallback(() => {
      const b = m.collectionRef.current;
      if (!b) return [];
      const w = Array.from(b.querySelectorAll(`[${u}]`));
      return Array.from(m.itemMap.values()).sort((S, x) => w.indexOf(S.ref.current) - w.indexOf(x.ref.current))
    }, [m.collectionRef, m.itemMap])
  }
  return [{
    Provider: i,
    Slot: c,
    ItemSlot: d
  }, f, r]
}
const Qre = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  Ke = Qre.reduce((t, e) => {
    const n = g.forwardRef((r, o) => {
      const {
        asChild: s,
        ...i
      } = r, a = s ? Wi : e;
      return g.useEffect(() => {
        window[Symbol.for("radix-ui")] = !0
      }, []), g.createElement(a, G({}, i, {
        ref: o
      }))
    });
    return n.displayName = `Primitive.${e}`, {
      ...t,
      [e]: n
    }
  }, {});

function Rh(t, e) {
  t && ta.flushSync(() => t.dispatchEvent(e))
}

function At(t) {
  const e = g.useRef(t);
  return g.useEffect(() => {
    e.current = t
  }), g.useMemo(() => (...n) => {
    var r;
    return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n)
  }, [])
}

function eE(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t);
  g.useEffect(() => {
    const r = o => {
      o.key === "Escape" && n(o)
    };
    return e.addEventListener("keydown", r), () => e.removeEventListener("keydown", r)
  }, [n, e])
}
const d_ = "dismissableLayer.update",
  eoe = "dismissableLayer.pointerDownOutside",
  toe = "dismissableLayer.focusOutside";
let A2;
const lj = g.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
  }),
  noe = g.forwardRef((t, e) => {
    var n;
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: a,
      onDismiss: c,
      ...l
    } = t, u = g.useContext(lj), [d, f] = g.useState(null), h = (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, m] = g.useState({}), p = rt(e, C => f(C)), b = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), v = b.indexOf(w), _ = d ? b.indexOf(d) : -1, S = u.layersWithOutsidePointerEventsDisabled.size > 0, x = _ >= v, E = ooe(C => {
      const $ = C.target,
        I = [...u.branches].some(R => R.contains($));
      !x || I || (s == null || s(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h), k = soe(C => {
      const $ = C.target;
      [...u.branches].some(R => R.contains($)) || (i == null || i(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h);
    return eE(C => {
      _ === u.layers.size - 1 && (o == null || o(C), !C.defaultPrevented && c && (C.preventDefault(), c()))
    }, h), g.useEffect(() => {
      if (d) return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (A2 = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), M2(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = A2)
      }
    }, [d, h, r, u]), g.useEffect(() => () => {
      d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), M2())
    }, [d, u]), g.useEffect(() => {
      const C = () => m({});
      return document.addEventListener(d_, C), () => document.removeEventListener(d_, C)
    }, []), g.createElement(Ke.div, G({}, l, {
      ref: p,
      style: {
        pointerEvents: S ? x ? "auto" : "none" : void 0,
        ...t.style
      },
      onFocusCapture: ie(t.onFocusCapture, k.onFocusCapture),
      onBlurCapture: ie(t.onBlurCapture, k.onBlurCapture),
      onPointerDownCapture: ie(t.onPointerDownCapture, E.onPointerDownCapture)
    }))
  }),
  roe = g.forwardRef((t, e) => {
    const n = g.useContext(lj),
      r = g.useRef(null),
      o = rt(e, r);
    return g.useEffect(() => {
      const s = r.current;
      if (s) return n.branches.add(s), () => {
        n.branches.delete(s)
      }
    }, [n.branches]), g.createElement(Ke.div, G({}, t, {
      ref: o
    }))
  });

function ooe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1),
    o = g.useRef(() => {});
  return g.useEffect(() => {
    const s = a => {
        if (a.target && !r.current) {
          let l = function() {
            uj(eoe, n, c, {
              discrete: !0
            })
          };
          const c = {
            originalEvent: a
          };
          a.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = l, e.addEventListener("click", o.current, {
            once: !0
          })) : l()
        }
        r.current = !1
      },
      i = window.setTimeout(() => {
        e.addEventListener("pointerdown", s)
      }, 0);
    return () => {
      window.clearTimeout(i), e.removeEventListener("pointerdown", s), e.removeEventListener("click", o.current)
    }
  }, [e, n]), {
    onPointerDownCapture: () => r.current = !0
  }
}

function soe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1);
  return g.useEffect(() => {
    const o = s => {
      s.target && !r.current && uj(toe, n, {
        originalEvent: s
      }, {
        discrete: !1
      })
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o)
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  }
}

function M2() {
  const t = new CustomEvent(d_);
  document.dispatchEvent(t)
}

function uj(t, e, n, {
  discrete: r
}) {
  const o = n.originalEvent.target,
    s = new CustomEvent(t, {
      bubbles: !1,
      cancelable: !0,
      detail: n
    });
  e && o.addEventListener(t, e, {
    once: !0
  }), r ? Rh(o, s) : o.dispatchEvent(s)
}
const ioe = noe,
  aoe = roe,
  coe = g.forwardRef((t, e) => {
    var n;
    const {
      container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body,
      ...o
    } = t;
    return r ? KR.createPortal(g.createElement(Ke.div, G({}, o, {
      ref: e
    })), r) : null
  }),
  Sr = globalThis != null && globalThis.document ? g.useLayoutEffect : () => {};

function loe(t, e) {
  return g.useReducer((n, r) => {
    const o = e[n][r];
    return o ?? n
  }, t)
}
const Wo = t => {
  const {
    present: e,
    children: n
  } = t, r = uoe(e), o = typeof n == "function" ? n({
    present: r.isPresent
  }) : g.Children.only(n), s = rt(r.ref, o.ref);
  return typeof n == "function" || r.isPresent ? g.cloneElement(o, {
    ref: s
  }) : null
};
Wo.displayName = "Presence";

function uoe(t) {
  const [e, n] = g.useState(), r = g.useRef({}), o = g.useRef(t), s = g.useRef("none"), i = t ? "mounted" : "unmounted", [a, c] = loe(i, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return g.useEffect(() => {
    const l = Yp(r.current);
    s.current = a === "mounted" ? l : "none"
  }, [a]), Sr(() => {
    const l = r.current,
      u = o.current;
    if (u !== t) {
      const f = s.current,
        h = Yp(l);
      t ? c("MOUNT") : h === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), o.current = t
    }
  }, [t, c]), Sr(() => {
    if (e) {
      const l = d => {
          const h = Yp(r.current).includes(d.animationName);
          d.target === e && h && ta.flushSync(() => c("ANIMATION_END"))
        },
        u = d => {
          d.target === e && (s.current = Yp(r.current))
        };
      return e.addEventListener("animationstart", u), e.addEventListener("animationcancel", l), e.addEventListener("animationend", l), () => {
        e.removeEventListener("animationstart", u), e.removeEventListener("animationcancel", l), e.removeEventListener("animationend", l)
      }
    } else c("ANIMATION_END")
  }, [e, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: g.useCallback(l => {
      l && (r.current = getComputedStyle(l)), n(l)
    }, [])
  }
}

function Yp(t) {
  return (t == null ? void 0 : t.animationName) || "none"
}

function Xs({
  prop: t,
  defaultProp: e,
  onChange: n = () => {}
}) {
  const [r, o] = doe({
    defaultProp: e,
    onChange: n
  }), s = t !== void 0, i = s ? t : r, a = At(n), c = g.useCallback(l => {
    if (s) {
      const d = typeof l == "function" ? l(t) : l;
      d !== t && a(d)
    } else o(l)
  }, [s, t, o, a]);
  return [i, c]
}

function doe({
  defaultProp: t,
  onChange: e
}) {
  const n = g.useState(t),
    [r] = n,
    o = g.useRef(r),
    s = At(e);
  return g.useEffect(() => {
    o.current !== r && (s(r), o.current = r)
  }, [r, o, s]), n
}
const yv = g.forwardRef((t, e) => g.createElement(Ke.span, G({}, t, {
    ref: e,
    style: {
      position: "absolute",
      border: 0,
      width: 1,
      height: 1,
      padding: 0,
      margin: -1,
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      wordWrap: "normal",
      ...t.style
    }
  }))),
  _be = yv,
  dj = "ToastProvider",
  [tE, foe, hoe] = mv("Toast"),
  [fj, xbe] = Vo("Toast", [hoe]),
  [poe, vv] = fj(dj),
  nE = t => {
    const {
      __scopeToast: e,
      label: n = "Notification",
      duration: r = 5e3,
      swipeDirection: o = "right",
      swipeThreshold: s = 50,
      children: i
    } = t, [a, c] = g.useState(null), [l, u] = g.useState(0), d = g.useRef(!1), f = g.useRef(!1);
    return g.createElement(tE.Provider, {
      scope: e
    }, g.createElement(poe, {
      scope: e,
      label: n,
      duration: r,
      swipeDirection: o,
      swipeThreshold: s,
      toastCount: l,
      viewport: a,
      onViewportChange: c,
      onToastAdd: g.useCallback(() => u(h => h + 1), []),
      onToastRemove: g.useCallback(() => u(h => h - 1), []),
      isFocusedToastEscapeKeyDownRef: d,
      isClosePausedRef: f
    }, i))
  };
nE.propTypes = {
  label(t) {
    if (t.label && typeof t.label == "string" && !t.label.trim()) {
      const e = `Invalid prop \`label\` supplied to \`${dj}\`. Expected non-empty \`string\`.`;
      return new Error(e)
    }
    return null
  }
};
const goe = "ToastViewport",
  moe = ["F8"],
  f_ = "toast.viewportPause",
  h_ = "toast.viewportResume",
  hj = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      hotkey: r = moe,
      label: o = "Notifications ({hotkey})",
      ...s
    } = t, i = vv(goe, n), a = foe(n), c = g.useRef(null), l = g.useRef(null), u = g.useRef(null), d = g.useRef(null), f = rt(e, d, i.onViewportChange), h = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), m = i.toastCount > 0;
    g.useEffect(() => {
      const b = w => {
        var v;
        r.every(S => w[S] || w.code === S) && ((v = d.current) === null || v === void 0 || v.focus())
      };
      return document.addEventListener("keydown", b), () => document.removeEventListener("keydown", b)
    }, [r]), g.useEffect(() => {
      const b = c.current,
        w = d.current;
      if (m && b && w) {
        const v = () => {
            if (!i.isClosePausedRef.current) {
              const E = new CustomEvent(f_);
              w.dispatchEvent(E), i.isClosePausedRef.current = !0
            }
          },
          _ = () => {
            if (i.isClosePausedRef.current) {
              const E = new CustomEvent(h_);
              w.dispatchEvent(E), i.isClosePausedRef.current = !1
            }
          },
          S = E => {
            !b.contains(E.relatedTarget) && _()
          },
          x = () => {
            b.contains(document.activeElement) || _()
          };
        return b.addEventListener("focusin", v), b.addEventListener("focusout", S), b.addEventListener("pointermove", v), b.addEventListener("pointerleave", x), window.addEventListener("blur", v), window.addEventListener("focus", _), () => {
          b.removeEventListener("focusin", v), b.removeEventListener("focusout", S), b.removeEventListener("pointermove", v), b.removeEventListener("pointerleave", x), window.removeEventListener("blur", v), window.removeEventListener("focus", _)
        }
      }
    }, [m, i.isClosePausedRef]);
    const p = g.useCallback(({
      tabbingDirection: b
    }) => {
      const v = a().map(_ => {
        const S = _.ref.current,
          x = [S, ...Roe(S)];
        return b === "forwards" ? x : x.reverse()
      });
      return (b === "forwards" ? v.reverse() : v).flat()
    }, [a]);
    return g.useEffect(() => {
      const b = d.current;
      if (b) {
        const w = v => {
          const _ = v.altKey || v.ctrlKey || v.metaKey;
          if (v.key === "Tab" && !_) {
            const C = document.activeElement,
              $ = v.shiftKey;
            if (v.target === b && $) {
              var x;
              (x = l.current) === null || x === void 0 || x.focus();
              return
            }
            const M = p({
                tabbingDirection: $ ? "backwards" : "forwards"
              }),
              j = M.findIndex(A => A === C);
            if (Ob(M.slice(j + 1))) v.preventDefault();
            else {
              var E, k;
              $ ? (E = l.current) === null || E === void 0 || E.focus() : (k = u.current) === null || k === void 0 || k.focus()
            }
          }
        };
        return b.addEventListener("keydown", w), () => b.removeEventListener("keydown", w)
      }
    }, [a, p]), g.createElement(aoe, {
      ref: c,
      role: "region",
      "aria-label": o.replace("{hotkey}", h),
      tabIndex: -1,
      style: {
        pointerEvents: m ? void 0 : "none"
      }
    }, m && g.createElement(j2, {
      ref: l,
      onFocusFromOutsideViewport: () => {
        const b = p({
          tabbingDirection: "forwards"
        });
        Ob(b)
      }
    }), g.createElement(tE.Slot, {
      scope: n
    }, g.createElement(Ke.ol, G({
      tabIndex: -1
    }, s, {
      ref: f
    }))), m && g.createElement(j2, {
      ref: u,
      onFocusFromOutsideViewport: () => {
        const b = p({
          tabbingDirection: "backwards"
        });
        Ob(b)
      }
    }))
  }),
  yoe = "ToastFocusProxy",
  j2 = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      onFocusFromOutsideViewport: r,
      ...o
    } = t, s = vv(yoe, n);
    return g.createElement(yv, G({
      "aria-hidden": !0,
      tabIndex: 0
    }, o, {
      ref: e,
      style: {
        position: "fixed"
      },
      onFocus: i => {
        var a;
        const c = i.relatedTarget;
        !((a = s.viewport) !== null && a !== void 0 && a.contains(c)) && r()
      }
    }))
  }),
  bv = "Toast",
  voe = "toast.swipeStart",
  boe = "toast.swipeMove",
  woe = "toast.swipeCancel",
  Soe = "toast.swipeEnd",
  _oe = g.forwardRef((t, e) => {
    const {
      forceMount: n,
      open: r,
      defaultOpen: o,
      onOpenChange: s,
      ...i
    } = t, [a = !0, c] = Xs({
      prop: r,
      defaultProp: o,
      onChange: s
    });
    return g.createElement(Wo, {
      present: n || a
    }, g.createElement(pj, G({
      open: a
    }, i, {
      ref: e,
      onClose: () => c(!1),
      onPause: At(t.onPause),
      onResume: At(t.onResume),
      onSwipeStart: ie(t.onSwipeStart, l => {
        l.currentTarget.setAttribute("data-swipe", "start")
      }),
      onSwipeMove: ie(t.onSwipeMove, l => {
        const {
          x: u,
          y: d
        } = l.detail.delta;
        l.currentTarget.setAttribute("data-swipe", "move"), l.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${u}px`), l.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${d}px`)
      }),
      onSwipeCancel: ie(t.onSwipeCancel, l => {
        l.currentTarget.setAttribute("data-swipe", "cancel"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), l.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
      }),
      onSwipeEnd: ie(t.onSwipeEnd, l => {
        const {
          x: u,
          y: d
        } = l.detail.delta;
        l.currentTarget.setAttribute("data-swipe", "end"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), l.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), l.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${u}px`), l.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${d}px`), c(!1)
      })
    })))
  }),
  [xoe, Eoe] = fj(bv, {
    onClose() {}
  }),
  pj = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: o,
      open: s,
      onClose: i,
      onEscapeKeyDown: a,
      onPause: c,
      onResume: l,
      onSwipeStart: u,
      onSwipeMove: d,
      onSwipeCancel: f,
      onSwipeEnd: h,
      ...m
    } = t, p = vv(bv, n), [b, w] = g.useState(null), v = rt(e, A => w(A)), _ = g.useRef(null), S = g.useRef(null), x = o || p.duration, E = g.useRef(0), k = g.useRef(x), C = g.useRef(0), {
      onToastAdd: $,
      onToastRemove: I
    } = p, R = At(() => {
      var A;
      (b == null ? void 0 : b.contains(document.activeElement)) && ((A = p.viewport) === null || A === void 0 || A.focus()), i()
    }), M = g.useCallback(A => {
      !A || A === 1 / 0 || (window.clearTimeout(C.current), E.current = new Date().getTime(), C.current = window.setTimeout(R, A))
    }, [R]);
    g.useEffect(() => {
      const A = p.viewport;
      if (A) {
        const D = () => {
            M(k.current), l == null || l()
          },
          N = () => {
            const q = new Date().getTime() - E.current;
            k.current = k.current - q, window.clearTimeout(C.current), c == null || c()
          };
        return A.addEventListener(f_, N), A.addEventListener(h_, D), () => {
          A.removeEventListener(f_, N), A.removeEventListener(h_, D)
        }
      }
    }, [p.viewport, x, c, l, M]), g.useEffect(() => {
      s && !p.isClosePausedRef.current && M(x)
    }, [s, x, p.isClosePausedRef, M]), g.useEffect(() => ($(), () => I()), [$, I]);
    const j = g.useMemo(() => b ? vj(b) : null, [b]);
    return p.viewport ? g.createElement(g.Fragment, null, j && g.createElement(koe, {
      __scopeToast: n,
      role: "status",
      "aria-live": r === "foreground" ? "assertive" : "polite",
      "aria-atomic": !0
    }, j), g.createElement(xoe, {
      scope: n,
      onClose: R
    }, ta.createPortal(g.createElement(tE.ItemSlot, {
      scope: n
    }, g.createElement(ioe, {
      asChild: !0,
      onEscapeKeyDown: ie(a, () => {
        p.isFocusedToastEscapeKeyDownRef.current || R(), p.isFocusedToastEscapeKeyDownRef.current = !1
      })
    }, g.createElement(Ke.li, G({
      role: "status",
      "aria-live": "off",
      "aria-atomic": !0,
      tabIndex: 0,
      "data-state": s ? "open" : "closed",
      "data-swipe-direction": p.swipeDirection
    }, m, {
      ref: v,
      style: {
        userSelect: "none",
        touchAction: "none",
        ...t.style
      },
      onKeyDown: ie(t.onKeyDown, A => {
        A.key === "Escape" && (a == null || a(A.nativeEvent), A.nativeEvent.defaultPrevented || (p.isFocusedToastEscapeKeyDownRef.current = !0, R()))
      }),
      onPointerDown: ie(t.onPointerDown, A => {
        A.button === 0 && (_.current = {
          x: A.clientX,
          y: A.clientY
        })
      }),
      onPointerMove: ie(t.onPointerMove, A => {
        if (!_.current) return;
        const D = A.clientX - _.current.x,
          N = A.clientY - _.current.y,
          q = !!S.current,
          F = ["left", "right"].includes(p.swipeDirection),
          B = ["left", "up"].includes(p.swipeDirection) ? Math.min : Math.max,
          V = F ? B(0, D) : 0,
          J = F ? 0 : B(0, N),
          ee = A.pointerType === "touch" ? 10 : 2,
          ye = {
            x: V,
            y: J
          },
          ge = {
            originalEvent: A,
            delta: ye
          };
        q ? (S.current = ye, qp(boe, d, ge, {
          discrete: !1
        })) : D2(ye, p.swipeDirection, ee) ? (S.current = ye, qp(voe, u, ge, {
          discrete: !1
        }), A.target.setPointerCapture(A.pointerId)) : (Math.abs(D) > ee || Math.abs(N) > ee) && (_.current = null)
      }),
      onPointerUp: ie(t.onPointerUp, A => {
        const D = S.current,
          N = A.target;
        if (N.hasPointerCapture(A.pointerId) && N.releasePointerCapture(A.pointerId), S.current = null, _.current = null, D) {
          const q = A.currentTarget,
            F = {
              originalEvent: A,
              delta: D
            };
          D2(D, p.swipeDirection, p.swipeThreshold) ? qp(Soe, h, F, {
            discrete: !0
          }) : qp(woe, f, F, {
            discrete: !0
          }), q.addEventListener("click", B => B.preventDefault(), {
            once: !0
          })
        }
      })
    })))), p.viewport))) : null
  });
pj.propTypes = {
  type(t) {
    if (t.type && !["foreground", "background"].includes(t.type)) {
      const e = `Invalid prop \`type\` supplied to \`${bv}\`. Expected \`foreground | background\`.`;
      return new Error(e)
    }
    return null
  }
};
const koe = t => {
    const {
      __scopeToast: e,
      children: n,
      ...r
    } = t, o = vv(bv, e), [s, i] = g.useState(!1), [a, c] = g.useState(!1);
    return Ioe(() => i(!0)), g.useEffect(() => {
      const l = window.setTimeout(() => c(!0), 1e3);
      return () => window.clearTimeout(l)
    }, []), a ? null : g.createElement(coe, {
      asChild: !0
    }, g.createElement(yv, r, s && g.createElement(g.Fragment, null, o.label, " ", n)))
  },
  Coe = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      ...r
    } = t;
    return g.createElement(Ke.div, G({}, r, {
      ref: e
    }))
  }),
  Poe = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      ...r
    } = t;
    return g.createElement(Ke.div, G({}, r, {
      ref: e
    }))
  }),
  Toe = "ToastAction",
  gj = g.forwardRef((t, e) => {
    const {
      altText: n,
      ...r
    } = t;
    return n ? g.createElement(yj, {
      altText: n,
      asChild: !0
    }, g.createElement(mj, G({}, r, {
      ref: e
    }))) : null
  });
gj.propTypes = {
  altText(t) {
    return t.altText ? null : new Error(`Missing prop \`altText\` expected on \`${Toe}\``)
  }
};
const $oe = "ToastClose",
  mj = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      ...r
    } = t, o = Eoe($oe, n);
    return g.createElement(yj, {
      asChild: !0
    }, g.createElement(Ke.button, G({
      type: "button"
    }, r, {
      ref: e,
      onClick: ie(t.onClick, o.onClose)
    })))
  }),
  yj = g.forwardRef((t, e) => {
    const {
      __scopeToast: n,
      altText: r,
      ...o
    } = t;
    return g.createElement(Ke.div, G({
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0
    }, o, {
      ref: e
    }))
  });

function vj(t) {
  const e = [];
  return Array.from(t.childNodes).forEach(r => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), Ooe(r)) {
      const o = r.ariaHidden || r.hidden || r.style.display === "none",
        s = r.dataset.radixToastAnnounceExclude === "";
      if (!o)
        if (s) {
          const i = r.dataset.radixToastAnnounceAlt;
          i && e.push(i)
        } else e.push(...vj(r))
    }
  }), e
}

function qp(t, e, n, {
  discrete: r
}) {
  const o = n.originalEvent.currentTarget,
    s = new CustomEvent(t, {
      bubbles: !0,
      cancelable: !0,
      detail: n
    });
  e && o.addEventListener(t, e, {
    once: !0
  }), r ? Rh(o, s) : o.dispatchEvent(s)
}
const D2 = (t, e, n = 0) => {
  const r = Math.abs(t.x),
    o = Math.abs(t.y),
    s = r > o;
  return e === "left" || e === "right" ? s && r > n : !s && o > n
};

function Ioe(t = () => {}) {
  const e = At(t);
  Sr(() => {
    let n = 0,
      r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(e)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r)
    }
  }, [e])
}

function Ooe(t) {
  return t.nodeType === t.ELEMENT_NODE
}

function Roe(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: r => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      }
    });
  for (; n.nextNode();) e.push(n.currentNode);
  return e
}

function Ob(t) {
  const e = document.activeElement;
  return t.some(n => n === e ? !0 : (n.focus(), document.activeElement !== e))
}
const Aoe = nE,
  Moe = hj,
  bj = _oe,
  wj = Coe,
  joe = Poe,
  Doe = gj,
  N2 = mj,
  Oa = "2.0.0-alpha.12";
let Km = {
  fonts: {
    draw: `https://unpkg.com/@tldraw/assets@${Oa}/fonts/Shantell_Sans-Normal-SemiBold.woff2`,
    serif: `https://unpkg.com/@tldraw/assets@${Oa}/fonts/IBMPlexSerif-Medium.woff2`,
    sansSerif: `https://unpkg.com/@tldraw/assets@${Oa}/fonts/IBMPlexSans-Medium.woff2`,
    monospace: `https://unpkg.com/@tldraw/assets@${Oa}/fonts/IBMPlexMono-Medium.woff2`
  }
};

function Ebe(t) {
  Km = t
}

function kbe(t) {
  return g.useMemo(() => t ? {
    fonts: {
      ...Km.fonts,
      ...t == null ? void 0 : t.fonts
    }
  } : Km, [t])
}
const Noe = ["align-bottom-center", "align-bottom-left", "align-bottom-right", "align-bottom", "align-center-center", "align-center-horizontal", "align-center-left", "align-center-right", "align-center-vertical", "align-left", "align-right", "align-top-center", "align-top-left", "align-top-right", "align-top", "arrow-left", "arrowhead-arrow", "arrowhead-bar", "arrowhead-diamond", "arrowhead-dot", "arrowhead-none", "arrowhead-square", "arrowhead-triangle-inverted", "arrowhead-triangle", "aspect-ratio", "avatar", "blob", "bring-forward", "bring-to-front", "check", "checkbox-checked", "checkbox-empty", "chevron-down", "chevron-left", "chevron-right", "chevron-up", "chevrons-ne", "chevrons-sw", "clipboard-copied", "clipboard-copy", "code", "collab", "color", "comment", "cross-2", "cross", "dash-dashed", "dash-dotted", "dash-draw", "dash-solid", "discord", "distribute-horizontal", "distribute-vertical", "dot", "dots-horizontal", "dots-vertical", "drag-handle-dots", "duplicate", "edit", "external-link", "file", "fill-none", "fill-pattern", "fill-semi", "fill-solid", "follow", "following", "font-draw", "font-mono", "font-sans", "font-serif", "geo-arrow-down", "geo-arrow-left", "geo-arrow-right", "geo-arrow-up", "geo-check-box", "geo-cloud", "geo-diamond", "geo-ellipse", "geo-hexagon", "geo-octagon", "geo-oval", "geo-pentagon", "geo-rectangle", "geo-rhombus-2", "geo-rhombus", "geo-star", "geo-trapezoid", "geo-triangle", "geo-x-box", "github", "group", "hidden", "image", "info-circle", "leading", "link", "lock-small", "lock", "menu", "minus", "mixed", "pack", "page", "plus", "question-mark-circle", "question-mark", "redo", "reset-zoom", "rotate-ccw", "rotate-cw", "ruler", "search", "send-backward", "send-to-back", "settings-horizontal", "settings-vertical-1", "settings-vertical", "share-1", "share-2", "size-extra-large", "size-large", "size-medium", "size-small", "spline-cubic", "spline-line", "stack-horizontal", "stack-vertical", "status-offline", "status-online", "stretch-horizontal", "stretch-vertical", "text-align-center", "text-align-justify", "text-align-left", "text-align-right", "tool-arrow", "tool-embed", "tool-eraser", "tool-frame", "tool-hand", "tool-highlight", "tool-laser", "tool-line", "tool-media", "tool-note", "tool-pencil", "tool-pointer", "tool-text", "trash", "triangle-down", "triangle-up", "twitter", "undo", "ungroup", "unlock-small", "unlock", "vertical-align-center", "vertical-align-end", "vertical-align-start", "visible", "warning-triangle", "zoom-in", "zoom-out"];
let Xc = {
  ...Km,
  icons: Object.fromEntries(Noe.map(t => [t, `https://unpkg.com/@tldraw/assets@${Oa}/icons/icon/${t}.svg`])),
  translations: Object.fromEntries(Of.map(t => [t.locale, `https://unpkg.com/@tldraw/assets@${Oa}/translations/${t.locale}.json`])),
  embedIcons: Object.fromEntries(nu.map(t => [t.type, `https://unpkg.com/@tldraw/assets@${Oa}/embed-icons/${t.type}.png`]))
};

function Cbe(t) {
  Xc = t
}

function Loe(t) {
  return t ? {
    fonts: Object.assign({
      ...Xc.fonts
    }, {
      ...t == null ? void 0 : t.fonts
    }),
    icons: Object.assign({
      ...Xc.icons
    }, {
      ...t == null ? void 0 : t.icons
    }),
    embedIcons: Object.assign({
      ...Xc.embedIcons
    }, {
      ...t == null ? void 0 : t.embedIcons
    }),
    translations: Object.assign({
      ...Xc.translations
    }, {
      ...t == null ? void 0 : t.translations
    })
  } : Xc
}
const Sj = g.createContext(null);

function Foe({
  assetUrls: t,
  children: e
}) {
  return y.jsx(Sj.Provider, {
    value: t,
    children: e
  })
}

function rE() {
  const t = g.useContext(Sj);
  if (!t) throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return t
}
const p_ = {
    "action.convert-to-bookmark": "Convert to Bookmark",
    "action.convert-to-embed": "Convert to Embed",
    "action.open-embed-link": "Open link",
    "action.align-bottom": "Align bottom",
    "action.align-center-horizontal": "Align horizontally",
    "action.align-center-vertical": "Align vertically",
    "action.align-center-horizontal.short": "Align H",
    "action.align-center-vertical.short": "Align V",
    "action.align-left": "Align left",
    "action.align-right": "Align right",
    "action.align-top": "Align top",
    "action.back-to-content": "Back to content",
    "action.bring-forward": "Bring forward",
    "action.bring-to-front": "Bring to front",
    "action.copy-as-json.short": "JSON",
    "action.copy-as-json": "Copy as JSON",
    "action.copy-as-png.short": "PNG",
    "action.copy-as-png": "Copy as PNG",
    "action.copy-as-svg.short": "SVG",
    "action.copy-as-svg": "Copy as SVG",
    "action.copy": "Copy",
    "action.cut": "Cut",
    "action.delete": "Delete",
    "action.unlock-all": "Unlock all",
    "action.distribute-horizontal": "Distribute horizontally",
    "action.distribute-vertical": "Distribute vertically",
    "action.distribute-horizontal.short": "Distribute H",
    "action.distribute-vertical.short": "Distribute V",
    "action.duplicate": "Duplicate",
    "action.edit-link": "Edit link",
    "action.exit-pen-mode": "Exit pen mode",
    "action.export-as-json.short": "JSON",
    "action.export-as-json": "Export as JSON",
    "action.export-as-png.short": "PNG",
    "action.export-as-png": "Export as PNG",
    "action.export-as-svg.short": "SVG",
    "action.export-as-svg": "Export as SVG",
    "action.flip-horizontal": "Flip horizontally",
    "action.flip-vertical": "Flip vertically",
    "action.flip-horizontal.short": "Flip H",
    "action.flip-vertical.short": "Flip V",
    "action.fork-project": "Fork this project",
    "action.group": "Group",
    "action.insert-embed": "Insert embed",
    "action.insert-media": "Upload media",
    "action.leave-shared-project": "Leave shared project",
    "action.new-project": "New project",
    "action.new-shared-project": "New shared project",
    "action.open-cursor-chat": "Cursor chat",
    "action.open-file": "Open file",
    "action.pack": "Pack",
    "action.paste": "Paste",
    "action.print": "Print",
    "action.redo": "Redo",
    "action.rotate-ccw": "Rotate counterclockwise",
    "action.rotate-cw": "Rotate clockwise",
    "action.save-copy": "Save a copy",
    "action.select-all": "Select all",
    "action.select-none": "Select none",
    "action.send-backward": "Send backward",
    "action.send-to-back": "Send to back",
    "action.share-project": "Share this project",
    "action.stack-horizontal": "Stack horizontally",
    "action.stack-vertical": "Stack vertically",
    "action.stack-horizontal.short": "Stack H",
    "action.stack-vertical.short": "Stack V",
    "action.stop-following": "Stop following",
    "action.stretch-horizontal": "Stretch horizontally",
    "action.stretch-vertical": "Stretch vertically",
    "action.stretch-horizontal.short": "Stretch H",
    "action.stretch-vertical.short": "Stretch V",
    "action.toggle-auto-size": "Toggle auto size",
    "action.toggle-dark-mode.menu": "Dark mode",
    "action.toggle-dark-mode": "Toggle dark mode",
    "action.toggle-reduce-motion.menu": "Reduce motion",
    "action.toggle-reduce-motion": "Toggle reduce motion",
    "action.toggle-debug-mode.menu": "Debug mode",
    "action.toggle-debug-mode": "Toggle debug mode",
    "action.toggle-focus-mode.menu": "Focus mode",
    "action.toggle-focus-mode": "Toggle focus mode",
    "action.toggle-grid.menu": "Show grid",
    "action.toggle-grid": "Toggle grid",
    "action.toggle-lock": "Toggle locked",
    "action.toggle-snap-mode.menu": "Always snap",
    "action.toggle-snap-mode": "Toggle always snap",
    "action.toggle-tool-lock.menu": "Tool lock",
    "action.toggle-tool-lock": "Toggle tool lock",
    "action.toggle-transparent.context-menu": "Transparent",
    "action.toggle-transparent.menu": "Transparent",
    "action.toggle-transparent": "Toggle transparent background",
    "action.undo": "Undo",
    "action.ungroup": "Ungroup",
    "action.zoom-in": "Zoom in",
    "action.zoom-out": "Zoom out",
    "action.zoom-to-100": "Zoom to 100%",
    "action.zoom-to-fit": "Zoom to fit",
    "action.zoom-to-selection": "Zoom to selection",
    "color-style.black": "Black",
    "color-style.blue": "Blue",
    "color-style.green": "Green",
    "color-style.grey": "Grey",
    "color-style.light-blue": "Light blue",
    "color-style.light-green": "Light green",
    "color-style.light-red": "Light red",
    "color-style.light-violet": "Light violet",
    "color-style.orange": "Orange",
    "color-style.red": "Red",
    "color-style.violet": "Violet",
    "color-style.yellow": "Yellow",
    "fill-style.none": "None",
    "fill-style.semi": "Semi",
    "fill-style.solid": "Solid",
    "fill-style.pattern": "Pattern",
    "dash-style.dashed": "Dashed",
    "dash-style.dotted": "Dotted",
    "dash-style.draw": "Draw",
    "dash-style.solid": "Solid",
    "size-style.s": "Small",
    "size-style.m": "Medium",
    "size-style.l": "Large",
    "size-style.xl": "Extra large",
    "opacity-style.0.1": "10%",
    "opacity-style.0.25": "25%",
    "opacity-style.0.5": "50%",
    "opacity-style.0.75": "75%",
    "opacity-style.1": "100%",
    "font-style.draw": "Draw",
    "font-style.sans": "Sans",
    "font-style.serif": "Serif",
    "font-style.mono": "Mono",
    "align-style.start": "Start",
    "align-style.middle": "Middle",
    "align-style.end": "End",
    "align-style.justify": "Justify",
    "geo-style.arrow-down": "Arrow down",
    "geo-style.arrow-left": "Arrow left",
    "geo-style.arrow-right": "Arrow right",
    "geo-style.arrow-up": "Arrow up",
    "geo-style.diamond": "Diamond",
    "geo-style.ellipse": "Ellipse",
    "geo-style.hexagon": "Hexagon",
    "geo-style.octagon": "Octagon",
    "geo-style.oval": "Oval",
    "geo-style.cloud": "Cloud",
    "geo-style.pentagon": "Pentagon",
    "geo-style.rectangle": "Rectangle",
    "geo-style.rhombus-2": "Rhombus 2",
    "geo-style.rhombus": "Rhombus",
    "geo-style.star": "Star",
    "geo-style.trapezoid": "Trapezoid",
    "geo-style.triangle": "Triangle",
    "geo-style.x-box": "X box",
    "geo-style.check-box": "Check box",
    "arrowheadStart-style.none": "None",
    "arrowheadStart-style.arrow": "Arrow",
    "arrowheadStart-style.bar": "Bar",
    "arrowheadStart-style.diamond": "Diamond",
    "arrowheadStart-style.dot": "Dot",
    "arrowheadStart-style.inverted": "Inverted",
    "arrowheadStart-style.pipe": "Pipe",
    "arrowheadStart-style.square": "Square",
    "arrowheadStart-style.triangle": "Triangle",
    "arrowheadEnd-style.none": "None",
    "arrowheadEnd-style.arrow": "Arrow",
    "arrowheadEnd-style.bar": "Bar",
    "arrowheadEnd-style.diamond": "Diamond",
    "arrowheadEnd-style.dot": "Dot",
    "arrowheadEnd-style.inverted": "Inverted",
    "arrowheadEnd-style.pipe": "Pipe",
    "arrowheadEnd-style.square": "Square",
    "arrowheadEnd-style.triangle": "Triangle",
    "spline-style.line": "Line",
    "spline-style.cubic": "Cubic",
    "tool.select": "Select",
    "tool.hand": "Hand",
    "tool.draw": "Draw",
    "tool.eraser": "Eraser",
    "tool.arrow-down": "Arrow down",
    "tool.arrow-left": "Arrow left",
    "tool.arrow-right": "Arrow right",
    "tool.arrow-up": "Arrow up",
    "tool.arrow": "Arrow",
    "tool.cloud": "Cloud",
    "tool.diamond": "Diamond",
    "tool.ellipse": "Ellipse",
    "tool.hexagon": "Hexagon",
    "tool.highlight": "Highlight",
    "tool.line": "Line",
    "tool.octagon": "Octagon",
    "tool.oval": "Oval",
    "tool.pentagon": "Pentagon",
    "tool.rectangle": "Rectangle",
    "tool.rhombus": "Rhombus",
    "tool.star": "Star",
    "tool.trapezoid": "Trapezoid",
    "tool.triangle": "Triangle",
    "tool.x-box": "X box",
    "tool.check-box": "Check box",
    "tool.asset": "Asset",
    "tool.frame": "Frame",
    "tool.note": "Note",
    "tool.laser": "Laser",
    "tool.embed": "Embed",
    "tool.text": "Text",
    "menu.title": "Menu",
    "menu.copy-as": "Copy as",
    "menu.edit": "Edit",
    "menu.export-as": "Export as",
    "menu.file": "File",
    "menu.language": "Language",
    "menu.preferences": "Preferences",
    "menu.view": "View",
    "context-menu.arrange": "Arrange",
    "context-menu.copy-as": "Copy as",
    "context-menu.export-as": "Export as",
    "context-menu.move-to-page": "Move to page",
    "context-menu.reorder": "Reorder",
    "page-menu.title": "Pages",
    "page-menu.create-new-page": "Create new page",
    "page-menu.max-page-count-reached": "Max pages reached",
    "page-menu.new-page-initial-name": "Page 1",
    "page-menu.edit-start": "Edit",
    "page-menu.edit-done": "Done",
    "page-menu.go-to-page": "Go to page",
    "page-menu.submenu.rename": "Rename",
    "page-menu.submenu.duplicate-page": "Duplicate",
    "page-menu.submenu.title": "Menu",
    "page-menu.submenu.move-down": "Move down",
    "page-menu.submenu.move-up": "Move up",
    "page-menu.submenu.delete": "Delete",
    "share-menu.title": "Share",
    "share-menu.save-note": "Download this project to your computer as a .tldr file.",
    "share-menu.fork-note": "Create a new shared project based on this snapshot.",
    "share-menu.share-project": "Share this project",
    "share-menu.default-project-name": "Shared Project",
    "share-menu.copy-link": "Copy share link",
    "share-menu.readonly-link": "Read-only",
    "share-menu.create-snapshot-link": "Copy snapshot link",
    "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
    "share-menu.copy-readonly-link": "Copy read-only link",
    "share-menu.offline-note": "Create a new shared project based on your current project.",
    "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
    "share-menu.copy-readonly-link-note": "Anyone with the link will be able to view (but not edit) this project.",
    "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
    "share-menu.upload-failed": "Sorry, we couldn't upload your project at the moment. Please try again or let us know if the problem persists.",
    "status.offline": "Offline",
    "status.online": "Online",
    "people-menu.title": "People",
    "people-menu.change-name": "Change name",
    "people-menu.change-color": "Change color",
    "people-menu.follow": "Following",
    "people-menu.following": "Following",
    "people-menu.leading": "Following You",
    "people-menu.user": "(You)",
    "people-menu.invite": "Invite others",
    "help-menu.title": "Help and resources",
    "help-menu.about": "About",
    "help-menu.discord": "Discord",
    "help-menu.github": "GitHub",
    "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
    "help-menu.twitter": "Twitter",
    "actions-menu.title": "Actions",
    "edit-link-dialog.title": "Edit link",
    "edit-link-dialog.invalid-url": "A link must be a valid URL.",
    "edit-link-dialog.detail": "Links will open in a new tab.",
    "edit-link-dialog.url": "URL",
    "edit-link-dialog.clear": "Clear",
    "edit-link-dialog.save": "Continue",
    "edit-link-dialog.cancel": "Cancel",
    "embed-dialog.title": "Insert embed",
    "embed-dialog.back": "Back",
    "embed-dialog.create": "Create",
    "embed-dialog.cancel": "Cancel",
    "embed-dialog.url": "URL",
    "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
    "embed-dialog.invalid-url": "We could not create an embed from that URL.",
    "edit-pages-dialog.move-down": "Move down",
    "edit-pages-dialog.move-up": "Move up",
    "shortcuts-dialog.title": "Keyboard shortcuts",
    "shortcuts-dialog.edit": "Edit",
    "shortcuts-dialog.file": "File",
    "shortcuts-dialog.preferences": "Preferences",
    "shortcuts-dialog.tools": "Tools",
    "shortcuts-dialog.transform": "Transform",
    "shortcuts-dialog.view": "View",
    "shortcuts-dialog.collaboration": "Collaboration",
    "home-project-dialog.title": "Home project",
    "home-project-dialog.description": "This is your local home project. It's just for you!",
    "rename-project-dialog.title": "Rename project",
    "rename-project-dialog.cancel": "Cancel",
    "rename-project-dialog.rename": "Rename",
    "home-project-dialog.ok": "Ok",
    "style-panel.title": "Styles",
    "style-panel.align": "Align",
    "style-panel.vertical-align": "Vertical align",
    "style-panel.position": "Position",
    "style-panel.arrowheads": "Arrows",
    "style-panel.arrowhead-start": "Start",
    "style-panel.arrowhead-end": "End",
    "style-panel.color": "Color",
    "style-panel.dash": "Dash",
    "style-panel.fill": "Fill",
    "style-panel.font": "Font",
    "style-panel.geo": "Shape",
    "style-panel.mixed": "Mixed",
    "style-panel.opacity": "Opacity",
    "style-panel.size": "Size",
    "style-panel.spline": "Spline",
    "tool-panel.drawing": "Drawing",
    "tool-panel.shapes": "Shapes",
    "tool-panel.more": "More",
    "debug-panel.more": "More",
    "navigation-zone.toggle-minimap": "Toggle minimap",
    "navigation-zone.zoom": "Zoom",
    "focus-mode.toggle-focus-mode": "Toggle focus mode",
    "toast.close": "Close",
    "file-system.file-open-error.title": "Could not open file",
    "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
    "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
    "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
    "file-system.confirm-open.title": "Overwrite current project?",
    "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
    "file-system.confirm-open.cancel": "Cancel",
    "file-system.confirm-open.open": "Open file",
    "file-system.confirm-open.dont-show-again": "Don't ask again",
    "file-system.confirm-clear.title": "Clear current project?",
    "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
    "file-system.confirm-clear.cancel": "Cancel",
    "file-system.confirm-clear.continue": "Continue",
    "file-system.confirm-clear.dont-show-again": "Don't ask again",
    "file-system.shared-document-file-open-error.title": "Could not open file",
    "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
    "sharing.confirm-leave.title": "Leave current project?",
    "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
    "sharing.confirm-leave.cancel": "Cancel",
    "sharing.confirm-leave.leave": "Leave",
    "sharing.confirm-leave.dont-show-again": "Don't ask again",
    "toast.error.export-fail.title": "Failed export",
    "toast.error.export-fail.desc": "Failed to export image",
    "toast.error.copy-fail.title": "Failed copy",
    "toast.error.copy-fail.desc": "Failed to copy image",
    "context.pages.new-page": "New page",
    "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
    "vscode.file-open.open": "Continue",
    "vscode.file-open.backup": "Backup",
    "vscode.file-open.backup-saved": "Backup saved",
    "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
    "vscode.file-open.dont-show-again": "Don't ask again",
    "cursor-chat.type-to-chat": "Type to chat..."
  },
  Lc = {
    locale: "en",
    label: "English",
    messages: p_
  };
async function Boe(t, e) {
  if (!(await fetch(e.translations.en)).ok) return console.warn("No main translations found."), Lc;
  if (t === "en") return Lc;
  const r = Of.find(a => a.locale === t);
  if (!r) return console.warn(`No translation found for locale ${t}`), Lc;
  const s = await (await fetch(e.translations[r.locale])).json();
  if (!s) return console.warn(`No messages found for locale ${t}`), Lc;
  const i = [];
  for (const a in Lc.messages) s[a] || i.push(a);
  return i.length > 0, {
    locale: t,
    label: r.label,
    messages: {
      ...Lc.messages,
      ...s
    }
  }
}
const _j = g.createContext({}),
  Uoe = () => g.useContext(_j),
  zoe = pt(function({
    overrides: e,
    children: n
  }) {
    const o = Y().user.locale,
      s = rE(),
      [i, a] = g.useState(() => e && e.en ? {
        locale: "en",
        label: "English",
        messages: {
          ...p_,
          ...e.en
        }
      } : {
        locale: "en",
        label: "English",
        messages: p_
      });
    return g.useEffect(() => {
      let c = !1;
      async function l() {
        const u = await Boe(o, s);
        u && !c && (e && e[o] ? a({
          ...u,
          messages: {
            ...u.messages,
            ...e[o]
          }
        }) : a(u))
      }
      return l(), () => {
        c = !0
      }
    }, [s, o, e]), y.jsx(_j.Provider, {
      value: i,
      children: n
    })
  });

function nt() {
  const t = Uoe();
  return g.useCallback(function(n) {
    return t.messages[n] ?? n
  }, [t])
}

function Hoe(t) {
  return y.jsx("svg", {
    width: 16,
    height: 16,
    viewBox: "0 0 16 16",
    ...t,
    children: y.jsxs("g", {
      strokeWidth: 2,
      fill: "none",
      fillRule: "evenodd",
      children: [y.jsx("circle", {
        strokeOpacity: .25,
        cx: 8,
        cy: 8,
        r: 7,
        stroke: "currentColor"
      }), y.jsx("path", {
        strokeLinecap: "round",
        d: "M15 8c0-4.5-4.5-7-7-7",
        stroke: "currentColor",
        children: y.jsx("animateTransform", {
          attributeName: "transform",
          type: "rotate",
          from: "0 8 8",
          to: "360 8 8",
          dur: "1s",
          repeatCount: "indefinite"
        })
      })]
    })
  })
}
const wr = g.memo(function({
    small: e,
    invertIcon: n,
    icon: r,
    color: o,
    className: s,
    ...i
  }) {
    const c = rE().icons[r],
      l = g.useRef(null);
    return g.useLayoutEffect(() => {
      l != null && l.current && (l.current.style.webkitMask = `url(${c}) center 100% / 100% no-repeat`)
    }, [l, c]), y.jsx("div", {
      ...i,
      ref: l,
      className: ae("tlui-icon", {
        "tlui-icon__small": e
      }, s),
      style: {
        color: o,
        mask: `url(${c}) center 100% / 100% no-repeat`,
        transform: n ? "scale(-1, 1)" : void 0
      }
    })
  }),
  xj = typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("mac") > -1,
  Ej = xj ? "" : "Ctrl",
  kj = xj ? "" : "Alt";

function Voe(t) {
  return t.split(",")[0].split("").map(e => {
    const n = e.replace(/\$/g, Ej).replace(/\?/g, kj).replace(/!/g, "");
    return n[0].toUpperCase() + n.slice(1)
  })
}

function fs(t) {
  return " " + t.split(",")[0].split("").map(e => {
    const n = e.replace(/\$/g, Ej).replace(/\?/g, kj).replace(/!/g, "");
    return n[0].toUpperCase() + n.slice(1)
  }).join("")
}

function wv({
  children: t
}) {
  return y.jsx("kbd", {
    className: "tlui-kbd",
    children: Voe(t).map((e, n) => y.jsx("span", {
      children: e
    }, n))
  })
}
const me = g.forwardRef(function({
    label: e,
    icon: n,
    invertIcon: r,
    iconLeft: o,
    smallIcon: s,
    kbd: i,
    isChecked: a = !1,
    type: c,
    children: l,
    spinner: u,
    ...d
  }, f) {
    const h = nt(),
      m = e ? h(e) : "";
    return y.jsxs("button", {
      ref: f,
      draggable: !1,
      type: "button",
      ...d,
      title: d.title ?? m,
      className: ae("tlui-button", `tlui-button__${c}`, d.className),
      children: [o && y.jsx(wr, {
        icon: o,
        className: "tlui-button__icon-left",
        small: !0
      }), l, e && y.jsxs("span", {
        className: "tlui-button__label",
        draggable: !1,
        children: [m, a && y.jsx(wr, {
          icon: "check"
        })]
      }), i && y.jsx(wv, {
        children: i
      }), n && !u && y.jsx(wr, {
        icon: n,
        small: !!e || s,
        invertIcon: r
      }), u && y.jsx(Hoe, {})]
    })
  }),
  Woe = cI["useId".toString()] || (() => {});
let Koe = 0;

function Mo(t) {
  const [e, n] = g.useState(Woe());
  return Sr(() => {
    t || n(r => r ?? String(Koe++))
  }, [t]), t || (e ? `radix-${e}` : "")
}
const g_ = "dismissableLayer.update",
  Goe = "dismissableLayer.pointerDownOutside",
  Yoe = "dismissableLayer.focusOutside";
let L2;
const qoe = g.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
  }),
  oE = g.forwardRef((t, e) => {
    var n;
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: a,
      onDismiss: c,
      ...l
    } = t, u = g.useContext(qoe), [d, f] = g.useState(null), h = (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, m] = g.useState({}), p = rt(e, C => f(C)), b = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), v = b.indexOf(w), _ = d ? b.indexOf(d) : -1, S = u.layersWithOutsidePointerEventsDisabled.size > 0, x = _ >= v, E = Xoe(C => {
      const $ = C.target,
        I = [...u.branches].some(R => R.contains($));
      !x || I || (s == null || s(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h), k = Zoe(C => {
      const $ = C.target;
      [...u.branches].some(R => R.contains($)) || (i == null || i(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h);
    return eE(C => {
      _ === u.layers.size - 1 && (o == null || o(C), !C.defaultPrevented && c && (C.preventDefault(), c()))
    }, h), g.useEffect(() => {
      if (d) return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (L2 = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), F2(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = L2)
      }
    }, [d, h, r, u]), g.useEffect(() => () => {
      d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), F2())
    }, [d, u]), g.useEffect(() => {
      const C = () => m({});
      return document.addEventListener(g_, C), () => document.removeEventListener(g_, C)
    }, []), g.createElement(Ke.div, G({}, l, {
      ref: p,
      style: {
        pointerEvents: S ? x ? "auto" : "none" : void 0,
        ...t.style
      },
      onFocusCapture: ie(t.onFocusCapture, k.onFocusCapture),
      onBlurCapture: ie(t.onBlurCapture, k.onBlurCapture),
      onPointerDownCapture: ie(t.onPointerDownCapture, E.onPointerDownCapture)
    }))
  });

function Xoe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1),
    o = g.useRef(() => {});
  return g.useEffect(() => {
    const s = a => {
        if (a.target && !r.current) {
          let l = function() {
            Cj(Goe, n, c, {
              discrete: !0
            })
          };
          const c = {
            originalEvent: a
          };
          a.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = l, e.addEventListener("click", o.current, {
            once: !0
          })) : l()
        } else e.removeEventListener("click", o.current);
        r.current = !1
      },
      i = window.setTimeout(() => {
        e.addEventListener("pointerdown", s)
      }, 0);
    return () => {
      window.clearTimeout(i), e.removeEventListener("pointerdown", s), e.removeEventListener("click", o.current)
    }
  }, [e, n]), {
    onPointerDownCapture: () => r.current = !0
  }
}

function Zoe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1);
  return g.useEffect(() => {
    const o = s => {
      s.target && !r.current && Cj(Yoe, n, {
        originalEvent: s
      }, {
        discrete: !1
      })
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o)
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  }
}

function F2() {
  const t = new CustomEvent(g_);
  document.dispatchEvent(t)
}

function Cj(t, e, n, {
  discrete: r
}) {
  const o = n.originalEvent.target,
    s = new CustomEvent(t, {
      bubbles: !1,
      cancelable: !0,
      detail: n
    });
  e && o.addEventListener(t, e, {
    once: !0
  }), r ? Rh(o, s) : o.dispatchEvent(s)
}
const Rb = "focusScope.autoFocusOnMount",
  Ab = "focusScope.autoFocusOnUnmount",
  B2 = {
    bubbles: !1,
    cancelable: !0
  },
  sE = g.forwardRef((t, e) => {
    const {
      loop: n = !1,
      trapped: r = !1,
      onMountAutoFocus: o,
      onUnmountAutoFocus: s,
      ...i
    } = t, [a, c] = g.useState(null), l = At(o), u = At(s), d = g.useRef(null), f = rt(e, p => c(p)), h = g.useRef({
      paused: !1,
      pause() {
        this.paused = !0
      },
      resume() {
        this.paused = !1
      }
    }).current;
    g.useEffect(() => {
      if (r) {
        let p = function(_) {
            if (h.paused || !a) return;
            const S = _.target;
            a.contains(S) ? d.current = S : fi(d.current, {
              select: !0
            })
          },
          b = function(_) {
            if (h.paused || !a) return;
            const S = _.relatedTarget;
            S !== null && (a.contains(S) || fi(d.current, {
              select: !0
            }))
          },
          w = function(_) {
            if (document.activeElement === document.body)
              for (const x of _) x.removedNodes.length > 0 && fi(a)
          };
        document.addEventListener("focusin", p), document.addEventListener("focusout", b);
        const v = new MutationObserver(w);
        return a && v.observe(a, {
          childList: !0,
          subtree: !0
        }), () => {
          document.removeEventListener("focusin", p), document.removeEventListener("focusout", b), v.disconnect()
        }
      }
    }, [r, a, h.paused]), g.useEffect(() => {
      if (a) {
        z2.add(h);
        const p = document.activeElement;
        if (!a.contains(p)) {
          const w = new CustomEvent(Rb, B2);
          a.addEventListener(Rb, l), a.dispatchEvent(w), w.defaultPrevented || (Joe(rse(Pj(a)), {
            select: !0
          }), document.activeElement === p && fi(a))
        }
        return () => {
          a.removeEventListener(Rb, l), setTimeout(() => {
            const w = new CustomEvent(Ab, B2);
            a.addEventListener(Ab, u), a.dispatchEvent(w), w.defaultPrevented || fi(p ?? document.body, {
              select: !0
            }), a.removeEventListener(Ab, u), z2.remove(h)
          }, 0)
        }
      }
    }, [a, l, u, h]);
    const m = g.useCallback(p => {
      if (!n && !r || h.paused) return;
      const b = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey,
        w = document.activeElement;
      if (b && w) {
        const v = p.currentTarget,
          [_, S] = Qoe(v);
        _ && S ? !p.shiftKey && w === S ? (p.preventDefault(), n && fi(_, {
          select: !0
        })) : p.shiftKey && w === _ && (p.preventDefault(), n && fi(S, {
          select: !0
        })) : w === v && p.preventDefault()
      }
    }, [n, r, h.paused]);
    return g.createElement(Ke.div, G({
      tabIndex: -1
    }, i, {
      ref: f,
      onKeyDown: m
    }))
  });

function Joe(t, {
  select: e = !1
} = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (fi(r, {
        select: e
      }), document.activeElement !== n) return
}

function Qoe(t) {
  const e = Pj(t),
    n = U2(e, t),
    r = U2(e.reverse(), t);
  return [n, r]
}

function Pj(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: r => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      }
    });
  for (; n.nextNode();) e.push(n.currentNode);
  return e
}

function U2(t, e) {
  for (const n of t)
    if (!ese(n, {
        upTo: e
      })) return n
}

function ese(t, {
  upTo: e
}) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t;) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement
  }
  return !1
}

function tse(t) {
  return t instanceof HTMLInputElement && "select" in t
}

function fi(t, {
  select: e = !1
} = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== n && tse(t) && e && t.select()
  }
}
const z2 = nse();

function nse() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = H2(t, e), t.unshift(e)
    },
    remove(e) {
      var n;
      t = H2(t, e), (n = t[0]) === null || n === void 0 || n.resume()
    }
  }
}

function H2(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n
}

function rse(t) {
  return t.filter(e => e.tagName !== "A")
}
const iE = g.forwardRef((t, e) => {
  var n;
  const {
    container: r = globalThis == null || (n = globalThis.document) === null || n === void 0 ? void 0 : n.body,
    ...o
  } = t;
  return r ? KR.createPortal(g.createElement(Ke.div, G({}, o, {
    ref: e
  })), r) : null
});
let Mb = 0;

function Sv() {
  g.useEffect(() => {
    var t, e;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (t = n[0]) !== null && t !== void 0 ? t : V2()), document.body.insertAdjacentElement("beforeend", (e = n[1]) !== null && e !== void 0 ? e : V2()), Mb++, () => {
      Mb === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(r => r.remove()), Mb--
    }
  }, [])
}

function V2() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", t
}
var ss = function() {
  return ss = Object.assign || function(e) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
    }
    return e
  }, ss.apply(this, arguments)
};

function Tj(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++) e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n
}

function ose(t, e, n) {
  if (n || arguments.length === 2)
    for (var r = 0, o = e.length, s; r < o; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return t.concat(s || Array.prototype.slice.call(e))
}
var Lg = "right-scroll-bar-position",
  Fg = "width-before-scroll-bar",
  sse = "with-scroll-bars-hidden",
  ise = "--removed-body-scroll-bar-size";

function ase(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t
}

function cse(t, e) {
  var n = g.useState(function() {
    return {
      value: t,
      callback: e,
      facade: {
        get current() {
          return n.value
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o))
        }
      }
    }
  })[0];
  return n.callback = e, n.facade
}

function lse(t, e) {
  return cse(e || null, function(n) {
    return t.forEach(function(r) {
      return ase(r, n)
    })
  })
}

function use(t) {
  return t
}

function dse(t, e) {
  e === void 0 && (e = use);
  var n = [],
    r = !1,
    o = {
      read: function() {
        if (r) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : t
      },
      useMedium: function(s) {
        var i = e(s, r);
        return n.push(i),
          function() {
            n = n.filter(function(a) {
              return a !== i
            })
          }
      },
      assignSyncMedium: function(s) {
        for (r = !0; n.length;) {
          var i = n;
          n = [], i.forEach(s)
        }
        n = {
          push: function(a) {
            return s(a)
          },
          filter: function() {
            return n
          }
        }
      },
      assignMedium: function(s) {
        r = !0;
        var i = [];
        if (n.length) {
          var a = n;
          n = [], a.forEach(s), i = n
        }
        var c = function() {
            var u = i;
            i = [], u.forEach(s)
          },
          l = function() {
            return Promise.resolve().then(c)
          };
        l(), n = {
          push: function(u) {
            i.push(u), l()
          },
          filter: function(u) {
            return i = i.filter(u), n
          }
        }
      }
    };
  return o
}

function fse(t) {
  t === void 0 && (t = {});
  var e = dse(null);
  return e.options = ss({
    async: !0,
    ssr: !1
  }, t), e
}
var $j = function(t) {
  var e = t.sideCar,
    n = Tj(t, ["sideCar"]);
  if (!e) throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r) throw new Error("Sidecar medium not found");
  return g.createElement(r, ss({}, n))
};
$j.isSideCarExport = !0;

function hse(t, e) {
  return t.useMedium(e), $j
}
var Ij = fse(),
  jb = function() {},
  _v = g.forwardRef(function(t, e) {
    var n = g.useRef(null),
      r = g.useState({
        onScrollCapture: jb,
        onWheelCapture: jb,
        onTouchMoveCapture: jb
      }),
      o = r[0],
      s = r[1],
      i = t.forwardProps,
      a = t.children,
      c = t.className,
      l = t.removeScrollBar,
      u = t.enabled,
      d = t.shards,
      f = t.sideCar,
      h = t.noIsolation,
      m = t.inert,
      p = t.allowPinchZoom,
      b = t.as,
      w = b === void 0 ? "div" : b,
      v = Tj(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]),
      _ = f,
      S = lse([n, e]),
      x = ss(ss({}, v), o);
    return g.createElement(g.Fragment, null, u && g.createElement(_, {
      sideCar: Ij,
      removeScrollBar: l,
      shards: d,
      noIsolation: h,
      inert: m,
      setCallbacks: s,
      allowPinchZoom: !!p,
      lockRef: n
    }), i ? g.cloneElement(g.Children.only(a), ss(ss({}, x), {
      ref: S
    })) : g.createElement(w, ss({}, x, {
      className: c,
      ref: S
    }), a))
  });
_v.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
_v.classNames = {
  fullWidth: Fg,
  zeroRight: Lg
};
var W2, pse = function() {
  if (W2) return W2;
  if (typeof __webpack_nonce__ < "u") return __webpack_nonce__
};

function gse() {
  if (!document) return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = pse();
  return e && t.setAttribute("nonce", e), t
}

function mse(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}

function yse(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t)
}
var vse = function() {
    var t = 0,
      e = null;
    return {
      add: function(n) {
        t == 0 && (e = gse()) && (mse(e, n), yse(e)), t++
      },
      remove: function() {
        t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null)
      }
    }
  },
  bse = function() {
    var t = vse();
    return function(e, n) {
      g.useEffect(function() {
        return t.add(e),
          function() {
            t.remove()
          }
      }, [e && n])
    }
  },
  Oj = function() {
    var t = bse(),
      e = function(n) {
        var r = n.styles,
          o = n.dynamic;
        return t(r, o), null
      };
    return e
  },
  wse = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  },
  Db = function(t) {
    return parseInt(t || "", 10) || 0
  },
  Sse = function(t) {
    var e = window.getComputedStyle(document.body),
      n = e[t === "padding" ? "paddingLeft" : "marginLeft"],
      r = e[t === "padding" ? "paddingTop" : "marginTop"],
      o = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [Db(n), Db(r), Db(o)]
  },
  _se = function(t) {
    if (t === void 0 && (t = "margin"), typeof window > "u") return wse;
    var e = Sse(t),
      n = document.documentElement.clientWidth,
      r = window.innerWidth;
    return {
      left: e[0],
      top: e[1],
      right: e[2],
      gap: Math.max(0, r - n + e[2] - e[0])
    }
  },
  xse = Oj(),
  Ese = function(t, e, n, r) {
    var o = t.left,
      s = t.top,
      i = t.right,
      a = t.gap;
    return n === void 0 && (n = "margin"), `
  .`.concat(sse, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(r, ";"), n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(i, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `), n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Lg, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Fg, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Lg, " .").concat(Lg, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Fg, " .").concat(Fg, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(ise, ": ").concat(a, `px;
  }
`)
  },
  kse = function(t) {
    var e = t.noRelative,
      n = t.noImportant,
      r = t.gapMode,
      o = r === void 0 ? "margin" : r,
      s = g.useMemo(function() {
        return _se(o)
      }, [o]);
    return g.createElement(xse, {
      styles: Ese(s, !e, o, n ? "" : "!important")
    })
  },
  m_ = !1;
if (typeof window < "u") try {
  var Xp = Object.defineProperty({}, "passive", {
    get: function() {
      return m_ = !0, !0
    }
  });
  window.addEventListener("test", Xp, Xp), window.removeEventListener("test", Xp, Xp)
} catch {
  m_ = !1
}
var Fc = m_ ? {
    passive: !1
  } : !1,
  Cse = function(t) {
    return t.tagName === "TEXTAREA"
  },
  Rj = function(t, e) {
    var n = window.getComputedStyle(t);
    return n[e] !== "hidden" && !(n.overflowY === n.overflowX && !Cse(t) && n[e] === "visible")
  },
  Pse = function(t) {
    return Rj(t, "overflowY")
  },
  Tse = function(t) {
    return Rj(t, "overflowX")
  },
  K2 = function(t, e) {
    var n = e;
    do {
      typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
      var r = Aj(t, n);
      if (r) {
        var o = Mj(t, n),
          s = o[1],
          i = o[2];
        if (s > i) return !0
      }
      n = n.parentNode
    } while (n && n !== document.body);
    return !1
  },
  $se = function(t) {
    var e = t.scrollTop,
      n = t.scrollHeight,
      r = t.clientHeight;
    return [e, n, r]
  },
  Ise = function(t) {
    var e = t.scrollLeft,
      n = t.scrollWidth,
      r = t.clientWidth;
    return [e, n, r]
  },
  Aj = function(t, e) {
    return t === "v" ? Pse(e) : Tse(e)
  },
  Mj = function(t, e) {
    return t === "v" ? $se(e) : Ise(e)
  },
  Ose = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
  },
  Rse = function(t, e, n, r, o) {
    var s = Ose(t, window.getComputedStyle(e).direction),
      i = s * r,
      a = n.target,
      c = e.contains(a),
      l = !1,
      u = i > 0,
      d = 0,
      f = 0;
    do {
      var h = Mj(t, a),
        m = h[0],
        p = h[1],
        b = h[2],
        w = p - b - s * m;
      (m || w) && Aj(t, a) && (d += w, f += m), a = a.parentNode
    } while (!c && a !== document.body || c && (e.contains(a) || e === a));
    return (u && (o && d === 0 || !o && i > d) || !u && (o && f === 0 || !o && -i > f)) && (l = !0), l
  },
  Zp = function(t) {
    return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
  },
  G2 = function(t) {
    return [t.deltaX, t.deltaY]
  },
  Y2 = function(t) {
    return t && "current" in t ? t.current : t
  },
  Ase = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
  },
  Mse = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
  },
  jse = 0,
  Bc = [];

function Dse(t) {
  var e = g.useRef([]),
    n = g.useRef([0, 0]),
    r = g.useRef(),
    o = g.useState(jse++)[0],
    s = g.useState(function() {
      return Oj()
    })[0],
    i = g.useRef(t);
  g.useEffect(function() {
    i.current = t
  }, [t]), g.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var p = ose([t.lockRef.current], (t.shards || []).map(Y2), !0).filter(Boolean);
      return p.forEach(function(b) {
          return b.classList.add("allow-interactivity-".concat(o))
        }),
        function() {
          document.body.classList.remove("block-interactivity-".concat(o)), p.forEach(function(b) {
            return b.classList.remove("allow-interactivity-".concat(o))
          })
        }
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = g.useCallback(function(p, b) {
      if ("touches" in p && p.touches.length === 2) return !i.current.allowPinchZoom;
      var w = Zp(p),
        v = n.current,
        _ = "deltaX" in p ? p.deltaX : v[0] - w[0],
        S = "deltaY" in p ? p.deltaY : v[1] - w[1],
        x, E = p.target,
        k = Math.abs(_) > Math.abs(S) ? "h" : "v";
      if ("touches" in p && k === "h" && E.type === "range") return !1;
      var C = K2(k, E);
      if (!C) return !0;
      if (C ? x = k : (x = k === "v" ? "h" : "v", C = K2(k, E)), !C) return !1;
      if (!r.current && "changedTouches" in p && (_ || S) && (r.current = x), !x) return !0;
      var $ = r.current || x;
      return Rse($, b, p, $ === "h" ? _ : S, !0)
    }, []),
    c = g.useCallback(function(p) {
      var b = p;
      if (!(!Bc.length || Bc[Bc.length - 1] !== s)) {
        var w = "deltaY" in b ? G2(b) : Zp(b),
          v = e.current.filter(function(x) {
            return x.name === b.type && x.target === b.target && Ase(x.delta, w)
          })[0];
        if (v && v.should) {
          b.cancelable && b.preventDefault();
          return
        }
        if (!v) {
          var _ = (i.current.shards || []).map(Y2).filter(Boolean).filter(function(x) {
              return x.contains(b.target)
            }),
            S = _.length > 0 ? a(b, _[0]) : !i.current.noIsolation;
          S && b.cancelable && b.preventDefault()
        }
      }
    }, []),
    l = g.useCallback(function(p, b, w, v) {
      var _ = {
        name: p,
        delta: b,
        target: w,
        should: v
      };
      e.current.push(_), setTimeout(function() {
        e.current = e.current.filter(function(S) {
          return S !== _
        })
      }, 1)
    }, []),
    u = g.useCallback(function(p) {
      n.current = Zp(p), r.current = void 0
    }, []),
    d = g.useCallback(function(p) {
      l(p.type, G2(p), p.target, a(p, t.lockRef.current))
    }, []),
    f = g.useCallback(function(p) {
      l(p.type, Zp(p), p.target, a(p, t.lockRef.current))
    }, []);
  g.useEffect(function() {
    return Bc.push(s), t.setCallbacks({
        onScrollCapture: d,
        onWheelCapture: d,
        onTouchMoveCapture: f
      }), document.addEventListener("wheel", c, Fc), document.addEventListener("touchmove", c, Fc), document.addEventListener("touchstart", u, Fc),
      function() {
        Bc = Bc.filter(function(p) {
          return p !== s
        }), document.removeEventListener("wheel", c, Fc), document.removeEventListener("touchmove", c, Fc), document.removeEventListener("touchstart", u, Fc)
      }
  }, []);
  var h = t.removeScrollBar,
    m = t.inert;
  return g.createElement(g.Fragment, null, m ? g.createElement(s, {
    styles: Mse(o)
  }) : null, h ? g.createElement(kse, {
    gapMode: "margin"
  }) : null)
}
const Nse = hse(Ij, Dse);
var jj = g.forwardRef(function(t, e) {
  return g.createElement(_v, ss({}, t, {
    ref: e,
    sideCar: Nse
  }))
});
jj.classNames = _v.classNames;
const xv = jj;
var Lse = function(t) {
    if (typeof document > "u") return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
  },
  Uc = new WeakMap,
  Jp = new WeakMap,
  Qp = {},
  Nb = 0,
  Ev = function(t, e, n) {
    e === void 0 && (e = Lse(t)), n === void 0 && (n = "data-aria-hidden");
    var r = Array.isArray(t) ? t : [t];
    Qp[n] || (Qp[n] = new WeakMap);
    var o = Qp[n],
      s = [],
      i = new Set,
      a = function(l) {
        !l || i.has(l) || (i.add(l), a(l.parentNode))
      };
    r.forEach(a);
    var c = function(l) {
      !l || r.indexOf(l) >= 0 || Array.prototype.forEach.call(l.children, function(u) {
        if (i.has(u)) c(u);
        else {
          var d = u.getAttribute("aria-hidden"),
            f = d !== null && d !== "false",
            h = (Uc.get(u) || 0) + 1,
            m = (o.get(u) || 0) + 1;
          Uc.set(u, h), o.set(u, m), s.push(u), h === 1 && f && Jp.set(u, !0), m === 1 && u.setAttribute(n, "true"), f || u.setAttribute("aria-hidden", "true")
        }
      })
    };
    return c(e), i.clear(), Nb++,
      function() {
        s.forEach(function(l) {
          var u = Uc.get(l) - 1,
            d = o.get(l) - 1;
          Uc.set(l, u), o.set(l, d), u || (Jp.has(l) || l.removeAttribute("aria-hidden"), Jp.delete(l)), d || l.removeAttribute(n)
        }), Nb--, Nb || (Uc = new WeakMap, Uc = new WeakMap, Jp = new WeakMap, Qp = {})
      }
  };
const Dj = "Dialog",
  [Nj, Pbe] = Vo(Dj),
  [Fse, Ko] = Nj(Dj),
  Bse = t => {
    const {
      __scopeDialog: e,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: s,
      modal: i = !0
    } = t, a = g.useRef(null), c = g.useRef(null), [l = !1, u] = Xs({
      prop: r,
      defaultProp: o,
      onChange: s
    });
    return g.createElement(Fse, {
      scope: e,
      triggerRef: a,
      contentRef: c,
      contentId: Mo(),
      titleId: Mo(),
      descriptionId: Mo(),
      open: l,
      onOpenChange: u,
      onOpenToggle: g.useCallback(() => u(d => !d), [u]),
      modal: i
    }, n)
  },
  Use = "DialogTrigger",
  zse = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      ...r
    } = t, o = Ko(Use, n), s = rt(e, o.triggerRef);
    return g.createElement(Ke.button, G({
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": o.open,
      "aria-controls": o.contentId,
      "data-state": aE(o.open)
    }, r, {
      ref: s,
      onClick: ie(t.onClick, o.onOpenToggle)
    }))
  }),
  Lj = "DialogPortal",
  [Hse, Fj] = Nj(Lj, {
    forceMount: void 0
  }),
  Vse = t => {
    const {
      __scopeDialog: e,
      forceMount: n,
      children: r,
      container: o
    } = t, s = Ko(Lj, e);
    return g.createElement(Hse, {
      scope: e,
      forceMount: n
    }, g.Children.map(r, i => g.createElement(Wo, {
      present: n || s.open
    }, g.createElement(iE, {
      asChild: !0,
      container: o
    }, i))))
  },
  y_ = "DialogOverlay",
  Wse = g.forwardRef((t, e) => {
    const n = Fj(y_, t.__scopeDialog),
      {
        forceMount: r = n.forceMount,
        ...o
      } = t,
      s = Ko(y_, t.__scopeDialog);
    return s.modal ? g.createElement(Wo, {
      present: r || s.open
    }, g.createElement(Kse, G({}, o, {
      ref: e
    }))) : null
  }),
  Kse = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      ...r
    } = t, o = Ko(y_, n);
    return g.createElement(xv, {
      as: Wi,
      allowPinchZoom: !0,
      shards: [o.contentRef]
    }, g.createElement(Ke.div, G({
      "data-state": aE(o.open)
    }, r, {
      ref: e,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  }),
  Nf = "DialogContent",
  Gse = g.forwardRef((t, e) => {
    const n = Fj(Nf, t.__scopeDialog),
      {
        forceMount: r = n.forceMount,
        ...o
      } = t,
      s = Ko(Nf, t.__scopeDialog);
    return g.createElement(Wo, {
      present: r || s.open
    }, s.modal ? g.createElement(Yse, G({}, o, {
      ref: e
    })) : g.createElement(qse, G({}, o, {
      ref: e
    })))
  }),
  Yse = g.forwardRef((t, e) => {
    const n = Ko(Nf, t.__scopeDialog),
      r = g.useRef(null),
      o = rt(e, n.contentRef, r);
    return g.useEffect(() => {
      const s = r.current;
      if (s) return Ev(s)
    }, []), g.createElement(Bj, G({}, t, {
      ref: o,
      trapFocus: n.open,
      disableOutsidePointerEvents: !0,
      onCloseAutoFocus: ie(t.onCloseAutoFocus, s => {
        var i;
        s.preventDefault(), (i = n.triggerRef.current) === null || i === void 0 || i.focus()
      }),
      onPointerDownOutside: ie(t.onPointerDownOutside, s => {
        const i = s.detail.originalEvent,
          a = i.button === 0 && i.ctrlKey === !0;
        (i.button === 2 || a) && s.preventDefault()
      }),
      onFocusOutside: ie(t.onFocusOutside, s => s.preventDefault())
    }))
  }),
  qse = g.forwardRef((t, e) => {
    const n = Ko(Nf, t.__scopeDialog),
      r = g.useRef(!1),
      o = g.useRef(!1);
    return g.createElement(Bj, G({}, t, {
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: s => {
        var i;
        if ((i = t.onCloseAutoFocus) === null || i === void 0 || i.call(t, s), !s.defaultPrevented) {
          var a;
          r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(), s.preventDefault()
        }
        r.current = !1, o.current = !1
      },
      onInteractOutside: s => {
        var i, a;
        (i = t.onInteractOutside) === null || i === void 0 || i.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (o.current = !0));
        const c = s.target;
        ((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(c)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && o.current && s.preventDefault()
      }
    }))
  }),
  Bj = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      ...i
    } = t, a = Ko(Nf, n), c = g.useRef(null), l = rt(e, c);
    return Sv(), g.createElement(g.Fragment, null, g.createElement(sE, {
      asChild: !0,
      loop: !0,
      trapped: r,
      onMountAutoFocus: o,
      onUnmountAutoFocus: s
    }, g.createElement(oE, G({
      role: "dialog",
      id: a.contentId,
      "aria-describedby": a.descriptionId,
      "aria-labelledby": a.titleId,
      "data-state": aE(a.open)
    }, i, {
      ref: l,
      onDismiss: () => a.onOpenChange(!1)
    }))), !1)
  }),
  Xse = "DialogTitle",
  Uj = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      ...r
    } = t, o = Ko(Xse, n);
    return g.createElement(Ke.h2, G({
      id: o.titleId
    }, r, {
      ref: e
    }))
  }),
  Zse = "DialogDescription",
  Jse = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      ...r
    } = t, o = Ko(Zse, n);
    return g.createElement(Ke.p, G({
      id: o.descriptionId
    }, r, {
      ref: e
    }))
  }),
  Qse = "DialogClose",
  eie = g.forwardRef((t, e) => {
    const {
      __scopeDialog: n,
      ...r
    } = t, o = Ko(Qse, n);
    return g.createElement(Ke.button, G({
      type: "button"
    }, r, {
      ref: e,
      onClick: ie(t.onClick, () => o.onOpenChange(!1))
    }))
  });

function aE(t) {
  return t ? "open" : "closed"
}
const zj = Bse,
  Tbe = zse,
  Hj = Vse,
  Vj = Wse,
  Wj = Gse,
  tie = Uj,
  nie = Jse;

function Ah({
  className: t,
  children: e
}) {
  return y.jsx("div", {
    className: ae("tlui-dialog__header", t),
    children: e
  })
}

function Mh({
  className: t,
  children: e
}) {
  return y.jsx(Uj, {
    dir: "ltr",
    className: ae("tlui-dialog__header__title", t),
    children: e
  })
}

function jh() {
  return y.jsx("div", {
    className: "tlui-dialog__header__close",
    children: y.jsx(eie, {
      "data-testid": "dialog.close",
      dir: "ltr",
      asChild: !0,
      children: y.jsx(me, {
        type: "icon",
        "aria-label": "Close",
        onTouchEnd: t => t.target.click(),
        children: y.jsx(wr, {
          small: !0,
          icon: "cross-2"
        })
      })
    })
  })
}

function su({
  className: t,
  children: e,
  style: n
}) {
  return y.jsx("div", {
    className: ae("tlui-dialog__body", t),
    style: n,
    children: e
  })
}

function kv({
  className: t,
  children: e
}) {
  return y.jsx("div", {
    className: ae("tlui-dialog__footer", t),
    children: e
  })
}
const $be = Object.freeze(Object.defineProperty({
    __proto__: null,
    Body: su,
    CloseButton: jh,
    Footer: kv,
    Header: Ah,
    Title: Mh
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  cE = g.forwardRef(function({
    className: e,
    label: n,
    icon: r,
    iconLeft: o,
    autoselect: s = !1,
    autofocus: i = !1,
    defaultValue: a,
    placeholder: c,
    onComplete: l,
    onValueChange: u,
    onCancel: d,
    onBlur: f,
    shouldManuallyMaintainScrollPositionWhenFocused: h = !1,
    children: m,
    value: p
  }, b) {
    const w = Y(),
      v = g.useRef(null);
    g.useImperativeHandle(b, () => v.current);
    const _ = nt(),
      S = g.useRef(a ?? ""),
      x = g.useRef(a ?? ""),
      [E, k] = g.useState(!1),
      C = g.useCallback(M => {
        k(!0);
        const j = M.currentTarget;
        x.current = j.value, requestAnimationFrame(() => {
          s && j.select()
        })
      }, [s]),
      $ = g.useCallback(M => {
        const j = M.currentTarget.value;
        x.current = j, u == null || u(j)
      }, [u]),
      I = g.useCallback(M => {
        switch (M.key) {
          case "Enter": {
            M.currentTarget.blur(), Wn(M), l == null || l(M.currentTarget.value);
            break
          }
          case "Escape": {
            M.currentTarget.value = S.current, M.currentTarget.blur(), Wn(M), d == null || d(M.currentTarget.value);
            break
          }
        }
      }, [l, d]),
      R = g.useCallback(M => {
        k(!1);
        const j = M.currentTarget.value;
        f == null || f(j)
      }, [f]);
    return g.useEffect(() => {
      if (!w.environment.isIos) return;
      const M = window.visualViewport;
      if (E && h && M) {
        const j = () => {
          var A;
          (A = v.current) == null || A.scrollIntoView({
            block: "center"
          })
        };
        return M.addEventListener("resize", j), M.addEventListener("scroll", j), requestAnimationFrame(() => {
          var A;
          (A = v.current) == null || A.scrollIntoView({
            block: "center"
          })
        }), () => {
          M.removeEventListener("resize", j), M.removeEventListener("scroll", j)
        }
      }
    }, [w, E, h]), y.jsxs("div", {
      draggable: !1,
      className: "tlui-input__wrapper",
      children: [m, n && y.jsx("label", {
        children: _(n)
      }), o && y.jsx(wr, {
        icon: o,
        className: "tlui-icon-left",
        small: !0
      }), y.jsx("input", {
        ref: v,
        className: ae("tlui-input", e),
        type: "text",
        defaultValue: a,
        onKeyUp: I,
        onChange: $,
        onFocus: C,
        onBlur: R,
        autoFocus: i,
        placeholder: c,
        value: p
      }), r && y.jsx(wr, {
        icon: r,
        small: !!n
      })]
    })
  });

function q2(t) {
  return AS(t) ? {
    isValid: !0,
    hasProtocol: !0
  } : AS("https://" + t) ? {
    isValid: !0,
    hasProtocol: !1
  } : {
    isValid: !1,
    hasProtocol: !1
  }
}
const rie = pt(function({
    onClose: e
  }) {
    const r = Y().getOnlySelectedShape();
    return r && "url" in r.props && typeof r.props.url == "string" ? y.jsx(oie, {
      onClose: e,
      selectedShape: r
    }) : null
  }),
  oie = pt(function({
    onClose: e,
    selectedShape: n
  }) {
    const r = Y(),
      o = nt(),
      s = g.useRef(null);
    g.useEffect(() => {
      requestAnimationFrame(() => {
        var m;
        return (m = s.current) == null ? void 0 : m.focus()
      })
    }, []);
    const i = g.useRef(n.props.url),
      [a, c] = g.useState(() => {
        const m = q2(n.props.url),
          p = m.isValid === !0 ? m.hasProtocol ? n.props.url : "https://" + n.props.url : "https://";
        return {
          actual: p,
          safe: p,
          valid: !0
        }
      }),
      l = g.useCallback(m => {
        const p = m.replace(/https?:\/\/(https?:\/\/)/, (v, _) => _),
          b = q2(p),
          w = b.isValid === !0 ? b.hasProtocol ? p : "https://" + p : "https://";
        c({
          actual: p,
          safe: w,
          valid: b.isValid
        })
      }, []),
      u = g.useCallback(() => {
        const m = r.getOnlySelectedShape();
        m && (r.updateShapes([{
          id: m.id,
          type: m.type,
          props: {
            url: ""
          }
        }]), e())
      }, [r, e]),
      d = g.useCallback(() => {
        const m = r.getOnlySelectedShape();
        m && (m && "url" in m.props && m.props.url !== a.safe && r.updateShapes([{
          id: m.id,
          type: m.type,
          props: {
            url: a.safe
          }
        }]), e())
      }, [r, e, a]),
      f = g.useCallback(() => {
        e()
      }, [e]);
    if (!n) return e(), null;
    const h = i.current && !a.valid;
    return y.jsxs(y.Fragment, {
      children: [y.jsxs(Ah, {
        children: [y.jsx(Mh, {
          children: o("edit-link-dialog.title")
        }), y.jsx(jh, {})]
      }), y.jsx(su, {
        children: y.jsxs("div", {
          className: "tlui-edit-link-dialog",
          children: [y.jsx(cE, {
            ref: s,
            className: "tlui-edit-link-dialog__input",
            label: "edit-link-dialog.url",
            autofocus: !0,
            value: a.actual,
            onValueChange: l,
            onComplete: d,
            onCancel: f
          }), y.jsx("div", {
            children: a.valid ? o("edit-link-dialog.detail") : o("edit-link-dialog.invalid-url")
          })]
        })
      }), y.jsxs(kv, {
        className: "tlui-dialog__footer__actions",
        children: [y.jsx(me, {
          type: "normal",
          onClick: f,
          onTouchEnd: f,
          children: o("edit-link-dialog.cancel")
        }), h ? y.jsx(me, {
          type: "danger",
          onTouchEnd: u,
          onClick: u,
          children: o("edit-link-dialog.clear")
        }) : y.jsx(me, {
          type: "primary",
          disabled: !a.valid,
          onTouchEnd: d,
          onClick: d,
          children: o("edit-link-dialog.save")
        })]
      })]
    })
  }),
  Kj = pt(function({
    onClose: e
  }) {
    const n = Y(),
      r = nt(),
      o = rE(),
      [s, i] = g.useState(null),
      [a, c] = g.useState(""),
      [l, u] = g.useState(null),
      [d, f] = g.useState(!1),
      h = g.useRef(-1);
    return y.jsxs(y.Fragment, {
      children: [y.jsxs(Ah, {
        children: [y.jsx(Mh, {
          children: s ? `${r("embed-dialog.title")}  ${s.title}` : r("embed-dialog.title")
        }), y.jsx(jh, {})]
      }), s ? y.jsxs(y.Fragment, {
        children: [y.jsxs(su, {
          className: "tlui-embed-dialog__enter",
          children: [y.jsx(cE, {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "http://example.com",
            autofocus: !0,
            onValueChange: m => {
              c(m);
              const p = Q1(m);
              u(p && p.definition.type === s.type ? p : null), f(!1), clearTimeout(h.current), h.current = setTimeout(() => f(!p), 320)
            }
          }), a === "" ? y.jsxs("div", {
            className: "tlui-embed-dialog__instruction",
            children: [y.jsx("span", {
              children: r("embed-dialog.instruction")
            }), " ", s.instructionLink && y.jsxs("a", {
              target: "_blank",
              rel: "noopener noreferrer",
              href: s.instructionLink,
              className: "tlui-embed-dialog__instruction__link",
              children: ["Learn more.", y.jsx(wr, {
                icon: "external-link",
                small: !0
              })]
            })]
          }) : y.jsx("div", {
            className: "tlui-embed-dialog__warning",
            children: d ? r("embed-dialog.invalid-url") : " "
          })]
        }), y.jsxs(kv, {
          className: "tlui-dialog__footer__actions",
          children: [y.jsx(me, {
            type: "normal",
            onClick: () => {
              i(null), u(null), c("")
            },
            label: "embed-dialog.back"
          }), y.jsx("div", {
            className: "tlui-embed__spacer"
          }), y.jsx(me, {
            type: "normal",
            label: "embed-dialog.cancel",
            onClick: e
          }), y.jsx(me, {
            type: "primary",
            disabled: !l,
            label: "embed-dialog.create",
            onClick: () => {
              l && (n.putExternalContent({
                type: "embed",
                url: a,
                point: n.viewportPageCenter,
                embed: l.definition
              }), e())
            }
          })]
        })]
      }) : y.jsx(y.Fragment, {
        children: y.jsx(su, {
          className: "tlui-embed-dialog__list",
          children: nu.map(m => y.jsx(me, {
            type: "menu",
            onClick: () => i(m),
            label: m.title,
            children: y.jsx("div", {
              className: "tlui-embed-dialog__item__image",
              style: {
                backgroundImage: `url(${o.embedIcons[m.type]})`
              }
            })
          }, m.type))
        })
      })]
    })
  });
var lE = {
  exports: {}
};
lE.exports;
(function(t) {
  var e = function() {
    var n = String.fromCharCode,
      r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",
      s = {};

    function i(c, l) {
      if (!s[c]) {
        s[c] = {};
        for (var u = 0; u < c.length; u++) s[c][c.charAt(u)] = u
      }
      return s[c][l]
    }
    var a = {
      compressToBase64: function(c) {
        if (c == null) return "";
        var l = a._compress(c, 6, function(u) {
          return r.charAt(u)
        });
        switch (l.length % 4) {
          default:
          case 0:
            return l;
          case 1:
            return l + "===";
          case 2:
            return l + "==";
          case 3:
            return l + "="
        }
      },
      decompressFromBase64: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32, function(l) {
          return i(r, c.charAt(l))
        })
      },
      compressToUTF16: function(c) {
        return c == null ? "" : a._compress(c, 15, function(l) {
          return n(l + 32)
        }) + " "
      },
      decompressFromUTF16: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 16384, function(l) {
          return c.charCodeAt(l) - 32
        })
      },
      compressToUint8Array: function(c) {
        for (var l = a.compress(c), u = new Uint8Array(l.length * 2), d = 0, f = l.length; d < f; d++) {
          var h = l.charCodeAt(d);
          u[d * 2] = h >>> 8, u[d * 2 + 1] = h % 256
        }
        return u
      },
      decompressFromUint8Array: function(c) {
        if (c == null) return a.decompress(c);
        for (var l = new Array(c.length / 2), u = 0, d = l.length; u < d; u++) l[u] = c[u * 2] * 256 + c[u * 2 + 1];
        var f = [];
        return l.forEach(function(h) {
          f.push(n(h))
        }), a.decompress(f.join(""))
      },
      compressToEncodedURIComponent: function(c) {
        return c == null ? "" : a._compress(c, 6, function(l) {
          return o.charAt(l)
        })
      },
      decompressFromEncodedURIComponent: function(c) {
        return c == null ? "" : c == "" ? null : (c = c.replace(/ /g, "+"), a._decompress(c.length, 32, function(l) {
          return i(o, c.charAt(l))
        }))
      },
      compress: function(c) {
        return a._compress(c, 16, function(l) {
          return n(l)
        })
      },
      _compress: function(c, l, u) {
        if (c == null) return "";
        var d, f, h = {},
          m = {},
          p = "",
          b = "",
          w = "",
          v = 2,
          _ = 3,
          S = 2,
          x = [],
          E = 0,
          k = 0,
          C;
        for (C = 0; C < c.length; C += 1)
          if (p = c.charAt(C), Object.prototype.hasOwnProperty.call(h, p) || (h[p] = _++, m[p] = !0), b = w + p, Object.prototype.hasOwnProperty.call(h, b)) w = b;
          else {
            if (Object.prototype.hasOwnProperty.call(m, w)) {
              if (w.charCodeAt(0) < 256) {
                for (d = 0; d < S; d++) E = E << 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++;
                for (f = w.charCodeAt(0), d = 0; d < 8; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1
              } else {
                for (f = 1, d = 0; d < S; d++) E = E << 1 | f, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = 0;
                for (f = w.charCodeAt(0), d = 0; d < 16; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1
              }
              v--, v == 0 && (v = Math.pow(2, S), S++), delete m[w]
            } else
              for (f = h[w], d = 0; d < S; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1;
            v--, v == 0 && (v = Math.pow(2, S), S++), h[b] = _++, w = String(p)
          } if (w !== "") {
          if (Object.prototype.hasOwnProperty.call(m, w)) {
            if (w.charCodeAt(0) < 256) {
              for (d = 0; d < S; d++) E = E << 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++;
              for (f = w.charCodeAt(0), d = 0; d < 8; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1
            } else {
              for (f = 1, d = 0; d < S; d++) E = E << 1 | f, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = 0;
              for (f = w.charCodeAt(0), d = 0; d < 16; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1
            }
            v--, v == 0 && (v = Math.pow(2, S), S++), delete m[w]
          } else
            for (f = h[w], d = 0; d < S; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1;
          v--, v == 0 && (v = Math.pow(2, S), S++)
        }
        for (f = 2, d = 0; d < S; d++) E = E << 1 | f & 1, k == l - 1 ? (k = 0, x.push(u(E)), E = 0) : k++, f = f >> 1;
        for (;;)
          if (E = E << 1, k == l - 1) {
            x.push(u(E));
            break
          } else k++;
        return x.join("")
      },
      decompress: function(c) {
        return c == null ? "" : c == "" ? null : a._decompress(c.length, 32768, function(l) {
          return c.charCodeAt(l)
        })
      },
      _decompress: function(c, l, u) {
        var d = [],
          f = 4,
          h = 4,
          m = 3,
          p = "",
          b = [],
          w, v, _, S, x, E, k, C = {
            val: u(0),
            position: l,
            index: 1
          };
        for (w = 0; w < 3; w += 1) d[w] = w;
        for (_ = 0, x = Math.pow(2, 2), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
        switch (_) {
          case 0:
            for (_ = 0, x = Math.pow(2, 8), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
            k = n(_);
            break;
          case 1:
            for (_ = 0, x = Math.pow(2, 16), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
            k = n(_);
            break;
          case 2:
            return ""
        }
        for (d[3] = k, v = k, b.push(k);;) {
          if (C.index > c) return "";
          for (_ = 0, x = Math.pow(2, m), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
          switch (k = _) {
            case 0:
              for (_ = 0, x = Math.pow(2, 8), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
              d[h++] = n(_), k = h - 1, f--;
              break;
            case 1:
              for (_ = 0, x = Math.pow(2, 16), E = 1; E != x;) S = C.val & C.position, C.position >>= 1, C.position == 0 && (C.position = l, C.val = u(C.index++)), _ |= (S > 0 ? 1 : 0) * E, E <<= 1;
              d[h++] = n(_), k = h - 1, f--;
              break;
            case 2:
              return b.join("")
          }
          if (f == 0 && (f = Math.pow(2, m), m++), d[k]) p = d[k];
          else if (k === h) p = v + v.charAt(0);
          else return null;
          b.push(p), d[h++] = v + p.charAt(0), f--, v = p, f == 0 && (f = Math.pow(2, m), m++)
        }
      }
    };
    return a
  }();
  t != null && (t.exports = e)
})(lE);
var Gj = lE.exports;
async function sie(t, e, n) {
  var w, v, _;
  const {
    elements: r,
    files: o
  } = e, s = {
    shapes: [],
    rootShapeIds: [],
    assets: [],
    schema: t.store.schema.serialize()
  }, i = new Map, a = new Map, {
    currentPageId: c
  } = t, l = new Map, u = [], d = new Set;
  r.forEach(S => {
    if (l.set(S.id, is()), S.boundElements !== null)
      for (const x of S.boundElements) x.type === "text" && d.add(x.id)
  });
  let f = "a1";
  for (const S of r) {
    if (d.has(S.id)) continue;
    const x = l.get(S.id),
      E = {
        id: x,
        typeName: "shape",
        parentId: c,
        index: f,
        x: S.x,
        y: S.y,
        rotation: 0,
        isLocked: S.locked,
        opacity: iie(S.opacity),
        meta: {}
      };
    switch (S.angle !== 0 && a.set(x, S.angle), S.groupIds && S.groupIds.length > 0 ? i.has(S.groupIds[0]) ? (w = i.get(S.groupIds[0])) == null || w.push(x) : i.set(S.groupIds[0], [x]) : u.push(x), S.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let k = "",
          C = "middle";
        if (S.boundElements !== null) {
          for (const I of S.boundElements)
            if (I.type === "text") {
              const R = r.find(M => M.id === I.id);
              R && (k = R.text, C = X2[R.textAlign])
            }
        }
        const $ = S.backgroundColor === "transparent" ? S.strokeColor : S.backgroundColor;
        s.shapes.push({
          ...E,
          type: "geo",
          props: {
            geo: S.type,
            url: S.link ?? "",
            w: S.width,
            h: S.height,
            size: eg[S.strokeWidth] ?? "draw",
            color: hd[$] ?? "black",
            text: k,
            align: C,
            dash: tg(S),
            fill: hie(S)
          }
        });
        break
      }
      case "freedraw": {
        s.shapes.push({
          ...E,
          type: "draw",
          props: {
            dash: tg(S),
            size: eg[S.strokeWidth],
            color: hd[S.strokeColor] ?? "black",
            segments: [{
              type: "free",
              points: S.points.map(([k, C, $ = .5]) => ({
                x: k,
                y: C,
                z: $
              }))
            }]
          }
        });
        break
      }
      case "line": {
        const k = S.points[0],
          C = S.points[S.points.length - 1],
          $ = j3(S.points.length);
        s.shapes.push({
          ...E,
          type: "line",
          props: {
            dash: tg(S),
            size: eg[S.strokeWidth],
            color: hd[S.strokeColor] ?? "black",
            spline: S.roundness ? "cubic" : "line",
            handles: {
              start: {
                id: "start",
                type: "vertex",
                index: $[0],
                x: k[0],
                y: k[1]
              },
              end: {
                id: "end",
                type: "vertex",
                index: $[$.length - 1],
                x: C[0],
                y: C[1]
              },
              ...Object.fromEntries(S.points.slice(1, -1).map(([I, R], M) => {
                const j = It();
                return [j, {
                  id: j,
                  type: "vertex",
                  index: $[M + 1],
                  x: I,
                  y: R
                }]
              }))
            }
          }
        });
        break
      }
      case "arrow": {
        let k = "";
        if (S.boundElements !== null) {
          for (const M of S.boundElements)
            if (M.type === "text") {
              const j = r.find(A => A.id === M.id);
              j && (k = j.text)
            }
        }
        const C = S.points[0],
          $ = S.points[S.points.length - 1],
          I = l.get((v = S.startBinding) == null ? void 0 : v.elementId),
          R = l.get((_ = S.endBinding) == null ? void 0 : _.elementId);
        s.shapes.push({
          ...E,
          type: "arrow",
          props: {
            text: k,
            bend: fie(S, C, $),
            dash: tg(S),
            size: eg[S.strokeWidth] ?? "m",
            color: hd[S.strokeColor] ?? "black",
            start: I ? {
              type: "binding",
              boundShapeId: I,
              normalizedAnchor: {
                x: .5,
                y: .5
              },
              isExact: !1
            } : {
              type: "point",
              x: C[0],
              y: C[1]
            },
            end: R ? {
              type: "binding",
              boundShapeId: R,
              normalizedAnchor: {
                x: .5,
                y: .5
              },
              isExact: !1
            } : {
              type: "point",
              x: $[0],
              y: $[1]
            },
            arrowheadEnd: Z2[S.endArrowhead] ?? "none",
            arrowheadStart: Z2[S.startArrowhead] ?? "none"
          }
        });
        break
      }
      case "text": {
        const {
          size: k,
          scale: C
        } = cie(S.fontSize);
        s.shapes.push({
          ...E,
          type: "text",
          props: {
            size: k,
            scale: C,
            font: lie[S.fontFamily] ?? "draw",
            color: hd[S.strokeColor] ?? "black",
            text: S.text,
            align: X2[S.textAlign]
          }
        });
        break
      }
      case "image": {
        const k = o[S.fileId];
        if (!k) break;
        const C = $f.createId();
        s.assets.push({
          id: C,
          typeName: "asset",
          type: "image",
          props: {
            w: S.width,
            h: S.height,
            name: S.id ?? "Untitled",
            isAnimated: !1,
            mimeType: k.mimeType,
            src: k.dataURL
          },
          meta: {}
        }), s.shapes.push({
          ...E,
          type: "image",
          props: {
            w: S.width,
            h: S.height,
            assetId: C
          }
        })
      }
    }
    f = yi(f)
  }
  const h = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContentOntoCurrentPage(s, {
    point: h,
    select: !1,
    preserveIds: !0
  });
  for (const S of i.values())
    if (S.length > 1) {
      t.groupShapes(S);
      const x = t.getShape(S[0]);
      x != null && x.parentId && yo(x.parentId) && u.push(x.parentId)
    } for (const [S, x] of a) t.select(S), t.rotateShapesBy([S], x);
  const m = Fe(u.map(S => t.getShape(S))),
    p = Be.Common(m.map(S => t.getShapePageBounds(S))),
    b = t.viewportPageBounds.center;
  t.updateShapes(m.map(S => {
    const x = {
      x: (S.x ?? 0) - (p.x + p.w / 2),
      y: (S.y ?? 0) - (p.y + p.h / 2)
    };
    return {
      id: S.id,
      type: S.type,
      x: b.x + x.x,
      y: b.y + x.y
    }
  })), t.setSelectedShapes(u)
}
const iie = t => {
    const e = t / 100;
    return e < .2 ? .1 : e < .4 ? .25 : e < .6 ? .5 : e < .8 ? .75 : 1
  },
  eg = {
    1: "s",
    2: "m",
    3: "l",
    4: "xl"
  },
  aie = {
    16: "s",
    20: "m",
    28: "l",
    36: "xl"
  };

function cie(t) {
  const e = aie[t];
  return e ? {
    size: e,
    scale: 1
  } : t < 16 ? {
    size: "s",
    scale: t / 16
  } : t > 36 ? {
    size: "xl",
    scale: t / 36
  } : {
    size: "m",
    scale: 1
  }
}
const lie = {
    1: "draw",
    2: "sans",
    3: "mono"
  },
  hd = {
    "#ffffff": "grey",
    "#000000": "black",
    "#343a40": "black",
    "#495057": "grey",
    "#c92a2a": "red",
    "#a61e4d": "light-red",
    "#862e9c": "violet",
    "#5f3dc4": "light-violet",
    "#364fc7": "blue",
    "#1864ab": "light-blue",
    "#0b7285": "light-green",
    "#087f5b": "light-green",
    "#2b8a3e": "green",
    "#5c940d": "light-green",
    "#e67700": "yellow",
    "#d9480f": "orange",
    "#ced4da": "grey",
    "#868e96": "grey",
    "#fa5252": "light-red",
    "#e64980": "red",
    "#be4bdb": "light-violet",
    "#7950f2": "violet",
    "#4c6ef5": "blue",
    "#228be6": "light-blue",
    "#15aabf": "light-green",
    "#12b886": "green",
    "#40c057": "green",
    "#82c91e": "light-green",
    "#fab005": "yellow",
    "#fd7e14": "orange",
    "#212529": "grey"
  },
  uie = {
    solid: "draw",
    dashed: "dashed",
    dotted: "dotted"
  },
  die = {
    "cross-hatch": "pattern",
    hachure: "pattern",
    solid: "solid"
  },
  X2 = {
    left: "start",
    center: "middle",
    right: "end"
  },
  Z2 = {
    arrow: "arrow",
    dot: "dot",
    triangle: "triangle",
    bar: "pipe"
  };

function fie(t, e, n) {
  let r = 0;
  if (t.points.length > 2) {
    const o = new T(e[0], e[1]),
      s = new T(n[0], n[1]),
      i = new T(t.points[1][0], t.points[1][1]),
      a = T.Sub(s, o),
      c = T.Per(a),
      l = T.Med(s, o),
      u = T.Sub(l, c),
      d = T.Add(l, c),
      f = T.NearestPointOnLineSegment(u, d, i, !1);
    r = T.Dist(f, l), T.Clockwise(f, s, l) && (r *= -1)
  }
  return r
}
const tg = t => {
    let e = uie[t.strokeStyle] ?? "draw";
    return e === "draw" && t.roughness === 0 && (e = "solid"), e
  },
  hie = t => t.backgroundColor === "transparent" ? "none" : die[t.fillStyle] ?? "solid";
async function Yj(t, e, n, r) {
  const s = (await Promise.all(e.map(async i => await (await fetch(i)).blob()))).map(i => new File([i], "tldrawFile", {
    type: i.type
  }));
  t.mark("paste"), await t.putExternalContent({
    type: "files",
    files: s,
    point: n,
    ignoreParent: !1,
    sources: r
  }), e.forEach(i => URL.revokeObjectURL(i))
}

function pie(t, e, n) {
  const r = n ?? (t.inputs.shiftKey ? t.inputs.currentPagePoint : void 0);
  t.mark("paste"), t.putContentOntoCurrentPage(e, {
    point: r,
    select: !0
  })
}
async function v_(t, e, n, r) {
  var o;
  try {
    if (new URL(e).pathname.match(/\.(png|jpe?g|gif|svg|webp)$/i) && (o = (await fetch(e, {
        method: "HEAD"
      })).headers.get("content-type")) != null && o.match(/^image\//)) {
      t.mark("paste"), Yj(t, [e]);
      return
    }
  } catch (s) {
    s.message !== "Failed to fetch" && console.error(s)
  }
  return t.mark("paste"), await t.putExternalContent({
    type: "url",
    point: n,
    url: e,
    sources: r
  })
}
const qj = () => {},
  Xj = g.createContext({});

function gie({
  onEvent: t,
  children: e
}) {
  return y.jsx(Xj.Provider, {
    value: t ?? qj,
    children: e
  })
}

function $u() {
  return g.useContext(Xj) ?? qj
}

function mie(t) {
  const e = document.implementation.createHTMLDocument("");
  return e.documentElement.innerHTML = t.trim(), e.body.textContent || e.body.innerText || ""
}
const yie = t => {
    try {
      const e = new URL(t);
      return e.protocol === "http:" || e.protocol === "https:"
    } catch {
      return !1
    }
  },
  vie = t => {
    const e = t.split(/[\n\s]/);
    for (const n of e) try {
      const r = new URL(n);
      if (!(r.protocol === "http:" || r.protocol === "https:")) return
    } catch {
      return
    }
    return f3(e)
  },
  bie = t => /^<svg/.test(t),
  wie = ["input", "select", "textarea"];

function Bg(t) {
  const {
    activeElement: e
  } = document;
  return t.getIsMenuOpen() || e && (e.getAttribute("contenteditable") || wie.indexOf(e.tagName.toLowerCase()) > -1)
}
async function Lb(t) {
  return new Promise((e, n) => {
    const r = new FileReader;
    r.addEventListener("loadend", () => {
      const o = r.result;
      e(o)
    }), r.addEventListener("error", () => {
      n(r.error)
    }), r.readAsText(t)
  })
}
const Sie = t => t.types.find(e => e.match(/^image\//)),
  Fb = (t, e, n, r) => {
    const o = vie(e);
    if (o)
      for (const s of o) v_(t, s, n);
    else yie(e) ? v_(t, e, n) : bie(e) ? (t.mark("paste"), t.putExternalContent({
      type: "svg-text",
      text: e,
      point: n,
      sources: r
    })) : (t.mark("paste"), t.putExternalContent({
      type: "text",
      text: e,
      point: n,
      sources: r
    }))
  },
  _ie = async (t, e, n) => {
    if (t.getEditingShapeId() !== null) return;
    if (!e) throw Error("No clipboard data");
    const r = [];
    for (const o of Object.values(e.items)) switch (o.kind) {
      case "file": {
        r.push({
          type: "file",
          source: new Promise(s => s(o.getAsFile()))
        });
        break
      }
      case "string": {
        o.type === "text/html" ? r.push({
          type: "html",
          source: new Promise(s => o.getAsString(s))
        }) : o.type === "text/plain" ? r.push({
          type: "text",
          source: new Promise(s => o.getAsString(s))
        }) : r.push({
          type: o.type,
          source: new Promise(s => o.getAsString(s))
        });
        break
      }
    }
    Jj(t, r, n)
  }, Zj = async (t, e, n) => {
    const r = [];
    for (const o of e) {
      if (Sie(o))
        for (const s of o.types) s.match(/^image\//) && r.push({
          type: "blob",
          source: o.getType(s)
        });
      o.types.includes("text/html") && r.push({
        type: "html",
        source: new Promise(s => o.getType("text/html").then(i => Lb(i).then(s)))
      }), o.types.includes("text/uri-list") && r.push({
        type: "url",
        source: new Promise(s => o.getType("text/uri-list").then(i => Lb(i).then(s)))
      }), o.types.includes("text/plain") && r.push({
        type: "text",
        source: new Promise(s => o.getType("text/plain").then(i => Lb(i).then(s)))
      })
    }
    return await Jj(t, r, n)
  };
async function Jj(t, e, n) {
  const r = e.filter(s => (s.type === "file" || s.type === "blob") && s.source !== null);
  if (r.length) {
    const i = (await Promise.all(r.map(a => a.source))).filter(Boolean).map(a => URL.createObjectURL(a));
    return await Yj(t, i, n)
  }
  const o = await Promise.all(e.filter(s => s.type !== "file").map(s => new Promise(i => {
    const a = s;
    if (a.type === "file") {
      i({
        type: "error",
        data: null,
        reason: "unexpected file"
      });
      return
    }
    a.source.then(c => {
      var u;
      const l = (u = c.match(/<tldraw[^>]*>(.*)<\/tldraw>/)) == null ? void 0 : u[1];
      if (l) try {
        const d = Gj.decompressFromBase64(l);
        if (d === null) {
          i({
            type: "error",
            data: d,
            reason: "found tldraw data comment but could not parse base64"
          });
          return
        } else {
          const f = JSON.parse(d);
          if (f.type !== "application/tldraw" && i({
              type: "error",
              data: f,
              reason: `found tldraw data comment but JSON was of a different type: ${f.type}`
            }), typeof f.data == "string") {
            i({
              type: "error",
              data: f,
              reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
            });
            return
          }
          i({
            type: "tldraw",
            data: f.data
          });
          return
        }
      } catch {
        i({
          type: "error",
          data: l,
          reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
        });
        return
      } else {
        if (a.type === "html") {
          i({
            type: "text",
            data: c,
            subtype: "html"
          });
          return
        }
        if (a.type === "url") {
          i({
            type: "text",
            data: c,
            subtype: "url"
          });
          return
        }
        try {
          const d = JSON.parse(c);
          if (d.type === "excalidraw/clipboard") {
            i({
              type: "excalidraw",
              data: d
            });
            return
          } else {
            i({
              type: "text",
              data: c,
              subtype: "json"
            });
            return
          }
        } catch {
          i({
            type: "text",
            data: c,
            subtype: "text"
          });
          return
        }
      }
      i({
        type: "error",
        data: c,
        reason: "unhandled case"
      })
    })
  })));
  for (const s of o)
    if (s.type === "tldraw") {
      pie(t, s.data, n);
      return
    } for (const s of o)
    if (s.type === "excalidraw") {
      sie(t, s.data, n);
      return
    } for (const s of o)
    if (s.type === "text" && s.subtype === "html") {
      const a = new DOMParser().parseFromString(s.data, "text/html").querySelector("body");
      if (a && Array.from(a.children).filter(l => l.nodeType === 1).length === 1 && a.firstElementChild && a.firstElementChild.tagName === "A" && a.firstElementChild.hasAttribute("href") && a.firstElementChild.getAttribute("href") !== "") {
        const l = a.firstElementChild.getAttribute("href");
        Fb(t, l, n, o);
        return
      }
      if (!o.some(l => l.type === "text" && l.subtype !== "html") && s.data.trim()) {
        Fb(t, mie(s.data), n, o);
        return
      }
    } for (const s of o)
    if (s.type === "text" && s.subtype === "url") {
      v_(t, s.data, n, o);
      return
    } for (const s of o)
    if (s.type === "text" && s.subtype === "text" && s.data.trim()) {
      Fb(t, s.data, n, o);
      return
    }
}
const Gm = t => {
  var r;
  const e = t.getContentFromCurrentPage(t.getSelectedShapeIds());
  if (!e) {
    navigator && navigator.clipboard && navigator.clipboard.writeText("");
    return
  }
  const n = Gj.compressToBase64(JSON.stringify({
    type: "application/tldraw",
    kind: "content",
    data: e
  }));
  if (!(typeof navigator > "u")) {
    const o = e.shapes.map(s => t.isShapeOfType(s, "text") || t.isShapeOfType(s, "geo") || t.isShapeOfType(s, "arrow") ? s.props.text : t.isShapeOfType(s, "bookmark") || t.isShapeOfType(s, "embed") ? s.props.url : null).filter($z);
    if ((r = navigator.clipboard) != null && r.write) {
      const s = new Blob([`<tldraw>${n}</tldraw>`], {
        type: "text/html"
      });
      let i = o.join(" ");
      i === "" && (i = " "), navigator.clipboard.write([new ClipboardItem({
        "text/html": s,
        "text/plain": new Blob([i], {
          type: "text/plain"
        })
      })])
    } else navigator.clipboard.writeText && navigator.clipboard.writeText(`<tldraw>${n}</tldraw>`)
  }
};

function xie() {
  const t = Y(),
    e = $u(),
    n = g.useCallback(function(i) {
      t.getSelectedShapeIds().length !== 0 && (Gm(t), e("copy", {
        source: i
      }))
    }, [t, e]),
    r = g.useCallback(function(i) {
      t.getSelectedShapeIds().length !== 0 && (Gm(t), t.deleteShapes(t.getSelectedShapeIds()), e("cut", {
        source: i
      }))
    }, [t, e]),
    o = g.useCallback(async function(i, a, c) {
      t.getEditingShapeId() !== null || Bg(t) || (Array.isArray(i) && i[0] instanceof ClipboardItem ? (Zj(t, i, c), e("paste", {
        source: "menu"
      })) : navigator.clipboard.read().then(l => {
        o(l, a, c)
      }))
    }, [t, e]);
  return {
    copy: n,
    cut: r,
    paste: o
  }
}

function Eie() {
  const t = Y(),
    e = $u(),
    n = te("editor.isFocused", () => t.getInstanceState().isFocused, [t]);
  g.useEffect(() => {
    if (!n) return;
    const r = () => {
      t.getSelectedShapeIds().length === 0 || t.getEditingShapeId() !== null || Bg(t) || (Gm(t), e("copy", {
        source: "kbd"
      }))
    };

    function o() {
      t.getSelectedShapeIds().length === 0 || t.getEditingShapeId() !== null || Bg(t) || (Gm(t), t.deleteShapes(t.getSelectedShapeIds()), e("cut", {
        source: "kbd"
      }))
    }
    let s = !1;
    const i = c => {
        c.button === 1 && (s = !0, requestAnimationFrame(() => {
          s = !1
        }))
      },
      a = c => {
        if (s) {
          c.stopPropagation();
          return
        }
        t.getEditingShapeId() !== null || Bg(t) || (c.clipboardData && !t.inputs.shiftKey ? _ie(t, c.clipboardData) : navigator.clipboard.read().then(l => {
          Array.isArray(l) && l[0] instanceof ClipboardItem && Zj(t, l, t.inputs.currentPagePoint)
        }), e("paste", {
          source: "kbd"
        }))
      };
    return document.addEventListener("copy", r), document.addEventListener("cut", o), document.addEventListener("paste", a), document.addEventListener("pointerup", i), () => {
      document.removeEventListener("copy", r), document.removeEventListener("cut", o), document.removeEventListener("paste", a), document.removeEventListener("pointerup", i)
    }
  }, [t, e, n])
}

function Qj(t) {
  const e = t.cloneNode(!0);
  return t.setAttribute("width", +t.getAttribute("width") + ""), t.setAttribute("height", +t.getAttribute("height") + ""), new XMLSerializer().serializeToString(e).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1")
}
async function eD(t, e, n) {
  const {
    type: r,
    quality: o,
    scale: s
  } = n, i = +t.getAttribute("width"), a = +t.getAttribute("height");
  let c = i * s,
    l = a * s;
  const u = await tD(t),
    d = await wre();
  if (i > d.maxWidth && (c = d.maxWidth, l = c / i * a), a > d.maxHeight && (l = d.maxHeight, c = l / a * i), c * l > d.maxArea) {
    const b = Math.sqrt(d.maxArea / (c * l));
    c *= b, l *= b
  }
  c = Math.floor(c), l = Math.floor(l);
  const f = c / i,
    h = await new Promise(b => {
      const w = new Image;
      w.crossOrigin = "anonymous", w.onload = async () => {
        e && await new Promise(S => setTimeout(S, 250));
        const v = document.createElement("canvas"),
          _ = v.getContext("2d");
        v.width = c, v.height = l, _.imageSmoothingEnabled = !0, _.imageSmoothingQuality = "high", _.drawImage(w, 0, 0, c, l), URL.revokeObjectURL(u), b(v)
      }, w.onerror = () => {
        b(null)
      }, w.src = u
    });
  if (!h) return null;
  const m = await new Promise(b => h.toBlob(w => {
    (!w || Nt.throwToBlob.get()) && b(null), b(w)
  }, "image/" + r, o));
  if (!m) return null;
  const p = new DataView(await m.arrayBuffer());
  return Sa.setPhysChunk(p, f, {
    type: "image/" + r
  })
}
async function tD(t) {
  const e = t.cloneNode(!0);
  e.setAttribute("encoding", 'UTF-8"');
  const n = new FileReader,
    r = Array.from(e.querySelectorAll("image"));
  for (const o of r) {
    const s = o.getAttribute("xlink:href");
    if (s && !s.startsWith("data:")) {
      const i = await (await fetch(s)).blob(),
        a = await new Promise((c, l) => {
          n.onload = () => c(n.result), n.onerror = () => l(n.error), n.readAsDataURL(i)
        });
      o.setAttribute("xlink:href", a)
    }
  }
  return kie(e)
}

function kie(t) {
  const e = new XMLSerializer().serializeToString(t);
  return `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(e)))}`
}

function Bb(t, e) {
  const n = document.createElement("a");
  n.href = t, n.download = e, n.click()
}
const nD = g.createContext({});

function Cie({
  children: t
}) {
  const [e, n] = g.useState([]), r = g.useCallback(i => {
    const a = i.id ?? It();
    return n(c => [...c.filter(l => l.id !== i.id), {
      ...i,
      id: a
    }]), a
  }, []), o = g.useCallback(i => (n(a => a.filter(c => c.id !== i)), i), []), s = g.useCallback(() => {
    n(() => [])
  }, []);
  return y.jsx(nD.Provider, {
    value: {
      toasts: e,
      addToast: r,
      removeToast: o,
      clearToasts: s
    },
    children: t
  })
}

function bs() {
  const t = g.useContext(nD);
  if (!t) throw new Error("useToasts must be used within a ToastsProvider");
  return t
}

function Pie() {
  const t = Y(),
    {
      addToast: e
    } = bs(),
    n = nt();
  return g.useCallback(function(o = t.getSelectedShapeIds(), s = "svg") {
    if (o.length === 0 && (o = [...t.currentPageShapeIds]), o.length !== 0) switch (s) {
      case "svg": {
        window.navigator.clipboard && (window.navigator.clipboard.write ? window.navigator.clipboard.write([new ClipboardItem({
          "text/plain": Tie(t, o)
        })]) : J2(async () => Qj(await uE(t, o))));
        break
      }
      case "jpeg":
      case "png": {
        const i = s === "jpeg" ? "image/jpeg" : "image/png",
          a = $ie(t, o, s).then(c => {
            if (c) {
              if (window.navigator.clipboard) return c;
              throw new Error("Copy not supported")
            } else throw e({
              id: "copy-fail",
              icon: "warning-triangle",
              title: n("toast.error.copy-fail.title"),
              description: n("toast.error.copy-fail.desc")
            }), new Error("Copy not possible")
          });
        window.navigator.clipboard.write([new ClipboardItem({
          [i]: a
        })]).catch(c => {
          c.toString().match(/^TypeError: DOMString not supported/) || console.error(c), a.then(l => {
            window.navigator.clipboard.write([new ClipboardItem({
              [i]: l
            })])
          })
        });
        break
      }
      case "json": {
        const i = t.getContentFromCurrentPage(o);
        if (window.navigator.clipboard) {
          const a = JSON.stringify(i);
          window.navigator.clipboard.write ? window.navigator.clipboard.write([new ClipboardItem({
            "text/plain": new Blob([a], {
              type: "text/plain"
            })
          })]) : J2(async () => a)
        }
        break
      }
      default:
        throw new Error(`Copy type ${s} not supported.`)
    }
  }, [t, e, n])
}
async function uE(t, e) {
  const n = await t.getSvg(e, {
    scale: 1,
    background: t.getInstanceState().exportBackground
  });
  if (!n) throw new Error("Could not construct SVG.");
  return n
}
async function Tie(t, e) {
  return new Blob([Qj(await uE(t, e))], {
    type: "text/plain"
  })
}
async function $ie(t, e, n) {
  return await eD(await uE(t, e), t.environment.isSafari, {
    type: n,
    quality: 1,
    scale: 2
  })
}
async function J2(t) {
  navigator && navigator.clipboard && navigator.clipboard.writeText(await t())
}
const rD = g.createContext({});

function Iie({
  children: t
}) {
  const e = Y(),
    n = $u(),
    [r, o] = g.useState([]),
    s = g.useCallback(l => {
      const u = l.id ?? It();
      return o(d => [...d.filter(f => f.id !== l.id), {
        ...l,
        id: u
      }]), n("open-menu", {
        source: "dialog",
        id: u
      }), e.addOpenMenu(u), u
    }, [e, n]),
    i = g.useCallback((l, u) => (o(d => d.map(f => f.id === l ? {
      ...f,
      ...u
    } : f)), n("open-menu", {
      source: "dialog",
      id: l
    }), e.addOpenMenu(l), l), [e, n]),
    a = g.useCallback(l => (o(u => u.filter(d => {
      var f;
      return d.id === l ? ((f = d.onClose) == null || f.call(d), !1) : !0
    })), n("close-menu", {
      source: "dialog",
      id: l
    }), e.deleteOpenMenu(l), l), [e, n]),
    c = g.useCallback(() => {
      o(l => (l.forEach(u => {
        var d;
        (d = u.onClose) == null || d.call(u), n("close-menu", {
          source: "dialog",
          id: u.id
        }), e.deleteOpenMenu(u.id)
      }), []))
    }, [e, n]);
  return y.jsx(rD.Provider, {
    value: {
      dialogs: r,
      addDialog: s,
      removeDialog: a,
      clearDialogs: c,
      updateDialog: i
    },
    children: t
  })
}

function gc() {
  const t = g.useContext(rD);
  if (!t) throw new Error("useDialogs must be used within a DialogsProvider");
  return t
}

function Oie() {
  const t = Y(),
    {
      addToast: e
    } = bs(),
    n = nt();
  return g.useCallback(async function(o = t.getSelectedShapeIds(), s = "png") {
    if (o.length === 0 && (o = [...t.currentPageShapeIds]), o.length === 0) return;
    const i = await t.getSvg(o, {
      scale: 1,
      background: t.getInstanceState().exportBackground
    });
    if (!i) throw new Error("Could not construct SVG.");
    let a = "shapes" + Rie();
    if (o.length === 1) {
      const c = t.getShape(o[0]);
      t.isShapeOfType(c, "frame") ? a = c.props.name ?? "frame" : a = c.id.replace(/:/, "_")
    }
    switch (s) {
      case "svg": {
        const c = await tD(i);
        Bb(c, `${a}.svg`);
        return
      }
      case "webp":
      case "png": {
        const c = await eD(i, t.environment.isSafari, {
          type: s,
          quality: 1,
          scale: 2
        });
        if (!c) {
          e({
            id: "export-fail",
            title: n("toast.error.export-fail.title"),
            description: n("toast.error.export-fail.desc")
          });
          return
        }
        const l = URL.createObjectURL(c);
        Bb(l, `${a}.${s}`), URL.revokeObjectURL(l);
        return
      }
      case "json": {
        const c = t.getContentFromCurrentPage(o),
          l = URL.createObjectURL(new Blob([JSON.stringify(c, null, 4)], {
            type: "application/json"
          }));
        Bb(l, `${a||"shapes"}.json`), URL.revokeObjectURL(l);
        return
      }
      default:
        throw new Error(`Export type ${s} not supported.`)
    }
  }, [t, e, n])
}

function Rie() {
  const t = new Date,
    e = String(t.getFullYear()).slice(2),
    n = String(t.getMonth() + 1).padStart(2, "0"),
    r = String(t.getDate()).padStart(2, "0"),
    o = String(t.getHours()).padStart(2, "0"),
    s = String(t.getMinutes()).padStart(2, "0"),
    i = String(t.getSeconds()).padStart(2, "0");
  return ` at ${e}-${n}-${r} ${o}.${s}.${i}`
}

function oD() {
  const t = Y(),
    e = g.useRef();
  return g.useEffect(() => {
    const n = window.document.createElement("input");
    n.type = "file", n.accept = "image/jpeg,image/png,image/gif,image/svg+xml,video/mp4,video/quicktime", n.multiple = !0, e.current = n;
    async function r(o) {
      const s = o.target.files;
      !s || s.length === 0 || (await t.putExternalContent({
        type: "files",
        files: Array.from(s),
        point: t.viewportPageBounds.center,
        ignoreParent: !1
      }), n.value = "")
    }
    return n.addEventListener("change", r), () => {
      e.current = void 0, n.removeEventListener("change", r)
    }
  }, [t]), g.useCallback(() => {
    var n;
    (n = e.current) == null || n.click()
  }, [e])
}

function Aie() {
  const t = Y(),
    e = g.useRef(null),
    n = g.useRef(null);
  return g.useCallback(async function() {
    const o = document.createElement("div"),
      s = document.createElement("style"),
      i = (w, v) => {
        w && (w.innerHTML = ""), v && document.head.contains(v) && document.head.removeChild(v), w && document.body.contains(w) && document.body.removeChild(w)
      };
    i(e.current, n.current), e.current = o, n.current = s;
    const a = `tl-print-surface-${It()}`;
    o.className = a, s.innerHTML = `
			.${a} {
				display: none;
			}

			.${a} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${a} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${a}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${a}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${a}__item__header {
					display: none;
				}

				.${a}__item__footer {
					display: none;
					text-align: right;
				}

				.${a}__item__footer__hide {
					display: none;
				}

				
			}

		`;
    const c = () => {
        document.head.appendChild(s), document.body.appendChild(o)
      },
      l = () => {
        t.once("change-history", () => {
          i(o, s)
        })
      };
    window.addEventListener("beforeprint", c), window.addEventListener("afterprint", l);

    function u(w, v, _) {
      try {
        o.innerHTML += `<div class="${a}__item">
        <div class="${a}__item__header">
          ${w.replace(/</g,"&lt;").replace(/>/g,"&gt;")}
        </div>
        <div class="${a}__item__main">
          ${_.outerHTML}
        </div>
        <div class="${a}__item__footer ${a}__item__footer__${v?"":"hide"}">
          ${v??""}
        </div>
      </div>`
      } catch (S) {
        console.error(S)
      }
    }

    function d() {
      t.environment.isChromeForIos ? (c(), window.print()) : t.environment.isSafari ? (c(), document.execCommand("print", !1)) : window.print()
    }
    const f = t.getSelectedShapeIds(),
      {
        pages: h,
        currentPageId: m
      } = t,
      b = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
    if (t.getSelectedShapeIds().length > 0) {
      const w = await t.getSvg(f, b);
      if (w) {
        const v = h.find(_ => _.id === m);
        u(`tldraw  ${v==null?void 0:v.name}`, null, w), d()
      }
    } else {
      const w = t.currentPage,
        v = await t.getSvg(t.getSortedChildIdsForParent(w.id), b);
      v && (u(`tldraw  ${w.name}`, null, v), d())
    }
    window.removeEventListener("beforeprint", c), window.removeEventListener("afterprint", l)
  }, [t])
}
const sD = g.createContext({});

function Mie(t) {
  return Object.fromEntries(t.map(e => [e.id, e]))
}

function jie({
  overrides: t,
  children: e
}) {
  const n = Y(),
    {
      addDialog: r,
      clearDialogs: o
    } = gc(),
    {
      clearToasts: s
    } = bs(),
    i = oD(),
    a = Aie(),
    {
      cut: c,
      copy: l,
      paste: u
    } = xie(),
    d = Pie(),
    f = Oie(),
    h = $u(),
    m = g.useMemo(() => {
      function p() {
        return n.isIn("select") || (n.complete(), n.setCurrentTool("select")), !1
      }

      function b() {
        return n.getSelectedShapeIds().length > 0
      }
      const w = Mie([{
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("edit-link", {
            source: v
          }), n.mark("edit-link"), r({
            component: rie
          })))
        }
      }, {
        id: "insert-embed",
        label: "action.insert-embed",
        readonlyOk: !1,
        kbd: "$i",
        onSelect(v) {
          h("insert-embed", {
            source: v
          }), r({
            component: Kj
          })
        }
      }, {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "$u",
        readonlyOk: !1,
        onSelect(v) {
          h("insert-media", {
            source: v
          }), i()
        }
      }, {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "$z",
        readonlyOk: !1,
        onSelect(v) {
          h("undo", {
            source: v
          }), n.undo()
        }
      }, {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "$!z",
        readonlyOk: !1,
        onSelect(v) {
          h("redo", {
            source: v
          }), n.redo()
        }
      }, {
        id: "export-as-svg",
        label: "action.export-as-svg",
        menuLabel: "action.export-as-svg.short",
        contextMenuLabel: "action.export-as-svg.short",
        readonlyOk: !0,
        onSelect(v) {
          h("export-as", {
            format: "svg",
            source: v
          }), f(n.getSelectedShapeIds(), "svg")
        }
      }, {
        id: "export-as-png",
        label: "action.export-as-png",
        menuLabel: "action.export-as-png.short",
        contextMenuLabel: "action.export-as-png.short",
        readonlyOk: !0,
        onSelect(v) {
          h("export-as", {
            format: "png",
            source: v
          }), f(n.getSelectedShapeIds(), "png")
        }
      }, {
        id: "export-as-json",
        label: "action.export-as-json",
        menuLabel: "action.export-as-json.short",
        contextMenuLabel: "action.export-as-json.short",
        readonlyOk: !0,
        onSelect(v) {
          h("export-as", {
            format: "json",
            source: v
          }), f(n.getSelectedShapeIds(), "json")
        }
      }, {
        id: "copy-as-svg",
        label: "action.copy-as-svg",
        menuLabel: "action.copy-as-svg.short",
        contextMenuLabel: "action.copy-as-svg.short",
        kbd: "$!c",
        readonlyOk: !0,
        onSelect(v) {
          h("copy-as", {
            format: "svg",
            source: v
          }), d(n.getSelectedShapeIds(), "svg")
        }
      }, {
        id: "copy-as-png",
        label: "action.copy-as-png",
        menuLabel: "action.copy-as-png.short",
        contextMenuLabel: "action.copy-as-png.short",
        readonlyOk: !0,
        onSelect(v) {
          h("copy-as", {
            format: "png",
            source: v
          }), d(n.getSelectedShapeIds(), "png")
        }
      }, {
        id: "copy-as-json",
        label: "action.copy-as-json",
        menuLabel: "action.copy-as-json.short",
        contextMenuLabel: "action.copy-as-json.short",
        readonlyOk: !0,
        onSelect(v) {
          h("copy-as", {
            format: "json",
            source: v
          }), d(n.getSelectedShapeIds(), "json")
        }
      }, {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("toggle-auto-size", {
            source: v
          }), n.mark("toggling auto size"), n.updateShapes(n.getSelectedShapes().filter(_ => n.isShapeOfType(_, "text") && _.props.autoSize === !1).map(_ => ({
            id: _.id,
            type: _.type,
            props: {
              ..._.props,
              w: 8,
              autoSize: !0
            }
          })))))
        }
      }, {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect(v) {
          h("open-embed-link", {
            source: v
          });
          const _ = n.getSelectedShapeIds(),
            S = "No embed shapes selected";
          if (_.length !== 1) {
            console.error(S);
            return
          }
          const x = n.getShape(_[0]);
          if (!x || !n.isShapeOfType(x, "embed")) {
            console.error(S);
            return
          }
          oX(x.props.url, "_blank")
        }
      }, {
        id: "select-zoom-tool",
        readonlyOk: !0,
        kbd: "z",
        onSelect(v) {
          var _, S;
          if (((_ = n.root.current.get()) == null ? void 0 : _.id) !== "zoom" && (h("zoom-tool", {
              source: v
            }), !(n.inputs.shiftKey || n.inputs.ctrlKey))) {
            const x = n.root.current.get();
            x && ((S = x.current.get()) == null ? void 0 : S.id) === "idle" && n.setCurrentTool("zoom", {
              onInteractionEnd: x.id,
              maskAs: "zoom"
            })
          }
        }
      }, {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || n.batch(() => {
            h("convert-to-bookmark", {
              source: v
            });
            const _ = n.getSelectedShapes(),
              S = [],
              x = [];
            for (const E of _) {
              if (!E || !n.isShapeOfType(E, "embed") || !E.props.url) continue;
              const k = new T(E.x, E.y);
              k.rot(-E.rotation), k.add(new T(E.props.w / 2 - 300 / 2, E.props.h / 2 - 320 / 2)), k.rot(E.rotation);
              const C = {
                id: is(),
                type: "bookmark",
                rotation: E.rotation,
                x: k.x,
                y: k.y,
                opacity: 1,
                props: {
                  url: E.props.url
                }
              };
              S.push(C), x.push(E.id)
            }
            n.mark("convert shapes to bookmark"), n.deleteShapes(x), n.createShapes(S)
          }))
        }
      }, {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("convert-to-embed", {
            source: v
          }), n.batch(() => {
            const _ = n.getSelectedShapeIds(),
              S = Fe(_.map(k => n.getShape(k))),
              x = [],
              E = [];
            for (const k of S) {
              if (!n.isShapeOfType(k, "bookmark")) continue;
              const {
                url: C
              } = k.props, $ = Q1(k.props.url);
              if (!$ || !$.definition) continue;
              const {
                width: I,
                height: R
              } = $.definition, M = new T(k.x, k.y);
              M.rot(-k.rotation), M.add(new T(k.props.w / 2 - I / 2, k.props.h / 2 - R / 2)), M.rot(k.rotation);
              const j = {
                id: is(),
                type: "embed",
                x: M.x,
                y: M.y,
                rotation: k.rotation,
                props: {
                  url: C,
                  w: I,
                  h: R
                }
              };
              x.push(j), E.push(k.id)
            }
            n.mark("convert shapes to embed"), n.deleteShapes(E), n.createShapes(x)
          })))
        }
      }, {
        id: "duplicate",
        kbd: "$d",
        label: "action.duplicate",
        icon: "duplicate",
        readonlyOk: !1,
        onSelect(v) {
          if (!b() || p()) return;
          h("duplicate-shapes", {
            source: v
          });
          const _ = n.getSelectedShapeIds(),
            S = Be.Common(Fe(_.map(E => n.getShapePageBounds(E)))),
            x = n.getInstanceState().canMoveCamera ? {
              x: S.width + 10,
              y: 0
            } : {
              x: 16 / n.zoomLevel,
              y: 16 / n.zoomLevel
            };
          n.mark("duplicate shapes"), n.duplicateShapes(_, x)
        }
      }, {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "$!g",
        icon: "ungroup",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("ungroup-shapes", {
            source: v
          }), n.mark("ungroup"), n.ungroupShapes(n.getSelectedShapeIds())))
        }
      }, {
        id: "group",
        label: "action.group",
        kbd: "$g",
        icon: "group",
        readonlyOk: !1,
        onSelect(v) {
          if (!b() || p()) return;
          h("group-shapes", {
            source: v
          });
          const _ = n.getOnlySelectedShape();
          _ && n.isShapeOfType(_, "group") ? (n.mark("ungroup"), n.ungroupShapes(n.getSelectedShapeIds())) : (n.mark("group"), n.groupShapes(n.getSelectedShapeIds()))
        }
      }, {
        id: "align-left",
        label: "action.align-left",
        kbd: "?A",
        icon: "align-left",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "left",
            source: v
          }), n.mark("align left"), n.alignShapes(n.getSelectedShapeIds(), "left")))
        }
      }, {
        id: "align-center-horizontal",
        label: "action.align-center-horizontal",
        contextMenuLabel: "action.align-center-horizontal.short",
        kbd: "?H",
        icon: "align-center-horizontal",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "center-horizontal",
            source: v
          }), n.mark("align center horizontal"), n.alignShapes(n.getSelectedShapeIds(), "center-horizontal")))
        }
      }, {
        id: "align-right",
        label: "action.align-right",
        kbd: "?D",
        icon: "align-right",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "right",
            source: v
          }), n.mark("align right"), n.alignShapes(n.getSelectedShapeIds(), "right")))
        }
      }, {
        id: "align-center-vertical",
        label: "action.align-center-vertical",
        contextMenuLabel: "action.align-center-vertical.short",
        kbd: "?V",
        icon: "align-center-vertical",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "center-vertical",
            source: v
          }), n.mark("align center vertical"), n.alignShapes(n.getSelectedShapeIds(), "center-vertical")))
        }
      }, {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "?W",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "top",
            source: v
          }), n.mark("align top"), n.alignShapes(n.getSelectedShapeIds(), "top")))
        }
      }, {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "?S",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("align-shapes", {
            operation: "bottom",
            source: v
          }), n.mark("align bottom"), n.alignShapes(n.getSelectedShapeIds(), "bottom")))
        }
      }, {
        id: "distribute-horizontal",
        label: "action.distribute-horizontal",
        contextMenuLabel: "action.distribute-horizontal.short",
        icon: "distribute-horizontal",
        kbd: "?!h",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("distribute-shapes", {
            operation: "horizontal",
            source: v
          }), n.mark("distribute horizontal"), n.distributeShapes(n.getSelectedShapeIds(), "horizontal")))
        }
      }, {
        id: "distribute-vertical",
        label: "action.distribute-vertical",
        contextMenuLabel: "action.distribute-vertical.short",
        icon: "distribute-vertical",
        kbd: "?!V",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("distribute-shapes", {
            operation: "vertical",
            source: v
          }), n.mark("distribute vertical"), n.distributeShapes(n.getSelectedShapeIds(), "vertical")))
        }
      }, {
        id: "stretch-horizontal",
        label: "action.stretch-horizontal",
        contextMenuLabel: "action.stretch-horizontal.short",
        icon: "stretch-horizontal",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("stretch-shapes", {
            operation: "horizontal",
            source: v
          }), n.mark("stretch horizontal"), n.stretchShapes(n.getSelectedShapeIds(), "horizontal")))
        }
      }, {
        id: "stretch-vertical",
        label: "action.stretch-vertical",
        contextMenuLabel: "action.stretch-vertical.short",
        icon: "stretch-vertical",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("stretch-shapes", {
            operation: "vertical",
            source: v
          }), n.mark("stretch vertical"), n.stretchShapes(n.getSelectedShapeIds(), "vertical")))
        }
      }, {
        id: "flip-horizontal",
        label: "action.flip-horizontal",
        contextMenuLabel: "action.flip-horizontal.short",
        kbd: "!h",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("flip-shapes", {
            operation: "horizontal",
            source: v
          }), n.mark("flip horizontal"), n.flipShapes(n.getSelectedShapeIds(), "horizontal")))
        }
      }, {
        id: "flip-vertical",
        label: "action.flip-vertical",
        contextMenuLabel: "action.flip-vertical.short",
        kbd: "!v",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("flip-shapes", {
            operation: "vertical",
            source: v
          }), n.mark("flip vertical"), n.flipShapes(n.getSelectedShapeIds(), "vertical")))
        }
      }, {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("pack-shapes", {
            source: v
          }), n.mark("pack"), n.packShapes(n.getSelectedShapeIds(), 16)))
        }
      }, {
        id: "stack-vertical",
        label: "action.stack-vertical",
        contextMenuLabel: "action.stack-vertical.short",
        icon: "stack-vertical",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("stack-shapes", {
            operation: "vertical",
            source: v
          }), n.mark("stack-vertical"), n.stackShapes(n.getSelectedShapeIds(), "vertical", 16)))
        }
      }, {
        id: "stack-horizontal",
        label: "action.stack-horizontal",
        contextMenuLabel: "action.stack-horizontal.short",
        icon: "stack-horizontal",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("stack-shapes", {
            operation: "horizontal",
            source: v
          }), n.mark("stack-horizontal"), n.stackShapes(n.getSelectedShapeIds(), "horizontal", 16)))
        }
      }, {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("reorder-shapes", {
            operation: "toFront",
            source: v
          }), n.mark("bring to front"), n.bringToFront(n.getSelectedShapeIds())))
        }
      }, {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "?]",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("reorder-shapes", {
            operation: "forward",
            source: v
          }), n.mark("bring forward"), n.bringForward(n.getSelectedShapeIds())))
        }
      }, {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "?[",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("reorder-shapes", {
            operation: "backward",
            source: v
          }), n.mark("send backward"), n.sendBackward(n.getSelectedShapeIds())))
        }
      }, {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("reorder-shapes", {
            operation: "toBack",
            source: v
          }), n.mark("send to back"), n.sendToBack(n.getSelectedShapeIds())))
        }
      }, {
        id: "cut",
        label: "action.cut",
        kbd: "$x",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (n.mark("cut"), c(v)))
        }
      }, {
        id: "copy",
        label: "action.copy",
        kbd: "$c",
        readonlyOk: !0,
        onSelect(v) {
          b() && (p() || l(v))
        }
      }, {
        id: "paste",
        label: "action.paste",
        kbd: "$v",
        readonlyOk: !1,
        onSelect(v) {
          var _;
          (_ = navigator.clipboard) == null || _.read().then(S => {
            u(S, v, v === "context-menu" ? n.inputs.currentPagePoint : void 0)
          })
        }
      }, {
        id: "select-all",
        label: "action.select-all",
        kbd: "$a",
        readonlyOk: !0,
        onSelect(v) {
          n.batch(() => {
            p() || (h("select-all-shapes", {
              source: v
            }), n.mark("select all kbd"), n.selectAll())
          })
        }
      }, {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect(v) {
          b() && (p() || (h("select-none-shapes", {
            source: v
          }), n.mark("select none"), n.selectNone()))
        }
      }, {
        id: "delete",
        label: "action.delete",
        kbd: ",del,backspace",
        icon: "trash",
        readonlyOk: !1,
        onSelect(v) {
          b() && (p() || (h("delete-shapes", {
            source: v
          }), n.mark("delete"), n.deleteShapes(n.getSelectedShapeIds())))
        }
      }, {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        readonlyOk: !1,
        onSelect(v) {
          if (!b() || p()) return;
          h("rotate-cw", {
            source: v
          }), n.mark("rotate-cw");
          const _ = n.getSelectionRotation() % (hr / 2),
            S = Gd(_, 0) || Gd(_, hr / 2);
          n.rotateShapesBy(n.getSelectedShapeIds(), hr / 2 - (S ? 0 : _))
        }
      }, {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        readonlyOk: !1,
        onSelect(v) {
          if (!b() || p()) return;
          h("rotate-ccw", {
            source: v
          }), n.mark("rotate-ccw");
          const _ = n.getSelectionRotation() % (hr / 2),
            S = Gd(_, 0);
          n.rotateShapesBy(n.getSelectedShapeIds(), S ? -(hr / 2) : -_)
        }
      }, {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "$=,=",
        readonlyOk: !0,
        onSelect(v) {
          h("zoom-in", {
            source: v
          }), n.zoomIn(n.viewportScreenCenter, {
            duration: Os
          })
        }
      }, {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "$-,-",
        readonlyOk: !0,
        onSelect(v) {
          h("zoom-out", {
            source: v
          }), n.zoomOut(n.viewportScreenCenter, {
            duration: Os
          })
        }
      }, {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "!0",
        readonlyOk: !0,
        onSelect(v) {
          h("reset-zoom", {
            source: v
          }), n.resetZoom(n.viewportScreenCenter, {
            duration: Os
          })
        }
      }, {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "!1",
        readonlyOk: !0,
        onSelect(v) {
          h("zoom-to-fit", {
            source: v
          }), n.zoomToFit({
            duration: Os
          })
        }
      }, {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "!2",
        readonlyOk: !0,
        onSelect(v) {
          b() && (p() || (h("zoom-to-selection", {
            source: v
          }), n.zoomToSelection({
            duration: Os
          })))
        }
      }, {
        id: "toggle-snap-mode",
        label: "action.toggle-snap-mode",
        menuLabel: "action.toggle-snap-mode.menu",
        readonlyOk: !1,
        onSelect(v) {
          h("toggle-snap-mode", {
            source: v
          }), n.user.updateUserPreferences({
            isSnapMode: !n.user.isSnapMode
          })
        },
        checkbox: !0
      }, {
        id: "toggle-dark-mode",
        label: "action.toggle-dark-mode",
        menuLabel: "action.toggle-dark-mode.menu",
        kbd: "$/",
        readonlyOk: !0,
        onSelect(v) {
          h("toggle-dark-mode", {
            source: v
          }), n.user.updateUserPreferences({
            isDarkMode: !n.user.isDarkMode
          })
        },
        checkbox: !0
      }, {
        id: "toggle-reduce-motion",
        label: "action.toggle-reduce-motion",
        menuLabel: "action.toggle-reduce-motion.menu",
        readonlyOk: !0,
        onSelect(v) {
          h("toggle-reduce-motion", {
            source: v
          }), n.user.updateUserPreferences({
            animationSpeed: n.user.animationSpeed === 0 ? 1 : 0
          })
        },
        checkbox: !0
      }, {
        id: "toggle-transparent",
        label: "action.toggle-transparent",
        menuLabel: "action.toggle-transparent.menu",
        contextMenuLabel: "action.toggle-transparent.context-menu",
        readonlyOk: !0,
        onSelect(v) {
          h("toggle-transparent", {
            source: v
          }), n.updateInstanceState({
            exportBackground: !n.getInstanceState().exportBackground
          }, {
            ephemeral: !0
          })
        },
        checkbox: !0
      }, {
        id: "toggle-tool-lock",
        label: "action.toggle-tool-lock",
        menuLabel: "action.toggle-tool-lock.menu",
        readonlyOk: !1,
        kbd: "q",
        onSelect(v) {
          h("toggle-tool-lock", {
            source: v
          }), n.updateInstanceState({
            isToolLocked: !n.getInstanceState().isToolLocked
          })
        },
        checkbox: !0
      }, {
        id: "unlock-all",
        label: "action.unlock-all",
        readonlyOk: !1,
        onSelect(v) {
          h("unlock-all", {
            source: v
          });
          const _ = [];
          for (const S of n.currentPageShapes) S.isLocked && _.push({
            id: S.id,
            type: S.type,
            isLocked: !1
          });
          _.length > 0 && n.updateShapes(_)
        }
      }, {
        id: "toggle-focus-mode",
        label: "action.toggle-focus-mode",
        menuLabel: "action.toggle-focus-mode.menu",
        readonlyOk: !0,
        kbd: "$.",
        checkbox: !0,
        onSelect(v) {
          requestAnimationFrame(() => {
            n.batch(() => {
              h("toggle-focus-mode", {
                source: v
              }), o(), s(), n.updateInstanceState({
                isFocusMode: !n.getInstanceState().isFocusMode
              })
            })
          })
        }
      }, {
        id: "toggle-grid",
        label: "action.toggle-grid",
        menuLabel: "action.toggle-grid.menu",
        readonlyOk: !0,
        kbd: "$'",
        onSelect(v) {
          h("toggle-grid-mode", {
            source: v
          }), n.updateInstanceState({
            isGridMode: !n.getInstanceState().isGridMode
          })
        },
        checkbox: !0
      }, {
        id: "toggle-debug-mode",
        label: "action.toggle-debug-mode",
        menuLabel: "action.toggle-debug-mode.menu",
        readonlyOk: !0,
        onSelect(v) {
          h("toggle-debug-mode", {
            source: v
          }), n.updateInstanceState({
            isDebugMode: !n.getInstanceState().isDebugMode
          })
        },
        checkbox: !0
      }, {
        id: "print",
        label: "action.print",
        kbd: "$p",
        readonlyOk: !0,
        onSelect(v) {
          h("print", {
            source: v
          }), a()
        }
      }, {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(v) {
          h("exit-pen-mode", {
            source: v
          }), n.updateInstanceState({
            isPenMode: !1
          })
        }
      }, {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(v) {
          h("stop-following", {
            source: v
          }), n.stopFollowingUser()
        }
      }, {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect(v) {
          h("zoom-to-content", {
            source: v
          }), n.zoomToContent()
        }
      }, {
        id: "toggle-lock",
        label: "action.toggle-lock",
        readonlyOk: !1,
        kbd: "!l",
        onSelect(v) {
          n.mark("locking"), h("toggle-lock", {
            source: v
          }), n.toggleLock(n.getSelectedShapeIds())
        }
      }]);
      return t ? t(n, w, void 0) : w
    }, [h, t, n, r, i, f, d, c, l, u, o, s, a]);
  return y.jsx(sD.Provider, {
    value: m,
    children: e
  })
}

function Xn() {
  const t = g.useContext(sD);
  if (!t) throw new Error("useTools must be used within a ToolProvider");
  return t
}

function Cv(t) {
  return t.filter(e => e != null && e !== !1)
}

function Ye(t, ...e) {
  const n = Cv(e);
  return n.length === 0 ? null : {
    id: t,
    type: "group",
    checkbox: n.every(r => r.type === "item" && r.actionItem.checkbox),
    disabled: n.every(r => r.disabled),
    readonlyOk: n.some(r => r.readonlyOk),
    children: n
  }
}

function ns(t, e, ...n) {
  const r = Cv(n);
  return r.length === 0 ? null : {
    id: t,
    type: "submenu",
    label: e,
    children: r,
    disabled: r.every(o => o.disabled),
    readonlyOk: r.some(o => o.readonlyOk)
  }
}

function dE(t, e = {}) {
  const {
    readonlyOk: n = !0,
    disabled: r = !1
  } = e;
  return {
    id: t,
    type: "custom",
    disabled: r,
    readonlyOk: n
  }
}

function H(t, e = {}) {
  if (!t) throw Error("No action item provided to menuItem");
  if (!t.label) throw Error("Trying to create menu item for action item that doesn't have a label");
  const {
    checked: n = !1,
    disabled: r = !1
  } = e;
  return {
    id: t.id,
    type: "item",
    actionItem: t,
    disabled: r,
    checked: n,
    readonlyOk: t.readonlyOk
  }
}

function Die(t) {
  return t.getSelectedShapeIds().map(r => t.getShape(r)).filter(r => !(!r || t.isShapeOfType(r, "arrow") && r.props.start.type === "binding" || t.isShapeOfType(r, "arrow") && r.props.end.type === "binding"))
}
const iD = () => {
  const t = Y();
  return te("threeStackableItems", () => Die(t).length > 2, [t])
};

function Nie(t) {
  const e = t.getSelectedShapes(),
    n = [],
    r = new Map;
  e.forEach(s => {
    s.type === "arrow" ? n.push(s) : r.set(s.id, s)
  });
  const o = n.filter(s => !(s.props.start.type === "binding" && !r.has(s.props.start.boundShapeId) || s.props.end.type === "binding" && !r.has(s.props.end.boundShapeId)));
  return Array.from(r.values()).concat(o)
}
const fE = () => {
    const t = Y();
    return te("allowGroup", () => Nie(t).length > 1, [t])
  },
  hE = () => {
    const t = Y();
    return te("allowUngroup", () => t.getSelectedShapeIds().some(e => {
      var n;
      return ((n = t.getShape(e)) == null ? void 0 : n.type) === "group"
    }), [t])
  };

function Ibe(t, e) {
  const n = aD(t, e);
  return Xa(n, `Menu item ${e.join(" > ")} not found`), n
}

function aD(t, e) {
  const [n, ...r] = e;
  if (!n) return null;
  const o = t.find(s => s.id === n);
  if (!o) return null;
  switch (o.type) {
    case "group":
    case "submenu":
      return r.length === 0 ? o : aD(o.children, r);
    case "item":
    case "custom":
      return r.length === 0 ? o : null;
    default:
      bu(o, "type")
  }
}
const cD = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read,
  Ub = [0, 390, 428, 468, 580, 640, 840, 1023],
  lD = se.createContext(0);

function Lie({
  forceMobile: t = !1,
  children: e
}) {
  const n = Y(),
    r = te("breakpoint", () => {
      const {
        width: o
      } = n.viewportScreenBounds, s = t ? 3 : Ub.length - 1;
      for (let i = 0; i < s; i++)
        if (o > Ub[i] && o <= Ub[i + 1]) return i;
      return s
    }, [n]);
  return y.jsx(lD.Provider, {
    value: r,
    children: e
  })
}

function uo() {
  return g.useContext(lD)
}

function pE() {
  const t = Y();
  return te("hasLinkShapeSelected", () => {
    const e = t.getSelectedShapes();
    return e.length === 1 && "url" in e[0].props && e[0].type !== "embed"
  }, [t])
}
const uD = se.createContext({}),
  Fie = ({
    overrides: t,
    children: e
  }) => {
    const n = Y(),
      r = Xn(),
      o = te("selected count", () => n.getSelectedShapeIds().length, [n]),
      s = o > 0,
      i = o > 1,
      a = o > 2,
      c = iD(),
      l = fE(),
      u = hE(),
      d = pE(),
      f = uo(),
      h = te("zoom is 1", () => n.zoomLevel === 1, [n]),
      m = g.useMemo(() => {
        const p = [H(r["align-left"], {
          disabled: !i
        }), H(r["align-center-horizontal"], {
          disabled: !i
        }), H(r["align-right"], {
          disabled: !i
        }), H(r["stretch-horizontal"], {
          disabled: !i
        }), H(r["align-top"], {
          disabled: !i
        }), H(r["align-center-vertical"], {
          disabled: !i
        }), H(r["align-bottom"], {
          disabled: !i
        }), H(r["stretch-vertical"], {
          disabled: !i
        }), H(r["distribute-horizontal"], {
          disabled: !a
        }), H(r["distribute-vertical"], {
          disabled: !a
        }), H(r["stack-horizontal"], {
          disabled: !c
        }), H(r["stack-vertical"], {
          disabled: !c
        }), H(r["send-to-back"], {
          disabled: !s
        }), H(r["send-backward"], {
          disabled: !s
        }), H(r["bring-forward"], {
          disabled: !s
        }), H(r["bring-to-front"], {
          disabled: !s
        }), f < 5 ? H(r["zoom-to-100"], {
          disabled: !!h
        }) : H(r["rotate-ccw"], {
          disabled: !s
        }), H(r["rotate-cw"], {
          disabled: !s
        }), H(r["edit-link"], {
          disabled: !d
        }), l ? H(r.group, {
          disabled: !i
        }) : u ? H(r.ungroup) : H(r.group, {
          disabled: !i
        })];
        return t ? t(n, p, {
          actions: r,
          oneSelected: s,
          twoSelected: i,
          threeSelected: a
        }) : p
      }, [n, h, l, t, r, s, i, a, c, u, d, f]);
    return y.jsx(uD.Provider, {
      value: m,
      children: e
    })
  };

function Bie() {
  const t = se.useContext(uD);
  if (!t) throw new Error("useActionsMenuSchema must be used inside of a ActionsMenuSchemaProvider.");
  return t
}

function Uie() {
  const t = Y();
  return te("onlyFlippableShape", () => {
    const e = t.getSelectedShapes();
    return e.length === 1 && e.every(n => t.isShapeOfType(n, "group") || t.isShapeOfType(n, "arrow") || t.isShapeOfType(n, "line") || t.isShapeOfType(n, "draw"))
  }, [t])
}

function dD() {
  const t = Y();
  return te("showAutoSizeToggle", () => {
    const e = t.getSelectedShapes();
    return e.length === 1 && t.isShapeOfType(e[0], "text") && e[0].props.autoSize === !1
  }, [t])
}
const fD = se.createContext({}),
  zie = pt(function({
    overrides: e,
    children: n
  }) {
    var x;
    const r = Y(),
      o = Xn(),
      s = dD(),
      i = Uie(),
      a = r.getSelectedShapeIds().length,
      c = a > 0,
      l = a > 1,
      u = a > 2,
      d = iD(),
      f = te("atLeastOneShapeOnPage", () => r.currentPageShapeIds.size > 0, []),
      h = te("isTransparentBg", () => r.getInstanceState().exportBackground, []),
      m = fE(),
      p = hE(),
      b = !!((x = window.navigator.clipboard) != null && x.write),
      w = pE(),
      v = r.getOnlySelectedShape(),
      _ = v && r.isShapeOrAncestorLocked(v),
      S = g.useMemo(() => {
        let E = Cv([Ye("selection", s && H(o["toggle-auto-size"]), w && !_ && H(o["edit-link"]), c && !_ && H(o.duplicate), m && !_ && H(o.group), p && !_ && H(o.ungroup), c && H(o["toggle-lock"])), Ye("modify", (l || i) && ns("arrange", "context-menu.arrange", l && Ye("align", H(o["align-left"]), H(o["align-center-horizontal"]), H(o["align-right"]), H(o["align-top"]), H(o["align-center-vertical"]), H(o["align-bottom"])), u && Ye("distribute", H(o["distribute-horizontal"]), H(o["distribute-vertical"])), l && Ye("stretch", H(o["stretch-horizontal"]), H(o["stretch-vertical"])), i && !_ && Ye("flip", H(o["flip-horizontal"]), H(o["flip-vertical"])), l && Ye("order", H(o.pack, {
          disabled: !l
        }), d && H(o["stack-vertical"]), d && H(o["stack-horizontal"]))), c && !_ && ns("reorder", "context-menu.reorder", Ye("reorder", H(o["bring-to-front"]), H(o["bring-forward"]), H(o["send-backward"]), H(o["send-to-back"]))), c && !_ && dE("MOVE_TO_PAGE_MENU", {
          readonlyOk: !1
        })), Ye("clipboard-group", c && !_ && H(o.cut), c && H(o.copy), cD && H(o.paste)), f && Ye("conversions", ns("copy-as", "context-menu.copy-as", Ye("copy-as-group", H(o["copy-as-svg"]), b && H(o["copy-as-png"]), H(o["copy-as-json"])), Ye("export-bg", H(o["toggle-transparent"], {
          checked: !h
        }))), ns("export-as", "context-menu.export-as", Ye("export-as-group", H(o["export-as-svg"]), H(o["export-as-png"]), H(o["export-as-json"])), Ye("export-bg,", H(o["toggle-transparent"], {
          checked: !h
        })))), f && Ye("set-selection-group", H(o["select-all"]), c && H(o["select-none"])), c && !_ && Ye("delete-group", H(o.delete))]);
        return e && (E = e(r, E, {
          actions: o,
          oneSelected: c,
          twoSelected: l,
          threeSelected: u,
          showAutoSizeToggle: s,
          showUngroup: p,
          onlyFlippableShapeSelected: i
        })), E
      }, [r, e, o, c, l, u, s, i, f, d, m, p, b, w, h, _]);
    return y.jsx(fD.Provider, {
      value: S,
      children: n
    })
  });

function hD() {
  const t = se.useContext(fD);
  if (!t) throw new Error("useContextMenuSchema must be used inside of a TLUiContextMenuSchemaProvider.");
  return t
}
const pD = g.createContext({});

function Hie({
  overrides: t,
  children: e
}) {
  const n = Y(),
    r = $u(),
    {
      addDialog: o
    } = gc(),
    s = oD(),
    i = g.useMemo(() => {
      const a = [{
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect(l) {
          n.setCurrentTool("select"), r("select-tool", {
            source: l,
            id: "select"
          })
        }
      }, {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect(l) {
          n.setCurrentTool("hand"), r("select-tool", {
            source: l,
            id: "hand"
          })
        }
      }, {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        readonlyOk: !1,
        onSelect(l) {
          n.setCurrentTool("eraser"), r("select-tool", {
            source: l,
            id: "eraser"
          })
        }
      }, {
        id: "draw",
        label: "tool.draw",
        readonlyOk: !1,
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(l) {
          n.setCurrentTool("draw"), r("select-tool", {
            source: l,
            id: "draw"
          })
        }
      }, ...[...ec.values].map(l => ({
        id: l,
        label: `tool.${l}`,
        readonlyOk: !1,
        meta: {
          geo: l
        },
        kbd: l === "rectangle" ? "r" : l === "ellipse" ? "o" : void 0,
        icon: "geo-" + l,
        onSelect(u) {
          n.batch(() => {
            n.updateInstanceState({
              stylesForNextShape: {
                ...n.getInstanceState().stylesForNextShape,
                [ec.id]: l
              }
            }, {
              ephemeral: !0
            }), n.setCurrentTool("geo"), r("select-tool", {
              source: u,
              id: `geo-${l}`
            })
          })
        }
      })), {
        id: "arrow",
        label: "tool.arrow",
        readonlyOk: !1,
        icon: "tool-arrow",
        kbd: "a",
        onSelect(l) {
          n.setCurrentTool("arrow"), r("select-tool", {
            source: l,
            id: "arrow"
          })
        }
      }, {
        id: "line",
        label: "tool.line",
        readonlyOk: !1,
        icon: "tool-line",
        kbd: "l",
        onSelect(l) {
          n.setCurrentTool("line"), r("select-tool", {
            source: l,
            id: "line"
          })
        }
      }, {
        id: "frame",
        label: "tool.frame",
        readonlyOk: !1,
        icon: "tool-frame",
        kbd: "f",
        onSelect(l) {
          n.setCurrentTool("frame"), r("select-tool", {
            source: l,
            id: "frame"
          })
        }
      }, {
        id: "text",
        label: "tool.text",
        readonlyOk: !1,
        icon: "tool-text",
        kbd: "t",
        onSelect(l) {
          n.setCurrentTool("text"), r("select-tool", {
            source: l,
            id: "text"
          })
        }
      }, {
        id: "asset",
        label: "tool.asset",
        readonlyOk: !1,
        icon: "tool-media",
        kbd: "$u",
        onSelect(l) {
          s(), r("select-tool", {
            source: l,
            id: "media"
          })
        }
      }, {
        id: "note",
        label: "tool.note",
        readonlyOk: !1,
        icon: "tool-note",
        kbd: "n",
        onSelect(l) {
          n.setCurrentTool("note"), r("select-tool", {
            source: l,
            id: "note"
          })
        }
      }, {
        id: "laser",
        label: "tool.laser",
        readonlyOk: !0,
        icon: "tool-laser",
        kbd: "k",
        onSelect(l) {
          n.setCurrentTool("laser"), r("select-tool", {
            source: l,
            id: "laser"
          })
        }
      }, {
        id: "embed",
        label: "tool.embed",
        readonlyOk: !1,
        icon: "tool-embed",
        onSelect(l) {
          o({
            component: Kj
          }), r("select-tool", {
            source: l,
            id: "embed"
          })
        }
      }];
      a.push({
        id: "highlight",
        label: "tool.highlight",
        readonlyOk: !0,
        icon: "tool-highlight",
        kbd: "!d",
        onSelect(l) {
          n.setCurrentTool("highlight"), r("select-tool", {
            source: l,
            id: "highlight"
          })
        }
      });
      const c = Object.fromEntries(a.map(l => [l.id, l]));
      return t ? t(n, c, {
        insertMedia: s
      }) : c
    }, [t, n, r, s, o]);
  return y.jsx(pD.Provider, {
    value: i,
    children: e
  })
}

function gE() {
  const t = g.useContext(pD);
  if (!t) throw new Error("useTools must be used within a ToolProvider");
  return t
}
const gD = se.createContext({}),
  Vie = pt(function({
    overrides: e,
    children: n
  }) {
    const r = Y(),
      o = gE(),
      s = Xn(),
      i = g.useMemo(() => {
        const a = Fe([Ye("shortcuts-dialog.tools", H(s["toggle-tool-lock"]), H(o.select), H(o.draw), H(o.eraser), H(o.hand), H(o.rectangle), H(o.ellipse), H(o.arrow), H(o.line), H(o.text), H(o.frame), H(o.note), H(o.laser)), Ye("shortcuts-dialog.file", H(s["insert-media"]), H(s.print)), Ye("shortcuts-dialog.preferences", H(s["toggle-dark-mode"]), H(s["toggle-focus-mode"]), H(s["toggle-grid"])), Ye("shortcuts-dialog.edit", H(s.undo), H(s.redo), H(s.cut), H(s.copy), H(s.paste), H(s["select-all"]), H(s.delete), H(s.duplicate), H(s["export-as-svg"]), H(s["export-as-png"])), Ye("shortcuts-dialog.view", H(s["zoom-in"]), H(s["zoom-out"]), H(s["zoom-to-100"]), H(s["zoom-to-fit"]), H(s["zoom-to-selection"])), Ye("shortcuts-dialog.transform", H(s["bring-to-front"]), H(s["bring-forward"]), H(s["send-backward"]), H(s["send-to-back"]), H(s.group), H(s.ungroup), H(s["flip-horizontal"]), H(s["flip-vertical"]), H(s["align-top"]), H(s["align-center-vertical"]), H(s["align-bottom"]), H(s["align-left"]), H(s["align-center-horizontal"]), H(s["align-right"]))]);
        return e ? e(r, a, {
          tools: o,
          actions: s
        }) : a
      }, [r, e, s, o]);
    return y.jsx(gD.Provider, {
      value: i,
      children: n
    })
  });

function Wie() {
  const t = se.useContext(gD);
  if (!t) throw new Error("Shortcuts must be used inside of a ShortcutsProvider.");
  return t
}
const Kie = () => {
  const t = nt(),
    e = lo(),
    n = Wie();

  function r(o) {
    if (e && !o.readonlyOk) return null;
    switch (o.type) {
      case "group":
        return y.jsxs("div", {
          className: "tlui-shortcuts-dialog__group",
          children: [y.jsx("h2", {
            className: "tlui-shortcuts-dialog__group__title",
            children: t(o.id)
          }), y.jsx("div", {
            className: "tlui-shortcuts-dialog__group__content",
            children: o.children.filter(s => s.type === "item" && s.actionItem.kbd).map(r)
          })]
        }, o.id);
      case "item": {
        const {
          id: s,
          label: i,
          shortcutsLabel: a,
          kbd: c
        } = o.actionItem;
        return y.jsxs("div", {
          className: "tlui-shortcuts-dialog__key-pair",
          children: [y.jsx("div", {
            className: "tlui-shortcuts-dialog__key-pair__key",
            children: t(a ?? i)
          }), y.jsx("div", {
            className: "tlui-shortcuts-dialog__key-pair__value",
            children: y.jsx(wv, {
              children: c
            })
          })]
        }, s)
      }
    }
  }
  return y.jsxs(y.Fragment, {
    children: [y.jsxs(Ah, {
      className: "tlui-shortcuts-dialog__header",
      children: [y.jsx(Mh, {
        children: t("shortcuts-dialog.title")
      }), y.jsx(jh, {})]
    }), y.jsx(su, {
      className: "tlui-shortcuts-dialog__body",
      children: n.map(r)
    }), y.jsx("div", {
      className: "tlui-dialog__scrim"
    })]
  })
};

function mD() {
  const t = Y();
  return {
    languages: Of,
    currentLanguage: t.user.locale
  }
}
const yD = se.createContext({}),
  Gie = pt(function({
    overrides: e,
    children: n
  }) {
    const r = Y(),
      o = Xn(),
      s = r.getSelectedShapeIds().length,
      i = s > 0,
      a = s > 1,
      c = s > 2,
      {
        languages: l,
        currentLanguage: u
      } = mD(),
      {
        addDialog: d
      } = gc(),
      f = g.useMemo(() => {
        const h = Fe([Ye("top", dE("LANGUAGE_MENU", {
          readonlyOk: !0
        }), H({
          id: "keyboard-shortcuts",
          label: "help-menu.keyboard-shortcuts",
          readonlyOk: !0,
          onSelect() {
            d({
              component: Kie
            })
          }
        }))]);
        return e ? e(r, h, {
          actions: o,
          currentLanguage: u,
          languages: l,
          oneSelected: i,
          twoSelected: a,
          threeSelected: c
        }) : h
      }, [r, e, l, o, i, a, c, u, d]);
    return y.jsx(yD.Provider, {
      value: f,
      children: n
    })
  });

function Yie() {
  const t = se.useContext(yD);
  if (!t) throw new Error("useHelpMenuSchema must be used inside of a helpTLUiMenuSchemaProvider.");
  return t
}

function vD() {
  const t = Y();
  return te("useCanRedo", () => t.getCanRedo(), [t])
}

function bD() {
  const t = Y();
  return te("useCanUndo", () => t.getCanUndo(), [t])
}
const wD = se.createContext({});

function qie({
  overrides: t,
  children: e
}) {
  var D;
  const n = Y(),
    r = Xn(),
    s = uo() < 5,
    i = te("isDarkMode", () => n.user.isDarkMode, [n]),
    a = te("animationSpeed", () => n.user.animationSpeed, [n]),
    c = te("isGridMode", () => n.getInstanceState().isGridMode, [n]),
    l = te("isSnapMode", () => n.user.isSnapMode, [n]),
    u = te("isToolLock", () => n.getInstanceState().isToolLocked, [n]),
    d = te("isFocusMode", () => n.getInstanceState().isFocusMode, [n]),
    f = te("isDebugMode", () => n.getInstanceState().isDebugMode, [n]),
    h = te("exportBackground", () => n.getInstanceState().exportBackground, [n]),
    m = te("emptyPage", () => n.currentPageShapeIds.size === 0, [n]),
    p = te("selectedCount", () => n.getSelectedShapeIds().length, [n]),
    b = p === 0,
    w = p > 0,
    v = p > 1,
    _ = p > 2,
    S = !!((D = window.navigator.clipboard) != null && D.write),
    x = pE(),
    E = dD(),
    k = fE(),
    C = hE(),
    $ = bD(),
    I = vD(),
    R = te("isZoomedTo100", () => n.zoomLevel === 1, [n]),
    M = te("oneEmbedSelected", () => {
      const N = n.getOnlySelectedShape();
      return N ? !!(n.isShapeOfType(N, "embed") && N.props.url && !n.isShapeOrAncestorLocked(N)) : !1
    }, []),
    j = te("oneEmbeddableBookmarkSelected", () => {
      const N = n.getOnlySelectedShape();
      return N ? !!(n.isShapeOfType(N, "bookmark") && N.props.url && Q1(N.props.url) && !n.isShapeOrAncestorLocked(N)) : !1
    }, []),
    A = g.useMemo(() => {
      const N = Cv([Ye("menu", ns("file", "menu.file", Ye("print", H(r.print, {
        disabled: m
      }))), ns("edit", "menu.edit", Ye("undo-actions", H(r.undo, {
        disabled: !$
      }), H(r.redo, {
        disabled: !I
      })), Ye("clipboard-actions", H(r.cut, {
        disabled: b
      }), H(r.copy, {
        disabled: b
      }), H(r.paste, {
        disabled: !cD
      })), Ye("conversions", ns("copy-as", "menu.copy-as", Ye("copy-as-group", H(r["copy-as-svg"], {
        disabled: m
      }), H(r["copy-as-png"], {
        disabled: m || !S
      }), H(r["copy-as-json"], {
        disabled: m
      })), Ye("export-bg", H(r["toggle-transparent"], {
        checked: !h
      }))), ns("export-as", "menu.export-as", Ye("export-as-group", H(r["export-as-svg"], {
        disabled: m
      }), H(r["export-as-png"], {
        disabled: m
      }), H(r["export-as-json"], {
        disabled: m
      })), Ye("export-bg", H(r["toggle-transparent"], {
        checked: !h
      })))), Ye("set-selection-group", H(r["select-all"], {
        disabled: m
      }), H(r["select-none"], {
        disabled: !w
      })), Ye("selection", E && H(r["toggle-auto-size"]), x && H(r["edit-link"]), H(r.duplicate, {
        disabled: !w
      }), k && H(r.group), C && H(r.ungroup), H(r["unlock-all"], {
        disabled: m
      })), Ye("delete-group", H(r.delete, {
        disabled: !w
      })), Ye("embeds", M && H(r["open-embed-link"]), M && H(r["convert-to-bookmark"]), j && H(r["convert-to-embed"]))), ns("view", "menu.view", Ye("view-actions", H(r["zoom-in"]), H(r["zoom-out"]), H(r["zoom-to-100"], {
        disabled: R
      }), H(r["zoom-to-fit"], {
        disabled: m
      }), H(r["zoom-to-selection"], {
        disabled: m || !w
      })))), Ye("extras", H(r["insert-embed"]), H(r["insert-media"])), Ye("preferences", ns("preferences", "menu.preferences", Ye("preferences-actions", H(r["toggle-snap-mode"], {
        checked: l
      }), H(r["toggle-tool-lock"], {
        checked: u
      }), H(r["toggle-grid"], {
        checked: c
      }), H(r["toggle-dark-mode"], {
        checked: i
      }), H(r["toggle-focus-mode"], {
        checked: d
      }), H(r["toggle-reduce-motion"], {
        checked: a === 0
      }), H(r["toggle-debug-mode"], {
        checked: f
      }))), s && dE("LANGUAGE_MENU", {
        readonlyOk: !0
      }))]);
      return t ? t(n, N, {
        actions: r,
        noneSelected: b,
        oneSelected: w,
        twoSelected: v,
        threeSelected: _
      }) : N
    }, [n, t, r, w, v, _, m, s, k, C, x, S, E, b, $, I, a, i, c, l, u, d, h, f, R, j, M]);
  return y.jsx(wD.Provider, {
    value: A,
    children: e
  })
}

function Xie() {
  const t = se.useContext(wD);
  if (!t) throw new Error("useMenuSchema must be used inside of a TLUiMenuSchemaProvider.");
  return t
}

function wt(t) {
  return {
    id: t.id,
    type: "item",
    readonlyOk: t.readonlyOk,
    toolItem: t
  }
}
const SD = se.createContext([]);

function Zie({
  overrides: t,
  children: e
}) {
  const n = Y(),
    r = gE(),
    o = se.useMemo(() => {
      const s = Fe([wt(r.select), wt(r.hand), wt(r.draw), wt(r.eraser), wt(r.arrow), wt(r.text), wt(r.note), wt(r.asset), wt(r.rectangle), wt(r.ellipse), wt(r.diamond), wt(r.triangle), wt(r.trapezoid), wt(r.rhombus), wt(r.hexagon), wt(r.cloud), wt(r.star), wt(r.oval), wt(r["x-box"]), wt(r["check-box"]), wt(r["arrow-left"]), wt(r["arrow-up"]), wt(r["arrow-down"]), wt(r["arrow-right"]), wt(r.frame), wt(r.line), wt(r.highlight), wt(r.laser)]);
      return t ? t(n, s, {
        tools: r
      }) : s
    }, [n, t, r]);
  return y.jsx(SD.Provider, {
    value: o,
    children: e
  })
}

function Jie() {
  const t = se.useContext(SD);
  if (!t) throw new Error("useToolbarSchema must be used within a ToolbarSchemaProvider");
  return t
}

function Qie() {
  const {
    addToast: t,
    removeToast: e,
    clearToasts: n
  } = bs(), {
    addDialog: r,
    clearDialogs: o,
    removeDialog: s,
    updateDialog: i
  } = gc(), c = uo() < 5, l = nt();
  return g.useMemo(() => ({
    addToast: t,
    removeToast: e,
    clearToasts: n,
    addDialog: r,
    clearDialogs: o,
    removeDialog: s,
    updateDialog: i,
    msg: l,
    isMobile: c
  }), [r, t, o, n, l, s, e, i, c])
}

function eae(t, e) {
  const n = {};
  for (const r of t)
    if (r.translations)
      for (const [o, s] of Ls(r.translations)) {
        let i = n[o];
        i || (i = n[o] = {}), Object.assign(i, s)
      }
  return {
    actionsMenu: (r, o, s) => {
      for (const i of t) i.actionsMenu && (o = i.actionsMenu(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    actions: (r, o) => {
      for (const s of t) s.actions && (o = s.actions(r, o, e));
      return o
    },
    contextMenu: (r, o, s) => {
      for (const i of t) i.contextMenu && (o = i.contextMenu(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    helpMenu: (r, o, s) => {
      for (const i of t) i.helpMenu && (o = i.helpMenu(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    menu: (r, o, s) => {
      for (const i of t) i.menu && (o = i.menu(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    toolbar: (r, o, s) => {
      for (const i of t) i.toolbar && (o = i.toolbar(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    keyboardShortcutsMenu: (r, o, s) => {
      for (const i of t) i.keyboardShortcutsMenu && (o = i.keyboardShortcutsMenu(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    tools: (r, o, s) => {
      for (const i of t) i.tools && (o = i.tools(r, o, {
        ...e,
        ...s
      }));
      return o
    },
    translations: n
  }
}

function _D(t) {
  return g.useMemo(() => t, t)
}

function tae(t) {
  const e = _D(t == null ? [] : Array.isArray(t) ? t : [t]);
  return g.useMemo(() => {
    const n = {};
    for (const r of e)
      if (r.translations)
        for (const [o, s] of Ls(r.translations)) {
          let i = n[o];
          i || (i = n[o] = {}), Object.assign(i, s)
        }
    return n
  }, [e])
}

function nae(t) {
  const e = Qie(),
    n = _D(t == null ? [] : Array.isArray(t) ? t : [t]);
  return g.useMemo(() => eae(n, e), [n, e])
}

function rae({
  overrides: t,
  assetUrls: e,
  onUiEvent: n,
  forceMobile: r,
  children: o
}) {
  return y.jsx(Foe, {
    assetUrls: Loe(e),
    children: y.jsx(zoe, {
      overrides: tae(t),
      children: y.jsx(gie, {
        onEvent: n,
        children: y.jsx(Cie, {
          children: y.jsx(Iie, {
            children: y.jsx(Lie, {
              forceMobile: r,
              children: y.jsx(oae, {
                overrides: t,
                children: o
              })
            })
          })
        })
      })
    })
  })
}

function oae({
  overrides: t,
  children: e
}) {
  const n = nae(t);
  return y.jsx(jie, {
    overrides: n.actions,
    children: y.jsx(Hie, {
      overrides: n.tools,
      children: y.jsx(Zie, {
        overrides: n.toolbar,
        children: y.jsx(Fie, {
          overrides: n.actionsMenu,
          children: y.jsx(Vie, {
            overrides: n.keyboardShortcutsMenu,
            children: y.jsx(zie, {
              overrides: n.contextMenu,
              children: y.jsx(Gie, {
                overrides: n.helpMenu,
                children: y.jsx(qie, {
                  overrides: n.menu,
                  children: e
                })
              })
            })
          })
        })
      })
    })
  })
}

function sae() {
  const t = Y(),
    n = Xn()["back-to-content"],
    [r, o] = g.useState(!1);
  return g.useEffect(() => {
    let s = !1;
    const i = setInterval(() => {
      const {
        renderingShapes: a,
        renderingBounds: c
      } = t, u = a.filter(d => d.maskedPageBounds && c.includes(d.maskedPageBounds)).length === 0 && t.currentPageShapes.length > 0;
      s !== u && (o(u), s = u)
    }, 1e3);
    return () => {
      clearInterval(i)
    }
  }, [t]), r ? y.jsx(me, {
    iconLeft: n.icon,
    label: n.label,
    type: "low",
    onClick: () => {
      n.onSelect("helper-buttons"), o(!1)
    }
  }) : null
}
const iae = g.createContext(void 0);

function mE(t) {
  const e = g.useContext(iae);
  return t || e || "ltr"
}

function Iu(t) {
  return t.split("-")[1]
}

function yE(t) {
  return t === "y" ? "height" : "width"
}

function Bs(t) {
  return t.split("-")[0]
}

function mc(t) {
  return ["top", "bottom"].includes(Bs(t)) ? "x" : "y"
}

function Q2(t, e, n) {
  let {
    reference: r,
    floating: o
  } = t;
  const s = r.x + r.width / 2 - o.width / 2,
    i = r.y + r.height / 2 - o.height / 2,
    a = mc(e),
    c = yE(a),
    l = r[c] / 2 - o[c] / 2,
    u = a === "x";
  let d;
  switch (Bs(e)) {
    case "top":
      d = {
        x: s,
        y: r.y - o.height
      };
      break;
    case "bottom":
      d = {
        x: s,
        y: r.y + r.height
      };
      break;
    case "right":
      d = {
        x: r.x + r.width,
        y: i
      };
      break;
    case "left":
      d = {
        x: r.x - o.width,
        y: i
      };
      break;
    default:
      d = {
        x: r.x,
        y: r.y
      }
  }
  switch (Iu(e)) {
    case "start":
      d[a] -= l * (n && u ? -1 : 1);
      break;
    case "end":
      d[a] += l * (n && u ? -1 : 1)
  }
  return d
}
const aae = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: s = [],
    platform: i
  } = n, a = s.filter(Boolean), c = await (i.isRTL == null ? void 0 : i.isRTL(e));
  let l = await i.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }),
    {
      x: u,
      y: d
    } = Q2(l, r, c),
    f = r,
    h = {},
    m = 0;
  for (let p = 0; p < a.length; p++) {
    const {
      name: b,
      fn: w
    } = a[p], {
      x: v,
      y: _,
      data: S,
      reset: x
    } = await w({
      x: u,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: o,
      middlewareData: h,
      rects: l,
      platform: i,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = v ?? u, d = _ ?? d, h = {
      ...h,
      [b]: {
        ...h[b],
        ...S
      }
    }, x && m <= 50 && (m++, typeof x == "object" && (x.placement && (f = x.placement), x.rects && (l = x.rects === !0 ? await i.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : x.rects), {
      x: u,
      y: d
    } = Q2(l, f, c)), p = -1)
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: o,
    middlewareData: h
  }
};

function Zs(t, e) {
  return typeof t == "function" ? t(e) : t
}

function xD(t) {
  return typeof t != "number" ? function(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    }
  }(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  }
}

function Ym(t) {
  return {
    ...t,
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  }
}
async function Lf(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: s,
    rects: i,
    elements: a,
    strategy: c
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = Zs(e, t), m = xD(h), p = a[f ? d === "floating" ? "reference" : "floating" : d], b = Ym(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(p))) == null || n ? p : p.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: c
  })), w = d === "floating" ? {
    ...i.floating,
    x: r,
    y: o
  } : i.reference, v = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(v)) && await (s.getScale == null ? void 0 : s.getScale(v)) || {
    x: 1,
    y: 1
  }, S = Ym(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: w,
    offsetParent: v,
    strategy: c
  }) : w);
  return {
    top: (b.top - S.top + m.top) / _.y,
    bottom: (S.bottom - b.bottom + m.bottom) / _.y,
    left: (b.left - S.left + m.left) / _.x,
    right: (S.right - b.right + m.right) / _.x
  }
}
const Ff = Math.min,
  wa = Math.max;

function b_(t, e, n) {
  return wa(t, Ff(e, n))
}
const e$ = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: s,
        platform: i,
        elements: a
      } = e, {
        element: c,
        padding: l = 0
      } = Zs(t, e) || {};
      if (c == null) return {};
      const u = xD(l),
        d = {
          x: n,
          y: r
        },
        f = mc(o),
        h = yE(f),
        m = await i.getDimensions(c),
        p = f === "y",
        b = p ? "top" : "left",
        w = p ? "bottom" : "right",
        v = p ? "clientHeight" : "clientWidth",
        _ = s.reference[h] + s.reference[f] - d[f] - s.floating[h],
        S = d[f] - s.reference[f],
        x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c));
      let E = x ? x[v] : 0;
      E && await (i.isElement == null ? void 0 : i.isElement(x)) || (E = a.floating[v] || s.floating[h]);
      const k = _ / 2 - S / 2,
        C = E / 2 - m[h] / 2 - 1,
        $ = Ff(u[b], C),
        I = Ff(u[w], C),
        R = $,
        M = E - m[h] - I,
        j = E / 2 - m[h] / 2 + k,
        A = b_(R, j, M),
        D = Iu(o) != null && j != A && s.reference[h] / 2 - (j < R ? $ : I) - m[h] / 2 < 0 ? j < R ? R - j : M - j : 0;
      return {
        [f]: d[f] - D,
        data: {
          [f]: A,
          centerOffset: j - A + D
        }
      }
    }
  }),
  ED = ["top", "right", "bottom", "left"];
ED.reduce((t, e) => t.concat(e, e + "-start", e + "-end"), []);
const cae = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};

function qm(t) {
  return t.replace(/left|right|bottom|top/g, e => cae[e])
}

function lae(t, e, n) {
  n === void 0 && (n = !1);
  const r = Iu(t),
    o = mc(t),
    s = yE(o);
  let i = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (i = qm(i)), {
    main: i,
    cross: qm(i)
  }
}
const uae = {
  start: "end",
  end: "start"
};

function zb(t) {
  return t.replace(/start|end/g, e => uae[e])
}
const kD = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n;
      const {
        placement: r,
        middlewareData: o,
        rects: s,
        initialPlacement: i,
        platform: a,
        elements: c
      } = e, {
        mainAxis: l = !0,
        crossAxis: u = !0,
        fallbackPlacements: d,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: m = !0,
        ...p
      } = Zs(t, e), b = Bs(r), w = Bs(i) === i, v = await (a.isRTL == null ? void 0 : a.isRTL(c.floating)), _ = d || (w || !m ? [qm(i)] : function(R) {
        const M = qm(R);
        return [zb(R), M, zb(M)]
      }(i));
      d || h === "none" || _.push(... function(R, M, j, A) {
        const D = Iu(R);
        let N = function(q, F, B) {
          const V = ["left", "right"],
            J = ["right", "left"],
            ee = ["top", "bottom"],
            ye = ["bottom", "top"];
          switch (q) {
            case "top":
            case "bottom":
              return B ? F ? J : V : F ? V : J;
            case "left":
            case "right":
              return F ? ee : ye;
            default:
              return []
          }
        }(Bs(R), j === "start", A);
        return D && (N = N.map(q => q + "-" + D), M && (N = N.concat(N.map(zb)))), N
      }(i, m, h, v));
      const S = [i, ..._],
        x = await Lf(e, p),
        E = [];
      let k = ((n = o.flip) == null ? void 0 : n.overflows) || [];
      if (l && E.push(x[b]), u) {
        const {
          main: R,
          cross: M
        } = lae(r, s, v);
        E.push(x[R], x[M])
      }
      if (k = [...k, {
          placement: r,
          overflows: E
        }], !E.every(R => R <= 0)) {
        var C, $;
        const R = (((C = o.flip) == null ? void 0 : C.index) || 0) + 1,
          M = S[R];
        if (M) return {
          data: {
            index: R,
            overflows: k
          },
          reset: {
            placement: M
          }
        };
        let j = ($ = k.filter(A => A.overflows[0] <= 0).sort((A, D) => A.overflows[1] - D.overflows[1])[0]) == null ? void 0 : $.placement;
        if (!j) switch (f) {
          case "bestFit": {
            var I;
            const A = (I = k.map(D => [D.placement, D.overflows.filter(N => N > 0).reduce((N, q) => N + q, 0)]).sort((D, N) => D[1] - N[1])[0]) == null ? void 0 : I[0];
            A && (j = A);
            break
          }
          case "initialPlacement":
            j = i
        }
        if (r !== j) return {
          reset: {
            placement: j
          }
        }
      }
      return {}
    }
  }
};

function t$(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  }
}

function n$(t) {
  return ED.some(e => t[e] >= 0)
}
const CD = function(t) {
    return t === void 0 && (t = {}), {
      name: "hide",
      options: t,
      async fn(e) {
        const {
          rects: n
        } = e, {
          strategy: r = "referenceHidden",
          ...o
        } = Zs(t, e);
        switch (r) {
          case "referenceHidden": {
            const s = t$(await Lf(e, {
              ...o,
              elementContext: "reference"
            }), n.reference);
            return {
              data: {
                referenceHiddenOffsets: s,
                referenceHidden: n$(s)
              }
            }
          }
          case "escaped": {
            const s = t$(await Lf(e, {
              ...o,
              altBoundary: !0
            }), n.floating);
            return {
              data: {
                escapedOffsets: s,
                escaped: n$(s)
              }
            }
          }
          default:
            return {}
        }
      }
    }
  },
  PD = function(t) {
    return t === void 0 && (t = 0), {
      name: "offset",
      options: t,
      async fn(e) {
        const {
          x: n,
          y: r
        } = e, o = await async function(s, i) {
          const {
            placement: a,
            platform: c,
            elements: l
          } = s, u = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), d = Bs(a), f = Iu(a), h = mc(a) === "x", m = ["left", "top"].includes(d) ? -1 : 1, p = u && h ? -1 : 1, b = Zs(i, s);
          let {
            mainAxis: w,
            crossAxis: v,
            alignmentAxis: _
          } = typeof b == "number" ? {
            mainAxis: b,
            crossAxis: 0,
            alignmentAxis: null
          } : {
            mainAxis: 0,
            crossAxis: 0,
            alignmentAxis: null,
            ...b
          };
          return f && typeof _ == "number" && (v = f === "end" ? -1 * _ : _), h ? {
            x: v * p,
            y: w * m
          } : {
            x: w * m,
            y: v * p
          }
        }(e, t);
        return {
          x: n + o.x,
          y: r + o.y,
          data: o
        }
      }
    }
  };

function TD(t) {
  return t === "x" ? "y" : "x"
}
const $D = function(t) {
    return t === void 0 && (t = {}), {
      name: "shift",
      options: t,
      async fn(e) {
        const {
          x: n,
          y: r,
          placement: o
        } = e, {
          mainAxis: s = !0,
          crossAxis: i = !1,
          limiter: a = {
            fn: b => {
              let {
                x: w,
                y: v
              } = b;
              return {
                x: w,
                y: v
              }
            }
          },
          ...c
        } = Zs(t, e), l = {
          x: n,
          y: r
        }, u = await Lf(e, c), d = mc(Bs(o)), f = TD(d);
        let h = l[d],
          m = l[f];
        if (s) {
          const b = d === "y" ? "bottom" : "right";
          h = b_(h + u[d === "y" ? "top" : "left"], h, h - u[b])
        }
        if (i) {
          const b = f === "y" ? "bottom" : "right";
          m = b_(m + u[f === "y" ? "top" : "left"], m, m - u[b])
        }
        const p = a.fn({
          ...e,
          [d]: h,
          [f]: m
        });
        return {
          ...p,
          data: {
            x: p.x - n,
            y: p.y - r
          }
        }
      }
    }
  },
  ID = function(t) {
    return t === void 0 && (t = {}), {
      options: t,
      fn(e) {
        const {
          x: n,
          y: r,
          placement: o,
          rects: s,
          middlewareData: i
        } = e, {
          offset: a = 0,
          mainAxis: c = !0,
          crossAxis: l = !0
        } = Zs(t, e), u = {
          x: n,
          y: r
        }, d = mc(o), f = TD(d);
        let h = u[d],
          m = u[f];
        const p = Zs(a, e),
          b = typeof p == "number" ? {
            mainAxis: p,
            crossAxis: 0
          } : {
            mainAxis: 0,
            crossAxis: 0,
            ...p
          };
        if (c) {
          const _ = d === "y" ? "height" : "width",
            S = s.reference[d] - s.floating[_] + b.mainAxis,
            x = s.reference[d] + s.reference[_] - b.mainAxis;
          h < S ? h = S : h > x && (h = x)
        }
        if (l) {
          var w, v;
          const _ = d === "y" ? "width" : "height",
            S = ["top", "left"].includes(Bs(o)),
            x = s.reference[f] - s.floating[_] + (S && ((w = i.offset) == null ? void 0 : w[f]) || 0) + (S ? 0 : b.crossAxis),
            E = s.reference[f] + s.reference[_] + (S ? 0 : ((v = i.offset) == null ? void 0 : v[f]) || 0) - (S ? b.crossAxis : 0);
          m < x ? m = x : m > E && (m = E)
        }
        return {
          [d]: h,
          [f]: m
        }
      }
    }
  },
  OD = function(t) {
    return t === void 0 && (t = {}), {
      name: "size",
      options: t,
      async fn(e) {
        const {
          placement: n,
          rects: r,
          platform: o,
          elements: s
        } = e, {
          apply: i = () => {},
          ...a
        } = Zs(t, e), c = await Lf(e, a), l = Bs(n), u = Iu(n), d = mc(n) === "x", {
          width: f,
          height: h
        } = r.floating;
        let m, p;
        l === "top" || l === "bottom" ? (m = l, p = u === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (p = l, m = u === "end" ? "top" : "bottom");
        const b = h - c[m],
          w = f - c[p],
          v = !e.middlewareData.shift;
        let _ = b,
          S = w;
        if (d) {
          const E = f - c.left - c.right;
          S = u || v ? Ff(w, E) : E
        } else {
          const E = h - c.top - c.bottom;
          _ = u || v ? Ff(b, E) : E
        }
        if (v && !u) {
          const E = wa(c.left, 0),
            k = wa(c.right, 0),
            C = wa(c.top, 0),
            $ = wa(c.bottom, 0);
          d ? S = f - 2 * (E !== 0 || k !== 0 ? E + k : wa(c.left, c.right)) : _ = h - 2 * (C !== 0 || $ !== 0 ? C + $ : wa(c.top, c.bottom))
        }
        await i({
          ...e,
          availableWidth: S,
          availableHeight: _
        });
        const x = await o.getDimensions(s.floating);
        return f !== x.width || h !== x.height ? {
          reset: {
            rects: !0
          }
        } : {}
      }
    }
  };

function Nr(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}

function hs(t) {
  return Nr(t).getComputedStyle(t)
}

function RD(t) {
  return t instanceof Nr(t).Node
}

function Ki(t) {
  return RD(t) ? (t.nodeName || "").toLowerCase() : "#document"
}

function Fo(t) {
  return t instanceof Nr(t).HTMLElement
}

function r$(t) {
  return typeof ShadowRoot < "u" && (t instanceof Nr(t).ShadowRoot || t instanceof ShadowRoot)
}

function Bf(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: o
  } = hs(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !["inline", "contents"].includes(o)
}

function dae(t) {
  return ["table", "td", "th"].includes(Ki(t))
}

function w_(t) {
  const e = vE(),
    n = hs(t);
  return n.transform !== "none" || n.perspective !== "none" || !!n.containerType && n.containerType !== "normal" || !e && !!n.backdropFilter && n.backdropFilter !== "none" || !e && !!n.filter && n.filter !== "none" || ["transform", "perspective", "filter"].some(r => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (n.contain || "").includes(r))
}

function vE() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none")
}

function Pv(t) {
  return ["html", "body", "#document"].includes(Ki(t))
}
const S_ = Math.min,
  Bl = Math.max,
  Xm = Math.round,
  ng = Math.floor,
  Gi = t => ({
    x: t,
    y: t
  });

function AD(t) {
  const e = hs(t);
  let n = parseFloat(e.width) || 0,
    r = parseFloat(e.height) || 0;
  const o = Fo(t),
    s = o ? t.offsetWidth : n,
    i = o ? t.offsetHeight : r,
    a = Xm(n) !== s || Xm(r) !== i;
  return a && (n = s, r = i), {
    width: n,
    height: r,
    $: a
  }
}

function Us(t) {
  return t instanceof Nr(t).Element
}

function bE(t) {
  return Us(t) ? t : t.contextElement
}

function Ul(t) {
  const e = bE(t);
  if (!Fo(e)) return Gi(1);
  const n = e.getBoundingClientRect(),
    {
      width: r,
      height: o,
      $: s
    } = AD(e);
  let i = (s ? Xm(n.width) : n.width) / r,
    a = (s ? Xm(n.height) : n.height) / o;
  return i && Number.isFinite(i) || (i = 1), a && Number.isFinite(a) || (a = 1), {
    x: i,
    y: a
  }
}
const fae = Gi(0);

function MD(t) {
  const e = Nr(t);
  return vE() && e.visualViewport ? {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  } : fae
}

function nc(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(),
    s = bE(t);
  let i = Gi(1);
  e && (r ? Us(r) && (i = Ul(r)) : i = Ul(t));
  const a = function(f, h, m) {
    return h === void 0 && (h = !1), !(!m || h && m !== Nr(f)) && h
  }(s, n, r) ? MD(s) : Gi(0);
  let c = (o.left + a.x) / i.x,
    l = (o.top + a.y) / i.y,
    u = o.width / i.x,
    d = o.height / i.y;
  if (s) {
    const f = Nr(s),
      h = r && Us(r) ? Nr(r) : r;
    let m = f.frameElement;
    for (; m && r && h !== f;) {
      const p = Ul(m),
        b = m.getBoundingClientRect(),
        w = getComputedStyle(m),
        v = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * p.x,
        _ = b.top + (m.clientTop + parseFloat(w.paddingTop)) * p.y;
      c *= p.x, l *= p.y, u *= p.x, d *= p.y, c += v, l += _, m = Nr(m).frameElement
    }
  }
  return Ym({
    width: u,
    height: d,
    x: c,
    y: l
  })
}

function Tv(t) {
  return Us(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  }
}

function zs(t) {
  return ((RD(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function jD(t) {
  return nc(zs(t)).left + Tv(t).scrollLeft
}

function iu(t) {
  if (Ki(t) === "html") return t;
  const e = t.assignedSlot || t.parentNode || r$(t) && t.host || zs(t);
  return r$(e) ? e.host : e
}

function DD(t) {
  const e = iu(t);
  return Pv(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Fo(e) && Bf(e) ? e : DD(e)
}

function Zm(t, e) {
  var n;
  e === void 0 && (e = []);
  const r = DD(t),
    o = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
    s = Nr(r);
  return o ? e.concat(s, s.visualViewport || [], Bf(r) ? r : []) : e.concat(r, Zm(r))
}

function o$(t, e, n) {
  let r;
  if (e === "viewport") r = function(o, s) {
    const i = Nr(o),
      a = zs(o),
      c = i.visualViewport;
    let l = a.clientWidth,
      u = a.clientHeight,
      d = 0,
      f = 0;
    if (c) {
      l = c.width, u = c.height;
      const h = vE();
      (!h || h && s === "fixed") && (d = c.offsetLeft, f = c.offsetTop)
    }
    return {
      width: l,
      height: u,
      x: d,
      y: f
    }
  }(t, n);
  else if (e === "document") r = function(o) {
    const s = zs(o),
      i = Tv(o),
      a = o.ownerDocument.body,
      c = Bl(s.scrollWidth, s.clientWidth, a.scrollWidth, a.clientWidth),
      l = Bl(s.scrollHeight, s.clientHeight, a.scrollHeight, a.clientHeight);
    let u = -i.scrollLeft + jD(o);
    const d = -i.scrollTop;
    return hs(a).direction === "rtl" && (u += Bl(s.clientWidth, a.clientWidth) - c), {
      width: c,
      height: l,
      x: u,
      y: d
    }
  }(zs(t));
  else if (Us(e)) r = function(o, s) {
    const i = nc(o, !0, s === "fixed"),
      a = i.top + o.clientTop,
      c = i.left + o.clientLeft,
      l = Fo(o) ? Ul(o) : Gi(1);
    return {
      width: o.clientWidth * l.x,
      height: o.clientHeight * l.y,
      x: c * l.x,
      y: a * l.y
    }
  }(e, n);
  else {
    const o = MD(t);
    r = {
      ...e,
      x: e.x - o.x,
      y: e.y - o.y
    }
  }
  return Ym(r)
}

function ND(t, e) {
  const n = iu(t);
  return !(n === e || !Us(n) || Pv(n)) && (hs(n).position === "fixed" || ND(n, e))
}

function hae(t, e, n) {
  const r = Fo(e),
    o = zs(e),
    s = n === "fixed",
    i = nc(t, !0, s, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Gi(0);
  if (r || !r && !s)
    if ((Ki(e) !== "body" || Bf(o)) && (a = Tv(e)), Fo(e)) {
      const l = nc(e, !0, s, e);
      c.x = l.x + e.clientLeft, c.y = l.y + e.clientTop
    } else o && (c.x = jD(o));
  return {
    x: i.left + a.scrollLeft - c.x,
    y: i.top + a.scrollTop - c.y,
    width: i.width,
    height: i.height
  }
}

function s$(t, e) {
  return Fo(t) && hs(t).position !== "fixed" ? e ? e(t) : t.offsetParent : null
}

function i$(t, e) {
  const n = Nr(t);
  if (!Fo(t)) return n;
  let r = s$(t, e);
  for (; r && dae(r) && hs(r).position === "static";) r = s$(r, e);
  return r && (Ki(r) === "html" || Ki(r) === "body" && hs(r).position === "static" && !w_(r)) ? n : r || function(o) {
    let s = iu(o);
    for (; Fo(s) && !Pv(s);) {
      if (w_(s)) return s;
      s = iu(s)
    }
    return null
  }(t) || n
}
const pae = {
  convertOffsetParentRelativeRectToViewportRelativeRect: function(t) {
    let {
      rect: e,
      offsetParent: n,
      strategy: r
    } = t;
    const o = Fo(n),
      s = zs(n);
    if (n === s) return e;
    let i = {
        scrollLeft: 0,
        scrollTop: 0
      },
      a = Gi(1);
    const c = Gi(0);
    if ((o || !o && r !== "fixed") && ((Ki(n) !== "body" || Bf(s)) && (i = Tv(n)), Fo(n))) {
      const l = nc(n);
      a = Ul(n), c.x = l.x + n.clientLeft, c.y = l.y + n.clientTop
    }
    return {
      width: e.width * a.x,
      height: e.height * a.y,
      x: e.x * a.x - i.scrollLeft * a.x + c.x,
      y: e.y * a.y - i.scrollTop * a.y + c.y
    }
  },
  getDocumentElement: zs,
  getClippingRect: function(t) {
    let {
      element: e,
      boundary: n,
      rootBoundary: r,
      strategy: o
    } = t;
    const s = [...n === "clippingAncestors" ? function(c, l) {
        const u = l.get(c);
        if (u) return u;
        let d = Zm(c).filter(p => Us(p) && Ki(p) !== "body"),
          f = null;
        const h = hs(c).position === "fixed";
        let m = h ? iu(c) : c;
        for (; Us(m) && !Pv(m);) {
          const p = hs(m),
            b = w_(m);
          b || p.position !== "fixed" || (f = null), (h ? !b && !f : !b && p.position === "static" && f && ["absolute", "fixed"].includes(f.position) || Bf(m) && !b && ND(c, m)) ? d = d.filter(w => w !== m) : f = p, m = iu(m)
        }
        return l.set(c, d), d
      }(e, this._c) : [].concat(n), r],
      i = s[0],
      a = s.reduce((c, l) => {
        const u = o$(e, l, o);
        return c.top = Bl(u.top, c.top), c.right = S_(u.right, c.right), c.bottom = S_(u.bottom, c.bottom), c.left = Bl(u.left, c.left), c
      }, o$(e, i, o));
    return {
      width: a.right - a.left,
      height: a.bottom - a.top,
      x: a.left,
      y: a.top
    }
  },
  getOffsetParent: i$,
  getElementRects: async function(t) {
    let {
      reference: e,
      floating: n,
      strategy: r
    } = t;
    const o = this.getOffsetParent || i$,
      s = this.getDimensions;
    return {
      reference: hae(e, await o(n), r),
      floating: {
        x: 0,
        y: 0,
        ...await s(n)
      }
    }
  },
  getClientRects: function(t) {
    return Array.from(t.getClientRects())
  },
  getDimensions: function(t) {
    return AD(t)
  },
  getScale: Ul,
  isElement: Us,
  isRTL: function(t) {
    return getComputedStyle(t).direction === "rtl"
  }
};

function LD(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: s = !0,
    elementResize: i = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = bE(t), u = o || s ? [...l ? Zm(l) : [], ...Zm(e)] : [];
  u.forEach(b => {
    o && b.addEventListener("scroll", n, {
      passive: !0
    }), s && b.addEventListener("resize", n)
  });
  const d = l && a ? function(b, w) {
    let v, _ = null;
    const S = zs(b);

    function x() {
      clearTimeout(v), _ && _.disconnect(), _ = null
    }
    return function E(k, C) {
      k === void 0 && (k = !1), C === void 0 && (C = 1), x();
      const {
        left: $,
        top: I,
        width: R,
        height: M
      } = b.getBoundingClientRect();
      if (k || w(), !R || !M) return;
      const j = {
        rootMargin: -ng(I) + "px " + -ng(S.clientWidth - ($ + R)) + "px " + -ng(S.clientHeight - (I + M)) + "px " + -ng($) + "px",
        threshold: Bl(0, S_(1, C)) || 1
      };
      let A = !0;

      function D(N) {
        const q = N[0].intersectionRatio;
        if (q !== C) {
          if (!A) return E();
          q ? E(!1, q) : v = setTimeout(() => {
            E(!1, 1e-7)
          }, 100)
        }
        A = !1
      }
      try {
        _ = new IntersectionObserver(D, {
          ...j,
          root: S.ownerDocument
        })
      } catch {
        _ = new IntersectionObserver(D, j)
      }
      _.observe(b)
    }(!0), x
  }(l, n) : null;
  let f, h = -1,
    m = null;
  i && (m = new ResizeObserver(b => {
    let [w] = b;
    w && w.target === l && m && (m.unobserve(e), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
      m && m.observe(e)
    })), n()
  }), l && !c && m.observe(l), m.observe(e));
  let p = c ? nc(t) : null;
  return c && function b() {
    const w = nc(t);
    !p || w.x === p.x && w.y === p.y && w.width === p.width && w.height === p.height || n(), p = w, f = requestAnimationFrame(b)
  }(), n(), () => {
    u.forEach(b => {
      o && b.removeEventListener("scroll", n), s && b.removeEventListener("resize", n)
    }), d && d(), m && m.disconnect(), m = null, c && cancelAnimationFrame(f)
  }
}
const gae = (t, e, n) => {
    const r = new Map,
      o = {
        platform: pae,
        ...n
      },
      s = {
        ...o.platform,
        _c: r
      };
    return aae(t, e, {
      ...o,
      platform: s
    })
  },
  FD = t => {
    function e(n) {
      return {}.hasOwnProperty.call(n, "current")
    }
    return {
      name: "arrow",
      options: t,
      fn(n) {
        const {
          element: r,
          padding: o
        } = typeof t == "function" ? t(n) : t;
        return r && e(r) ? r.current != null ? e$({
          element: r.current,
          padding: o
        }).fn(n) : {} : r ? e$({
          element: r,
          padding: o
        }).fn(n) : {}
      }
    }
  };
var Ug = typeof document < "u" ? g.useLayoutEffect : g.useEffect;

function Jm(t, e) {
  if (t === e) return !0;
  if (typeof t != typeof e) return !1;
  if (typeof t == "function" && t.toString() === e.toString()) return !0;
  let n, r, o;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n != e.length) return !1;
      for (r = n; r-- !== 0;)
        if (!Jm(t[r], e[r])) return !1;
      return !0
    }
    if (o = Object.keys(t), n = o.length, n !== Object.keys(e).length) return !1;
    for (r = n; r-- !== 0;)
      if (!{}.hasOwnProperty.call(e, o[r])) return !1;
    for (r = n; r-- !== 0;) {
      const s = o[r];
      if (!(s === "_owner" && t.$$typeof) && !Jm(t[s], e[s])) return !1
    }
    return !0
  }
  return t !== t && e !== e
}

function BD(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}

function a$(t, e) {
  const n = BD(t);
  return Math.round(e * n) / n
}

function c$(t) {
  const e = g.useRef(t);
  return Ug(() => {
    e.current = t
  }), e
}

function UD(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: s,
      floating: i
    } = {},
    transform: a = !0,
    whileElementsMounted: c,
    open: l
  } = t, [u, d] = g.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = g.useState(r);
  Jm(f, r) || h(r);
  const [m, p] = g.useState(null), [b, w] = g.useState(null), v = g.useCallback(N => {
    N != E.current && (E.current = N, p(N))
  }, [p]), _ = g.useCallback(N => {
    N !== k.current && (k.current = N, w(N))
  }, [w]), S = s || m, x = i || b, E = g.useRef(null), k = g.useRef(null), C = g.useRef(u), $ = c$(c), I = c$(o), R = g.useCallback(() => {
    if (!E.current || !k.current) return;
    const N = {
      placement: e,
      strategy: n,
      middleware: f
    };
    I.current && (N.platform = I.current), gae(E.current, k.current, N).then(q => {
      const F = {
        ...q,
        isPositioned: !0
      };
      M.current && !Jm(C.current, F) && (C.current = F, ta.flushSync(() => {
        d(F)
      }))
    })
  }, [f, e, n, I]);
  Ug(() => {
    l === !1 && C.current.isPositioned && (C.current.isPositioned = !1, d(N => ({
      ...N,
      isPositioned: !1
    })))
  }, [l]);
  const M = g.useRef(!1);
  Ug(() => (M.current = !0, () => {
    M.current = !1
  }), []), Ug(() => {
    if (S && (E.current = S), x && (k.current = x), S && x) {
      if ($.current) return $.current(S, x, R);
      R()
    }
  }, [S, x, R, $]);
  const j = g.useMemo(() => ({
      reference: E,
      floating: k,
      setReference: v,
      setFloating: _
    }), [v, _]),
    A = g.useMemo(() => ({
      reference: S,
      floating: x
    }), [S, x]),
    D = g.useMemo(() => {
      const N = {
        position: n,
        left: 0,
        top: 0
      };
      if (!A.floating) return N;
      const q = a$(A.floating, u.x),
        F = a$(A.floating, u.y);
      return a ? {
        ...N,
        transform: "translate(" + q + "px, " + F + "px)",
        ...BD(A.floating) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: n,
        left: q,
        top: F
      }
    }, [n, a, A.floating, u.x, u.y]);
  return g.useMemo(() => ({
    ...u,
    update: R,
    refs: j,
    elements: A,
    floatingStyles: D
  }), [u, R, j, A, D])
}

function zD(t) {
  const [e, n] = g.useState(void 0);
  return Sr(() => {
    if (t) {
      n({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const r = new ResizeObserver(o => {
        if (!Array.isArray(o) || !o.length) return;
        const s = o[0];
        let i, a;
        if ("borderBoxSize" in s) {
          const c = s.borderBoxSize,
            l = Array.isArray(c) ? c[0] : c;
          i = l.inlineSize, a = l.blockSize
        } else i = t.offsetWidth, a = t.offsetHeight;
        n({
          width: i,
          height: a
        })
      });
      return r.observe(t, {
        box: "border-box"
      }), () => r.unobserve(t)
    } else n(void 0)
  }, [t]), e
}
const HD = "Popper",
  [VD, $v] = Vo(HD),
  [mae, WD] = VD(HD),
  yae = t => {
    const {
      __scopePopper: e,
      children: n
    } = t, [r, o] = g.useState(null);
    return g.createElement(mae, {
      scope: e,
      anchor: r,
      onAnchorChange: o
    }, n)
  },
  vae = "PopperAnchor",
  bae = g.forwardRef((t, e) => {
    const {
      __scopePopper: n,
      virtualRef: r,
      ...o
    } = t, s = WD(vae, n), i = g.useRef(null), a = rt(e, i);
    return g.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || i.current)
    }), r ? null : g.createElement(Ke.div, G({}, o, {
      ref: a
    }))
  }),
  KD = "PopperContent",
  [wae, Obe] = VD(KD),
  Sae = g.forwardRef((t, e) => {
    var n, r, o, s, i, a, c, l;
    const {
      __scopePopper: u,
      side: d = "bottom",
      sideOffset: f = 0,
      align: h = "center",
      alignOffset: m = 0,
      arrowPadding: p = 0,
      avoidCollisions: b = !0,
      collisionBoundary: w = [],
      collisionPadding: v = 0,
      sticky: _ = "partial",
      hideWhenDetached: S = !1,
      updatePositionStrategy: x = "optimized",
      onPlaced: E,
      ...k
    } = t, C = WD(KD, u), [$, I] = g.useState(null), R = rt(e, xt => I(xt)), [M, j] = g.useState(null), A = zD(M), D = (n = A == null ? void 0 : A.width) !== null && n !== void 0 ? n : 0, N = (r = A == null ? void 0 : A.height) !== null && r !== void 0 ? r : 0, q = d + (h !== "center" ? "-" + h : ""), F = typeof v == "number" ? v : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...v
    }, B = Array.isArray(w) ? w : [w], V = B.length > 0, J = {
      padding: F,
      boundary: B.filter(_ae),
      altBoundary: V
    }, {
      refs: ee,
      floatingStyles: ye,
      placement: ge,
      isPositioned: ce,
      middlewareData: Ce
    } = UD({
      strategy: "fixed",
      placement: q,
      whileElementsMounted: (...xt) => LD(...xt, {
        animationFrame: x === "always"
      }),
      elements: {
        reference: C.anchor
      },
      middleware: [PD({
        mainAxis: f + N,
        alignmentAxis: m
      }), b && $D({
        mainAxis: !0,
        crossAxis: !1,
        limiter: _ === "partial" ? ID() : void 0,
        ...J
      }), b && kD({
        ...J
      }), OD({
        ...J,
        apply: ({
          elements: xt,
          rects: An,
          availableWidth: ln,
          availableHeight: bn
        }) => {
          const {
            width: Go,
            height: Zn
          } = An.reference, fo = xt.floating.style;
          fo.setProperty("--radix-popper-available-width", `${ln}px`), fo.setProperty("--radix-popper-available-height", `${bn}px`), fo.setProperty("--radix-popper-anchor-width", `${Go}px`), fo.setProperty("--radix-popper-anchor-height", `${Zn}px`)
        }
      }), M && FD({
        element: M,
        padding: p
      }), xae({
        arrowWidth: D,
        arrowHeight: N
      }), S && CD({
        strategy: "referenceHidden",
        ...J
      })]
    }), [oe, pe] = GD(ge), _e = At(E);
    Sr(() => {
      ce && (_e == null || _e())
    }, [ce, _e]);
    const xe = (o = Ce.arrow) === null || o === void 0 ? void 0 : o.x,
      Me = (s = Ce.arrow) === null || s === void 0 ? void 0 : s.y,
      Le = ((i = Ce.arrow) === null || i === void 0 ? void 0 : i.centerOffset) !== 0,
      [gt, Ze] = g.useState();
    return Sr(() => {
      $ && Ze(window.getComputedStyle($).zIndex)
    }, [$]), g.createElement("div", {
      ref: ee.setFloating,
      "data-radix-popper-content-wrapper": "",
      style: {
        ...ye,
        transform: ce ? ye.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: gt,
        "--radix-popper-transform-origin": [(a = Ce.transformOrigin) === null || a === void 0 ? void 0 : a.x, (c = Ce.transformOrigin) === null || c === void 0 ? void 0 : c.y].join(" ")
      },
      dir: t.dir
    }, g.createElement(wae, {
      scope: u,
      placedSide: oe,
      onArrowChange: j,
      arrowX: xe,
      arrowY: Me,
      shouldHideArrow: Le
    }, g.createElement(Ke.div, G({
      "data-side": oe,
      "data-align": pe
    }, k, {
      ref: R,
      style: {
        ...k.style,
        animation: ce ? void 0 : "none",
        opacity: (l = Ce.hide) !== null && l !== void 0 && l.referenceHidden ? 0 : void 0
      }
    }))))
  });

function _ae(t) {
  return t !== null
}
const xae = t => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var n, r, o, s, i;
    const {
      placement: a,
      rects: c,
      middlewareData: l
    } = e, d = ((n = l.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, f = d ? 0 : t.arrowWidth, h = d ? 0 : t.arrowHeight, [m, p] = GD(a), b = {
      start: "0%",
      center: "50%",
      end: "100%"
    } [p], w = ((r = (o = l.arrow) === null || o === void 0 ? void 0 : o.x) !== null && r !== void 0 ? r : 0) + f / 2, v = ((s = (i = l.arrow) === null || i === void 0 ? void 0 : i.y) !== null && s !== void 0 ? s : 0) + h / 2;
    let _ = "",
      S = "";
    return m === "bottom" ? (_ = d ? b : `${w}px`, S = `${-h}px`) : m === "top" ? (_ = d ? b : `${w}px`, S = `${c.floating.height+h}px`) : m === "right" ? (_ = `${-h}px`, S = d ? b : `${v}px`) : m === "left" && (_ = `${c.floating.width+h}px`, S = d ? b : `${v}px`), {
      data: {
        x: _,
        y: S
      }
    }
  }
});

function GD(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n]
}
const wE = yae,
  YD = bae,
  qD = Sae,
  Hb = "rovingFocusGroup.onEntryFocus",
  Eae = {
    bubbles: !1,
    cancelable: !0
  },
  SE = "RovingFocusGroup",
  [__, XD, kae] = mv(SE),
  [Cae, ZD] = Vo(SE, [kae]),
  [Pae, Tae] = Cae(SE),
  $ae = g.forwardRef((t, e) => g.createElement(__.Provider, {
    scope: t.__scopeRovingFocusGroup
  }, g.createElement(__.Slot, {
    scope: t.__scopeRovingFocusGroup
  }, g.createElement(Iae, G({}, t, {
    ref: e
  }))))),
  Iae = g.forwardRef((t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      orientation: r,
      loop: o = !1,
      dir: s,
      currentTabStopId: i,
      defaultCurrentTabStopId: a,
      onCurrentTabStopIdChange: c,
      onEntryFocus: l,
      ...u
    } = t, d = g.useRef(null), f = rt(e, d), h = mE(s), [m = null, p] = Xs({
      prop: i,
      defaultProp: a,
      onChange: c
    }), [b, w] = g.useState(!1), v = At(l), _ = XD(n), S = g.useRef(!1), [x, E] = g.useState(0);
    return g.useEffect(() => {
      const k = d.current;
      if (k) return k.addEventListener(Hb, v), () => k.removeEventListener(Hb, v)
    }, [v]), g.createElement(Pae, {
      scope: n,
      orientation: r,
      dir: h,
      loop: o,
      currentTabStopId: m,
      onItemFocus: g.useCallback(k => p(k), [p]),
      onItemShiftTab: g.useCallback(() => w(!0), []),
      onFocusableItemAdd: g.useCallback(() => E(k => k + 1), []),
      onFocusableItemRemove: g.useCallback(() => E(k => k - 1), [])
    }, g.createElement(Ke.div, G({
      tabIndex: b || x === 0 ? -1 : 0,
      "data-orientation": r
    }, u, {
      ref: f,
      style: {
        outline: "none",
        ...t.style
      },
      onMouseDown: ie(t.onMouseDown, () => {
        S.current = !0
      }),
      onFocus: ie(t.onFocus, k => {
        const C = !S.current;
        if (k.target === k.currentTarget && C && !b) {
          const $ = new CustomEvent(Hb, Eae);
          if (k.currentTarget.dispatchEvent($), !$.defaultPrevented) {
            const I = _().filter(D => D.focusable),
              R = I.find(D => D.active),
              M = I.find(D => D.id === m),
              A = [R, M, ...I].filter(Boolean).map(D => D.ref.current);
            JD(A)
          }
        }
        S.current = !1
      }),
      onBlur: ie(t.onBlur, () => w(!1))
    })))
  }),
  Oae = "RovingFocusGroupItem",
  Rae = g.forwardRef((t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: s,
      ...i
    } = t, a = Mo(), c = s || a, l = Tae(Oae, n), u = l.currentTabStopId === c, d = XD(n), {
      onFocusableItemAdd: f,
      onFocusableItemRemove: h
    } = l;
    return g.useEffect(() => {
      if (r) return f(), () => h()
    }, [r, f, h]), g.createElement(__.ItemSlot, {
      scope: n,
      id: c,
      focusable: r,
      active: o
    }, g.createElement(Ke.span, G({
      tabIndex: u ? 0 : -1,
      "data-orientation": l.orientation
    }, i, {
      ref: e,
      onMouseDown: ie(t.onMouseDown, m => {
        r ? l.onItemFocus(c) : m.preventDefault()
      }),
      onFocus: ie(t.onFocus, () => l.onItemFocus(c)),
      onKeyDown: ie(t.onKeyDown, m => {
        if (m.key === "Tab" && m.shiftKey) {
          l.onItemShiftTab();
          return
        }
        if (m.target !== m.currentTarget) return;
        const p = jae(m, l.orientation, l.dir);
        if (p !== void 0) {
          m.preventDefault();
          let w = d().filter(v => v.focusable).map(v => v.ref.current);
          if (p === "last") w.reverse();
          else if (p === "prev" || p === "next") {
            p === "prev" && w.reverse();
            const v = w.indexOf(m.currentTarget);
            w = l.loop ? Dae(w, v + 1) : w.slice(v + 1)
          }
          setTimeout(() => JD(w))
        }
      })
    })))
  }),
  Aae = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };

function Mae(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t
}

function jae(t, e, n) {
  const r = Mae(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r))) return Aae[r]
}

function JD(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return
}

function Dae(t, e) {
  return t.map((n, r) => t[(e + r) % t.length])
}
const Nae = $ae,
  Lae = Rae,
  x_ = ["Enter", " "],
  Fae = ["ArrowDown", "PageUp", "Home"],
  QD = ["ArrowUp", "PageDown", "End"],
  Bae = [...Fae, ...QD],
  Uae = {
    ltr: [...x_, "ArrowRight"],
    rtl: [...x_, "ArrowLeft"]
  },
  zae = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
  },
  Iv = "Menu",
  [Uf, Hae, Vae] = mv(Iv),
  [yc, Ov] = Vo(Iv, [Vae, $v, ZD]),
  Rv = $v(),
  e5 = ZD(),
  [t5, aa] = yc(Iv),
  [Wae, Dh] = yc(Iv),
  Kae = t => {
    const {
      __scopeMenu: e,
      open: n = !1,
      children: r,
      dir: o,
      onOpenChange: s,
      modal: i = !0
    } = t, a = Rv(e), [c, l] = g.useState(null), u = g.useRef(!1), d = At(s), f = mE(o);
    return g.useEffect(() => {
      const h = () => {
          u.current = !0, document.addEventListener("pointerdown", m, {
            capture: !0,
            once: !0
          }), document.addEventListener("pointermove", m, {
            capture: !0,
            once: !0
          })
        },
        m = () => u.current = !1;
      return document.addEventListener("keydown", h, {
        capture: !0
      }), () => {
        document.removeEventListener("keydown", h, {
          capture: !0
        }), document.removeEventListener("pointerdown", m, {
          capture: !0
        }), document.removeEventListener("pointermove", m, {
          capture: !0
        })
      }
    }, []), g.createElement(wE, a, g.createElement(t5, {
      scope: e,
      open: n,
      onOpenChange: d,
      content: c,
      onContentChange: l
    }, g.createElement(Wae, {
      scope: e,
      onClose: g.useCallback(() => d(!1), [d]),
      isUsingKeyboardRef: u,
      dir: f,
      modal: i
    }, r)))
  },
  n5 = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      ...r
    } = t, o = Rv(n);
    return g.createElement(YD, G({}, o, r, {
      ref: e
    }))
  }),
  r5 = "MenuPortal",
  [Gae, o5] = yc(r5, {
    forceMount: void 0
  }),
  Yae = t => {
    const {
      __scopeMenu: e,
      forceMount: n,
      children: r,
      container: o
    } = t, s = aa(r5, e);
    return g.createElement(Gae, {
      scope: e,
      forceMount: n
    }, g.createElement(Wo, {
      present: n || s.open
    }, g.createElement(iE, {
      asChild: !0,
      container: o
    }, r)))
  },
  jo = "MenuContent",
  [qae, _E] = yc(jo),
  Xae = g.forwardRef((t, e) => {
    const n = o5(jo, t.__scopeMenu),
      {
        forceMount: r = n.forceMount,
        ...o
      } = t,
      s = aa(jo, t.__scopeMenu),
      i = Dh(jo, t.__scopeMenu);
    return g.createElement(Uf.Provider, {
      scope: t.__scopeMenu
    }, g.createElement(Wo, {
      present: r || s.open
    }, g.createElement(Uf.Slot, {
      scope: t.__scopeMenu
    }, i.modal ? g.createElement(Zae, G({}, o, {
      ref: e
    })) : g.createElement(Jae, G({}, o, {
      ref: e
    })))))
  }),
  Zae = g.forwardRef((t, e) => {
    const n = aa(jo, t.__scopeMenu),
      r = g.useRef(null),
      o = rt(e, r);
    return g.useEffect(() => {
      const s = r.current;
      if (s) return Ev(s)
    }, []), g.createElement(xE, G({}, t, {
      ref: o,
      trapFocus: n.open,
      disableOutsidePointerEvents: n.open,
      disableOutsideScroll: !0,
      onFocusOutside: ie(t.onFocusOutside, s => s.preventDefault(), {
        checkForDefaultPrevented: !1
      }),
      onDismiss: () => n.onOpenChange(!1)
    }))
  }),
  Jae = g.forwardRef((t, e) => {
    const n = aa(jo, t.__scopeMenu);
    return g.createElement(xE, G({}, t, {
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }))
  }),
  xE = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: s,
      onCloseAutoFocus: i,
      disableOutsidePointerEvents: a,
      onEntryFocus: c,
      onEscapeKeyDown: l,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      onDismiss: h,
      disableOutsideScroll: m,
      ...p
    } = t, b = aa(jo, n), w = Dh(jo, n), v = Rv(n), _ = e5(n), S = Hae(n), [x, E] = g.useState(null), k = g.useRef(null), C = rt(e, k, b.onContentChange), $ = g.useRef(0), I = g.useRef(""), R = g.useRef(0), M = g.useRef(null), j = g.useRef("right"), A = g.useRef(0), D = m ? xv : g.Fragment, N = m ? {
      as: Wi,
      allowPinchZoom: !0
    } : void 0, q = B => {
      var V, J;
      const ee = I.current + B,
        ye = S().filter(_e => !_e.disabled),
        ge = document.activeElement,
        ce = (V = ye.find(_e => _e.ref.current === ge)) === null || V === void 0 ? void 0 : V.textValue,
        Ce = ye.map(_e => _e.textValue),
        oe = mce(Ce, ee, ce),
        pe = (J = ye.find(_e => _e.textValue === oe)) === null || J === void 0 ? void 0 : J.ref.current;
      (function _e(xe) {
        I.current = xe, window.clearTimeout($.current), xe !== "" && ($.current = window.setTimeout(() => _e(""), 1e3))
      })(ee), pe && setTimeout(() => pe.focus())
    };
    g.useEffect(() => () => window.clearTimeout($.current), []), Sv();
    const F = g.useCallback(B => {
      var V, J;
      return j.current === ((V = M.current) === null || V === void 0 ? void 0 : V.side) && vce(B, (J = M.current) === null || J === void 0 ? void 0 : J.area)
    }, []);
    return g.createElement(qae, {
      scope: n,
      searchRef: I,
      onItemEnter: g.useCallback(B => {
        F(B) && B.preventDefault()
      }, [F]),
      onItemLeave: g.useCallback(B => {
        var V;
        F(B) || ((V = k.current) === null || V === void 0 || V.focus(), E(null))
      }, [F]),
      onTriggerLeave: g.useCallback(B => {
        F(B) && B.preventDefault()
      }, [F]),
      pointerGraceTimerRef: R,
      onPointerGraceIntentChange: g.useCallback(B => {
        M.current = B
      }, [])
    }, g.createElement(D, N, g.createElement(sE, {
      asChild: !0,
      trapped: o,
      onMountAutoFocus: ie(s, B => {
        var V;
        B.preventDefault(), (V = k.current) === null || V === void 0 || V.focus()
      }),
      onUnmountAutoFocus: i
    }, g.createElement(oE, {
      asChild: !0,
      disableOutsidePointerEvents: a,
      onEscapeKeyDown: l,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      onDismiss: h
    }, g.createElement(Nae, G({
      asChild: !0
    }, _, {
      dir: w.dir,
      orientation: "vertical",
      loop: r,
      currentTabStopId: x,
      onCurrentTabStopIdChange: E,
      onEntryFocus: ie(c, B => {
        w.isUsingKeyboardRef.current || B.preventDefault()
      })
    }), g.createElement(qD, G({
      role: "menu",
      "aria-orientation": "vertical",
      "data-state": d5(b.open),
      "data-radix-menu-content": "",
      dir: w.dir
    }, v, p, {
      ref: C,
      style: {
        outline: "none",
        ...p.style
      },
      onKeyDown: ie(p.onKeyDown, B => {
        const J = B.target.closest("[data-radix-menu-content]") === B.currentTarget,
          ee = B.ctrlKey || B.altKey || B.metaKey,
          ye = B.key.length === 1;
        J && (B.key === "Tab" && B.preventDefault(), !ee && ye && q(B.key));
        const ge = k.current;
        if (B.target !== ge || !Bae.includes(B.key)) return;
        B.preventDefault();
        const Ce = S().filter(oe => !oe.disabled).map(oe => oe.ref.current);
        QD.includes(B.key) && Ce.reverse(), pce(Ce)
      }),
      onBlur: ie(t.onBlur, B => {
        B.currentTarget.contains(B.target) || (window.clearTimeout($.current), I.current = "")
      }),
      onPointerMove: ie(t.onPointerMove, zf(B => {
        const V = B.target,
          J = A.current !== B.clientX;
        if (B.currentTarget.contains(V) && J) {
          const ee = B.clientX > A.current ? "right" : "left";
          j.current = ee, A.current = B.clientX
        }
      }))
    })))))))
  }),
  s5 = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      ...r
    } = t;
    return g.createElement(Ke.div, G({
      role: "group"
    }, r, {
      ref: e
    }))
  }),
  E_ = "MenuItem",
  l$ = "menu.itemSelect",
  EE = g.forwardRef((t, e) => {
    const {
      disabled: n = !1,
      onSelect: r,
      ...o
    } = t, s = g.useRef(null), i = Dh(E_, t.__scopeMenu), a = _E(E_, t.__scopeMenu), c = rt(e, s), l = g.useRef(!1), u = () => {
      const d = s.current;
      if (!n && d) {
        const f = new CustomEvent(l$, {
          bubbles: !0,
          cancelable: !0
        });
        d.addEventListener(l$, h => r == null ? void 0 : r(h), {
          once: !0
        }), Rh(d, f), f.defaultPrevented ? l.current = !1 : i.onClose()
      }
    };
    return g.createElement(i5, G({}, o, {
      ref: c,
      disabled: n,
      onClick: ie(t.onClick, u),
      onPointerDown: d => {
        var f;
        (f = t.onPointerDown) === null || f === void 0 || f.call(t, d), l.current = !0
      },
      onPointerUp: ie(t.onPointerUp, d => {
        var f;
        l.current || (f = d.currentTarget) === null || f === void 0 || f.click()
      }),
      onKeyDown: ie(t.onKeyDown, d => {
        const f = a.searchRef.current !== "";
        n || f && d.key === " " || x_.includes(d.key) && (d.currentTarget.click(), d.preventDefault())
      })
    }))
  }),
  i5 = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      disabled: r = !1,
      textValue: o,
      ...s
    } = t, i = _E(E_, n), a = e5(n), c = g.useRef(null), l = rt(e, c), [u, d] = g.useState(!1), [f, h] = g.useState("");
    return g.useEffect(() => {
      const m = c.current;
      if (m) {
        var p;
        h(((p = m.textContent) !== null && p !== void 0 ? p : "").trim())
      }
    }, [s.children]), g.createElement(Uf.ItemSlot, {
      scope: n,
      disabled: r,
      textValue: o ?? f
    }, g.createElement(Lae, G({
      asChild: !0
    }, a, {
      focusable: !r
    }), g.createElement(Ke.div, G({
      role: "menuitem",
      "data-highlighted": u ? "" : void 0,
      "aria-disabled": r || void 0,
      "data-disabled": r ? "" : void 0
    }, s, {
      ref: l,
      onPointerMove: ie(t.onPointerMove, zf(m => {
        r ? i.onItemLeave(m) : (i.onItemEnter(m), m.defaultPrevented || m.currentTarget.focus())
      })),
      onPointerLeave: ie(t.onPointerLeave, zf(m => i.onItemLeave(m))),
      onFocus: ie(t.onFocus, () => d(!0)),
      onBlur: ie(t.onBlur, () => d(!1))
    }))))
  }),
  Qae = g.forwardRef((t, e) => {
    const {
      checked: n = !1,
      onCheckedChange: r,
      ...o
    } = t;
    return g.createElement(c5, {
      scope: t.__scopeMenu,
      checked: n
    }, g.createElement(EE, G({
      role: "menuitemcheckbox",
      "aria-checked": Qm(n) ? "mixed" : n
    }, o, {
      ref: e,
      "data-state": kE(n),
      onSelect: ie(o.onSelect, () => r == null ? void 0 : r(Qm(n) ? !0 : !n), {
        checkForDefaultPrevented: !1
      })
    })))
  }),
  ece = "MenuRadioGroup",
  [tce, nce] = yc(ece, {
    value: void 0,
    onValueChange: () => {}
  }),
  rce = g.forwardRef((t, e) => {
    const {
      value: n,
      onValueChange: r,
      ...o
    } = t, s = At(r);
    return g.createElement(tce, {
      scope: t.__scopeMenu,
      value: n,
      onValueChange: s
    }, g.createElement(s5, G({}, o, {
      ref: e
    })))
  }),
  oce = "MenuRadioItem",
  sce = g.forwardRef((t, e) => {
    const {
      value: n,
      ...r
    } = t, o = nce(oce, t.__scopeMenu), s = n === o.value;
    return g.createElement(c5, {
      scope: t.__scopeMenu,
      checked: s
    }, g.createElement(EE, G({
      role: "menuitemradio",
      "aria-checked": s
    }, r, {
      ref: e,
      "data-state": kE(s),
      onSelect: ie(r.onSelect, () => {
        var i;
        return (i = o.onValueChange) === null || i === void 0 ? void 0 : i.call(o, n)
      }, {
        checkForDefaultPrevented: !1
      })
    })))
  }),
  a5 = "MenuItemIndicator",
  [c5, ice] = yc(a5, {
    checked: !1
  }),
  ace = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      forceMount: r,
      ...o
    } = t, s = ice(a5, n);
    return g.createElement(Wo, {
      present: r || Qm(s.checked) || s.checked === !0
    }, g.createElement(Ke.span, G({}, o, {
      ref: e,
      "data-state": kE(s.checked)
    })))
  }),
  cce = g.forwardRef((t, e) => {
    const {
      __scopeMenu: n,
      ...r
    } = t;
    return g.createElement(Ke.div, G({
      role: "separator",
      "aria-orientation": "horizontal"
    }, r, {
      ref: e
    }))
  }),
  l5 = "MenuSub",
  [lce, u5] = yc(l5),
  uce = t => {
    const {
      __scopeMenu: e,
      children: n,
      open: r = !1,
      onOpenChange: o
    } = t, s = aa(l5, e), i = Rv(e), [a, c] = g.useState(null), [l, u] = g.useState(null), d = At(o);
    return g.useEffect(() => (s.open === !1 && d(!1), () => d(!1)), [s.open, d]), g.createElement(wE, i, g.createElement(t5, {
      scope: e,
      open: r,
      onOpenChange: d,
      content: l,
      onContentChange: u
    }, g.createElement(lce, {
      scope: e,
      contentId: Mo(),
      triggerId: Mo(),
      trigger: a,
      onTriggerChange: c
    }, n)))
  },
  rg = "MenuSubTrigger",
  dce = g.forwardRef((t, e) => {
    const n = aa(rg, t.__scopeMenu),
      r = Dh(rg, t.__scopeMenu),
      o = u5(rg, t.__scopeMenu),
      s = _E(rg, t.__scopeMenu),
      i = g.useRef(null),
      {
        pointerGraceTimerRef: a,
        onPointerGraceIntentChange: c
      } = s,
      l = {
        __scopeMenu: t.__scopeMenu
      },
      u = g.useCallback(() => {
        i.current && window.clearTimeout(i.current), i.current = null
      }, []);
    return g.useEffect(() => u, [u]), g.useEffect(() => {
      const d = a.current;
      return () => {
        window.clearTimeout(d), c(null)
      }
    }, [a, c]), g.createElement(n5, G({
      asChild: !0
    }, l), g.createElement(i5, G({
      id: o.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": n.open,
      "aria-controls": o.contentId,
      "data-state": d5(n.open)
    }, t, {
      ref: gv(e, o.onTriggerChange),
      onClick: d => {
        var f;
        (f = t.onClick) === null || f === void 0 || f.call(t, d), !(t.disabled || d.defaultPrevented) && (d.currentTarget.focus(), n.open || n.onOpenChange(!0))
      },
      onPointerMove: ie(t.onPointerMove, zf(d => {
        s.onItemEnter(d), !d.defaultPrevented && !t.disabled && !n.open && !i.current && (s.onPointerGraceIntentChange(null), i.current = window.setTimeout(() => {
          n.onOpenChange(!0), u()
        }, 100))
      })),
      onPointerLeave: ie(t.onPointerLeave, zf(d => {
        var f;
        u();
        const h = (f = n.content) === null || f === void 0 ? void 0 : f.getBoundingClientRect();
        if (h) {
          var m;
          const p = (m = n.content) === null || m === void 0 ? void 0 : m.dataset.side,
            b = p === "right",
            w = b ? -5 : 5,
            v = h[b ? "left" : "right"],
            _ = h[b ? "right" : "left"];
          s.onPointerGraceIntentChange({
            area: [{
              x: d.clientX + w,
              y: d.clientY
            }, {
              x: v,
              y: h.top
            }, {
              x: _,
              y: h.top
            }, {
              x: _,
              y: h.bottom
            }, {
              x: v,
              y: h.bottom
            }],
            side: p
          }), window.clearTimeout(a.current), a.current = window.setTimeout(() => s.onPointerGraceIntentChange(null), 300)
        } else {
          if (s.onTriggerLeave(d), d.defaultPrevented) return;
          s.onPointerGraceIntentChange(null)
        }
      })),
      onKeyDown: ie(t.onKeyDown, d => {
        const f = s.searchRef.current !== "";
        if (!(t.disabled || f && d.key === " ") && Uae[r.dir].includes(d.key)) {
          var h;
          n.onOpenChange(!0), (h = n.content) === null || h === void 0 || h.focus(), d.preventDefault()
        }
      })
    })))
  }),
  fce = "MenuSubContent",
  hce = g.forwardRef((t, e) => {
    const n = o5(jo, t.__scopeMenu),
      {
        forceMount: r = n.forceMount,
        ...o
      } = t,
      s = aa(jo, t.__scopeMenu),
      i = Dh(jo, t.__scopeMenu),
      a = u5(fce, t.__scopeMenu),
      c = g.useRef(null),
      l = rt(e, c);
    return g.createElement(Uf.Provider, {
      scope: t.__scopeMenu
    }, g.createElement(Wo, {
      present: r || s.open
    }, g.createElement(Uf.Slot, {
      scope: t.__scopeMenu
    }, g.createElement(xE, G({
      id: a.contentId,
      "aria-labelledby": a.triggerId
    }, o, {
      ref: l,
      align: "start",
      side: i.dir === "rtl" ? "left" : "right",
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      trapFocus: !1,
      onOpenAutoFocus: u => {
        var d;
        i.isUsingKeyboardRef.current && ((d = c.current) === null || d === void 0 || d.focus()), u.preventDefault()
      },
      onCloseAutoFocus: u => u.preventDefault(),
      onFocusOutside: ie(t.onFocusOutside, u => {
        u.target !== a.trigger && s.onOpenChange(!1)
      }),
      onEscapeKeyDown: ie(t.onEscapeKeyDown, u => {
        i.onClose(), u.preventDefault()
      }),
      onKeyDown: ie(t.onKeyDown, u => {
        const d = u.currentTarget.contains(u.target),
          f = zae[i.dir].includes(u.key);
        if (d && f) {
          var h;
          s.onOpenChange(!1), (h = a.trigger) === null || h === void 0 || h.focus(), u.preventDefault()
        }
      })
    })))))
  });

function d5(t) {
  return t ? "open" : "closed"
}

function Qm(t) {
  return t === "indeterminate"
}

function kE(t) {
  return Qm(t) ? "indeterminate" : t ? "checked" : "unchecked"
}

function pce(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return
}

function gce(t, e) {
  return t.map((n, r) => t[(e + r) % t.length])
}

function mce(t, e, n) {
  const o = e.length > 1 && Array.from(e).every(l => l === e[0]) ? e[0] : e,
    s = n ? t.indexOf(n) : -1;
  let i = gce(t, Math.max(s, 0));
  o.length === 1 && (i = i.filter(l => l !== n));
  const c = i.find(l => l.toLowerCase().startsWith(o.toLowerCase()));
  return c !== n ? c : void 0
}

function yce(t, e) {
  const {
    x: n,
    y: r
  } = t;
  let o = !1;
  for (let s = 0, i = e.length - 1; s < e.length; i = s++) {
    const a = e[s].x,
      c = e[s].y,
      l = e[i].x,
      u = e[i].y;
    c > r != u > r && n < (l - a) * (r - c) / (u - c) + a && (o = !o)
  }
  return o
}

function vce(t, e) {
  if (!e) return !1;
  const n = {
    x: t.clientX,
    y: t.clientY
  };
  return yce(n, e)
}

function zf(t) {
  return e => e.pointerType === "mouse" ? t(e) : void 0
}
const f5 = Kae,
  h5 = n5,
  p5 = Yae,
  g5 = Xae,
  m5 = s5,
  y5 = EE,
  v5 = Qae,
  bce = rce,
  wce = sce,
  Sce = ace,
  _ce = cce,
  b5 = uce,
  w5 = dce,
  S5 = hce,
  _5 = "DropdownMenu",
  [xce, Rbe] = Vo(_5, [Ov]),
  Er = Ov(),
  [Ece, x5] = xce(_5),
  kce = t => {
    const {
      __scopeDropdownMenu: e,
      children: n,
      dir: r,
      open: o,
      defaultOpen: s,
      onOpenChange: i,
      modal: a = !0
    } = t, c = Er(e), l = g.useRef(null), [u = !1, d] = Xs({
      prop: o,
      defaultProp: s,
      onChange: i
    });
    return g.createElement(Ece, {
      scope: e,
      triggerId: Mo(),
      triggerRef: l,
      contentId: Mo(),
      open: u,
      onOpenChange: d,
      onOpenToggle: g.useCallback(() => d(f => !f), [d]),
      modal: a
    }, g.createElement(f5, G({}, c, {
      open: u,
      onOpenChange: d,
      dir: r,
      modal: a
    }), n))
  },
  Cce = "DropdownMenuTrigger",
  Pce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      disabled: r = !1,
      ...o
    } = t, s = x5(Cce, n), i = Er(n);
    return g.createElement(h5, G({
      asChild: !0
    }, i), g.createElement(Ke.button, G({
      type: "button",
      id: s.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": s.open,
      "aria-controls": s.open ? s.contentId : void 0,
      "data-state": s.open ? "open" : "closed",
      "data-disabled": r ? "" : void 0,
      disabled: r
    }, o, {
      ref: gv(e, s.triggerRef),
      onPointerDown: ie(t.onPointerDown, a => {
        !r && a.button === 0 && a.ctrlKey === !1 && (s.onOpenToggle(), s.open || a.preventDefault())
      }),
      onKeyDown: ie(t.onKeyDown, a => {
        r || (["Enter", " "].includes(a.key) && s.onOpenToggle(), a.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault())
      })
    })))
  }),
  Tce = t => {
    const {
      __scopeDropdownMenu: e,
      ...n
    } = t, r = Er(e);
    return g.createElement(p5, G({}, r, n))
  },
  $ce = "DropdownMenuContent",
  Ice = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = x5($ce, n), s = Er(n), i = g.useRef(!1);
    return g.createElement(g5, G({
      id: o.contentId,
      "aria-labelledby": o.triggerId
    }, s, r, {
      ref: e,
      onCloseAutoFocus: ie(t.onCloseAutoFocus, a => {
        var c;
        i.current || (c = o.triggerRef.current) === null || c === void 0 || c.focus(), i.current = !1, a.preventDefault()
      }),
      onInteractOutside: ie(t.onInteractOutside, a => {
        const c = a.detail.originalEvent,
          l = c.button === 0 && c.ctrlKey === !0,
          u = c.button === 2 || l;
        (!o.modal || u) && (i.current = !0)
      }),
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))
  }),
  Oce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(m5, G({}, o, r, {
      ref: e
    }))
  }),
  Rce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(y5, G({}, o, r, {
      ref: e
    }))
  }),
  Ace = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(v5, G({}, o, r, {
      ref: e
    }))
  }),
  Mce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(bce, G({}, o, r, {
      ref: e
    }))
  }),
  jce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(wce, G({}, o, r, {
      ref: e
    }))
  }),
  Dce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(Sce, G({}, o, r, {
      ref: e
    }))
  }),
  Nce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(_ce, G({}, o, r, {
      ref: e
    }))
  }),
  Lce = t => {
    const {
      __scopeDropdownMenu: e,
      children: n,
      open: r,
      onOpenChange: o,
      defaultOpen: s
    } = t, i = Er(e), [a = !1, c] = Xs({
      prop: r,
      defaultProp: s,
      onChange: o
    });
    return g.createElement(b5, G({}, i, {
      open: a,
      onOpenChange: c
    }), n)
  },
  Fce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(w5, G({}, o, r, {
      ref: e
    }))
  }),
  Bce = g.forwardRef((t, e) => {
    const {
      __scopeDropdownMenu: n,
      ...r
    } = t, o = Er(n);
    return g.createElement(S5, G({}, o, r, {
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))
  }),
  E5 = kce,
  Hf = Pce,
  CE = Tce,
  k5 = Ice,
  Uce = Oce,
  Zc = Rce,
  C5 = Ace,
  Abe = Mce,
  Mbe = jce,
  P5 = Dce,
  jbe = Nce,
  zce = Lce,
  Hce = Fce,
  Vce = Bce;

function vc(t, e) {
  const n = Y(),
    r = g.useRef(!1),
    o = $u(),
    s = g.useRef(0),
    i = g.useCallback(c => {
      const l = Date.now();
      l - s.current < 50 || (s.current = l, r.current = c, n.batch(() => {
        c ? (n.complete(), n.addOpenMenu(t)) : n.updateInstanceState({
          openMenus: n.getOpenMenus().filter(u => !u.startsWith(t))
        }), e == null || e(c)
      }))
    }, [n, t, e]),
    a = te("is menu open", () => n.getOpenMenus().includes(t), [n, t]);
  return g.useEffect(() => (r.current && (o("open-menu", {
    source: "unknown",
    id: t
  }), n.addOpenMenu(t)), () => {
    r.current && (n.deleteOpenMenu(t), n.getOpenMenus().forEach(c => {
      c.startsWith(t) && (o("close-menu", {
        source: "unknown",
        id: t
      }), n.deleteOpenMenu(c))
    }), r.current = !1)
  }), [n, t, o]), [a, i]
}

function Js({
  id: t,
  children: e,
  modal: n = !1,
  debugOpen: r = !1
}) {
  const [o, s] = vc(t);
  return y.jsx(E5, {
    open: r || o,
    dir: "ltr",
    modal: n,
    onOpenChange: s,
    children: e
  })
}

function Ou({
  children: t,
  "data-testid": e
}) {
  return y.jsx(Hf, {
    dir: "ltr",
    "data-testid": e,
    asChild: !0,
    onTouchEnd: n => at(n),
    children: t
  })
}

function Qs({
  side: t = "bottom",
  align: e = "start",
  sideOffset: n = 8,
  alignOffset: r = 8,
  children: o
}) {
  const s = Rn();
  return y.jsx(CE, {
    container: s,
    children: y.jsx(k5, {
      className: "tlui-menu",
      align: e,
      sideOffset: n,
      side: t,
      alignOffset: r,
      collisionPadding: 4,
      children: o
    })
  })
}

function Av({
  id: t,
  children: e
}) {
  const [n, r] = vc(t);
  return y.jsx(zce, {
    open: n,
    onOpenChange: r,
    children: e
  })
}

function Mv({
  label: t,
  "data-testid": e,
  "data-direction": n
}) {
  return y.jsx(Hce, {
    dir: "ltr",
    "data-direction": n,
    "data-testid": e,
    asChild: !0,
    children: y.jsx(me, {
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      label: t,
      icon: "chevron-right"
    })
  })
}

function jv({
  alignOffset: t = 0,
  sideOffset: e = 5,
  children: n
}) {
  const r = Rn();
  return y.jsx(CE, {
    container: r,
    children: y.jsx(Vce, {
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: t,
      sideOffset: e,
      collisionPadding: 4,
      children: n
    })
  })
}

function ls({
  children: t,
  size: e = "medium"
}) {
  return y.jsx(Uce, {
    dir: "ltr",
    className: "tlui-menu__group",
    "data-size": e,
    children: t
  })
}

function Wce() {
  return y.jsx(P5, {
    dir: "ltr",
    asChild: !0,
    children: y.jsx(wr, {
      icon: "check"
    })
  })
}

function fr({
  noClose: t,
  ...e
}) {
  return y.jsx(Zc, {
    dir: "ltr",
    asChild: !0,
    onClick: t || e.isChecked !== void 0 ? at : void 0,
    children: y.jsx(me, {
      ...e
    })
  })
}

function PE({
  children: t,
  onSelect: e,
  ...n
}) {
  return y.jsxs(C5, {
    dir: "ltr",
    className: "tlui-button tlui-button__menu tlui-button__checkbox",
    onSelect: r => {
      e == null || e(r), at(r)
    },
    ...n,
    children: [y.jsx(wr, {
      small: !0,
      icon: n.checked ? "check" : "checkbox-empty"
    }), t]
  })
}

function T5({
  children: t,
  onSelect: e,
  ...n
}) {
  return y.jsxs(C5, {
    dir: "ltr",
    className: "tlui-button tlui-button__menu tlui-button__checkbox",
    onSelect: r => {
      e == null || e(r), at(r)
    },
    ...n,
    children: [y.jsx("div", {
      className: "tlui-button__checkbox__indicator",
      children: y.jsx(P5, {
        dir: "ltr",
        children: y.jsx(wr, {
          icon: "check",
          small: !0
        })
      })
    }), t]
  })
}
const Dbe = Object.freeze(Object.defineProperty({
  __proto__: null,
  CheckboxItem: PE,
  Content: Qs,
  Group: ls,
  Indicator: Wce,
  Item: fr,
  RadioItem: T5,
  Root: Js,
  Sub: Av,
  SubContent: jv,
  SubTrigger: Mv,
  Trigger: Ou
}, Symbol.toStringTag, {
  value: "Module"
}));
let u$ = 0;

function Kce(t, e) {
  const n = Array(e),
    r = Math.floor(Math.sqrt(e));
  for (let o = 0; o < e; o++) u$++, n[o] = {
    id: is("box" + u$),
    type: "geo",
    x: o % r * 132,
    y: Math.floor(o / r) * 132
  };
  t.batch(() => {
    t.createShapes(n).setSelectedShapes(n.map(o => o.id))
  })
}
const Gce = g.memo(function({
    renderDebugMenuItems: e
  }) {
    const n = nt();
    return y.jsxs("div", {
      className: "tlui-debug-panel",
      children: [y.jsx(Yce, {}), y.jsx(qce, {}), y.jsxs(Js, {
        id: "debug",
        children: [y.jsx(Ou, {
          children: y.jsx(me, {
            type: "icon",
            icon: "dots-horizontal",
            title: n("debug-panel.more")
          })
        }), y.jsx(Qs, {
          side: "top",
          align: "end",
          alignOffset: 0,
          children: y.jsx(Xce, {
            renderDebugMenuItems: e
          })
        })]
      })]
    })
  }),
  Yce = pt(function() {
    const e = Y();
    return y.jsx("div", {
      className: "tlui-debug-panel__current-state",
      children: e.root.path.get()
    })
  }),
  qce = function() {
    const e = Y(),
      n = te("rendering shapes count", () => e.renderingShapes.length, [e]);
    return y.jsxs("div", {
      children: [n, " Shapes"]
    })
  },
  Xce = pt(function({
    renderDebugMenuItems: e
  }) {
    const n = Y(),
      {
        addToast: r
      } = bs(),
      {
        addDialog: o
      } = gc(),
      [s, i] = g.useState(!1);
    return y.jsxs(y.Fragment, {
      children: [y.jsxs(ls, {
        children: [y.jsx(fr, {
          type: "menu",
          onClick: () => {
            r({
              id: It(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !1
            }), r({
              id: It(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              icon: "twitter",
              actions: [{
                label: "Primary",
                type: "primary",
                onClick: () => {}
              }, {
                label: "Normal",
                type: "normal",
                onClick: () => {}
              }, {
                label: "Danger",
                type: "danger",
                onClick: () => {}
              }]
            })
          },
          label: "Show toast"
        }), y.jsx(fr, {
          type: "menu",
          onClick: () => {
            o({
              component: ({
                onClose: a
              }) => y.jsx(Jce, {
                displayDontShowAgain: !0,
                onCancel: () => {
                  a()
                },
                onContinue: () => {
                  a()
                }
              }),
              onClose: () => {}
            })
          },
          label: "Show dialog"
        }), y.jsx(fr, {
          type: "menu",
          onClick: () => Kce(n, 100),
          label: "Create 100 shapes"
        }), y.jsx(fr, {
          type: "menu",
          onClick: () => {
            function a({
              children: f
            }) {
              let h = 0;
              if (!f.length) return 0;
              for (const m of [...f]) h++, h += a(m);
              return h
            }
            const c = n.getSelectedShapes(),
              l = c.length === 0 ? n.renderingShapes : c,
              u = l.map(f => document.getElementById(f.id).parentElement);
            let d = u.length;
            for (const f of u) d += a(f);
            window.alert(`Shapes ${l.length}, DOM nodes:${d}`)
          },
          label: "Count shapes / nodes"
        }), (() => {
          if (s) throw Error("oh no!")
        })(), y.jsx(fr, {
          type: "menu",
          onClick: () => {
            i(!0)
          },
          label: "Throw error"
        }), y.jsx(fr, {
          type: "menu",
          onClick: () => {
            qA()
          },
          label: "Hard reset"
        })]
      }), y.jsxs(ls, {
        children: [y.jsx(pd, {
          flag: Nt.debugSvg
        }), y.jsx(pd, {
          flag: Nt.forceSrgb
        }), y.jsx(pd, {
          flag: Nt.debugGeometry
        }), y.jsx(pd, {
          flag: Nt.hideShapes
        })]
      }), y.jsx(ls, {
        children: Object.values(HH).map(a => y.jsx(pd, {
          flag: a
        }, a.name))
      }), e == null ? void 0 : e()]
    })
  });

function Zce({
  label: t,
  value: e,
  onChange: n
}) {
  return y.jsx(PE, {
    title: t,
    checked: e,
    onSelect: () => n(!e),
    children: y.jsx("span", {
      className: "tlui-button__label",
      draggable: !1,
      children: t
    })
  })
}
const pd = pt(function({
  flag: e,
  onChange: n
}) {
  return y.jsx(Zce, {
    label: e.name.replace(/([a-z0-9])([A-Z])/g, r => `${r[0]} ${r[1].toLowerCase()}`).replace(/^[a-z]/, r => r.toUpperCase()),
    value: e.get(),
    onChange: r => {
      e.set(r), n == null || n(r)
    }
  })
});

function Jce({
  title: t = "title",
  body: e = "hello hello hello",
  cancel: n = "Cancel",
  confirm: r = "Continue",
  displayDontShowAgain: o = !1,
  onCancel: s,
  onContinue: i
}) {
  const [a, c] = g.useState(!1);
  return y.jsxs(y.Fragment, {
    children: [y.jsxs(Ah, {
      children: [y.jsx(Mh, {
        children: t
      }), y.jsx(jh, {})]
    }), y.jsx(su, {
      style: {
        maxWidth: 350
      },
      children: e
    }), y.jsxs(kv, {
      className: "tlui-dialog__footer__actions",
      children: [o && y.jsx(me, {
        type: "normal",
        onClick: () => c(!a),
        iconLeft: a ? "check" : "checkbox-empty",
        style: {
          marginRight: "auto"
        },
        children: "Don't show again"
      }), y.jsx(me, {
        type: "normal",
        onClick: s,
        children: n
      }), y.jsx(me, {
        type: "primary",
        onClick: async () => i(),
        children: r
      })]
    })]
  })
}
const Qce = ({
  id: t,
  component: e,
  onClose: n
}) => {
  const {
    removeDialog: r
  } = gc(), o = Rn(), s = g.useCallback(i => {
    if (!i) {
      if (n) try {
        n()
      } catch (a) {
        console.warn(a)
      }
      r(t)
    }
  }, [t, n, r]);
  return y.jsx(zj, {
    onOpenChange: s,
    defaultOpen: !0,
    children: y.jsx(Hj, {
      container: o,
      children: y.jsx(Vj, {
        dir: "ltr",
        className: "tlui-dialog__overlay",
        children: y.jsx(Wj, {
          dir: "ltr",
          className: "tlui-dialog__content",
          children: y.jsx(e, {
            onClose: () => s(!1)
          })
        })
      })
    })
  })
};

function ele() {
  const {
    dialogs: t
  } = gc();
  return y.jsx(y.Fragment, {
    children: t.map(e => y.jsx(Qce, {
      ...e
    }, e.id))
  })
}
const tle = se.memo(ele);

function nle() {
  const t = Y(),
    e = te("follow", () => t.getInstanceState().followingUserId, [t]);
  return e ? y.jsx(rle, {
    userId: e
  }) : null
}

function rle({
  userId: t
}) {
  const e = h3(t);
  return e ? y.jsx("div", {
    className: "tlui-following-indicator",
    style: {
      borderColor: e.color
    }
  }) : null
}

function $5() {
  const t = Y(),
    {
      languages: e,
      currentLanguage: n
    } = mD(),
    r = g.useCallback(o => t.user.updateUserPreferences({
      locale: o
    }), [t]);
  return y.jsxs(Av, {
    id: "help menu language",
    children: [y.jsx(Mv, {
      label: "menu.language",
      "data-direction": "left"
    }), y.jsx(jv, {
      sideOffset: -4,
      children: y.jsx(ls, {
        children: e.map(({
          locale: o,
          label: s
        }) => y.jsx(T5, {
          title: o,
          checked: o === n,
          onSelect: () => r(o),
          children: y.jsx("span", {
            className: "tlui-button__label",
            children: s
          })
        }, o))
      })
    })]
  })
}
const ole = g.memo(function() {
  const e = Rn(),
    n = nt(),
    [r, o] = vc("help menu");
  return y.jsx("div", {
    className: "tlui-help-menu",
    children: y.jsxs(E5, {
      dir: "ltr",
      open: r,
      onOpenChange: o,
      modal: !1,
      children: [y.jsx(Hf, {
        asChild: !0,
        dir: "ltr",
        children: y.jsx(me, {
          type: "help",
          className: "tlui-button",
          smallIcon: !0,
          title: n("help-menu.title"),
          icon: "question-mark"
        })
      }), y.jsx(CE, {
        container: e,
        children: y.jsx(k5, {
          className: "tlui-menu",
          side: "top",
          sideOffset: 8,
          align: "end",
          alignOffset: 0,
          collisionPadding: 4,
          children: y.jsx(sle, {})
        })
      })]
    })
  })
});

function sle() {
  const t = Yie(),
    e = lo();

  function n(r) {
    if (e && !r.readonlyOk) return null;
    switch (r.type) {
      case "custom": {
        if (r.id === "LANGUAGE_MENU") return y.jsx($5, {}, "item");
        break
      }
      case "group":
        return y.jsx(ls, {
          size: "small",
          children: r.children.map(n)
        }, r.id);
      case "submenu":
        return y.jsxs(Av, {
          id: `help menu ${r.id}`,
          children: [y.jsx(Mv, {
            label: r.label
          }), y.jsx(jv, {
            children: r.children.map(n)
          })]
        }, r.id);
      case "item": {
        const {
          id: o,
          kbd: s,
          label: i,
          onSelect: a,
          icon: c
        } = r.actionItem;
        return y.jsx(fr, {
          type: "menu",
          kbd: s,
          label: i,
          onClick: () => a("help-menu"),
          iconLeft: c
        }, o)
      }
    }
  }
  return y.jsx(y.Fragment, {
    children: t.map(n)
  })
}
const I5 = "Popover",
  [O5, Nbe] = Vo(I5, [$v]),
  TE = $v(),
  [ile, Ru] = O5(I5),
  ale = t => {
    const {
      __scopePopover: e,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: s,
      modal: i = !1
    } = t, a = TE(e), c = g.useRef(null), [l, u] = g.useState(!1), [d = !1, f] = Xs({
      prop: r,
      defaultProp: o,
      onChange: s
    });
    return g.createElement(wE, a, g.createElement(ile, {
      scope: e,
      contentId: Mo(),
      triggerRef: c,
      open: d,
      onOpenChange: f,
      onOpenToggle: g.useCallback(() => f(h => !h), [f]),
      hasCustomAnchor: l,
      onCustomAnchorAdd: g.useCallback(() => u(!0), []),
      onCustomAnchorRemove: g.useCallback(() => u(!1), []),
      modal: i
    }, n))
  },
  cle = "PopoverTrigger",
  lle = g.forwardRef((t, e) => {
    const {
      __scopePopover: n,
      ...r
    } = t, o = Ru(cle, n), s = TE(n), i = rt(e, o.triggerRef), a = g.createElement(Ke.button, G({
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": o.open,
      "aria-controls": o.contentId,
      "data-state": M5(o.open)
    }, r, {
      ref: i,
      onClick: ie(t.onClick, o.onOpenToggle)
    }));
    return o.hasCustomAnchor ? a : g.createElement(YD, G({
      asChild: !0
    }, s), a)
  }),
  R5 = "PopoverPortal",
  [ule, dle] = O5(R5, {
    forceMount: void 0
  }),
  fle = t => {
    const {
      __scopePopover: e,
      forceMount: n,
      children: r,
      container: o
    } = t, s = Ru(R5, e);
    return g.createElement(ule, {
      scope: e,
      forceMount: n
    }, g.createElement(Wo, {
      present: n || s.open
    }, g.createElement(iE, {
      asChild: !0,
      container: o
    }, r)))
  },
  Vf = "PopoverContent",
  hle = g.forwardRef((t, e) => {
    const n = dle(Vf, t.__scopePopover),
      {
        forceMount: r = n.forceMount,
        ...o
      } = t,
      s = Ru(Vf, t.__scopePopover);
    return g.createElement(Wo, {
      present: r || s.open
    }, s.modal ? g.createElement(ple, G({}, o, {
      ref: e
    })) : g.createElement(gle, G({}, o, {
      ref: e
    })))
  }),
  ple = g.forwardRef((t, e) => {
    const n = Ru(Vf, t.__scopePopover),
      r = g.useRef(null),
      o = rt(e, r),
      s = g.useRef(!1);
    return g.useEffect(() => {
      const i = r.current;
      if (i) return Ev(i)
    }, []), g.createElement(xv, {
      as: Wi,
      allowPinchZoom: !0
    }, g.createElement(A5, G({}, t, {
      ref: o,
      trapFocus: n.open,
      disableOutsidePointerEvents: !0,
      onCloseAutoFocus: ie(t.onCloseAutoFocus, i => {
        var a;
        i.preventDefault(), s.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus()
      }),
      onPointerDownOutside: ie(t.onPointerDownOutside, i => {
        const a = i.detail.originalEvent,
          c = a.button === 0 && a.ctrlKey === !0,
          l = a.button === 2 || c;
        s.current = l
      }, {
        checkForDefaultPrevented: !1
      }),
      onFocusOutside: ie(t.onFocusOutside, i => i.preventDefault(), {
        checkForDefaultPrevented: !1
      })
    })))
  }),
  gle = g.forwardRef((t, e) => {
    const n = Ru(Vf, t.__scopePopover),
      r = g.useRef(!1),
      o = g.useRef(!1);
    return g.createElement(A5, G({}, t, {
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      onCloseAutoFocus: s => {
        var i;
        if ((i = t.onCloseAutoFocus) === null || i === void 0 || i.call(t, s), !s.defaultPrevented) {
          var a;
          r.current || (a = n.triggerRef.current) === null || a === void 0 || a.focus(), s.preventDefault()
        }
        r.current = !1, o.current = !1
      },
      onInteractOutside: s => {
        var i, a;
        (i = t.onInteractOutside) === null || i === void 0 || i.call(t, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (o.current = !0));
        const c = s.target;
        ((a = n.triggerRef.current) === null || a === void 0 ? void 0 : a.contains(c)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && o.current && s.preventDefault()
      }
    }))
  }),
  A5 = g.forwardRef((t, e) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: i,
      onEscapeKeyDown: a,
      onPointerDownOutside: c,
      onFocusOutside: l,
      onInteractOutside: u,
      ...d
    } = t, f = Ru(Vf, n), h = TE(n);
    return Sv(), g.createElement(sE, {
      asChild: !0,
      loop: !0,
      trapped: r,
      onMountAutoFocus: o,
      onUnmountAutoFocus: s
    }, g.createElement(oE, {
      asChild: !0,
      disableOutsidePointerEvents: i,
      onInteractOutside: u,
      onEscapeKeyDown: a,
      onPointerDownOutside: c,
      onFocusOutside: l,
      onDismiss: () => f.onOpenChange(!1)
    }, g.createElement(qD, G({
      "data-state": M5(f.open),
      role: "dialog",
      id: f.contentId
    }, h, d, {
      ref: e,
      style: {
        ...d.style,
        "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
        "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
        "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))))
  });

function M5(t) {
  return t ? "open" : "closed"
}
const mle = ale,
  yle = lle,
  j5 = fle,
  D5 = hle,
  $E = ({
    id: t,
    children: e,
    onOpenChange: n,
    open: r
  }) => {
    const [o, s] = vc(t, n);
    return y.jsx(mle, {
      onOpenChange: s,
      open: r || o,
      children: y.jsx("div", {
        className: "tlui-popover",
        children: e
      })
    })
  },
  IE = ({
    children: t,
    disabled: e,
    "data-testid": n
  }) => y.jsx(yle, {
    "data-testid": n,
    disabled: e,
    asChild: !0,
    dir: "ltr",
    children: t
  }),
  N5 = ({
    side: t,
    children: e,
    align: n = "center",
    sideOffset: r = 8,
    alignOffset: o = 0
  }) => {
    const s = Rn();
    return y.jsx(j5, {
      container: s,
      children: y.jsx(D5, {
        className: "tlui-popover__content",
        side: t,
        sideOffset: r,
        align: n,
        alignOffset: o,
        dir: "ltr",
        children: e
      })
    })
  },
  L5 = g.memo(function() {
    const e = nt(),
      n = Rn(),
      r = Bie(),
      o = lo();

    function s(i) {
      if (o && !i.readonlyOk) return null;
      switch (i.type) {
        case "item": {
          const {
            id: a,
            icon: c,
            label: l,
            kbd: u,
            onSelect: d
          } = i.actionItem;
          return y.jsx(me, {
            "data-testid": `menu-item.${i.id}`,
            icon: c,
            type: "icon",
            title: l ? u ? `${e(l)} ${fs(u)}` : `${e(l)}` : u ? `${fs(u)}` : "",
            onClick: () => d("actions-menu"),
            disabled: i.disabled
          }, a)
        }
      }
    }
    return y.jsxs($E, {
      id: "actions-menu",
      children: [y.jsx(IE, {
        children: y.jsx(me, {
          className: "tlui-menu__trigger",
          "data-testid": "main.action-menu",
          icon: "dots-vertical",
          title: e("actions-menu.title"),
          type: "icon",
          smallIcon: !0
        })
      }), y.jsx(j5, {
        container: n,
        children: y.jsx(D5, {
          className: "tlui-popover__content",
          side: "bottom",
          dir: "ltr",
          sideOffset: 6,
          children: y.jsx("div", {
            className: "tlui-actions-menu tlui-buttons__grid",
            children: r.map(s)
          })
        })
      })]
    })
  }),
  F5 = pt(function() {
    const e = Y(),
      n = Xn(),
      r = nt(),
      o = n.duplicate;
    return y.jsx(me, {
      icon: o.icon,
      type: "icon",
      onClick: () => o.onSelect("quick-actions"),
      disabled: !(e.isIn("select") && e.getSelectedShapeIds().length > 0),
      title: `${r(o.label)} ${fs(o.kbd)}`,
      smallIcon: !0
    })
  }),
  vle = g.memo(function() {
    const e = nt();
    return y.jsxs(Js, {
      id: "main menu",
      children: [y.jsx(Ou, {
        children: y.jsx(me, {
          type: "icon",
          className: "tlui-menu__trigger",
          "data-testid": "main.menu",
          title: e("menu.title"),
          icon: "menu",
          smallIcon: !0
        })
      }), y.jsx(Qs, {
        alignOffset: 0,
        sideOffset: 6,
        children: y.jsx(ble, {})
      })]
    })
  });

function ble() {
  const t = Y(),
    e = nt(),
    n = Xie(),
    r = uo(),
    o = lo();

  function s(i, a, c, l) {
    switch (a.type) {
      case "custom":
        return o && !a.readonlyOk ? null : a.id === "LANGUAGE_MENU" ? y.jsx($5, {}, "item") : null;
      case "group":
        return o && !a.readonlyOk ? null : y.jsx(ls, {
          size: l <= 1 ? "medium" : r < 3 || (c == null ? void 0 : c.type) === "submenu" && l > 2 ? "tiny" : "medium",
          children: a.children.map(u => s(i, u, a, l + 1))
        }, a.id);
      case "submenu":
        return o && !a.readonlyOk ? null : y.jsxs(Av, {
          id: `main menu ${c?c.id+" ":""}${a.id}`,
          children: [y.jsx(Mv, {
            label: a.label,
            "data-testid": `menu-item.${a.id}`
          }), y.jsx(jv, {
            sideOffset: -4,
            alignOffset: -1,
            children: a.children.map(u => s(i, u, a, l + 1))
          })]
        }, a.id);
      case "item": {
        if (o && !a.readonlyOk) return null;
        const {
          id: u,
          checkbox: d,
          menuLabel: f,
          label: h,
          onSelect: m,
          kbd: p
        } = a.actionItem, b = f ?? h, w = b ? e(b) : void 0;
        return d ? y.jsxs(PE, {
          onSelect: () => m("menu"),
          title: w || "",
          checked: a.checked,
          disabled: a.disabled,
          children: [w && y.jsx("span", {
            className: "tlui-button__label",
            children: w
          }), p && y.jsx(wv, {
            children: p
          })]
        }, u) : y.jsx(fr, {
          type: "menu",
          "data-testid": `menu-item.${a.id}`,
          kbd: p,
          label: b,
          onClick: () => m("menu"),
          disabled: a.disabled
        }, u)
      }
    }
  }
  return y.jsx(y.Fragment, {
    children: n.map(i => s(t, i, null, 0))
  })
}
const wle = function({
    name: e,
    id: n,
    isCurrentPage: r
  }) {
    const o = Y(),
      s = g.useRef(null),
      i = g.useCallback(c => {
        o.renamePage(n, c || "New Page", {
          ephemeral: !0
        })
      }, [o, n]),
      a = g.useCallback(c => {
        o.mark("rename page"), o.renamePage(n, c || "New Page", {
          ephemeral: !1
        })
      }, [o, n]);
    return y.jsx(cE, {
      className: "tlui-page-menu__item__input",
      ref: c => s.current = c,
      defaultValue: e,
      onValueChange: i,
      onComplete: a,
      onCancel: a,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autofocus: r,
      autoselect: !0
    })
  },
  k_ = (t, e, n, r) => {
    let o;
    const s = t.pages,
      i = n > r ? s[r - 1] : s[r],
      a = n > r ? s[r] : s[r + 1];
    i && !a ? o = yi(i.index) : !i && a ? o = gY(s[0].index) : o = Ag(i.index, a.index), o !== s[n].index && (t.mark("moving page"), t.updatePage({
      id: e,
      index: o
    }))
  },
  d$ = pt(function({
    index: e,
    listSize: n,
    item: r,
    onRename: o
  }) {
    const s = Y(),
      i = nt(),
      a = s.pages,
      c = g.useCallback(() => {
        s.mark("creating page");
        const f = Ys.createId();
        s.duplicatePage(r.id, f)
      }, [s, r]),
      l = g.useCallback(() => {
        k_(s, r.id, e, e - 1)
      }, [s, r, e]),
      u = g.useCallback(() => {
        k_(s, r.id, e, e + 1)
      }, [s, r, e]),
      d = g.useCallback(() => {
        s.mark("deleting page"), s.deletePage(r.id)
      }, [s, r]);
    return y.jsxs(Js, {
      id: `page item submenu ${e}`,
      children: [y.jsx(Ou, {
        children: y.jsx(me, {
          type: "icon",
          title: i("page-menu.submenu.title"),
          icon: "dots-vertical"
        })
      }), y.jsxs(Qs, {
        alignOffset: 0,
        children: [y.jsxs(ls, {
          children: [o && y.jsx(Zc, {
            dir: "ltr",
            onSelect: o,
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              label: "page-menu.submenu.rename"
            })
          }), y.jsx(Zc, {
            dir: "ltr",
            onSelect: c,
            disabled: a.length >= Rm,
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              label: "page-menu.submenu.duplicate-page"
            })
          }), e > 0 && y.jsx(Zc, {
            dir: "ltr",
            onSelect: l,
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              label: "page-menu.submenu.move-up"
            })
          }), e < n - 1 && y.jsx(Zc, {
            dir: "ltr",
            onSelect: u,
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              label: "page-menu.submenu.move-down"
            })
          })]
        }), n > 1 && y.jsx(ls, {
          children: y.jsx(Zc, {
            dir: "ltr",
            onSelect: d,
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              label: "page-menu.submenu.delete"
            })
          })
        })]
      })]
    })
  }),
  Sle = function() {
    const e = Y(),
      n = nt(),
      r = uo(),
      o = g.useCallback(() => b(!1), []),
      [s, i] = vc("page-menu", o),
      a = 36,
      c = g.useRef(null),
      l = te("pages", () => e.pages, [e]),
      u = te("currentPage", () => e.currentPage, [e]),
      d = te("currentPageId", () => e.currentPageId, [e]),
      f = lo(),
      h = te("maxPageCountReached", () => e.pages.length >= Rm, [e]),
      m = te("isCoarsePointer", () => e.getInstanceState().isCoarsePointer, [e]),
      [p, b] = g.useState(!1),
      w = g.useCallback(() => {
        f || b(I => !I)
      }, [f]),
      v = g.useRef({
        isPointing: !1,
        status: "idle",
        pointing: null,
        startY: 0,
        startIndex: 0,
        dragIndex: 0
      }),
      [_, S] = g.useState(Object.fromEntries(l.map((I, R) => [I.id, {
        y: R * a,
        offsetY: 0,
        isSelected: !1
      }])));
    g.useLayoutEffect(() => {
      S(Object.fromEntries(l.map((I, R) => [I.id, {
        y: R * a,
        offsetY: 0,
        isSelected: !1
      }])))
    }, [a, l]), g.useEffect(() => {
      s && requestAnimationFrame(() => {
        const I = document.querySelector(`[data-testid="page-menu-item-${d}"]`);
        if (I) {
          const R = c.current;
          if (!R) return;
          const M = I.offsetTop,
            j = R.scrollTop;
          M < j && R.scrollTo({
            top: M
          });
          const A = M + a,
            D = R.scrollTop + R.offsetHeight;
          A > D && R.scrollTo({
            top: A - R.offsetHeight
          })
        }
      })
    }, [a, d, s]);
    const x = g.useCallback(I => {
        const {
          clientY: R,
          currentTarget: M
        } = I, {
          dataset: {
            id: j,
            index: A
          }
        } = M;
        if (!j || !A) return;
        const D = v.current;
        Sh(I.currentTarget, I), D.status = "pointing", D.pointing = {
          id: j,
          index: +A
        };
        const q = _[j].y;
        D.startY = R, D.startIndex = Math.max(0, Math.min(Math.round(q / a), l.length - 1))
      }, [a, l.length, _]),
      E = g.useCallback(I => {
        const R = v.current;
        if (R.status === "pointing") {
          const {
            clientY: M
          } = I, j = M - R.startY;
          Math.abs(j) > 5 && (R.status = "dragging")
        }
        if (R.status === "dragging") {
          const {
            clientY: M
          } = I, j = M - R.startY, A = _[R.pointing.id], {
            startIndex: D,
            pointing: N
          } = R, q = A.y + j, F = Math.max(0, Math.min(Math.round(q / a), l.length - 1)), B = {
            ..._
          };
          if (B[N.id] = {
              y: A.y,
              offsetY: j,
              isSelected: !0
            }, F !== R.dragIndex) {
            R.dragIndex = F;
            for (let V = 0; V < l.length; V++) {
              const J = l[V];
              if (J.id === R.pointing.id) continue;
              let {
                y: ee
              } = B[J.id];
              F === D ? ee = V * a : F < D ? F <= V && V < D ? ee = (V + 1) * a : ee = V * a : F > D && (F >= V && V > D ? ee = (V - 1) * a : ee = V * a), ee !== B[J.id].y && (B[J.id] = {
                y: ee,
                offsetY: 0,
                isSelected: !0
              })
            }
          }
          S(B)
        }
      }, [a, l, _]),
      k = g.useCallback(I => {
        const R = v.current;
        if (R.status === "dragging") {
          const {
            id: M,
            index: j
          } = R.pointing;
          k_(e, M, j, R.dragIndex)
        }
        _h(I.currentTarget, I), R.status = "idle"
      }, [e]),
      C = g.useCallback(I => {
        const R = v.current;
        I.key === "Escape" && (R.status === "dragging" && S(Object.fromEntries(l.map((M, j) => [M.id, {
          y: j * a,
          offsetY: 0,
          isSelected: !1
        }]))), R.status = "idle")
      }, [a, l]),
      $ = g.useCallback(() => {
        f || e.batch(() => {
          e.mark("creating page");
          const I = Ys.createId();
          e.createPage({
            name: n("page-menu.new-page-initial-name"),
            id: I
          }), e.setCurrentPage(I), b(!0)
        })
      }, [e, n, f]);
    return y.jsxs($E, {
      id: "pages",
      onOpenChange: i,
      open: s,
      children: [y.jsx(IE, {
        children: y.jsx(me, {
          className: "tlui-page-menu__trigger tlui-menu__trigger",
          "data-testid": "main.page-menu",
          icon: "chevron-down",
          type: "menu",
          title: u.name,
          children: y.jsx("div", {
            className: "tlui-page-menu__name",
            children: u.name
          })
        })
      }), y.jsx(N5, {
        side: "bottom",
        align: "start",
        sideOffset: 6,
        children: y.jsxs("div", {
          className: "tlui-page-menu__wrapper",
          children: [y.jsxs("div", {
            className: "tlui-page-menu__header",
            children: [y.jsx("div", {
              className: "tlui-page-menu__header__title",
              children: n("page-menu.title")
            }), !f && y.jsxs("div", {
              className: "tlui-buttons__horizontal",
              children: [y.jsx(me, {
                type: "icon",
                "data-testid": "page-menu.edit",
                title: n(p ? "page-menu.edit-done" : "page-menu.edit-start"),
                icon: p ? "check" : "edit",
                onClick: w
              }), y.jsx(me, {
                type: "icon",
                "data-testid": "page-menu.create",
                icon: "plus",
                title: n(h ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"),
                disabled: h,
                onClick: $
              })]
            })]
          }), y.jsx("div", {
            className: "tlui-page-menu__list tlui-menu__group",
            style: {
              height: a * l.length + 4
            },
            ref: c,
            children: l.map((I, R) => {
              const M = _[I.id] ?? {
                position: R * 40,
                offsetY: 0
              };
              return p ? y.jsxs("div", {
                "data-testid": `page-menu-item-${I.id}`,
                className: "tlui-page_menu__item__sortable",
                style: {
                  zIndex: I.id === u.id ? 888 : R,
                  transform: `translate(0px, ${M.y+M.offsetY}px)`
                },
                children: [y.jsx(me, {
                  type: "icon",
                  tabIndex: -1,
                  className: "tlui-page_menu__item__sortable__handle",
                  icon: "drag-handle-dots",
                  onPointerDown: x,
                  onPointerUp: k,
                  onPointerMove: E,
                  onKeyDown: C,
                  "data-id": I.id,
                  "data-index": R
                }), r < 5 && m ? y.jsx(me, {
                  type: "normal",
                  className: "tlui-page-menu__item__button",
                  onClick: () => {
                    const j = window.prompt("Rename page", I.name);
                    j && j !== I.name && e.renamePage(I.id, j)
                  },
                  onDoubleClick: w,
                  isChecked: I.id === u.id,
                  children: y.jsx("span", {
                    children: I.name
                  })
                }) : y.jsx("div", {
                  className: "tlui-page_menu__item__sortable__title",
                  style: {
                    height: a
                  },
                  children: y.jsx(wle, {
                    id: I.id,
                    name: I.name,
                    isCurrentPage: I.id === u.id
                  })
                }), !f && y.jsx("div", {
                  className: "tlui-page_menu__item__submenu",
                  "data-isediting": p,
                  children: y.jsx(d$, {
                    index: R,
                    item: I,
                    listSize: l.length
                  })
                })]
              }, I.id + "_editing") : y.jsxs("div", {
                "data-testid": `page-menu-item-${I.id}`,
                className: "tlui-page-menu__item",
                children: [y.jsxs(me, {
                  type: "icon",
                  className: "tlui-page-menu__item__button tlui-page-menu__item__button__checkbox",
                  onClick: () => e.setCurrentPage(I.id),
                  onDoubleClick: w,
                  isChecked: I.id === u.id,
                  title: n("page-menu.go-to-page"),
                  children: [y.jsx("div", {
                    className: "tlui-page-menu__item__button__check",
                    children: I.id === u.id && y.jsx(wr, {
                      icon: "check"
                    })
                  }), y.jsx("span", {
                    children: I.name
                  })]
                }), !f && y.jsx("div", {
                  className: "tlui-page_menu__item__submenu",
                  children: y.jsx(d$, {
                    index: R,
                    item: I,
                    listSize: l.length,
                    onRename: () => {
                      if (e.environment.isIos) {
                        const j = window.prompt("Rename page", I.name);
                        j && j !== I.name && e.renamePage(I.id, j)
                      } else e.batch(() => {
                        b(!0), e.setCurrentPage(I.id)
                      })
                    }
                  })
                })]
              }, I.id)
            })
          })]
        })
      })]
    })
  },
  B5 = g.memo(function() {
    const e = nt(),
      n = vD(),
      o = Xn().redo;
    return y.jsx(me, {
      "data-testid": "main.redo",
      icon: o.icon,
      type: "icon",
      title: `${e(o.label)} ${fs(o.kbd)}`,
      disabled: !n,
      onClick: () => o.onSelect("quick-actions"),
      smallIcon: !0
    })
  }),
  U5 = pt(function() {
    const e = Y(),
      n = Xn(),
      r = nt(),
      o = n.delete;
    return lo() ? null : y.jsx(me, {
      icon: o.icon,
      type: "icon",
      onClick: () => o.onSelect("quick-actions"),
      disabled: !(e.isIn("select") && e.getSelectedShapeIds().length > 0),
      title: `${r(o.label)} ${fs(o.kbd)}`,
      smallIcon: !0
    })
  }),
  z5 = g.memo(function() {
    const e = nt(),
      n = bD(),
      o = Xn().undo;
    return y.jsx(me, {
      "data-testid": "main.undo",
      icon: o.icon,
      type: "icon",
      title: `${e(o.label)} ${fs(o.kbd)}`,
      disabled: !n,
      onClick: () => o.onSelect("quick-actions"),
      smallIcon: !0
    })
  }),
  _le = pt(function() {
    const e = Y(),
      n = uo(),
      r = lo();
    return y.jsx("div", {
      className: "tlui-menu-zone",
      children: y.jsxs("div", {
        className: "tlui-buttons__horizontal",
        children: [y.jsx(vle, {}), y.jsx(Sle, {}), n >= 6 && !r && !e.isInAny("hand", "zoom") && y.jsxs(y.Fragment, {
          children: [y.jsx(z5, {}), y.jsx(B5, {}), y.jsx(U5, {}), y.jsx(F5, {}), y.jsx(L5, {})]
        })]
      })
    })
  });

function xle(t, e) {
  const [n, r] = se.useState(e);
  se.useLayoutEffect(() => {
    const s = localStorage.getItem(t);
    if (s) try {
      r(JSON.parse(s))
    } catch {
      console.error(`Could not restore value ${t} from local storage.`)
    }
  }, [t]);
  const o = se.useCallback(s => {
    r(i => {
      const a = typeof s == "function" ? s(i) : s;
      return localStorage.setItem(t, JSON.stringify(a)), a
    })
  }, [t]);
  return [n, o]
}
class Jd {
  constructor(e) {
    P(this, "dpr", 1);
    P(this, "colors", {
      shapeFill: "rgba(144, 144, 144, .1)",
      selectFill: "#2f80ed",
      viewportFill: "rgba(144, 144, 144, .1)"
    });
    P(this, "id", It());
    P(this, "cvs", null);
    P(this, "pageBounds", []);
    P(this, "collaborators", []);
    P(this, "canvasScreenBounds", new Be);
    P(this, "canvasPageBounds", new Be);
    P(this, "contentPageBounds", new Be);
    P(this, "contentScreenBounds", new Be);
    P(this, "originPagePoint", new T);
    P(this, "originPageCenter", new T);
    P(this, "isInViewport", !1);
    P(this, "debug", !1);
    P(this, "updateContentScreenBounds", () => {
      const {
        contentScreenBounds: e,
        contentPageBounds: n,
        canvasScreenBounds: r
      } = this;
      let {
        x: o,
        y: s,
        w: i,
        h: a
      } = e;
      if (n.w > n.h) {
        const c = r.w / (n.w / n.h);
        c > r.h ? (o = (r.w - r.w * (r.h / c)) / 2, s = 0, i = r.w * (r.h / c), a = r.h) : (o = 0, s = (r.h - c) / 2, i = r.w, a = c)
      } else if (n.w < n.h) {
        const c = r.h / (n.h / n.w);
        o = (r.w - c) / 2, s = 0, i = c, a = r.h
      } else o = r.h / 2, s = 0, i = r.h, a = r.h;
      e.set(o, s, i, a)
    });
    P(this, "updateCanvasPageBounds", () => {
      const {
        canvasPageBounds: e,
        canvasScreenBounds: n,
        contentPageBounds: r,
        contentScreenBounds: o
      } = this;
      e.set(0, 0, r.width / (o.width / n.width), r.height / (o.height / n.height)), e.center = r.center
    });
    P(this, "getScreenPoint", (e, n) => {
      const {
        canvasScreenBounds: r
      } = this, o = (e - r.minX) * this.dpr, s = (n - r.minY) * this.dpr;
      return {
        x: o,
        y: s
      }
    });
    P(this, "getPagePoint", (e, n) => {
      const {
        contentPageBounds: r,
        contentScreenBounds: o,
        canvasPageBounds: s
      } = this, {
        x: i,
        y: a
      } = this.getScreenPoint(e, n);
      return new T(s.minX + i * r.width / o.width, s.minY + a * r.height / o.height, 1)
    });
    P(this, "minimapScreenPointToPagePoint", (e, n, r = !1, o = !1) => {
      const {
        editor: s
      } = this, {
        viewportPageBounds: i
      } = s;
      let {
        x: a,
        y: c
      } = this.getPagePoint(e, n);
      if (o) {
        const l = this.editor.currentPageBounds,
          u = i,
          d = ((l == null ? void 0 : l.minX) ?? 0) - u.width / 2,
          f = ((l == null ? void 0 : l.maxX) ?? 0) + u.width / 2,
          h = ((l == null ? void 0 : l.minY) ?? 0) - u.height / 2,
          m = ((l == null ? void 0 : l.maxY) ?? 0) + u.height / 2,
          p = Math.max(0, d + u.width - a),
          b = Math.max(0, -(f - u.width - a)),
          w = Math.max(0, h + u.height - c),
          v = Math.max(0, -(m - u.height - c)),
          _ = Math.max(0, p - b),
          S = Math.max(0, b - p),
          x = Math.max(0, w - v),
          E = Math.max(0, v - w);
        _ && _ > S ? a += _ / 2 : S && (a -= S / 2), x && x > E ? c += x / 2 : E && (c -= E / 2), a = eo(a, d, f), c = eo(c, h, m)
      }
      if (r) {
        const {
          originPagePoint: l
        } = this, u = Math.abs(a - l.x), d = Math.abs(c - l.y);
        u > d ? c = l.y : a = l.x
      }
      return new T(a, c)
    });
    P(this, "render", () => {
      const {
        cvs: e,
        pageBounds: n
      } = this;
      this.updateCanvasPageBounds();
      const {
        editor: r,
        canvasScreenBounds: o,
        canvasPageBounds: s,
        contentPageBounds: i,
        contentScreenBounds: a
      } = this, {
        width: c,
        height: l
      } = o, u = this.editor.getSelectedShapeIds(), {
        viewportPageBounds: d
      } = r;
      if (!e || !n) return;
      const f = e.getContext("2d");
      if (!f) throw new Error("Minimap (shapes): Could not get context");
      f.resetTransform(), f.globalAlpha = 1, f.clearRect(0, 0, c, l);
      const h = a.width / i.width,
        m = a.height / i.height;
      f.translate((c - a.width) / 2, (l - a.height) / 2), f.scale(h, m), f.translate(-i.minX, -i.minY);
      const p = 8 / h,
        b = 8 / h,
        w = 1 / h,
        v = 1 / h,
        _ = p / 4,
        S = b / 4,
        x = new Path2D,
        E = new Path2D,
        {
          shapeFill: k,
          selectFill: C,
          viewportFill: $
        } = this.colors;
      let I;
      for (let D = 0, N = n.length; D < N; D++) I = n[D], Jd.roundedRect(u.includes(I.id) ? E : x, I.minX, I.minY, I.width, I.height, eo(p, w, I.width / _), eo(b, v, I.height / S));
      if (f.fillStyle = k, f.fill(x), f.fillStyle = C, f.fill(E), this.debug) {
        const D = Be.Common(n),
          {
            minX: N,
            minY: q,
            width: F,
            height: B
          } = D;
        f.strokeStyle = "green", f.lineWidth = 2 / h, f.strokeRect(N + 1 / h, q + 1 / m, F - 2 / h, B - 2 / m)
      } {
        const {
          brush: D
        } = r.getInstanceState();
        if (D) {
          const {
            x: N,
            y: q,
            w: F,
            h: B
          } = D;
          f.beginPath(), Jd.sharpRect(f, N, q, F, B), f.closePath(), f.fillStyle = $, f.fill()
        }
      } {
        const {
          minX: D,
          minY: N,
          width: q,
          height: F
        } = d;
        f.beginPath();
        const B = 12 / h,
          V = 12 / h;
        Jd.roundedRect(f, D, N, q, F, Math.min(q / 4, B), Math.min(F / 4, V)), f.closePath(), f.fillStyle = $, f.fill(), this.debug && (f.strokeStyle = "orange", f.strokeRect(D + 1 / h, N + 1 / m, q - 2 / h, F - 2 / m))
      }
      const R = 2.5 / h,
        M = 2.5 / m,
        {
          currentPageId: j
        } = r;
      let A;
      for (let D = 0; D < this.collaborators.length; D++) A = this.collaborators[D], A.currentPageId === j && (f.beginPath(), f.ellipse(eo(A.cursor.x, s.minX + R, s.maxX - R), eo(A.cursor.y, s.minY + M, s.maxY - M), 5 / h, 5 / m, 0, 0, Rt), f.fillStyle = A.color, f.fill());
      if (this.debug) {
        f.lineWidth = 2 / h;
        {
          const {
            minX: D,
            minY: N,
            width: q,
            height: F
          } = i;
          f.strokeStyle = "red", f.strokeRect(D + 1 / h, N + 1 / m, q - 2 / h, F - 2 / m)
        } {
          const {
            minX: D,
            minY: N,
            width: q,
            height: F
          } = s;
          f.strokeStyle = "blue", f.strokeRect(D + 1 / h, N + 1 / m, q - 2 / h, F - 2 / m)
        }
      }
    });
    this.editor = e
  }
  setDpr(e) {
    this.dpr = +e.toFixed(2)
  }
  static roundedRect(e, n, r, o, s, i, a) {
    if (i < 1 && a < 1) {
      e.rect(n, r, o, s);
      return
    }
    e.moveTo(n + i, r), e.lineTo(n + o - i, r), e.quadraticCurveTo(n + o, r, n + o, r + a), e.lineTo(n + o, r + s - a), e.quadraticCurveTo(n + o, r + s, n + o - i, r + s), e.lineTo(n + i, r + s), e.quadraticCurveTo(n, r + s, n, r + s - a), e.lineTo(n, r + a), e.quadraticCurveTo(n, r, n + i, r)
  }
  static sharpRect(e, n, r, o, s, i, a) {
    e.rect(n, r, o, s)
  }
}

function Ele({
  shapeFill: t,
  selectFill: e,
  viewportFill: n
}) {
  const r = Y(),
    o = g.useRef(null),
    s = g.useRef(!1),
    i = sv(),
    a = EA("dpr", () => r.getInstanceState().devicePixelRatio, [r]),
    c = g.useMemo(() => r.store.query.records("instance_presence"), [r]),
    l = g.useMemo(() => new Jd(r), [r]);
  g.useEffect(() => {
    const m = requestAnimationFrame(() => {
      const p = getComputedStyle(r.getContainer());
      l.colors = {
        shapeFill: p.getPropertyValue(t).trim(),
        selectFill: p.getPropertyValue(e).trim(),
        viewportFill: p.getPropertyValue(n).trim()
      }, l.render()
    });
    return () => {
      cancelAnimationFrame(m)
    }
  }, [r, e, t, n, l, i]);
  const u = g.useCallback(m => {
      if (!r.currentPageShapeIds.size) return;
      const p = l.minimapScreenPointToPagePoint(m.clientX, m.clientY, !1, !1),
        b = l.minimapScreenPointToPagePoint(m.clientX, m.clientY, !1, !0);
      l.originPagePoint.setTo(b), l.originPageCenter.setTo(r.viewportPageBounds.center), r.centerOnPoint(p, {
        duration: Os
      })
    }, [r, l]),
    d = g.useCallback(m => {
      const p = m.currentTarget;
      if (Sh(p, m), !r.currentPageShapeIds.size) return;
      s.current = !0, l.isInViewport = !1;
      const b = l.minimapScreenPointToPagePoint(m.clientX, m.clientY, !1, !1),
        w = l.minimapScreenPointToPagePoint(m.clientX, m.clientY, !1, !0),
        v = r.viewportPageBounds;
      if (l.isInViewport = v.containsPoint(w), l.isInViewport) l.originPagePoint.setTo(w), l.originPageCenter.setTo(v.center);
      else {
        const S = T.Sub(v.center, v.point),
          x = T.Add(b, S);
        l.originPagePoint.setTo(x), l.originPageCenter.setTo(b), r.centerOnPoint(b, {
          duration: Os
        })
      }

      function _(S) {
        p && _h(p, S), s.current = !1, document.body.removeEventListener("pointerup", _)
      }
      document.body.addEventListener("pointerup", _)
    }, [r, l]),
    f = g.useCallback(m => {
      const p = l.minimapScreenPointToPagePoint(m.clientX, m.clientY, m.shiftKey, !0);
      if (s.current) {
        if (l.isInViewport) {
          const _ = l.originPagePoint.clone().sub(l.originPageCenter);
          r.centerOnPoint(T.Sub(p, _));
          return
        }
        r.centerOnPoint(p)
      }
      const b = l.getPagePoint(m.clientX, m.clientY),
        w = r.pageToScreen(b),
        v = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...gr(m),
          point: w,
          isPen: r.getInstanceState().isPenMode
        };
      r.dispatch(v)
    }, [r, l]),
    h = g.useCallback(m => {
      const p = i3(m);
      r.dispatch({
        type: "wheel",
        name: "wheel",
        delta: p,
        point: new T(m.clientX, m.clientY),
        shiftKey: m.shiftKey,
        altKey: m.altKey,
        ctrlKey: m.metaKey || m.ctrlKey
      })
    }, [r]);
  return ja("update when dpr changes", () => {
    const m = a.get();
    l.setDpr(m);
    const p = o.current,
      b = p.getBoundingClientRect(),
      w = b.width * m,
      v = b.height * m;
    p.width = w, p.height = v, l.canvasScreenBounds.set(b.x, b.y, w, v), l.cvs = o.current
  }, [a, l]), ja("minimap render when pagebounds or collaborators changes", () => {
    const {
      currentPageShapeIds: m,
      viewportPageBounds: p,
      currentPageBounds: b
    } = r;
    a.get(), l.contentPageBounds = b ? Be.Expand(b, p) : p, l.updateContentScreenBounds();
    const w = [];
    m.forEach(v => {
      let _ = r.getShapePageBounds(v);
      if (!_) return;
      const S = r.getShapeMask(v);
      if (S) {
        const x = zS(S, _.corners);
        if (!x) return;
        _ = Be.FromPoints(x)
      }
      _ && (_.id = v, w.push(_))
    }), l.pageBounds = w, l.collaborators = c.get(), l.render()
  }, [r, l]), y.jsx("div", {
    className: "tlui-minimap",
    children: y.jsx("canvas", {
      ref: o,
      className: "tlui-minimap__canvas",
      onDoubleClick: u,
      onPointerMove: f,
      onPointerDown: d,
      onWheel: h
    })
  })
}
const Vb = pt(function() {
  const e = Y(),
    n = nt(),
    r = uo(),
    o = e.zoomLevel,
    s = e.currentPageShapeIds.size > 0,
    i = e.getSelectedShapeIds().length > 0,
    a = e.zoomLevel === 1,
    c = g.useCallback(() => {
      e.resetZoom(e.viewportScreenCenter, {
        duration: Os
      })
    }, [e]);
  return y.jsxs(Js, {
    id: "zoom",
    children: [y.jsx(Ou, {
      children: y.jsx(me, {
        type: "icon",
        title: `${n("navigation-zone.zoom")}`,
        "data-testid": "minimap.zoom-menu",
        className: r < 5 ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
        onDoubleClick: c,
        icon: r < 4 ? "zoom-in" : void 0,
        children: r < 4 ? null : y.jsxs("span", {
          style: {
            flexGrow: 0,
            textAlign: "center"
          },
          children: [Math.floor(o * 100), "%"]
        })
      })
    }), y.jsx(Qs, {
      side: "top",
      align: "start",
      alignOffset: 0,
      children: y.jsxs(ls, {
        children: [y.jsx(gd, {
          action: "zoom-in",
          "data-testid": "minimap.zoom-menu.zoom-in",
          noClose: !0
        }), y.jsx(gd, {
          action: "zoom-out",
          "data-testid": "minimap.zoom-menu.zoom-out",
          noClose: !0
        }), y.jsx(gd, {
          action: "zoom-to-100",
          "data-testid": "minimap.zoom-menu.zoom-to-100",
          noClose: !0,
          disabled: a
        }), y.jsx(gd, {
          action: "zoom-to-fit",
          disabled: !s,
          "data-testid": "minimap.zoom-menu.zoom-to-fit",
          noClose: !0
        }), y.jsx(gd, {
          action: "zoom-to-selection",
          disabled: !i,
          "data-testid": "minimap.zoom-menu.zoom-to-selection",
          noClose: !0
        })]
      })
    })]
  })
});

function gd(t) {
  const {
    action: e,
    disabled: n = !1,
    noClose: r = !1
  } = t, o = Xn();
  return y.jsx(fr, {
    type: "menu",
    label: o[e].label,
    kbd: o[e].kbd,
    "data-testid": t["data-testid"],
    onClick: () => o[e].onSelect("zoom-menu"),
    noClose: r,
    disabled: n
  })
}
const kle = g.memo(function() {
    const e = Xn(),
      n = nt(),
      r = uo(),
      [o, s] = xle("minimap", !0),
      i = g.useCallback(() => {
        s(a => !a)
      }, [s]);
    return r < 4 ? null : y.jsxs("div", {
      className: "tlui-navigation-zone",
      children: [y.jsx("div", {
        className: "tlui-buttons__horizontal",
        children: r < 6 ? y.jsx(Vb, {}) : o ? y.jsxs(y.Fragment, {
          children: [y.jsx(Vb, {}), y.jsx(me, {
            type: "icon",
            icon: o ? "chevrons-ne" : "chevrons-sw",
            "data-testid": "minimap.toggle",
            title: n("navigation-zone.toggle-minimap"),
            className: "tlui-navigation-zone__toggle",
            onClick: i
          })]
        }) : y.jsxs(y.Fragment, {
          children: [y.jsx(me, {
            type: "icon",
            icon: "minus",
            "data-testid": "minimap.zoom-out",
            title: `${n(e["zoom-out"].label)} ${fs(e["zoom-out"].kbd)}`,
            onClick: () => e["zoom-out"].onSelect("navigation-zone")
          }), y.jsx(Vb, {}), y.jsx(me, {
            type: "icon",
            icon: "plus",
            "data-testid": "minimap.zoom-in",
            title: `${n(e["zoom-in"].label)} ${fs(e["zoom-in"].kbd)}`,
            onClick: () => e["zoom-in"].onSelect("navigation-zone")
          }), y.jsx(me, {
            type: "icon",
            icon: o ? "chevrons-ne" : "chevrons-sw",
            "data-testid": "minimap.toggle",
            title: n("navigation-zone.toggle-minimap"),
            className: "tlui-navigation-zone__toggle",
            onClick: i
          })]
        })
      }), r >= 6 && !o && y.jsx(Ele, {
        viewportFill: "--color-muted-1",
        selectFill: "--color-selected",
        shapeFill: "--color-text-3"
      })]
    })
  }),
  Cle = pt(function() {
    const n = Y().getInstanceState().isPenMode,
      r = Xn();
    if (!n) return null;
    const o = r["exit-pen-mode"];
    return y.jsx(me, {
      type: "normal",
      label: o.label,
      iconLeft: o.icon,
      onClick: () => o.onSelect("helper-buttons")
    })
  }),
  Ple = pt(function() {
    const e = Y(),
      n = Xn();
    if (!e.getInstanceState().followingUserId) return null;
    const r = n["stop-following"];
    return y.jsx(me, {
      type: "normal",
      label: r.label,
      iconLeft: r.icon,
      onClick: () => r.onSelect("people-menu")
    })
  }),
  Tle = [ao, Ja, tu, us];

function H5() {
  const t = Y();
  return te("getRelevantStyles", () => {
    var r;
    const e = new HS(t.sharedStyles),
      n = t.getSelectedShapeIds().length > 0 || !!((r = t.root.current.get()) != null && r.shapeType);
    if (e.size === 0 && t.isIn("select") && t.getSelectedShapeIds().length === 0)
      for (const o of Tle) e.applyValue(o, t.getStyleForNextShape(o));
    return e.size === 0 && !n ? null : {
      styles: e,
      opacity: t.sharedOpacity
    }
  }, [t])
}

function $le(t) {
  const {
    uiType: e,
    items: n,
    title: r,
    style: o,
    value: s,
    onValueChange: i
  } = t, a = Y(), c = nt(), l = g.useRef(!1), {
    handleButtonClick: u,
    handleButtonPointerDown: d,
    handleButtonPointerEnter: f,
    handleButtonPointerUp: h
  } = g.useMemo(() => {
    const p = () => {
      l.current = !1, window.removeEventListener("pointerup", p)
    };
    return {
      handleButtonClick: S => {
        const {
          id: x
        } = S.currentTarget.dataset;
        s.type === "shared" && s.value === x || (a.mark("point picker item"), i(o, x, !1))
      },
      handleButtonPointerDown: S => {
        const {
          id: x
        } = S.currentTarget.dataset;
        a.mark("point picker item"), i(o, x, !0), l.current = !0, window.addEventListener("pointerup", p)
      },
      handleButtonPointerEnter: S => {
        if (!l.current) return;
        const {
          id: x
        } = S.currentTarget.dataset;
        i(o, x, !0)
      },
      handleButtonPointerUp: S => {
        const {
          id: x
        } = S.currentTarget.dataset;
        i(o, x, !1)
      }
    }
  }, [s, a, i, o]), m = te("theme", () => wh({
    isDarkMode: a.user.isDarkMode
  }), [a]);
  return y.jsx("div", {
    className: ae("tlui-buttons__grid"),
    children: n.map(p => y.jsx(me, {
      type: "icon",
      "data-id": p.value,
      "data-testid": `style.${e}.${p.value}`,
      "aria-label": p.value,
      "data-state": s.type === "shared" && s.value === p.value ? "hinted" : void 0,
      title: r + "  " + c(`${e}-style.${p.value}`),
      className: ae("tlui-button-grid__button"),
      style: o === ao ? {
        color: m[p.value].solid
      } : void 0,
      onPointerEnter: f,
      onPointerDown: d,
      onPointerUp: h,
      onClick: u,
      icon: p.icon
    }, p.value))
  })
}
const _l = g.memo($le);

function Ile(t, [e, n]) {
  return Math.min(n, Math.max(e, t))
}

function xl(t, e, {
  checkForDefaultPrevented: n = !0
} = {}) {
  return function(o) {
    if (t == null || t(o), n === !1 || !o.defaultPrevented) return e == null ? void 0 : e(o)
  }
}

function Ole(t, e) {
  typeof t == "function" ? t(e) : t != null && (t.current = e)
}

function V5(...t) {
  return e => t.forEach(n => Ole(n, e))
}

function Yi(...t) {
  return g.useCallback(V5(...t), t)
}

function W5(t, e = []) {
  let n = [];

  function r(s, i) {
    const a = g.createContext(i),
      c = n.length;
    n = [...n, i];

    function l(d) {
      const {
        scope: f,
        children: h,
        ...m
      } = d, p = (f == null ? void 0 : f[t][c]) || a, b = g.useMemo(() => m, Object.values(m));
      return g.createElement(p.Provider, {
        value: b
      }, h)
    }

    function u(d, f) {
      const h = (f == null ? void 0 : f[t][c]) || a,
        m = g.useContext(h);
      if (m) return m;
      if (i !== void 0) return i;
      throw new Error(`\`${d}\` must be used within \`${s}\``)
    }
    return l.displayName = s + "Provider", [l, u]
  }
  const o = () => {
    const s = n.map(i => g.createContext(i));
    return function(a) {
      const c = (a == null ? void 0 : a[t]) || s;
      return g.useMemo(() => ({
        [`__scope${t}`]: {
          ...a,
          [t]: c
        }
      }), [a, c])
    }
  };
  return o.scopeName = t, [r, Rle(o, ...e)]
}

function Rle(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map(o => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(s) {
      const i = r.reduce((a, {
        useScope: c,
        scopeName: l
      }) => {
        const d = c(s)[`__scope${l}`];
        return {
          ...a,
          ...d
        }
      }, {});
      return g.useMemo(() => ({
        [`__scope${e.scopeName}`]: i
      }), [i])
    }
  };
  return n.scopeName = e.scopeName, n
}

function K5(t) {
  const e = g.useRef(t);
  return g.useEffect(() => {
    e.current = t
  }), g.useMemo(() => (...n) => {
    var r;
    return (r = e.current) === null || r === void 0 ? void 0 : r.call(e, ...n)
  }, [])
}

function Ale({
  prop: t,
  defaultProp: e,
  onChange: n = () => {}
}) {
  const [r, o] = Mle({
    defaultProp: e,
    onChange: n
  }), s = t !== void 0, i = s ? t : r, a = K5(n), c = g.useCallback(l => {
    if (s) {
      const d = typeof l == "function" ? l(t) : l;
      d !== t && a(d)
    } else o(l)
  }, [s, t, o, a]);
  return [i, c]
}

function Mle({
  defaultProp: t,
  onChange: e
}) {
  const n = g.useState(t),
    [r] = n,
    o = g.useRef(r),
    s = K5(e);
  return g.useEffect(() => {
    o.current !== r && (s(r), o.current = r)
  }, [r, o, s]), n
}
const jle = g.createContext(void 0);

function Dle(t) {
  const e = g.useContext(jle);
  return t || e || "ltr"
}

function Nle(t) {
  const e = g.useRef({
    value: t,
    previous: t
  });
  return g.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t])
}
const Lle = globalThis != null && globalThis.document ? g.useLayoutEffect : () => {};

function Fle(t) {
  const [e, n] = g.useState(void 0);
  return Lle(() => {
    if (t) {
      n({
        width: t.offsetWidth,
        height: t.offsetHeight
      });
      const r = new ResizeObserver(o => {
        if (!Array.isArray(o) || !o.length) return;
        const s = o[0];
        let i, a;
        if ("borderBoxSize" in s) {
          const c = s.borderBoxSize,
            l = Array.isArray(c) ? c[0] : c;
          i = l.inlineSize, a = l.blockSize
        } else i = t.offsetWidth, a = t.offsetHeight;
        n({
          width: i,
          height: a
        })
      });
      return r.observe(t, {
        box: "border-box"
      }), () => r.unobserve(t)
    } else n(void 0)
  }, [t]), e
}
const ey = g.forwardRef((t, e) => {
  const {
    children: n,
    ...r
  } = t, o = g.Children.toArray(n), s = o.find(Ule);
  if (s) {
    const i = s.props.children,
      a = o.map(c => c === s ? g.Children.count(i) > 1 ? g.Children.only(null) : g.isValidElement(i) ? i.props.children : null : c);
    return g.createElement(C_, G({}, r, {
      ref: e
    }), g.isValidElement(i) ? g.cloneElement(i, void 0, a) : null)
  }
  return g.createElement(C_, G({}, r, {
    ref: e
  }), n)
});
ey.displayName = "Slot";
const C_ = g.forwardRef((t, e) => {
  const {
    children: n,
    ...r
  } = t;
  return g.isValidElement(n) ? g.cloneElement(n, {
    ...zle(r, n.props),
    ref: V5(e, n.ref)
  }) : g.Children.count(n) > 1 ? g.Children.only(null) : null
});
C_.displayName = "SlotClone";
const Ble = ({
  children: t
}) => g.createElement(g.Fragment, null, t);

function Ule(t) {
  return g.isValidElement(t) && t.type === Ble
}

function zle(t, e) {
  const n = {
    ...e
  };
  for (const r in e) {
    const o = t[r],
      s = e[r];
    /^on[A-Z]/.test(r) ? o && s ? n[r] = (...a) => {
      s(...a), o(...a)
    } : o && (n[r] = o) : r === "style" ? n[r] = {
      ...o,
      ...s
    } : r === "className" && (n[r] = [o, s].filter(Boolean).join(" "))
  }
  return {
    ...t,
    ...n
  }
}
const Hle = ["a", "button", "div", "h2", "h3", "img", "label", "li", "nav", "ol", "p", "span", "svg", "ul"],
  Dv = Hle.reduce((t, e) => {
    const n = g.forwardRef((r, o) => {
      const {
        asChild: s,
        ...i
      } = r, a = s ? ey : e;
      return g.useEffect(() => {
        window[Symbol.for("radix-ui")] = !0
      }, []), g.createElement(a, G({}, i, {
        ref: o
      }))
    });
    return n.displayName = `Primitive.${e}`, {
      ...t,
      [e]: n
    }
  }, {});

function Vle(t) {
  const e = t + "CollectionProvider",
    [n, r] = W5(e),
    [o, s] = n(e, {
      collectionRef: {
        current: null
      },
      itemMap: new Map
    }),
    i = h => {
      const {
        scope: m,
        children: p
      } = h, b = se.useRef(null), w = se.useRef(new Map).current;
      return se.createElement(o, {
        scope: m,
        itemMap: w,
        collectionRef: b
      }, p)
    },
    a = t + "CollectionSlot",
    c = se.forwardRef((h, m) => {
      const {
        scope: p,
        children: b
      } = h, w = s(a, p), v = Yi(m, w.collectionRef);
      return se.createElement(ey, {
        ref: v
      }, b)
    }),
    l = t + "CollectionItemSlot",
    u = "data-radix-collection-item",
    d = se.forwardRef((h, m) => {
      const {
        scope: p,
        children: b,
        ...w
      } = h, v = se.useRef(null), _ = Yi(m, v), S = s(l, p);
      return se.useEffect(() => (S.itemMap.set(v, {
        ref: v,
        ...w
      }), () => void S.itemMap.delete(v))), se.createElement(ey, {
        [u]: "",
        ref: _
      }, b)
    });

  function f(h) {
    const m = s(t + "CollectionConsumer", h);
    return se.useCallback(() => {
      const b = m.collectionRef.current;
      if (!b) return [];
      const w = Array.from(b.querySelectorAll(`[${u}]`));
      return Array.from(m.itemMap.values()).sort((S, x) => w.indexOf(S.ref.current) - w.indexOf(x.ref.current))
    }, [m.collectionRef, m.itemMap])
  }
  return [{
    Provider: i,
    Slot: c,
    ItemSlot: d
  }, f, r]
}
const G5 = ["PageUp", "PageDown"],
  Y5 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"],
  q5 = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  },
  Nh = "Slider",
  [P_, Wle, Kle] = Vle(Nh),
  [X5, Lbe] = W5(Nh, [Kle]),
  [Gle, Nv] = X5(Nh),
  Yle = g.forwardRef((t, e) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: s = 1,
      orientation: i = "horizontal",
      disabled: a = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: l = [r],
      value: u,
      onValueChange: d = () => {},
      onValueCommit: f = () => {},
      inverted: h = !1,
      ...m
    } = t, [p, b] = g.useState(null), w = Yi(e, A => b(A)), v = g.useRef(new Set), _ = g.useRef(0), S = i === "horizontal", x = p ? !!p.closest("form") : !0, E = S ? qle : Xle, [k = [], C] = Ale({
      prop: u,
      defaultProp: l,
      onChange: A => {
        var D;
        (D = [...v.current][_.current]) === null || D === void 0 || D.focus(), d(A)
      }
    }), $ = g.useRef(k);

    function I(A) {
      const D = sue(k, A);
      j(A, D)
    }

    function R(A) {
      j(A, _.current)
    }

    function M() {
      const A = $.current[_.current];
      k[_.current] !== A && f(k)
    }

    function j(A, D, {
      commit: N
    } = {
      commit: !1
    }) {
      const q = lue(s),
        F = uue(Math.round((A - r) / s) * s + r, q),
        B = Ile(F, [r, o]);
      C((V = []) => {
        const J = rue(V, B, D);
        if (cue(J, c * s)) {
          _.current = J.indexOf(B);
          const ee = String(J) !== String(V);
          return ee && N && f(J), ee ? J : V
        } else return V
      })
    }
    return g.createElement(Gle, {
      scope: t.__scopeSlider,
      disabled: a,
      min: r,
      max: o,
      valueIndexToChangeRef: _,
      thumbs: v.current,
      values: k,
      orientation: i
    }, g.createElement(P_.Provider, {
      scope: t.__scopeSlider
    }, g.createElement(P_.Slot, {
      scope: t.__scopeSlider
    }, g.createElement(E, G({
      "aria-disabled": a,
      "data-disabled": a ? "" : void 0
    }, m, {
      ref: w,
      onPointerDown: xl(m.onPointerDown, () => {
        a || ($.current = k)
      }),
      min: r,
      max: o,
      inverted: h,
      onSlideStart: a ? void 0 : I,
      onSlideMove: a ? void 0 : R,
      onSlideEnd: a ? void 0 : M,
      onHomeKeyDown: () => !a && j(r, 0, {
        commit: !0
      }),
      onEndKeyDown: () => !a && j(o, k.length - 1, {
        commit: !0
      }),
      onStepKeyDown: ({
        event: A,
        direction: D
      }) => {
        if (!a) {
          const F = G5.includes(A.key) || A.shiftKey && Y5.includes(A.key) ? 10 : 1,
            B = _.current,
            V = k[B],
            J = s * F * D;
          j(V + J, B, {
            commit: !0
          })
        }
      }
    })))), x && k.map((A, D) => g.createElement(nue, {
      key: D,
      name: n ? n + (k.length > 1 ? "[]" : "") : void 0,
      value: A
    })))
  }),
  [Z5, J5] = X5(Nh, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }),
  qle = g.forwardRef((t, e) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: s,
      onSlideStart: i,
      onSlideMove: a,
      onSlideEnd: c,
      onStepKeyDown: l,
      ...u
    } = t, [d, f] = g.useState(null), h = Yi(e, _ => f(_)), m = g.useRef(), p = Dle(o), b = p === "ltr", w = b && !s || !b && s;

    function v(_) {
      const S = m.current || d.getBoundingClientRect(),
        x = [0, S.width],
        k = OE(x, w ? [n, r] : [r, n]);
      return m.current = S, k(_ - S.left)
    }
    return g.createElement(Z5, {
      scope: t.__scopeSlider,
      startEdge: w ? "left" : "right",
      endEdge: w ? "right" : "left",
      direction: w ? 1 : -1,
      size: "width"
    }, g.createElement(Q5, G({
      dir: p,
      "data-orientation": "horizontal"
    }, u, {
      ref: h,
      style: {
        ...u.style,
        "--radix-slider-thumb-transform": "translateX(-50%)"
      },
      onSlideStart: _ => {
        const S = v(_.clientX);
        i == null || i(S)
      },
      onSlideMove: _ => {
        const S = v(_.clientX);
        a == null || a(S)
      },
      onSlideEnd: () => {
        m.current = void 0, c == null || c()
      },
      onStepKeyDown: _ => {
        const x = q5[w ? "from-left" : "from-right"].includes(_.key);
        l == null || l({
          event: _,
          direction: x ? -1 : 1
        })
      }
    })))
  }),
  Xle = g.forwardRef((t, e) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: s,
      onSlideMove: i,
      onSlideEnd: a,
      onStepKeyDown: c,
      ...l
    } = t, u = g.useRef(null), d = Yi(e, u), f = g.useRef(), h = !o;

    function m(p) {
      const b = f.current || u.current.getBoundingClientRect(),
        w = [0, b.height],
        _ = OE(w, h ? [r, n] : [n, r]);
      return f.current = b, _(p - b.top)
    }
    return g.createElement(Z5, {
      scope: t.__scopeSlider,
      startEdge: h ? "bottom" : "top",
      endEdge: h ? "top" : "bottom",
      size: "height",
      direction: h ? 1 : -1
    }, g.createElement(Q5, G({
      "data-orientation": "vertical"
    }, l, {
      ref: d,
      style: {
        ...l.style,
        "--radix-slider-thumb-transform": "translateY(50%)"
      },
      onSlideStart: p => {
        const b = m(p.clientY);
        s == null || s(b)
      },
      onSlideMove: p => {
        const b = m(p.clientY);
        i == null || i(b)
      },
      onSlideEnd: () => {
        f.current = void 0, a == null || a()
      },
      onStepKeyDown: p => {
        const w = q5[h ? "from-bottom" : "from-top"].includes(p.key);
        c == null || c({
          event: p,
          direction: w ? -1 : 1
        })
      }
    })))
  }),
  Q5 = g.forwardRef((t, e) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: s,
      onHomeKeyDown: i,
      onEndKeyDown: a,
      onStepKeyDown: c,
      ...l
    } = t, u = Nv(Nh, n);
    return g.createElement(Dv.span, G({}, l, {
      ref: e,
      onKeyDown: xl(t.onKeyDown, d => {
        d.key === "Home" ? (i(d), d.preventDefault()) : d.key === "End" ? (a(d), d.preventDefault()) : G5.concat(Y5).includes(d.key) && (c(d), d.preventDefault())
      }),
      onPointerDown: xl(t.onPointerDown, d => {
        const f = d.target;
        f.setPointerCapture(d.pointerId), d.preventDefault(), u.thumbs.has(f) ? f.focus() : r(d)
      }),
      onPointerMove: xl(t.onPointerMove, d => {
        d.target.hasPointerCapture(d.pointerId) && o(d)
      }),
      onPointerUp: xl(t.onPointerUp, d => {
        const f = d.target;
        f.hasPointerCapture(d.pointerId) && (f.releasePointerCapture(d.pointerId), s(d))
      })
    }))
  }),
  Zle = "SliderTrack",
  Jle = g.forwardRef((t, e) => {
    const {
      __scopeSlider: n,
      ...r
    } = t, o = Nv(Zle, n);
    return g.createElement(Dv.span, G({
      "data-disabled": o.disabled ? "" : void 0,
      "data-orientation": o.orientation
    }, r, {
      ref: e
    }))
  }),
  f$ = "SliderRange",
  Qle = g.forwardRef((t, e) => {
    const {
      __scopeSlider: n,
      ...r
    } = t, o = Nv(f$, n), s = J5(f$, n), i = g.useRef(null), a = Yi(e, i), c = o.values.length, l = o.values.map(f => e4(f, o.min, o.max)), u = c > 1 ? Math.min(...l) : 0, d = 100 - Math.max(...l);
    return g.createElement(Dv.span, G({
      "data-orientation": o.orientation,
      "data-disabled": o.disabled ? "" : void 0
    }, r, {
      ref: a,
      style: {
        ...t.style,
        [s.startEdge]: u + "%",
        [s.endEdge]: d + "%"
      }
    }))
  }),
  h$ = "SliderThumb",
  eue = g.forwardRef((t, e) => {
    const n = Wle(t.__scopeSlider),
      [r, o] = g.useState(null),
      s = Yi(e, a => o(a)),
      i = g.useMemo(() => r ? n().findIndex(a => a.ref.current === r) : -1, [n, r]);
    return g.createElement(tue, G({}, t, {
      ref: s,
      index: i
    }))
  }),
  tue = g.forwardRef((t, e) => {
    const {
      __scopeSlider: n,
      index: r,
      ...o
    } = t, s = Nv(h$, n), i = J5(h$, n), [a, c] = g.useState(null), l = Yi(e, b => c(b)), u = Fle(a), d = s.values[r], f = d === void 0 ? 0 : e4(d, s.min, s.max), h = oue(r, s.values.length), m = u == null ? void 0 : u[i.size], p = m ? iue(m, f, i.direction) : 0;
    return g.useEffect(() => {
      if (a) return s.thumbs.add(a), () => {
        s.thumbs.delete(a)
      }
    }, [a, s.thumbs]), g.createElement("span", {
      style: {
        transform: "var(--radix-slider-thumb-transform)",
        position: "absolute",
        [i.startEdge]: `calc(${f}% + ${p}px)`
      }
    }, g.createElement(P_.ItemSlot, {
      scope: t.__scopeSlider
    }, g.createElement(Dv.span, G({
      role: "slider",
      "aria-label": t["aria-label"] || h,
      "aria-valuemin": s.min,
      "aria-valuenow": d,
      "aria-valuemax": s.max,
      "aria-orientation": s.orientation,
      "data-orientation": s.orientation,
      "data-disabled": s.disabled ? "" : void 0,
      tabIndex: s.disabled ? void 0 : 0
    }, o, {
      ref: l,
      style: d === void 0 ? {
        display: "none"
      } : t.style,
      onFocus: xl(t.onFocus, () => {
        s.valueIndexToChangeRef.current = r
      })
    }))))
  }),
  nue = t => {
    const {
      value: e,
      ...n
    } = t, r = g.useRef(null), o = Nle(e);
    return g.useEffect(() => {
      const s = r.current,
        i = window.HTMLInputElement.prototype,
        c = Object.getOwnPropertyDescriptor(i, "value").set;
      if (o !== e && c) {
        const l = new Event("input", {
          bubbles: !0
        });
        c.call(s, e), s.dispatchEvent(l)
      }
    }, [o, e]), g.createElement("input", G({
      style: {
        display: "none"
      }
    }, n, {
      ref: r,
      defaultValue: e
    }))
  };

function rue(t = [], e, n) {
  const r = [...t];
  return r[n] = e, r.sort((o, s) => o - s)
}

function e4(t, e, n) {
  return 100 / (n - e) * (t - e)
}

function oue(t, e) {
  return e > 2 ? `Value ${t+1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][t] : void 0
}

function sue(t, e) {
  if (t.length === 1) return 0;
  const n = t.map(o => Math.abs(o - e)),
    r = Math.min(...n);
  return n.indexOf(r)
}

function iue(t, e, n) {
  const r = t / 2,
    s = OE([0, 50], [0, r]);
  return (r - s(e) * n) * n
}

function aue(t) {
  return t.slice(0, -1).map((e, n) => t[n + 1] - e)
}

function cue(t, e) {
  if (e > 0) {
    const n = aue(t);
    return Math.min(...n) >= e
  }
  return !0
}

function OE(t, e) {
  return n => {
    if (t[0] === t[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (t[1] - t[0]);
    return e[0] + r * (n - t[0])
  }
}

function lue(t) {
  return (String(t).split(".")[1] || "").length
}

function uue(t, e) {
  const n = Math.pow(10, e);
  return Math.round(t * n) / n
}
const due = Yle,
  fue = Jle,
  hue = Qle,
  pue = eue,
  gue = g.memo(function(e) {
    const {
      title: n,
      steps: r,
      value: o,
      label: s,
      onValueChange: i
    } = e, a = Y(), c = nt(), l = g.useCallback(f => {
      i(f[0], !0)
    }, [i]), u = g.useCallback(() => {
      a.mark("click slider")
    }, [a]), d = g.useCallback(() => {
      o && i(o, !1)
    }, [o, i]);
    return y.jsx("div", {
      className: "tlui-slider__container",
      children: y.jsxs(due, {
        "data-testid": e["data-testid"],
        className: "tlui-slider",
        "area-label": "Opacity",
        dir: "ltr",
        min: 0,
        max: r,
        step: 1,
        value: o ? [o] : void 0,
        onPointerDown: u,
        onValueChange: l,
        onPointerUp: d,
        title: n + "  " + c(s),
        children: [y.jsx(fue, {
          className: "tlui-slider__track",
          dir: "ltr",
          children: o !== null && y.jsx(hue, {
            className: "tlui-slider__range",
            dir: "ltr"
          })
        }), o !== null && y.jsx(pue, {
          className: "tlui-slider__thumb",
          dir: "ltr"
        })]
      })
    })
  }),
  mue = g.memo(function({
    label: e,
    uiTypeA: n,
    uiTypeB: r,
    labelA: o,
    labelB: s,
    itemsA: i,
    itemsB: a,
    styleA: c,
    styleB: l,
    valueA: u,
    valueB: d,
    onValueChange: f
  }) {
    const h = nt(),
      m = g.useMemo(() => {
        var b;
        return ((b = i.find(w => u.type === "shared" && u.value === w.value)) == null ? void 0 : b.icon) ?? "mixed"
      }, [i, u]),
      p = g.useMemo(() => {
        var b;
        return ((b = a.find(w => d.type === "shared" && d.value === w.value)) == null ? void 0 : b.icon) ?? "mixed"
      }, [a, d]);
    return u === void 0 && d === void 0 ? null : y.jsxs("div", {
      className: "tlui-style-panel__double-select-picker",
      children: [y.jsx("div", {
        title: h(e),
        className: "tlui-style-panel__double-select-picker-label",
        children: h(e)
      }), y.jsxs("div", {
        className: "tlui-buttons__horizontal",
        children: [y.jsxs(Js, {
          id: `style panel ${n} A`,
          children: [y.jsx(Hf, {
            asChild: !0,
            onTouchEnd: b => at(b),
            children: y.jsx(me, {
              type: "icon",
              "data-testid": `style.${n}`,
              title: h(o) + "  " + (u === null || u.type === "mixed" ? h("style-panel.mixed") : h(`${n}-style.${u.value}`)),
              icon: m,
              invertIcon: !0,
              smallIcon: !0
            })
          }), y.jsx(Qs, {
            side: "bottom",
            align: "end",
            sideOffset: 0,
            alignOffset: -2,
            children: y.jsx("div", {
              className: "tlui-buttons__grid",
              children: i.map(b => y.jsx(fr, {
                type: "icon",
                title: h(o) + "  " + h(`${n}-style.${b.value}`),
                "data-testid": `style.${n}.${b.value}`,
                icon: b.icon,
                onClick: () => f(c, b.value, !1),
                invertIcon: !0
              }, b.value))
            })
          })]
        }), y.jsxs(Js, {
          id: `style panel ${r}`,
          children: [y.jsx(Hf, {
            asChild: !0,
            onTouchEnd: b => at(b),
            children: y.jsx(me, {
              type: "icon",
              "data-testid": `style.${r}`,
              title: h(s) + "  " + (d === null || d.type === "mixed" ? h("style-panel.mixed") : h(`${r}-style.${d.value}`)),
              icon: p,
              smallIcon: !0
            })
          }), y.jsx(Qs, {
            side: "bottom",
            align: "end",
            sideOffset: 0,
            alignOffset: -2,
            children: y.jsx("div", {
              className: "tlui-buttons__grid",
              children: a.map(b => y.jsx(fr, {
                type: "icon",
                title: h(s) + "  " + h(`${r}-style.${b.value}`),
                "data-testid": `style.${r}.${b.value}`,
                icon: b.icon,
                onClick: () => f(l, b.value, !1)
              }, b.value))
            })
          })]
        })]
      })]
    })
  }),
  RE = g.memo(function({
    id: e,
    label: n,
    uiType: r,
    style: o,
    items: s,
    type: i,
    value: a,
    onValueChange: c
  }) {
    const l = nt(),
      u = g.useMemo(() => {
        var d;
        return (d = s.find(f => a.type === "shared" && f.value === a.value)) == null ? void 0 : d.icon
      }, [s, a]);
    return y.jsxs(Js, {
      id: `style panel ${e}`,
      children: [y.jsx(Hf, {
        asChild: !0,
        onTouchEnd: d => at(d),
        children: y.jsx(me, {
          type: i,
          "data-testid": `style.${r}`,
          title: a.type === "mixed" ? l("style-panel.mixed") : l(`${r}-style.${a.value}`),
          label: n,
          icon: u ?? "mixed"
        })
      }), y.jsx(Qs, {
        side: "left",
        align: "center",
        alignOffset: 0,
        children: y.jsx("div", {
          className: "tlui-buttons__grid",
          children: s.map(d => y.jsx(fr, {
            type: "icon",
            "data-testid": `style.${r}.${d.value}`,
            title: l(`${r}-style.${d.value}`),
            icon: d.icon,
            onClick: () => c(o, d.value, !1)
          }, d.value))
        })
      })]
    })
  }),
  Po = {
    color: [{
      value: "black",
      icon: "color"
    }, {
      value: "grey",
      icon: "color"
    }, {
      value: "light-violet",
      icon: "color"
    }, {
      value: "violet",
      icon: "color"
    }, {
      value: "blue",
      icon: "color"
    }, {
      value: "light-blue",
      icon: "color"
    }, {
      value: "yellow",
      icon: "color"
    }, {
      value: "orange",
      icon: "color"
    }, {
      value: "green",
      icon: "color"
    }, {
      value: "light-green",
      icon: "color"
    }, {
      value: "light-red",
      icon: "color"
    }, {
      value: "red",
      icon: "color"
    }],
    fill: [{
      value: "none",
      icon: "fill-none"
    }, {
      value: "semi",
      icon: "fill-semi"
    }, {
      value: "solid",
      icon: "fill-solid"
    }, {
      value: "pattern",
      icon: "fill-pattern"
    }],
    dash: [{
      value: "draw",
      icon: "dash-draw"
    }, {
      value: "dashed",
      icon: "dash-dashed"
    }, {
      value: "dotted",
      icon: "dash-dotted"
    }, {
      value: "solid",
      icon: "dash-solid"
    }],
    size: [{
      value: "s",
      icon: "size-small"
    }, {
      value: "m",
      icon: "size-medium"
    }, {
      value: "l",
      icon: "size-large"
    }, {
      value: "xl",
      icon: "size-extra-large"
    }],
    font: [{
      value: "draw",
      icon: "font-draw"
    }, {
      value: "sans",
      icon: "font-sans"
    }, {
      value: "serif",
      icon: "font-serif"
    }, {
      value: "mono",
      icon: "font-mono"
    }],
    horizontalAlign: [{
      value: "start",
      icon: "text-align-left"
    }, {
      value: "middle",
      icon: "text-align-center"
    }, {
      value: "end",
      icon: "text-align-right"
    }],
    verticalAlign: [{
      value: "start",
      icon: "vertical-align-start"
    }, {
      value: "middle",
      icon: "vertical-align-center"
    }, {
      value: "end",
      icon: "vertical-align-end"
    }],
    geo: [{
      value: "rectangle",
      icon: "geo-rectangle"
    }, {
      value: "ellipse",
      icon: "geo-ellipse"
    }, {
      value: "cloud",
      icon: "geo-cloud"
    }, {
      value: "triangle",
      icon: "geo-triangle"
    }, {
      value: "diamond",
      icon: "geo-diamond"
    }, {
      value: "pentagon",
      icon: "geo-pentagon"
    }, {
      value: "hexagon",
      icon: "geo-hexagon"
    }, {
      value: "octagon",
      icon: "geo-octagon"
    }, {
      value: "star",
      icon: "geo-star"
    }, {
      value: "rhombus",
      icon: "geo-rhombus"
    }, {
      value: "rhombus-2",
      icon: "geo-rhombus-2"
    }, {
      value: "oval",
      icon: "geo-oval"
    }, {
      value: "trapezoid",
      icon: "geo-trapezoid"
    }, {
      value: "arrow-right",
      icon: "geo-arrow-right"
    }, {
      value: "arrow-left",
      icon: "geo-arrow-left"
    }, {
      value: "arrow-up",
      icon: "geo-arrow-up"
    }, {
      value: "arrow-down",
      icon: "geo-arrow-down"
    }, {
      value: "x-box",
      icon: "geo-x-box"
    }, {
      value: "check-box",
      icon: "geo-check-box"
    }],
    arrowheadStart: [{
      value: "none",
      icon: "arrowhead-none"
    }, {
      value: "arrow",
      icon: "arrowhead-arrow"
    }, {
      value: "triangle",
      icon: "arrowhead-triangle"
    }, {
      value: "square",
      icon: "arrowhead-square"
    }, {
      value: "dot",
      icon: "arrowhead-dot"
    }, {
      value: "diamond",
      icon: "arrowhead-diamond"
    }, {
      value: "inverted",
      icon: "arrowhead-triangle-inverted"
    }, {
      value: "bar",
      icon: "arrowhead-bar"
    }],
    arrowheadEnd: [{
      value: "none",
      icon: "arrowhead-none"
    }, {
      value: "arrow",
      icon: "arrowhead-arrow"
    }, {
      value: "triangle",
      icon: "arrowhead-triangle"
    }, {
      value: "square",
      icon: "arrowhead-square"
    }, {
      value: "dot",
      icon: "arrowhead-dot"
    }, {
      value: "diamond",
      icon: "arrowhead-diamond"
    }, {
      value: "inverted",
      icon: "arrowhead-triangle-inverted"
    }, {
      value: "bar",
      icon: "arrowhead-bar"
    }],
    spline: [{
      value: "line",
      icon: "spline-line"
    }, {
      value: "cubic",
      icon: "spline-cubic"
    }]
  },
  t4 = function({
    isMobile: e
  }) {
    const n = Y(),
      r = H5(),
      o = g.useCallback(() => {
        e || n.updateInstanceState({
          isChangingStyle: !1
        })
      }, [n, e]);
    if (!r) return null;
    const {
      styles: s,
      opacity: i
    } = r, a = s.get(ec), c = s.get(Tm), l = s.get(Pm), u = s.get(Im), d = s.get(Qa), f = a === void 0, h = c === void 0 && l === void 0, m = u === void 0, p = d === void 0;
    return y.jsxs("div", {
      className: "tlui-style-panel",
      "data-ismobile": e,
      onPointerLeave: o,
      children: [y.jsx(yue, {
        styles: s,
        opacity: i
      }), !p && y.jsx(vue, {
        styles: s
      }), !(f && h && m) && y.jsxs("div", {
        className: "tlui-style-panel__section",
        "aria-label": "style panel styles",
        children: [y.jsx(bue, {
          styles: s
        }), y.jsx(Sue, {
          styles: s
        }), y.jsx(wue, {
          styles: s
        })]
      })]
    })
  };

function Lh() {
  const t = Y();
  return se.useMemo(() => function(n, r, o) {
    t.batch(() => {
      t.isIn("select") && t.setStyleForSelectedShapes(n, r, {
        squashing: o
      }), t.setStyleForNextShapes(n, r, {
        squashing: o
      }), t.updateInstanceState({
        isChangingStyle: !0
      })
    })
  }, [t])
}
const md = [.1, .25, .5, .75, 1];

function yue({
  styles: t,
  opacity: e
}) {
  const n = Y(),
    r = nt(),
    o = Lh(),
    s = se.useCallback((f, h) => {
      const m = md[f];
      n.batch(() => {
        n.isIn("select") && n.setOpacityForSelectedShapes(m, {
          ephemeral: h
        }), n.setOpacityForNextShapes(m, {
          ephemeral: h
        }), n.updateInstanceState({
          isChangingStyle: !0
        })
      })
    }, [n]),
    i = t.get(ao),
    a = t.get(tu),
    c = t.get(Ja),
    l = t.get(us),
    u = a !== void 0 || c !== void 0 || l !== void 0,
    d = e.type === "mixed" ? -1 : md.indexOf(wz(md, f => Math.abs(f - e.value)));
  return y.jsxs(y.Fragment, {
    children: [y.jsxs("div", {
      tabIndex: -1,
      className: "tlui-style-panel__section__common",
      "aria-label": "style panel styles",
      children: [i === void 0 ? null : y.jsx(_l, {
        title: r("style-panel.color"),
        uiType: "color",
        style: ao,
        items: Po.color,
        value: i,
        onValueChange: o
      }), e === void 0 ? null : y.jsx(gue, {
        "data-testid": "style.opacity",
        value: d >= 0 ? d : md.length - 1,
        label: e.type === "mixed" ? "style-panel.mixed" : `opacity-style.${e.value}`,
        onValueChange: s,
        steps: md.length - 1,
        title: r("style-panel.opacity")
      })]
    }), u && y.jsxs("div", {
      className: "tlui-style-panel__section",
      "aria-label": "style panel styles",
      children: [a === void 0 ? null : y.jsx(_l, {
        title: r("style-panel.fill"),
        uiType: "fill",
        style: tu,
        items: Po.fill,
        value: a,
        onValueChange: o
      }), c === void 0 ? null : y.jsx(_l, {
        title: r("style-panel.dash"),
        uiType: "dash",
        style: Ja,
        items: Po.dash,
        value: c,
        onValueChange: o
      }), l === void 0 ? null : y.jsx(_l, {
        title: r("style-panel.size"),
        uiType: "size",
        style: us,
        items: Po.size,
        value: l,
        onValueChange: o
      })]
    })]
  })
}

function vue({
  styles: t
}) {
  const e = nt(),
    n = Lh(),
    r = t.get(Qa),
    o = t.get(If),
    s = t.get($m);
  return r === void 0 && o === void 0 ? null : y.jsxs("div", {
    className: "tlui-style-panel__section",
    "aria-label": "style panel text",
    children: [r === void 0 ? null : y.jsx(_l, {
      title: e("style-panel.font"),
      uiType: "font",
      style: Qa,
      items: Po.font,
      value: r,
      onValueChange: n
    }), o === void 0 ? null : y.jsxs("div", {
      className: "tlui-style-panel__row",
      children: [y.jsx(_l, {
        title: e("style-panel.align"),
        uiType: "align",
        style: If,
        items: Po.horizontalAlign,
        value: o,
        onValueChange: n
      }), y.jsx("div", {
        className: "tlui-style-panel__row__extra-button",
        children: s === void 0 ? y.jsx(me, {
          type: "icon",
          title: e("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          icon: "vertical-align-center",
          disabled: !0
        }) : y.jsx(RE, {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          style: $m,
          items: Po.verticalAlign,
          value: s,
          onValueChange: n
        })
      })]
    })]
  })
}

function bue({
  styles: t
}) {
  const e = Lh(),
    n = t.get(ec);
  return n === void 0 ? null : y.jsx(RE, {
    id: "geo",
    type: "menu",
    label: "style-panel.geo",
    uiType: "geo",
    style: ec,
    items: Po.geo,
    value: n,
    onValueChange: e
  })
}

function wue({
  styles: t
}) {
  const e = Lh(),
    n = t.get(Im);
  return n === void 0 ? null : y.jsx(RE, {
    id: "spline",
    type: "menu",
    label: "style-panel.spline",
    uiType: "spline",
    style: Im,
    items: Po.spline,
    value: n,
    onValueChange: e
  })
}

function Sue({
  styles: t
}) {
  const e = Lh(),
    n = t.get(Tm),
    r = t.get(Pm);
  return !n || !r ? null : y.jsx(mue, {
    label: "style-panel.arrowheads",
    uiTypeA: "arrowheadStart",
    styleA: Pm,
    itemsA: Po.arrowheadStart,
    valueA: r,
    uiTypeB: "arrowheadEnd",
    styleB: Tm,
    itemsB: Po.arrowheadEnd,
    valueB: n,
    onValueChange: e,
    labelA: "style-panel.arrowhead-start",
    labelB: "style-panel.arrowhead-end"
  })
}

function _ue({
  toast: t
}) {
  const {
    removeToast: e
  } = bs(), n = nt(), r = s => {
    s || e(t.id)
  }, o = t.actions && t.actions.length > 0;
  return y.jsxs(bj, {
    onOpenChange: r,
    className: "tlui-toast__container",
    duration: t.keepOpen ? 1 / 0 : 5e3,
    children: [t.icon && y.jsx("div", {
      className: "tlui-toast__icon",
      children: y.jsx(wr, {
        icon: t.icon
      })
    }), y.jsxs("div", {
      className: "tlui-toast__main",
      children: [y.jsxs("div", {
        className: "tlui-toast__content",
        children: [t.title && y.jsx(wj, {
          className: "tlui-toast__title",
          children: t.title
        }), t.description && y.jsx(joe, {
          className: "tlui-toast__description",
          children: t.description
        })]
      }), t.actions && y.jsxs("div", {
        className: "tlui-toast__actions",
        children: [t.actions.map((s, i) => y.jsx(Doe, {
          altText: s.label,
          asChild: !0,
          onClick: s.onClick,
          children: y.jsx(me, {
            type: s.type,
            children: s.label
          })
        }, i)), y.jsx(N2, {
          asChild: !0,
          children: y.jsx(me, {
            type: "normal",
            className: "tlui-toast__close",
            style: {
              marginLeft: "auto"
            },
            children: t.closeLabel ?? n("toast.close")
          })
        })]
      })]
    }), !o && y.jsx(N2, {
      asChild: !0,
      children: y.jsx(me, {
        type: "normal",
        className: "tlui-toast__close",
        children: t.closeLabel ?? n("toast.close")
      })
    })]
  })
}

function xue() {
  const {
    toasts: t
  } = bs();
  return y.jsx(y.Fragment, {
    children: t.map(e => y.jsx(_ue, {
      toast: e
    }, e.id))
  })
}
const Eue = g.memo(xue);

function kue() {
  const {
    toasts: t
  } = bs(), [e, n] = g.useState(!1);
  return g.useEffect(() => {
    let r = !1;
    return t.length ? n(!0) : setTimeout(() => {
      r || n(!1)
    }, 1e3), () => {
      r = !0
    }
  }, [t.length, n]), e ? y.jsx(hj, {
    className: "tlui-toast__viewport"
  }) : null
}

function Cue() {
  const t = Y(),
    e = nt(),
    n = H5(),
    r = n == null ? void 0 : n.styles.get(ao),
    o = wh({
      isDarkMode: t.user.isDarkMode
    }),
    s = ((r == null ? void 0 : r.type) === "shared" ? o[r.value] : o.black).solid,
    i = te("isHandOrEraserToolActive", () => t.isInAny("hand", "zoom", "eraser", "laser"), [t]),
    a = g.useCallback(c => {
      c || t.updateInstanceState({
        isChangingStyle: !1
      })
    }, [t]);
  return y.jsxs($E, {
    id: "style menu",
    onOpenChange: a,
    children: [y.jsx(IE, {
      disabled: i,
      children: y.jsx(me, {
        type: "tool",
        "data-testid": "mobile.styles",
        style: {
          color: i ? "var(--color-muted-1)" : s
        },
        title: e("style-panel.title"),
        children: y.jsx(wr, {
          icon: i ? "blob" : (r == null ? void 0 : r.type) === "mixed" ? "mixed" : "blob"
        })
      })
    }), y.jsx(N5, {
      side: "top",
      align: "end",
      children: y.jsx(t4, {
        isMobile: !0
      })
    })]
  })
}
const Pue = ["select", "hand", "draw", "eraser", "text", "zoom", "laser", "highlight"];

function Tue({
  activeToolId: t
}) {
  const e = Y(),
    n = uo(),
    r = nt(),
    o = te("is tool locked", () => e.getInstanceState().isToolLocked, [e]);
  return !t || Pue.includes(t) ? null : y.jsx(me, {
    type: "normal",
    title: r("action.toggle-tool-lock"),
    className: ae("tlui-toolbar__lock-button", {
      "tlui-toolbar__lock-button__mobile": n < 5
    }),
    icon: o ? "lock" : "unlock",
    onClick: () => e.updateInstanceState({
      isToolLocked: !o
    }),
    smallIcon: !0
  })
}
const $ue = g.memo(function() {
    const e = Y(),
      n = nt(),
      r = uo(),
      o = se.useRef(void 0),
      s = lo(),
      i = Jie(),
      a = i.find(b => b.toolItem.id === "laser"),
      c = te("current tool id", () => e.getCurrentToolId(), [e]),
      l = te("geo", () => e.sharedStyles.getAsKnownValue(ec), [e]),
      u = !s,
      d = b => b.label ? `${n(b.label)} ${b.kbd?fs(b.kbd):""}` : "",
      f = i.find(b => zc(b.toolItem, c, l)),
      {
        itemsInPanel: h,
        itemsInDropdown: m,
        dropdownFirstItem: p
      } = se.useMemo(() => {
        const b = [],
          w = [];
        let v;
        const _ = Math.min(8, 5 + r);
        for (let S = 4; S < i.length; S++) {
          const x = i[S];
          S < _ ? b.push(x) : (x === f && (v = x), w.push(x))
        }
        return v || (o.current || (o.current = w[0]), v = o.current, w.includes(v) || (v = w[0])), o.current = v, w.length <= 2 && (b.push(...w), w.length = 0), {
          itemsInPanel: b,
          itemsInDropdown: w,
          dropdownFirstItem: v
        }
      }, [i, f, r]);
    return y.jsx("div", {
      className: "tlui-toolbar",
      children: y.jsxs("div", {
        className: "tlui-toolbar__inner",
        children: [y.jsxs("div", {
          className: "tlui-toolbar__left",
          children: [!s && y.jsxs("div", {
            className: "tlui-toolbar__extras",
            children: [r < 6 && !(c === "hand" || c === "zoom") && y.jsxs("div", {
              className: "tlui-toolbar__extras__controls tlui-buttons__horizontal",
              children: [y.jsx(z5, {}), y.jsx(B5, {}), y.jsx(U5, {}), y.jsx(F5, {}), y.jsx(L5, {})]
            }), y.jsx(Tue, {
              activeToolId: c
            })]
          }), y.jsxs("div", {
            className: ae("tlui-toolbar__tools", {
              "tlui-toolbar__tools__mobile": r < 5
            }),
            children: [i.slice(0, 2).map(({
              toolItem: b
            }) => y.jsx(yd, {
              item: b,
              title: d(b),
              isSelected: zc(b, c, l)
            }, b.id)), s && a && y.jsx(yd, {
              item: a.toolItem,
              title: d(a.toolItem),
              isSelected: zc(a.toolItem, c, l)
            }, a.toolItem.id), u && y.jsxs(y.Fragment, {
              children: [i.slice(2, 4).map(({
                toolItem: b
              }) => y.jsx(yd, {
                item: b,
                title: d(b),
                isSelected: zc(b, c, l)
              }, b.id)), h.map(({
                toolItem: b
              }) => y.jsx(yd, {
                item: b,
                title: d(b),
                isSelected: zc(b, c, l)
              }, b.id)), m.length ? y.jsxs(y.Fragment, {
                children: [y.jsx(yd, {
                  item: p.toolItem,
                  title: d(p.toolItem),
                  isSelected: zc(p.toolItem, c, l)
                }, p.toolItem.id), y.jsxs(Js, {
                  id: "toolbar overflow",
                  modal: !1,
                  children: [y.jsx(Ou, {
                    children: y.jsx(me, {
                      className: "tlui-toolbar__overflow",
                      icon: "chevron-up",
                      type: "tool",
                      "data-testid": "tools.more",
                      title: n("tool-panel.more")
                    })
                  }), y.jsx(Qs, {
                    side: "top",
                    align: "center",
                    children: y.jsx(Iue, {
                      toolbarItems: m
                    })
                  })]
                })]
              }) : null]
            })]
          })]
        }), r < 5 && !s && y.jsx("div", {
          className: "tlui-toolbar__tools",
          children: y.jsx(Cue, {})
        })]
      })
    })
  }),
  Iue = pt(function({
    toolbarItems: e
  }) {
    const n = nt();
    return y.jsx("div", {
      className: "tlui-buttons__grid",
      children: e.map(({
        toolItem: {
          id: r,
          meta: o,
          kbd: s,
          label: i,
          onSelect: a,
          icon: c
        }
      }) => y.jsx(fr, {
        type: "icon",
        className: "tlui-button-grid__button",
        "data-testid": `tools.more.${r}`,
        "data-tool": r,
        "data-geo": (o == null ? void 0 : o.geo) ?? "",
        "aria-label": i,
        onClick: () => a("toolbar"),
        title: i ? `${n(i)} ${s?fs(s):""}` : "",
        icon: c
      }, r))
    })
  });

function yd({
  item: t,
  title: e,
  isSelected: n
}) {
  var r;
  return y.jsx(me, {
    type: "tool",
    "data-testid": `tools.${t.id}`,
    "data-tool": t.id,
    "data-geo": ((r = t.meta) == null ? void 0 : r.geo) ?? "",
    "aria-label": t.label,
    title: e,
    icon: t.icon,
    "data-state": n ? "selected" : void 0,
    onClick: () => t.onSelect("toolbar"),
    onTouchStart: o => {
      at(o), t.onSelect("toolbar")
    }
  })
}
const zc = (t, e, n) => {
  var r, o;
  return (r = t.meta) != null && r.geo ? e === "geo" && n === ((o = t.meta) == null ? void 0 : o.geo) : e === t.id
};

function Oue() {
  const t = Y(),
    {
      addToast: e
    } = bs();
  g.useEffect(() => {
    function n({
      name: r,
      count: o
    }) {
      e({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${r} (${o}). Please delete some shapes or move to a different page to continue.`
      })
    }
    return t.addListener("max-shapes", n), () => {
      t.removeListener("max-shapes", n)
    }
  }, [t, e])
}
var Wb = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;

function Kb(t, e, n, r) {
  t.addEventListener ? t.addEventListener(e, n, r) : t.attachEvent && t.attachEvent("on".concat(e), function() {
    n(window.event)
  })
}

function n4(t, e) {
  for (var n = e.slice(0, e.length - 1), r = 0; r < n.length; r++) n[r] = t[n[r].toLowerCase()];
  return n
}

function r4(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  for (var e = t.split(","), n = e.lastIndexOf(""); n >= 0;) e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e
}

function Rue(t, e) {
  for (var n = t.length >= e.length ? t : e, r = t.length >= e.length ? e : t, o = !0, s = 0; s < n.length; s++) r.indexOf(n[s]) === -1 && (o = !1);
  return o
}
var Wf = {
    backspace: 8,
    "": 8,
    tab: 9,
    clear: 12,
    enter: 13,
    "": 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": Wb ? 173 : 189,
    "=": Wb ? 61 : 187,
    ";": Wb ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  },
  ps = {
    "": 16,
    shift: 16,
    "": 18,
    alt: 18,
    option: 18,
    "": 17,
    ctrl: 17,
    control: 17,
    "": 91,
    cmd: 91,
    command: 91
  },
  T_ = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  },
  kn = {
    16: !1,
    18: !1,
    17: !1,
    91: !1
  },
  on = {};
for (var og = 1; og < 20; og++) Wf["f".concat(og)] = 111 + og;
var kt = [],
  p$ = !1,
  o4 = "all",
  s4 = [],
  Lv = function(e) {
    return Wf[e.toLowerCase()] || ps[e.toLowerCase()] || e.toUpperCase().charCodeAt(0)
  },
  Aue = function(e) {
    return Object.keys(Wf).find(function(n) {
      return Wf[n] === e
    })
  },
  Mue = function(e) {
    return Object.keys(ps).find(function(n) {
      return ps[n] === e
    })
  };

function i4(t) {
  o4 = t || "all"
}

function Kf() {
  return o4 || "all"
}

function jue() {
  return kt.slice(0)
}

function Due() {
  return kt.map(function(t) {
    return Aue(t) || Mue(t) || String.fromCharCode(t)
  })
}

function Nue(t) {
  var e = t.target || t.srcElement,
    n = e.tagName,
    r = !0;
  return (e.isContentEditable || (n === "INPUT" || n === "TEXTAREA" || n === "SELECT") && !e.readOnly) && (r = !1), r
}

function Lue(t) {
  return typeof t == "string" && (t = Lv(t)), kt.indexOf(t) !== -1
}

function Fue(t, e) {
  var n, r;
  t || (t = Kf());
  for (var o in on)
    if (Object.prototype.hasOwnProperty.call(on, o))
      for (n = on[o], r = 0; r < n.length;) n[r].scope === t ? n.splice(r, 1) : r++;
  Kf() === t && i4(e || "all")
}

function Bue(t) {
  var e = t.keyCode || t.which || t.charCode,
    n = kt.indexOf(e);
  if (n >= 0 && kt.splice(n, 1), t.key && t.key.toLowerCase() === "meta" && kt.splice(0, kt.length), (e === 93 || e === 224) && (e = 91), e in kn) {
    kn[e] = !1;
    for (var r in ps) ps[r] === e && (To[r] = !1)
  }
}

function Uue(t) {
  if (typeof t > "u") Object.keys(on).forEach(function(i) {
    return delete on[i]
  });
  else if (Array.isArray(t)) t.forEach(function(i) {
    i.key && Gb(i)
  });
  else if (typeof t == "object") t.key && Gb(t);
  else if (typeof t == "string") {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    var o = n[0],
      s = n[1];
    typeof o == "function" && (s = o, o = ""), Gb({
      key: t,
      scope: o,
      method: s,
      splitKey: "+"
    })
  }
}
var Gb = function(e) {
  var n = e.key,
    r = e.scope,
    o = e.method,
    s = e.splitKey,
    i = s === void 0 ? "+" : s,
    a = r4(n);
  a.forEach(function(c) {
    var l = c.split(i),
      u = l.length,
      d = l[u - 1],
      f = d === "*" ? "*" : Lv(d);
    if (on[f]) {
      r || (r = Kf());
      var h = u > 1 ? n4(ps, l) : [];
      on[f] = on[f].filter(function(m) {
        var p = o ? m.method === o : !0;
        return !(p && m.scope === r && Rue(m.mods, h))
      })
    }
  })
};

function g$(t, e, n, r) {
  if (e.element === r) {
    var o;
    if (e.scope === n || e.scope === "all") {
      o = e.mods.length > 0;
      for (var s in kn) Object.prototype.hasOwnProperty.call(kn, s) && (!kn[s] && e.mods.indexOf(+s) > -1 || kn[s] && e.mods.indexOf(+s) === -1) && (o = !1);
      (e.mods.length === 0 && !kn[16] && !kn[18] && !kn[17] && !kn[91] || o || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(kt), e.method(t, e) === !1 && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)))
    }
  }
}

function m$(t, e) {
  var n = on["*"],
    r = t.keyCode || t.which || t.charCode;
  if (To.filter.call(this, t)) {
    if ((r === 93 || r === 224) && (r = 91), kt.indexOf(r) === -1 && r !== 229 && kt.push(r), ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(m) {
        var p = T_[m];
        t[m] && kt.indexOf(p) === -1 ? kt.push(p) : !t[m] && kt.indexOf(p) > -1 ? kt.splice(kt.indexOf(p), 1) : m === "metaKey" && t[m] && kt.length === 3 && (t.ctrlKey || t.shiftKey || t.altKey || (kt = kt.slice(kt.indexOf(p))))
      }), r in kn) {
      kn[r] = !0;
      for (var o in ps) ps[o] === r && (To[o] = !0);
      if (!n) return
    }
    for (var s in kn) Object.prototype.hasOwnProperty.call(kn, s) && (kn[s] = t[T_[s]]);
    t.getModifierState && !(t.altKey && !t.ctrlKey) && t.getModifierState("AltGraph") && (kt.indexOf(17) === -1 && kt.push(17), kt.indexOf(18) === -1 && kt.push(18), kn[17] = !0, kn[18] = !0);
    var i = Kf();
    if (n)
      for (var a = 0; a < n.length; a++) n[a].scope === i && (t.type === "keydown" && n[a].keydown || t.type === "keyup" && n[a].keyup) && g$(t, n[a], i, e);
    if (r in on) {
      for (var c = 0; c < on[r].length; c++)
        if ((t.type === "keydown" && on[r][c].keydown || t.type === "keyup" && on[r][c].keyup) && on[r][c].key) {
          for (var l = on[r][c], u = l.splitKey, d = l.key.split(u), f = [], h = 0; h < d.length; h++) f.push(Lv(d[h]));
          f.sort().join("") === kt.sort().join("") && g$(t, l, i, e)
        }
    }
  }
}

function zue(t) {
  return s4.indexOf(t) > -1
}

function To(t, e, n) {
  kt = [];
  var r = r4(t),
    o = [],
    s = "all",
    i = document,
    a = 0,
    c = !1,
    l = !0,
    u = "+",
    d = !1;
  for (n === void 0 && typeof e == "function" && (n = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (s = e.scope), e.element && (i = e.element), e.keyup && (c = e.keyup), e.keydown !== void 0 && (l = e.keydown), e.capture !== void 0 && (d = e.capture), typeof e.splitKey == "string" && (u = e.splitKey)), typeof e == "string" && (s = e); a < r.length; a++) t = r[a].split(u), o = [], t.length > 1 && (o = n4(ps, t)), t = t[t.length - 1], t = t === "*" ? "*" : Lv(t), t in on || (on[t] = []), on[t].push({
    keyup: c,
    keydown: l,
    scope: s,
    mods: o,
    shortcut: r[a],
    method: n,
    key: r[a],
    splitKey: u,
    element: i
  });
  typeof i < "u" && !zue(i) && window && (s4.push(i), Kb(i, "keydown", function(f) {
    m$(f, i)
  }, d), p$ || (p$ = !0, Kb(window, "focus", function() {
    kt = []
  }, d)), Kb(i, "keyup", function(f) {
    m$(f, i), Bue(f)
  }, d))
}

function Hue(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(on).forEach(function(n) {
    var r = on[n].filter(function(o) {
      return o.scope === e && o.shortcut === t
    });
    r.forEach(function(o) {
      o && o.method && o.method()
    })
  })
}
var Yb = {
  getPressedKeyString: Due,
  setScope: i4,
  getScope: Kf,
  deleteScope: Fue,
  getPressedKeyCodes: jue,
  isPressed: Lue,
  filter: Nue,
  trigger: Hue,
  unbind: Uue,
  keyMap: Wf,
  modifier: ps,
  modifierMap: T_
};
for (var qb in Yb) Object.prototype.hasOwnProperty.call(Yb, qb) && (To[qb] = Yb[qb]);
if (typeof window < "u") {
  var Vue = window.hotkeys;
  To.noConflict = function(t) {
    return t && window.hotkeys === To && (window.hotkeys = Vue), To
  }, window.hotkeys = To
}
const y$ = ["copy", "cut", "paste", "asset"];

function Wue() {
  const t = Y(),
    e = lo(),
    n = Xn(),
    r = gE(),
    o = te("is focused", () => t.getInstanceState().isFocused, [t]);
  g.useEffect(() => {
    if (!o) return;
    const s = t.getContainer();
    To.setScope(t.store.id);
    const i = (c, l) => {
        To(c, {
          element: s,
          scope: t.store.id
        }, l)
      },
      a = () => t.getIsMenuOpen() || t.getEditingShapeId() !== null || t.crashingError;
    for (const c of Object.values(n)) c.kbd && (e && !c.readonlyOk || y$.includes(c.id) || i(v$(c.kbd), l => {
      a() || (at(l), c.onSelect("kbd"))
    }));
    for (const c of Object.values(r)) !c.kbd || !c.readonlyOk && t.getInstanceState().isReadonly || y$.includes(c.id) || i(v$(c.kbd), l => {
      a() || (at(l), c.onSelect("kbd"))
    });
    return () => {
      To.deleteScope(t.store.id)
    }
  }, [n, r, e, t, o])
}

function v$(t) {
  return Kue(t).map(e => {
    let n = "";
    const r = e.split("");
    return r.length === 1 ? n = r[0] : r[0] === "!" ? n = `shift+${r[1]}` : r[0] === "?" ? r.length === 3 && r[1] === "!" ? n = `alt+shift+${r[2]}` : n = `alt+${r[1]}` : r[0] === "$" ? r[1] === "!" ? n = `cmd+shift+${r[2]},ctrl+shift+${r[2]}` : r[1] === "?" ? n = `cmd++${r[2]},ctrl+alt+${r[2]}` : n = `cmd+${r[1]},ctrl+${r[1]}` : n = e, n
  }).join(",")
}

function Kue(t) {
  typeof t != "string" && (t = ""), t = t.replace(/\s/g, "");
  const e = t.split(",");
  let n = e.lastIndexOf("");
  for (; n >= 0;) e[n - 1] += ",", e.splice(n, 1), n = e.lastIndexOf("");
  return e
}
const Fbe = se.memo(function({
    shareZone: e,
    topZone: n,
    renderDebugMenuItems: r,
    children: o,
    hideUi: s,
    ...i
  }) {
    return y.jsx(rae, {
      ...i,
      children: y.jsx(Gue, {
        hideUi: s,
        shareZone: e,
        topZone: n,
        renderDebugMenuItems: r,
        children: o
      })
    })
  }),
  Gue = se.memo(function({
    children: e,
    hideUi: n,
    ...r
  }) {
    return y.jsxs(y.Fragment, {
      children: [e, n ? null : y.jsx(Yue, {
        ...r
      })]
    })
  }),
  Yue = se.memo(function({
    shareZone: e,
    topZone: n,
    renderDebugMenuItems: r
  }) {
    const o = Y(),
      s = nt(),
      i = uo(),
      a = te("isReadonlyMode", () => o.getInstanceState().isReadonly, [o]),
      c = te("focus", () => o.getInstanceState().isFocusMode, [o]),
      l = te("debug", () => o.getInstanceState().isDebugMode, [o]);
    Wue(), Eie(), Oue();
    const {
      "toggle-focus-mode": u
    } = Xn();
    return y.jsx(nE, {
      children: y.jsxs("div", {
        className: ae("tlui-layout", {
          "tlui-layout__mobile": i < 5
        }),
        "data-breakpoint": i,
        children: [c ? y.jsx("div", {
          className: "tlui-layout__top",
          children: y.jsx(me, {
            type: "icon",
            className: "tlui-focus-button",
            title: `${s("focus-mode.toggle-focus-mode")}`,
            icon: "dot",
            onClick: () => u.onSelect("menu")
          })
        }) : y.jsxs(y.Fragment, {
          children: [y.jsxs("div", {
            className: "tlui-layout__top",
            children: [y.jsxs("div", {
              className: "tlui-layout__top__left",
              children: [y.jsx(_le, {}), y.jsxs("div", {
                className: "tlui-helper-buttons",
                children: [y.jsx(Cle, {}), y.jsx(sae, {}), y.jsx(Ple, {})]
              })]
            }), y.jsx("div", {
              className: "tlui-layout__top__center",
              children: n
            }), y.jsxs("div", {
              className: "tlui-layout__top__right",
              children: [e, i >= 5 && !a && y.jsx("div", {
                className: "tlui-style-panel__wrapper",
                children: y.jsx(t4, {})
              })]
            })]
          }), y.jsxs("div", {
            className: "tlui-layout__bottom",
            children: [y.jsxs("div", {
              className: "tlui-layout__bottom__main",
              children: [y.jsx(kle, {}), y.jsx($ue, {}), i >= 4 && y.jsx(ole, {})]
            }), l && y.jsx(Gce, {
              renderDebugMenuItems: r ?? null
            })]
          })]
        }), y.jsx(Eue, {}), y.jsx(tle, {}), y.jsx(kue, {}), y.jsx(nle, {})]
      })
    })
  }),
  a4 = "ContextMenu",
  [que, Bbe] = Vo(a4, [Ov]),
  ws = Ov(),
  [Xue, c4] = que(a4),
  Zue = t => {
    const {
      __scopeContextMenu: e,
      children: n,
      onOpenChange: r,
      dir: o,
      modal: s = !0
    } = t, [i, a] = g.useState(!1), c = ws(e), l = At(r), u = g.useCallback(d => {
      a(d), l(d)
    }, [l]);
    return g.createElement(Xue, {
      scope: e,
      open: i,
      onOpenChange: u,
      modal: s
    }, g.createElement(f5, G({}, c, {
      dir: o,
      open: i,
      onOpenChange: u,
      modal: s
    }), n))
  },
  Jue = "ContextMenuTrigger",
  Que = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      disabled: r = !1,
      ...o
    } = t, s = c4(Jue, n), i = ws(n), a = g.useRef({
      x: 0,
      y: 0
    }), c = g.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({
        width: 0,
        height: 0,
        ...a.current
      })
    }), l = g.useRef(0), u = g.useCallback(() => window.clearTimeout(l.current), []), d = f => {
      a.current = {
        x: f.clientX,
        y: f.clientY
      }, s.onOpenChange(!0)
    };
    return g.useEffect(() => u, [u]), g.useEffect(() => void(r && u()), [r, u]), g.createElement(g.Fragment, null, g.createElement(h5, G({}, i, {
      virtualRef: c
    })), g.createElement(Ke.span, G({
      "data-state": s.open ? "open" : "closed",
      "data-disabled": r ? "" : void 0
    }, o, {
      ref: e,
      style: {
        WebkitTouchCallout: "none",
        ...t.style
      },
      onContextMenu: r ? t.onContextMenu : ie(t.onContextMenu, f => {
        u(), d(f), f.preventDefault()
      }),
      onPointerDown: r ? t.onPointerDown : ie(t.onPointerDown, sg(f => {
        u(), l.current = window.setTimeout(() => d(f), 700)
      })),
      onPointerMove: r ? t.onPointerMove : ie(t.onPointerMove, sg(u)),
      onPointerCancel: r ? t.onPointerCancel : ie(t.onPointerCancel, sg(u)),
      onPointerUp: r ? t.onPointerUp : ie(t.onPointerUp, sg(u))
    })))
  }),
  ede = t => {
    const {
      __scopeContextMenu: e,
      ...n
    } = t, r = ws(e);
    return g.createElement(p5, G({}, r, n))
  },
  tde = "ContextMenuContent",
  nde = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = c4(tde, n), s = ws(n), i = g.useRef(!1);
    return g.createElement(g5, G({}, s, r, {
      ref: e,
      side: "right",
      sideOffset: 2,
      align: "start",
      onCloseAutoFocus: a => {
        var c;
        (c = t.onCloseAutoFocus) === null || c === void 0 || c.call(t, a), !a.defaultPrevented && i.current && a.preventDefault(), i.current = !1
      },
      onInteractOutside: a => {
        var c;
        (c = t.onInteractOutside) === null || c === void 0 || c.call(t, a), !a.defaultPrevented && !o.modal && (i.current = !0)
      },
      style: {
        ...t.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))
  }),
  rde = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = ws(n);
    return g.createElement(m5, G({}, o, r, {
      ref: e
    }))
  }),
  ode = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = ws(n);
    return g.createElement(y5, G({}, o, r, {
      ref: e
    }))
  }),
  sde = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = ws(n);
    return g.createElement(v5, G({}, o, r, {
      ref: e
    }))
  }),
  ide = t => {
    const {
      __scopeContextMenu: e,
      children: n,
      onOpenChange: r,
      open: o,
      defaultOpen: s
    } = t, i = ws(e), [a, c] = Xs({
      prop: o,
      defaultProp: s,
      onChange: r
    });
    return g.createElement(b5, G({}, i, {
      open: a,
      onOpenChange: c
    }), n)
  },
  ade = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = ws(n);
    return g.createElement(w5, G({}, o, r, {
      ref: e
    }))
  }),
  cde = g.forwardRef((t, e) => {
    const {
      __scopeContextMenu: n,
      ...r
    } = t, o = ws(n);
    return g.createElement(S5, G({}, o, r, {
      ref: e,
      style: {
        ...t.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))
  });

function sg(t) {
  return e => e.pointerType !== "mouse" ? t(e) : void 0
}
const lde = Zue,
  ude = Que,
  ty = ede,
  dde = nde,
  $_ = rde,
  I_ = ode,
  fde = sde,
  l4 = ide,
  u4 = ade,
  d4 = cde,
  hde = pt(function() {
    const e = Y(),
      n = Rn(),
      r = e.pages,
      o = e.currentPageId,
      s = nt(),
      {
        addToast: i
      } = bs();
    return y.jsxs(l4, {
      children: [y.jsx(u4, {
        dir: "ltr",
        asChild: !0,
        children: y.jsx(me, {
          type: "menu",
          label: "context-menu.move-to-page",
          "data-testid": "menu-item.move-to-page",
          icon: "chevron-right"
        })
      }), y.jsx(ty, {
        container: n,
        children: y.jsxs(d4, {
          className: "tlui-menu",
          sideOffset: -4,
          collisionPadding: 4,
          children: [y.jsx($_, {
            dir: "ltr",
            className: "tlui-menu__group",
            "data-testid": "menu-item.pages",
            children: r.map(a => y.jsx(I_, {
              disabled: o === a.id,
              onSelect: () => {
                e.mark("move_shapes_to_page"), e.moveShapesToPage(e.getSelectedShapeIds(), a.id);
                const c = e.getPage(a.id);
                c && i({
                  title: "Changed Page",
                  description: `Moved to ${c.name}.`,
                  actions: [{
                    label: "Go Back",
                    type: "primary",
                    onClick: () => {
                      e.mark("change-page"), e.setCurrentPage(o)
                    }
                  }]
                })
              },
              asChild: !0,
              children: y.jsx(me, {
                type: "menu",
                title: a.name,
                className: "tlui-context-menu__move-to-page__name",
                children: y.jsx("span", {
                  className: "tlui-button__label",
                  children: a.name
                })
              })
            }, a.id))
          }, "pages"), y.jsx($_, {
            dir: "ltr",
            className: "tlui-menu__group",
            "data-testid": "menu-item.new-page",
            children: y.jsx(I_, {
              onSelect: () => {
                const a = Ys.createId(),
                  c = e.getSelectedShapeIds();
                e.batch(() => {
                  e.mark("move_shapes_to_page"), e.createPage({
                    name: "Page",
                    id: a
                  }), e.moveShapesToPage(c, a)
                })
              },
              asChild: !0,
              children: y.jsx(me, {
                type: "menu",
                title: s("context.pages.new-page"),
                className: "tlui-context-menu__move-to-page__name",
                children: y.jsx("span", {
                  className: "tlui-button__label",
                  children: s("context.pages.new-page")
                })
              })
            }, "new-page")
          }, "new-page")]
        })
      })]
    })
  }),
  Ube = function({
    children: e
  }) {
    const n = Y(),
      r = hD(),
      o = g.useCallback(f => {
        if (f) {
          if (n.getInstanceState().isCoarsePointer) {
            const h = n.getSelectedShapes(),
              {
                inputs: {
                  currentPagePoint: m
                }
              } = n,
              p = n.getShapesAtPoint(m);
            if (!n.getSelectedShapes().length || !p.some(b => h.includes(b))) {
              const b = p.filter(w => n.isShapeOrAncestorLocked(w));
              b.length && n.select(...b.map(w => w.id))
            }
          }
        } else {
          const h = n.getOnlySelectedShape();
          h && n.isShapeOrAncestorLocked(h) && n.setSelectedShapes([])
        }
      }, [n]),
      s = Rn(),
      [i, a] = vc("context menu", o),
      c = lo(),
      l = r.length === 0 || c && r.every(f => !f.readonlyOk),
      d = !te("isSelectToolActive", () => n.getCurrentToolId() === "select", [n]) || l;
    return y.jsxs(lde, {
      dir: "ltr",
      onOpenChange: a,
      children: [y.jsx(ude, {
        onContextMenu: d ? at : void 0,
        dir: "ltr",
        disabled: d,
        children: e
      }), y.jsx(ty, {
        container: s,
        children: y.jsx(pde, {})
      })]
    })
  },
  pde = g.forwardRef(function() {
    const e = Y(),
      n = nt(),
      r = hD(),
      [o, s] = vc("context menu sub"),
      i = lo(),
      a = uo(),
      c = Rn(),
      [l, u] = g.useState(!1);

    function d(f, h, m, p) {
      if (i && !h.readonlyOk) return null;
      switch (h.type) {
        case "custom": {
          switch (h.id) {
            case "MOVE_TO_PAGE_MENU":
              return y.jsx(hde, {}, h.id)
          }
          break
        }
        case "group":
          return y.jsx($_, {
            dir: "ltr",
            className: ae("tlui-menu__group", {
              "tlui-menu__group__small": (m == null ? void 0 : m.type) === "submenu"
            }),
            "data-testid": `menu-item.${h.id}`,
            children: h.children.map(b => d(f, b, h, p + 1))
          }, h.id);
        case "submenu":
          return y.jsxs(l4, {
            onOpenChange: s,
            children: [y.jsx(u4, {
              dir: "ltr",
              disabled: h.disabled,
              asChild: !0,
              children: y.jsx(me, {
                type: "menu",
                label: h.label,
                "data-testid": `menu-item.${h.id}`,
                icon: "chevron-right"
              })
            }), y.jsx(ty, {
              container: c,
              children: y.jsx(d4, {
                className: "tlui-menu",
                sideOffset: -4,
                collisionPadding: 4,
                children: h.children.map(b => d(f, b, h, p + 1))
              })
            })]
          }, h.id);
        case "item": {
          if (i && !h.readonlyOk) return null;
          const {
            id: b,
            checkbox: w,
            contextMenuLabel: v,
            label: _,
            onSelect: S,
            kbd: x,
            icon: E
          } = h.actionItem, k = v ?? _, C = k ? n(k) : void 0;
          return w ? y.jsxs(fde, {
            className: "tlui-button tlui-button__menu tlui-button__checkbox",
            dir: "ltr",
            disabled: h.disabled,
            onSelect: $ => {
              S("context-menu"), at($)
            },
            title: C || void 0,
            checked: h.checked,
            children: [y.jsx(wr, {
              small: !0,
              icon: h.checked ? "check" : "checkbox-empty"
            }), C && y.jsx("span", {
              className: "tlui-button__label",
              draggable: !1,
              children: C
            }), x && y.jsx(wv, {
              children: x
            })]
          }, b) : y.jsx(I_, {
            dir: "ltr",
            asChild: !0,
            children: y.jsx(me, {
              type: "menu",
              "data-testid": `menu-item.${b}`,
              kbd: x,
              label: k,
              disabled: h.disabled,
              iconLeft: a < 3 && p > 2 ? E : void 0,
              onClick: () => {
                l ? u(!1) : S("context-menu")
              }
            })
          }, b)
        }
      }
    }
    return y.jsx(ty, {
      container: c,
      children: y.jsx(dde, {
        className: "tlui-menu scrollable",
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: at,
        children: r.map(f => d(e, f, null, 0))
      })
    })
  }),
  gde = 15.5;

function mde(t, e) {
  t.batch(() => {
    e = vde(e, gde), t.cancel().cancel().cancel().cancel();
    const n = t.pages[0].id;
    t.setCurrentPage(n);
    for (const i of t.pages.slice(1)) t.deletePage(i.id);
    t.selectAll(), t.deleteShapes(t.getSelectedShapeIds());
    const r = new Map;
    Object.values(e.assets ?? {}).forEach(i => {
      switch (i.type) {
        case "image": {
          const a = $f.createId();
          r.set(i.id, a);
          const c = {
            id: a,
            typeName: "asset",
            type: "image",
            props: {
              w: rn(i.size[0]),
              h: rn(i.size[1]),
              name: i.fileName ?? "Untitled",
              isAnimated: !1,
              mimeType: null,
              src: i.src
            },
            meta: {}
          };
          t.createAssets([c]), yde(t, c);
          break
        }
        case "video": {
          const a = $f.createId();
          r.set(i.id, a), t.createAssets([{
            id: a,
            typeName: "asset",
            type: "video",
            props: {
              w: rn(i.size[0]),
              h: rn(i.size[1]),
              name: i.fileName ?? "Untitled",
              isAnimated: !0,
              mimeType: null,
              src: i.src
            },
            meta: {}
          }])
        }
        break
      }
    });
    const o = new Map;
    Object.values(e.pages ?? {}).sort((i, a) => (i.childIndex ?? 1) < (a.childIndex ?? 1) ? -1 : 1).forEach((i, a) => {
      if (a === 0) o.set(i.id, t.currentPageId);
      else {
        const c = Ys.createId();
        o.set(i.id, c), t.createPage({
          name: i.name ?? "Page",
          id: c
        })
      }
    }), Object.values(e.pages ?? {}).sort((i, a) => (i.childIndex ?? 1) < (a.childIndex ?? 1) ? -1 : 1).forEach(i => {
      t.setCurrentPage(o.get(i.id));
      const a = new Map,
        c = new Map,
        l = Object.values(i.shapes ?? {}).sort((d, f) => d.childIndex < f.childIndex ? -1 : 1).slice(0, Qo);
      l.forEach(d => {
        if (d.type !== "group") return;
        const f = is();
        a.set(d.id, f), c.set(d.id, [])
      });

      function u(d) {
        if (a.delete(d.id), c.has(d.parentId)) {
          const h = c.get(d.parentId).filter(m => m !== d.id);
          c.set(d.parentId, h)
        }
      }
      l.forEach(d => {
        var b, w;
        if (d.type === "group") return;
        const f = is();
        a.set(d.id, f), d.parentId !== i.id && (c.has(d.parentId) ? c.get(d.parentId).push(d.id) : console.warn("parent does not exist", d));
        const h = o.get(i.id),
          m = {
            id: f,
            parentId: h,
            x: Jt(d.point[0]),
            y: Jt(d.point[1]),
            rotation: 0,
            isLocked: !!d.isLocked
          };
        switch (d.type) {
          case "sticky": {
            t.createShapes([{
              ...m,
              type: "note",
              props: {
                text: d.text ?? "",
                color: go(d.style.color),
                size: Vc(d.style.size),
                font: Hc(d.style.font),
                align: b$(d.style.textAlign)
              }
            }]);
            break
          }
          case "rectangle": {
            t.createShapes([{
              ...m,
              type: "geo",
              props: {
                geo: "rectangle",
                w: rn(d.size[0]),
                h: rn(d.size[1]),
                text: d.label ?? "",
                fill: ig(d.style.isFilled, d.style.color),
                labelColor: go(d.style.color),
                color: go(d.style.color),
                size: Vc(d.style.size),
                font: Hc(d.style.font),
                dash: vd(d.style.dash),
                align: "middle"
              }
            }]);
            const v = t.getShapePageBounds(m.id);
            if (t.updateShapes([{
                id: m.id,
                type: "geo",
                props: {
                  text: d.label ?? ""
                }
              }]), v.width === v.height) {
              const _ = t.getShape(m.id),
                {
                  growY: S
                } = _.props,
                x = rn(_.props.w),
                E = rn(_.props.h),
                k = x + S / 2,
                C = E + S / 2;
              t.updateShapes([{
                id: m.id,
                type: "geo",
                x: Jt(_.x) - (k - x) / 2,
                y: Jt(_.y) - (C - E) / 2,
                props: {
                  w: k,
                  h: C
                }
              }])
            }
            break
          }
          case "triangle": {
            t.createShapes([{
              ...m,
              type: "geo",
              props: {
                geo: "triangle",
                w: rn(d.size[0]),
                h: rn(d.size[1]),
                fill: ig(d.style.isFilled, d.style.color),
                labelColor: go(d.style.color),
                color: go(d.style.color),
                size: Vc(d.style.size),
                font: Hc(d.style.font),
                dash: vd(d.style.dash),
                align: "middle"
              }
            }]);
            const v = t.getShapePageBounds(m.id);
            if (t.updateShapes([{
                id: m.id,
                type: "geo",
                props: {
                  text: d.label ?? ""
                }
              }]), v.width === v.height) {
              const _ = t.getShape(m.id),
                {
                  growY: S
                } = _.props,
                x = rn(_.props.w),
                E = rn(_.props.h),
                k = x + S / 2,
                C = E + S / 2;
              t.updateShapes([{
                id: m.id,
                type: "geo",
                x: Jt(_.x) - (k - x) / 2,
                y: Jt(_.y) - (C - E) / 2,
                props: {
                  w: k,
                  h: C
                }
              }])
            }
            break
          }
          case "ellipse": {
            t.createShapes([{
              ...m,
              type: "geo",
              props: {
                geo: "ellipse",
                w: rn(d.radius[0]) * 2,
                h: rn(d.radius[1]) * 2,
                fill: ig(d.style.isFilled, d.style.color),
                labelColor: go(d.style.color),
                color: go(d.style.color),
                size: Vc(d.style.size),
                font: Hc(d.style.font),
                dash: vd(d.style.dash),
                align: "middle"
              }
            }]);
            const v = t.getShapePageBounds(m.id);
            if (t.updateShapes([{
                id: m.id,
                type: "geo",
                props: {
                  text: d.label ?? ""
                }
              }]), v.width === v.height) {
              const _ = t.getShape(m.id),
                {
                  growY: S
                } = _.props,
                x = rn(_.props.w),
                E = rn(_.props.h),
                k = x + S / 2,
                C = E + S / 2;
              t.updateShapes([{
                id: m.id,
                type: "geo",
                x: Jt(_.x) - (k - x) / 2,
                y: Jt(_.y) - (C - E) / 2,
                props: {
                  w: k,
                  h: C
                }
              }])
            }
            break
          }
          case "draw": {
            if (d.points.length === 0) {
              u(d);
              break
            }
            t.createShapes([{
              ...m,
              type: "draw",
              props: {
                fill: ig(d.style.isFilled, d.style.color),
                color: go(d.style.color),
                size: Vc(d.style.size),
                dash: vd(d.style.dash),
                isPen: !1,
                isComplete: d.isComplete,
                segments: [{
                  type: "free",
                  points: d.points.map(Xb)
                }]
              }
            }]);
            break
          }
          case "arrow": {
            const v = Jt(d.bend),
              _ = Xb(d.handles.start.point),
              S = Xb(d.handles.end.point),
              E = T.Dist(_, S) * -v / 2;
            t.createShapes([{
              ...m,
              type: "arrow",
              props: {
                text: d.label ?? "",
                color: go(d.style.color),
                labelColor: go(d.style.color),
                size: Vc(d.style.size),
                font: Hc(d.style.font),
                dash: vd(d.style.dash),
                arrowheadStart: w$((b = d.decorations) == null ? void 0 : b.start),
                arrowheadEnd: w$((w = d.decorations) == null ? void 0 : w.end),
                start: {
                  type: "point",
                  x: Jt(d.handles.start.point[0]),
                  y: Jt(d.handles.start.point[1])
                },
                end: {
                  type: "point",
                  x: Jt(d.handles.end.point[0]),
                  y: Jt(d.handles.end.point[1])
                },
                bend: E
              }
            }]);
            break
          }
          case "text": {
            t.createShapes([{
              ...m,
              type: "text",
              props: {
                text: d.text ?? " ",
                color: go(d.style.color),
                size: kde(d.style.size),
                font: Hc(d.style.font),
                align: b$(d.style.textAlign),
                scale: d.style.scale ?? 1
              }
            }]);
            break
          }
          case "image": {
            const v = r.get(d.assetId);
            if (!v) {
              console.warn("Could not find asset id", d.assetId);
              return
            }
            t.createShapes([{
              ...m,
              type: "image",
              props: {
                w: rn(d.size[0]),
                h: rn(d.size[1]),
                assetId: v
              }
            }]);
            break
          }
          case "video": {
            const v = r.get(d.assetId);
            if (!v) {
              console.warn("Could not find asset id", d.assetId);
              return
            }
            t.createShapes([{
              ...m,
              type: "video",
              props: {
                w: rn(d.size[0]),
                h: rn(d.size[1]),
                assetId: v
              }
            }]);
            break
          }
        }
        const p = Jt(d.rotation);
        p !== 0 && (t.select(f), t.rotateShapesBy([f], p))
      }), c.forEach((d, f) => {
        const h = d.map(w => a.get(w)),
          m = a.get(f);
        t.groupShapes(h, m);
        const p = i.shapes[f],
          b = Jt(p.rotation);
        b !== 0 && (t.select(m), t.rotateShapesBy([m], b))
      }), l.forEach(d => {
        var m, p;
        if (d.type !== "arrow") return;
        const f = a.get(d.id),
          h = t.getShapeUtil("arrow");
        t.inputs.ctrlKey = !1;
        for (const b of ["start", "end"]) {
          const w = d.handles[b].bindingId;
          if (w) {
            const v = i.bindings[w];
            if (!v) continue;
            const _ = a.get(v.toId);
            if (!t.getShape(_)) continue;
            if (_) {
              const x = t.getShapePageBounds(_),
                E = t.getShape(f),
                k = eo((Jt(v.point[0]) + .5) / 2, .2, .8),
                C = eo((Jt(v.point[1]) + .5) / 2, .2, .8),
                $ = t.getPointInShapeSpace(E, {
                  x: x.minX + x.width * k,
                  y: x.minY + x.height * C
                }),
                I = t.getShapeHandles(E),
                R = h.onHandleChange(E, {
                  handle: {
                    ...I.find(M => M.id === b),
                    x: $.x,
                    y: $.y
                  },
                  isPrecise: $.x !== .5 || $.y !== .5
                });
              if (R) {
                if ((m = R.props) != null && m[b]) {
                  const M = (p = R.props) == null ? void 0 : p[b];
                  M.type === "binding" && (M.isExact = v.distance === 0, M.boundShapeId !== _ && (console.warn("Hit the wrong shape!"), M.boundShapeId = _, M.normalizedAnchor = {
                    x: .5,
                    y: .5
                  }))
                }
                t.updateShapes([R])
              }
            }
          }
        }
      })
    }), t.setCurrentPage(n), t.history.clear(), t.selectNone(), t.updateViewportScreenBounds();
    const s = t.currentPageBounds;
    s && t.zoomToBounds(s, 1)
  })
}

function Jt(t) {
  return typeof t != "number" || Number.isNaN(t) || !Number.isFinite(t) ? 0 : t
}

function rn(t) {
  const e = Jt(t);
  return e <= 0 ? 1 : e
}
async function yde(t, e) {
  try {
    if (e.type === "bookmark" || !e.props.src) return;
    const n = await fetch(e.props.src);
    if (!n.ok) return;
    const r = new File([await n.blob()], e.props.name, {
        type: n.headers.get("content-type") ?? e.props.mimeType ?? void 0
      }),
      o = await t.getAssetForExternalContent({
        type: "file",
        file: r
      });
    if (!o) throw new Error("Could not get asset for external content");
    if (o.type === "bookmark") return;
    t.updateAssets([{
      id: e.id,
      type: e.type,
      props: {
        ...o.props,
        name: e.props.name
      }
    }])
  } catch {}
}

function vde(t, e) {
  const {
    version: n = 0
  } = t;
  t.assets || (t.assets = {});
  const r = new Set;
  return Object.values(t.pages).forEach(o => Object.values(o.shapes).forEach(s => {
    const {
      parentId: i,
      children: a,
      assetId: c
    } = s;
    c && r.add(c), i !== o.id && !o.shapes[i] && (console.warn("Encountered a shape with a missing parent!"), s.parentId = o.id), s.type === "group" && a && a.forEach(l => {
      o.shapes[l] || (console.warn("Encountered a parent with a missing child!", s.id, l), a == null || a.splice(a.indexOf(l), 1))
    })
  })), Object.keys(t.assets).forEach(o => {
    r.has(o) || delete t.assets[o]
  }), n !== e && (n < 14 && Object.values(t.pages).forEach(o => {
    Object.values(o.shapes).filter(s => s.type === "text").forEach(s => {
      s.style.font === void 0 && s.style.font
    })
  }), n <= 13 && Object.values(t.pages).forEach(o => {
    Object.values(o.bindings).forEach(s => {
      Object.assign(s, s.meta)
    }), Object.values(o.shapes).forEach(s => {
      Object.entries(s.style).forEach(([i, a]) => {
        typeof a == "string" && (s.style[i] = a.toLowerCase())
      }), s.type === "arrow" && s.decorations && Object.entries(s.decorations).forEach(([i, a]) => {
        a === "Arrow" && (s.decorations = {
          ...s.decorations,
          [i]: "arrow"
        })
      })
    })
  }), n <= 13.1 && t.name == null && (t.name = "New Document"), n < 15 && t.assets == null && (t.assets = {}), Object.values(t.pages).forEach(o => {
    Object.values(o.shapes).forEach(s => {
      n < 15.2 && (s.type === "image" || s.type === "video") && s.style.isFilled == null && (s.style.isFilled = !0), n < 15.3 && (s.type === "rectangle" || s.type === "triangle" || s.type === "ellipse" || s.type === "arrow") && ("text" in s && typeof s.text == "string" && (s.label = s.text), s.label || (s.label = ""), s.labelPoint || (s.labelPoint = [.5, .5]))
    })
  })), Object.values(t.pageStates).forEach(o => {
    o.selectedIds = o.selectedIds.filter(s => t.pages[o.id].shapes[s] !== void 0), o.bindingId = void 0, o.editingId = void 0, o.hoveredId = void 0, o.pointedId = void 0
  }), t.version = e, t
}
const bde = {
    white: "black",
    black: "black",
    lightGray: "grey",
    gray: "grey",
    green: "light-green",
    cyan: "green",
    blue: "light-blue",
    indigo: "blue",
    orange: "orange",
    yellow: "yellow",
    red: "red",
    violet: "light-violet"
  },
  wde = {
    mono: "mono",
    sans: "sans",
    script: "draw",
    serif: "serif"
  },
  Sde = {
    start: "start",
    middle: "middle",
    end: "end",
    justify: "start"
  },
  _de = {
    small: "s",
    medium: "l",
    large: "xl"
  },
  xde = {
    small: "m",
    medium: "l",
    large: "xl"
  },
  Ede = {
    solid: "solid",
    dashed: "dashed",
    dotted: "dotted",
    draw: "draw"
  };

function go(t) {
  return t ? bde[t] ?? "black" : "black"
}

function Hc(t) {
  return t ? wde[t] ?? "draw" : "draw"
}

function b$(t) {
  return t ? Sde[t] ?? "middle" : "middle"
}

function kde(t) {
  return t ? _de[t] ?? "m" : "m"
}

function Vc(t) {
  return t ? xde[t] ?? "l" : "l"
}

function vd(t) {
  return t ? Ede[t] ?? "draw" : "draw"
}

function Xb(t) {
  return {
    x: Jt(t[0]),
    y: Jt(t[1]),
    z: t[2] == null ? .5 : Jt(t[2])
  }
}

function w$(t) {
  return t === "arrow" ? "arrow" : "none"
}

function ig(t, e) {
  return t ? e === "black" || e === "white" ? "semi" : "solid" : "none"
}
const Cde = "application/vnd.tldraw+json",
  zbe = ".tldr",
  f4 = 1,
  Pde = tt({
    tldrawFileFormatVersion: MA,
    schema: tt({
      schemaVersion: $d,
      storeVersion: $d,
      recordVersions: Cf(Te, tt({
        version: $d,
        subTypeVersions: Cf(Te, $d).optional(),
        subTypeKey: Te.optional()
      }))
    }),
    records: Vn(tt({
      id: Te,
      typeName: Te
    }).allowUnknownProperties())
  });

function Tde(t) {
  var e;
  try {
    return !!((e = t.document) != null && e.version)
  } catch {
    return !1
  }
}

function $de({
  json: t,
  schema: e
}) {
  let n;
  try {
    n = Pde.validate(JSON.parse(t))
  } catch (o) {
    try {
      if (n = JSON.parse(t), Tde(n)) return qe.err({
        type: "v1File",
        data: n
      })
    } catch {}
    return qe.err({
      type: "notATldrawFile",
      cause: o
    })
  }
  if (n.tldrawFileFormatVersion > f4) return qe.err({
    type: "fileFormatVersionTooNew",
    version: n.tldrawFileFormatVersion
  });
  let r;
  try {
    const o = Object.fromEntries(n.records.map(s => [s.id, s]));
    r = e.migrateStoreSnapshot({
      store: o,
      schema: n.schema
    })
  } catch (o) {
    return qe.err({
      type: "invalidRecords",
      cause: o
    })
  }
  if (r.type === "error") return qe.err({
    type: "migrationFailed",
    reason: r.reason
  });
  try {
    return qe.ok(KS({
      initialData: r.value,
      schema: e
    }))
  } catch (o) {
    return qe.err({
      type: "invalidRecords",
      cause: o
    })
  }
}
async function Ide(t) {
  const e = [],
    n = new Set,
    r = [];
  for (const s of t.allRecords()) switch (s.typeName) {
    case "asset":
      if (s.type !== "bookmark" && s.props.src && !s.props.src.startsWith("data:")) {
        let i;
        try {
          i = await xz.fileToBase64(await (await fetch(s.props.src)).blob())
        } catch {
          i = s.props.src
        }
        r.push({
          ...s,
          props: {
            ...s.props,
            src: i
          }
        })
      } else r.push(s);
      break;
    case "shape":
      "assetId" in s.props && n.add(s.props.assetId), e.push(s);
      break;
    default:
      e.push(s);
      break
  }
  const o = e.concat(r.filter(s => n.has(s.id)));
  return JSON.stringify({
    tldrawFileFormatVersion: f4,
    schema: t.schema.serialize(),
    records: o
  })
}
async function Hbe(t) {
  return new Blob([await Ide(t)], {
    type: Cde
  })
}
async function Vbe(t, e, n, r, o, s) {
  const i = $de({
    schema: t.store.schema,
    json: e
  });
  if (!i.ok) {
    let a;
    switch (i.error.type) {
      case "notATldrawFile":
        t.annotateError(i.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: !1,
          tags: {
            parseErrorType: i.error.type
          }
        }), reportError(i.error.cause), a = n("file-system.file-open-error.not-a-tldraw-file");
        break;
      case "fileFormatVersionTooNew":
        a = n("file-system.file-open-error.file-format-version-too-new");
        break;
      case "migrationFailed":
        i.error.reason === gl.TargetVersionTooNew ? a = n("file-system.file-open-error.file-format-version-too-new") : a = n("file-system.file-open-error.generic-corrupted-file");
        break;
      case "invalidRecords":
        t.annotateError(i.error.cause, {
          origin: "file-system.open.parse",
          willCrashApp: !1,
          tags: {
            parseErrorType: i.error.type
          }
        }), reportError(i.error.cause), a = n("file-system.file-open-error.generic-corrupted-file");
        break;
      case "v1File": {
        mde(t, i.error.data.document), o == null || o();
        return
      }
      default:
        bu(i.error, "type")
    }
    r({
      title: n("file-system.file-open-error.title"),
      description: a
    });
    return
  }
  Zr(() => {
    const a = t.getInstanceState().isFocused;
    t.store.clear();
    const [c, l] = Sz(i.value.allRecords(), d => d.typeName === "shape");
    t.store.put(l, "initialize"), t.store.ensureStoreIsUsable(), t.store.put(c, "initialize"), t.history.clear(), t.updateViewportScreenBounds(), t.updateRenderingBounds();
    const u = t.currentPageBounds;
    u && t.zoomToBounds(u, 1), t.updateInstanceState({
      isFocused: a
    })
  }), s && t.user.updateUserPreferences({
    isDarkMode: !0
  })
}
const Ode = "production--1c6114e1856527a36572c55fb02cd568e5d0b4aa",
  Rde = "production",
  Ade = Rde;

function Mde() {
  return "https://ce7a28bffc1048a4bea1292521a8435e@o578706.ingest.sentry.io/4504203639193600"
}
R7({
  dsn: Mde(),
  tracesSampleRate: 1,
  release: Ode,
  environment: Ade,
  integrations: [new jl({
    depth: 10
  })],
  beforeSend: (t, e) => {
    const n = window.editor,
      r = n == null ? void 0 : n.createErrorAnnotations("unknown", "unknown"),
      o = _z(e.originalException);
    return t.tags = {
      ...r == null ? void 0 : r.tags,
      ...o.tags,
      ...t.tags
    }, t.extra = {
      ...r == null ? void 0 : r.extras,
      ...o.extras,
      ...t.extra
    }, t
  }
});

function jde() {
  const t = r1();
  return g.useEffect(() => {
    nx(t)
  }, [t]), y.jsx(b1, {
    error: t
  })
}
const Dde = "/assets/check-large-2a682af6.svg",
  Nde = "/assets/check-small-ccc3114b.svg",
  Lde = "/assets/chevron-down-large-9fe175f2.svg",
  Fde = "/assets/chevron-down-small-45926933.svg",
  Bde = "/assets/chevron-left-large-964f6e2a.svg",
  Ude = "/assets/chevron-right-large-8f7ccc22.svg",
  zde = "/assets/chevron-right-small-b9262bda.svg",
  Hde = "/assets/chevron-up-small-d182dc3c.svg",
  Vde = "/assets/close-5a4dd99d.svg",
  Wde = "/assets/dashboard-65b3a854.svg",
  Kde = "/assets/discord-c2fdd4d1.svg",
  Gde = "/assets/download-small-63499dd6.svg",
  Yde = "/assets/edit-large-222f34a6.svg",
  qde = "/assets/edit-small-17a4129a.svg",
  Xde = "/assets/email-391794d3.svg",
  Zde = "/assets/folder-e5c1c6b1.svg",
  Jde = "/assets/grid-07d43f50.svg",
  Qde = "/assets/hamburger-cc33b868.svg",
  efe = "/assets/hidden-26e5a0f1.svg",
  tfe = "/assets/invite-9965e56a.svg",
  nfe = "/assets/lock-4da990b1.svg",
  rfe = "/assets/logo-bare-b1ead689.svg",
  ofe = "/assets/members-8158deee.svg",
  sfe = "/assets/more-large-8fc94df8.svg",
  ife = "/assets/more-small-10bacde0.svg",
  afe = "/assets/new-board-f0b2d6a1.svg",
  cfe = "/assets/no-result-f88ae500.svg",
  lfe = "/assets/plus-large-0bd371f5.svg",
  ufe = "/assets/plus-small-c7f1d8af.svg",
  dfe = "/assets/question-mark-91bc9053.svg",
  ffe = "/assets/redo-48b94ad3.svg",
  hfe = "/assets/rows-ab5a3b77.svg",
  pfe = "/assets/search-small-3cc94270.svg",
  gfe = "/assets/settings-2a0b8522.svg",
  mfe = "/assets/share-4cc05abe.svg",
  yfe = "/assets/signout-8ff25979.svg",
  vfe = "/assets/subscriptions-aba79fbb.svg",
  bfe = "/assets/switch-4fc2a8a4.svg",
  wfe = "/assets/trash-83899866.svg",
  Sfe = "/assets/warning-366e3900.svg",
  _fe = "/assets/workspaces-ad4d8d09.svg",
  O_ = {
    "check-large": Dde,
    "check-small": Nde,
    "chevron-down-small": Fde,
    "chevron-down-large": Lde,
    "chevron-up-small": Hde,
    "chevron-left-large": Bde,
    "chevron-right-large": Ude,
    "chevron-right-small": zde,
    close: Vde,
    dashboard: Wde,
    discord: Kde,
    "download-small": Gde,
    "edit-large": Yde,
    "edit-small": qde,
    email: Xde,
    folder: Zde,
    grid: Jde,
    hamburger: Qde,
    hidden: efe,
    invite: tfe,
    lock: nfe,
    members: ofe,
    "more-large": sfe,
    "more-small": ife,
    "new-board": afe,
    "no-result": cfe,
    "plus-large": lfe,
    "plus-small": ufe,
    "question-mark": dfe,
    redo: ffe,
    rows: hfe,
    "search-small": pfe,
    settings: gfe,
    share: mfe,
    signout: yfe,
    subscriptions: vfe,
    switch: bfe,
    workspaces: _fe,
    trash: wfe,
    warning: Sfe,
    "logo-bare": rfe
  },
  Wbe = Object.keys(O_),
  au = g.forwardRef(function({
    icon: e,
    className: n,
    containerSize: r,
    ...o
  }, s) {
    return y.jsx("span", {
      ref: s,
      className: ae([n, "flex flex-shrink-0 bg-[currentColor]", xfe(r)]),
      style: {
        mask: `url(${O_[e]}) center 100% / 100% no-repeat`,
        WebkitMask: `url(${O_[e]}) center 100% / 100% no-repeat`
      },
      ...o
    })
  });

function xfe(t) {
  switch (t) {
    case "extra-small":
      return ae(["h-icon-xs w-icon-xs"]);
    case "small":
      return ae(["h-icon-sm w-icon-sm"]);
    case "medium":
      return ae(["h-icon-md w-icon-md"])
  }
}
const Efe = {
    "account-settings.account-settings": "Account settings",
    "account-settings.avatar-recommended-size": "Recommended size: 9090px",
    "account-settings.avatar-supported-file-types": "Supported file types: PNG, JPG",
    "account-settings.avatar": "Avatar",
    "account-settings.delete-warning-data": "This will remove you from all of your workspaces and delete your user data. This action cannot be undone.",
    "account-settings.delete": "Delete account",
    "account-settings.name-placeholder": "Huppy",
    "account-settings.name": "Name",
    "account-settings.overview": "Overview",
    "account-settings.sign-out": "Sign out",
    "account-settings.username-placeholder": "@huppy",
    "account-settings.username": "Username",
    "account-settings.workspaces": "Workspaces",
    "archive-board-dialog.confirm": "Archive",
    "archive-board-dialog.description1": "This board will be archived.",
    "archive-board-dialog.description2": "You will be able to access all archived boards in the Archived folder.",
    "archive-board-dialog.error": "Failed to archive board",
    "archive-board-dialog.success": "{name} has been archived.",
    "archive-board-dialog.title": "Archive board",
    "archive-folder-dialog.confirm": "Archive",
    "archive-folder-dialog.description1": "All boards in this folder will be archived.",
    "archive-folder-dialog.description2": "You will be able to access",
    "archive-folder-dialog.description3": "all archived boards in the Archived folder.",
    "archive-folder-dialog.success": "{name} and all of its contents have been archived.",
    "archive-folder-dialog.title": "Archive folder",
    "archive.empty": "Any archived boards will appear here.",
    "archive.from-folder": "From {folder}",
    "archive.restore": "Restore",
    "avatar.upload-failed": "Failed to upload avatar.",
    "backbar.back": "Back",
    "board-location.private": "Private",
    "board-location.workspace": "All",
    "board.archive": "Archive",
    "board.archived": "{board} has been archived.",
    "board.copy-link": "Copy link",
    "board.created-at": "Created {time}",
    "board.delete": "Delete",
    "board.deleted": "{board} has been deleted.",
    "board.duplicate": "Duplicate",
    "board.edited-at": "Edited {time}",
    "board.link-copied": "Copied link to {board}.",
    "board.move": "Move",
    "board.never-viewed": "Never viewed",
    "board.new-name": "New name",
    "board.open-in-new-tab": "Open in new tab",
    "board.rename": "Rename",
    "board.untitled": "Untitled board",
    "board.updated": "Successfully updated",
    "board.viewed-at": "Viewed {time}",
    "boards-view.all-boards": "All boards",
    "boards-view.archive": "Archive",
    "boards-view.private": "Private",
    "boards.new-board": "New board",
    "collapsible-menu.account-settings": "Account Settings",
    "collapsible-menu.archive": "Archive",
    "collapsible-menu.change-workspace": "Change workspace",
    "collapsible-menu.dashboard": "Dashboard",
    "collapsible-menu.shared-w-me": "Shared with Me",
    "collapsible-menu.sign-out": "Sign out",
    "collapsible-menu.switch-workspace": "Switch workspace",
    "create-folder-dialog.confirm": "Create",
    "create-folder-dialog.description": "Enter a name for your new folder.",
    "create-folder-dialog.error": "Failed to create folder",
    "create-folder-dialog.name-error": "Name cannot be empty",
    "create-folder-dialog.placeholder": "My Folder",
    "create-folder-dialog.title": "New folder",
    "create-workspace.back": "Back",
    "create-workspace.continue": "Continue",
    "create-workspace.create-a-private-space": "Create a private space",
    "create-workspace.create-workspace": "Create workspace",
    "create-workspace.name-placeholder": "My workspace",
    "create-workspace.name": "Workspace name",
    "create-workspace.to-collaborate": "to collaborate with your teammates",
    "danger-zone.danger-zone": "Danger zone",
    "delete-board-dialog.confirm": "Delete",
    "delete-board-dialog.description1": "This board will be deleted.",
    "delete-board-dialog.description2": "This action cannot be undone.",
    "delete-board-dialog.error": "Failed to delete board",
    "delete-board-dialog.title": "Delete board",
    "delete-folder-dialog.confirm": "Delete",
    "delete-folder-dialog.description1": "All boards in this folder will be deleted.",
    "delete-folder-dialog.description2": "This action cannot be undone.",
    "delete-folder-dialog.title": "Delete folder",
    "dialog.cancel": "Cancel",
    "dialog.empty-string": "",
    "duplicate-board-dialog.confirm": "Duplicate",
    "duplicate-board-dialog.description": "Type in a name for the duplicate board.",
    "duplicate-board-dialog.name-error": "Name cannot be empty",
    "duplicate-board-dialog.title": "Duplicate board",
    "editor.about-this-board": "About this board",
    "empty.create-board": "Create board",
    "empty.folder-empty1": "This folder is empty.",
    "empty.folder-empty2": "Create a new board to get started.",
    "folder.archive": "Archive",
    "folder.copy-link": "Copy link",
    "folder.delete": "Delete",
    "folder.link-copied": "Copied link to {folder}.",
    "folder.new-board": "New board",
    "folder.rename": "Rename",
    "folder.updated": "Successfully updated",
    "generic.error": "Something went wrong",
    "generic.error-description": "Please try refreshing the page or get in touch with us on GitHub to report a persistent issue.",
    "join-workspace.create-new-workspace": "Create new workspace",
    "join-workspace.description": "You've been invited to join a workspace",
    "join-workspace.invalid-link-description-1": "This workspace join link is no longer valid.",
    "join-workspace.invalid-link-description-2": "Please ask the workspace admin for a new link.",
    "join-workspace.invalid-link-title": "Invalid join link",
    "join-workspace.join": "Join workspace",
    "join-workspace.not-logged-in": "You need to be logged in to join a workspace",
    "join-workspace.not-your-team": "Not your team",
    "join-workspace.preview-plural": "Join {name} and {count} others in the {workspaceName} workspace",
    "join-workspace.preview-single": "Join {name} in the {workspaceName} workspace",
    "join-workspace.preview-singular": "Join {name} and 1 other in the {workspaceName} workspace",
    "join-workspace.title": "Join workspace",
    "loading-message.loading": "Loading...",
    "members.copy-link": "Copy",
    "members.enable-invite-link": "Enable workspace invite link",
    "members.invite-link-copied": "Invite link copied to clipboard.",
    "members.invite-link-switch": "Invite link switch",
    "members.invite-link": "Workspace invite link",
    "members.member-since": "Member since",
    "members.member": "Member",
    "members.remove": "Remove member",
    "members.role-change-failure": "Failed to change the workspace role of {name}.",
    "members.role": "Role",
    "members.username": "Username",
    "move-board-dialog.all-boards": "All boards",
    "move-board-dialog.confirm": "Move",
    "move-board-dialog.description-private1": "Moving this board out of your Private Folder",
    "move-board-dialog.description-private2": "will make it visible to everyone on your team.",
    "move-board-dialog.description": "Select a folder to move this board to.",
    "move-board-dialog.title": "Move board",
    "mutation.something-went-wrong": "Something went wrong",
    "nav-bar.account-settings": "Account settings",
    "nav-bar.developer-sdk": "Developer SDK",
    "nav-bar.feature-requests": "Feature requests",
    "nav-bar.problem-fetching-boards": "Problem with fetching boards",
    "nav-bar.problem-fetching-data": "Problem with fetching data",
    "nav-bar.sign-out": "Sign out",
    "not-found-folder.header": "Folder not found",
    "not-found-folder.paragraph-one": "The folder you are looking for has been deleted or does not exist.",
    "not-found-folder.paragraph-two": "Please check your URL or return to the dashboard.",
    "not-found-workspace.header": "Workspace not found",
    "not-found-workspace.paragraph-one": "The workspace you are looking for has been deleted or does not exist.",
    "not-found-workspace.paragraph-two": "Please check your URL or return to the dashboard.",
    "not-found.button": "Go to home",
    "not-found.header": "Page not found",
    "not-found.icon-alt": "A sad winky face version of the tldraw logo",
    "not-found.paragraph-one": "The page you are looking does not exist or has been moved.",
    "playground.hello-world": "Hello World!",
    "playground.hello": "Hello {name}!",
    "playground.interpolation": "With {foo}",
    "playground.multiple-interpolations": "With {foo} {bar}",
    "playground.translation": "Translation",
    "private-folder.tooltip": "Only you can see the boards in this folder",
    "private.problem-fetching-profile": "Problem with fetching profile",
    "pro-waitlist.confirm": "Submit",
    "pro-waitlist.description1": "Sync your work, create private boards, and",
    "pro-waitlist.description2": "connect with your team on tldraw pro",
    "pro-waitlist.email-placeholder": "Email",
    "pro-waitlist.title": "Join the waitlist",
    raw: "{value}",
    "remove-member-dialog.confirm": "Remove",
    "remove-member-dialog.description": "This member will automatically lose access to all workspace boards.",
    "remove-member-dialog.failure": "Failed to remove {identifier} from the {workspaceName} workspace.",
    "remove-member-dialog.title": "Remove member",
    "rename-board-dialog.confirm": "Rename",
    "rename-board-dialog.description": "Type in a name to rename your board.",
    "rename-board-dialog.name-error": "Name cannot be empty",
    "rename-board-dialog.title": "Rename board",
    "rename-folder-dialog.confirm": "Rename",
    "rename-folder-dialog.description": "Type in a name to rename your folder.",
    "rename-folder-dialog.name-error": "Name cannot be empty",
    "rename-folder-dialog.name-length-error": "Name cannot exceed 60 characters",
    "rename-folder-dialog.title": "Rename folder",
    "role.admin": "Admin",
    "role.guest": "Guest",
    "role.member": "Member",
    "search.no-results": "No results",
    "search.search-boards": "Search boards",
    "settings-input.save": "Save",
    "settings-input.updated": "Successfully updated",
    "sign-in.check-spam": "Please check your spam folder if you haven't received it.",
    "sign-in.check-your-inbox": "Check your inbox",
    "sign-in.continue-with-email": "Continue with email",
    "sign-in.continue-with-google": "Continue with Google",
    "sign-in.email-placeholder": "user@email.com",
    "sign-in.for-you-and-team": "for you and your team",
    "sign-in.sent-activation-link": "We've sent you an activation link.",
    "sign-in.to-create-workspace": "Sign in to create a workspace",
    "sign-in.welcome": "Welcome to tldraw pro",
    "sign-up.and": "and",
    "sign-up.avatar": "Avatar",
    "sign-up.continue": "Continue",
    "sign-up.email-placeholder": "anne@tldraw.com",
    "sign-up.footer": "By continuing, you agree to tldraw's",
    "sign-up.name-placeholder": "Name",
    "sign-up.privacy": "Privacy Policy",
    "sign-up.terms": "Terms of Service",
    "sign-up.title": "Create account",
    "sign-up.user-information": "User information",
    "sign-up.username-placeholder": "@ username",
    "something-went-wrong.header": "Something went wrong",
    "something-went-wrong.paragraph-one": "Please return to your dashboard and try again.",
    "sort-dropdown.alphabetical": "Alphabetical",
    "sort-dropdown.created": "Date created",
    "sort-dropdown.edited": "Last edited",
    "sort-dropdown.viewed": "Recently viewed",
    "subscription.amount": "Amount",
    "subscription.billed": "BILLED",
    "subscription.billing-information": "Billing information",
    "subscription.cancel-plan": "Cancel plan",
    "subscription.cost-per-member": "{cost} per member",
    "subscription.date": "Date",
    "subscription.download": "Download",
    "subscription.invoice": "Invoice",
    "subscription.manage": "Manage",
    "subscription.member-count": "{number} members",
    "subscription.number": "Number",
    "subscription.renewal-date": "Renews on {date}",
    "subscription.status": "Status",
    "subscription.subscriptions": "Subscriptions",
    "subscription.upcoming": "UPCOMING",
    "subscription.yearly-plan": "Yearly plan",
    "title.account": "Account",
    "title.archive": "Archive",
    "title.private": "Private",
    "title.settings": "Settings",
    "title.sign-in": "Sign-in",
    "toast.unimplemented": "Not implemented yet.",
    "unarchive-board-dialog.confirm": "Unarchive",
    "unarchive-board-dialog.description": "Unarchiving this board will make the board public for everyone in your workspace.",
    "unarchive-board-dialog.error": "Failed to unarchive board",
    "unarchive-board-dialog.success": "{name} has been unarchived.",
    "unarchive-board-dialog.title": "Unarchive board",
    "waitlist-joined.cta": "Share on Twitter",
    "waitlist-joined.description": "We'll notify you when we launch.",
    "waitlist-joined.share": "I just joined the waitlist for tldraw pro  Sign up for the waitlist at https://tldraw.com/pro-waitlist.",
    "waitlist-joined.title": "Thank you for joining our waitlist",
    "welcome-banner.description": "You are now part of the {workspaceName} workspace and have access to all boards. Happy whiteboarding!",
    "welcome-banner.welcome": "Welcome to {workspaceName}",
    "workspace-menu.archive": "Archive",
    "workspace-menu.create-folder": "New folder",
    "workspace-menu.dashboard": "Dashboard",
    "workspace-menu.folders": "FOLDERS",
    "workspace-menu.invite": "Invite",
    "workspace-menu.private": "Private",
    "workspace-menu.settings": "Settings",
    "workspace-settings.delete": "Delete workspace",
    "workspace-settings.icon-recommended-size": "Recommended size: 9090px",
    "workspace-settings.icon-supported-file-types": "Supported file types: PNG, JPG",
    "workspace-settings.icon": "Workspace icon",
    "workspace-settings.members": "Members",
    "workspace-settings.name-placeholder": "Workspace name",
    "workspace-settings.name": "Workspace name",
    "workspace-settings.overview": "Overview",
    "workspace-settings.settings": "Settings",
    "workspace-settings.subscription": "Subscription",
    "workspace-settings.workspace-settings": "Workspace settings",
    "workspaces.member-since": "Member since",
    "workspaces.role": "Role",
    "workspaces.workspace": "Workspace"
  },
  h4 = (t, e) => {
    let n = Efe[t] ?? t;
    if (!e) return n;
    for (const r in e) {
      const o = e[r];
      n = n.replace(`{${r}}`, o)
    }
    return n
  },
  kfe = t => h4("raw", {
    value: t
  }),
  p4 = g.createContext({}),
  Cfe = ({
    children: t
  }) => y.jsx(p4.Provider, {
    value: {
      msg: h4,
      raw: kfe
    },
    children: t
  }),
  Fh = () => g.useContext(p4);

function Pfe({
  className: t,
  white: e
}) {
  const {
    msg: n
  } = Fh();
  return y.jsx("span", {
    className: "flex flex-col items-center overflow-clip rounded-[50%] ",
    children: y.jsxs("span", {
      className: ae([t, "h-md w-md flex animate-[spin_1s_linear_infinite_reverse]"]),
      children: [y.jsx("span", {
        className: "h-md w-md absolute flex flex-shrink-0 rotate-180",
        style: {
          mask: "url(/spinner/dot.svg) center 100% / 100% no-repeat",
          WebkitMask: "url(/spinner/dot.svg) center 100% / 100% no-repeat",
          background: e ? "currentColor" : "#999"
        }
      }), y.jsx("span", {
        className: "h-md w-md absolute flex flex-shrink-0",
        style: {
          mask: "url(/spinner/ring.svg) center 100% / 100% no-repeat",
          WebkitMask: "url(/spinner/ring.svg) center 100% / 100% no-repeat",
          background: `conic-gradient(${e?"currentColor":"#999"}, transparent )`
        }
      }), y.jsx("span", {
        className: "sr-only",
        children: n("loading-message.loading")
      })]
    })
  })
}
const R_ = g.forwardRef(function(e, n) {
    return y.jsx(g4, {
      ...e,
      ref: n,
      as: "button"
    })
  }),
  Tfe = g.forwardRef(function(e, n) {
    return y.jsx(g4, {
      ...e,
      ref: n,
      as: zU
    })
  }),
  g4 = g.forwardRef(function({
    as: e = "button",
    variant: n = "primary",
    layout: r = "inline",
    size: o = "medium",
    selected: s = !1,
    loading: i = !1,
    disabled: a = !1,
    icon: c,
    iconRight: l,
    iconContainerSize: u = "small",
    children: d,
    className: f,
    onClick: h,
    ...m
  }, p) {
    const b = e;
    return y.jsxs(b, {
      ...m,
      disabled: a || i,
      ref: p,
      className: ae([f, "relative flex cursor-pointer select-none items-center whitespace-nowrap rounded", Ofe({
        size: o
      }), Ife({
        layout: r,
        size: o,
        icon: c
      }), $fe({
        variant: n,
        selected: s,
        layout: r
      }), (a || i) && "pointer-events-none", a && "opacity-40"]),
      onClick: a || i ? void 0 : h,
      children: [y.jsxs("div", {
        className: ae("gap-xs flex items-center", i && "opacity-0", n === "dropdown" && "max-w-[200px] sm:max-w-[320px]"),
        children: [c && y.jsx(au, {
          icon: c,
          containerSize: u
        }), d, l && y.jsx(au, {
          icon: l,
          containerSize: u
        })]
      }), i && y.jsx("div", {
        className: "absolute inset-0 flex items-center justify-center",
        children: y.jsx(Pfe, {
          white: n === "primary" || n === "danger"
        })
      })]
    })
  }),
  $fe = t => {
    const {
      variant: e = "primary",
      selected: n = !1,
      loading: r = !1
    } = t;
    switch (e) {
      case "primary":
        return ae(["bg-blue sm:hover:bg-blue-hover text-white", "border-overlay border", "justify-center", "text-primary-bold"]);
      case "danger":
        return ae(["bg-red sm:hover:bg-red-hover text-white", "border-overlay border", "justify-center", "text-primary-bold"]);
      case "secondary":
        return ae(["bg-grey-button sm:hover:bg-grey-border-light", "border border-overlay", "justify-center", "text-primary-bold", r ? "text-grey" : "text-black"]);
      case "transparent":
        return ae(["border border-overlay", "justify-center", "text-primary-bold", r ? "text-grey" : "text-black", !n && "sm:hover:bg-black-selection-hover", n ? "bg-black-selection" : "bg-transparent"]);
      case "borderless":
        return ae(["border", "justify-center", "text-primary-bold", r ? "text-grey" : "text-black", n ? "border-grey" : "border-transparent sm:hover:bg-black-selection"]);
      case "borderless-fill-container":
        return ae(["justify-center", "text-primary-bold", 'before:bg-black-selection before:border before:absolute before:bottom-[4px] before:left-[0px] before:right-[0px] before:top-[4px] before:rounded before:content-[""]', r ? "text-grey" : "text-black", n ? ["before:border-grey"] : ["before:border-selection", "before:hidden", "sm:group-hover:before:block", "sm:hover:before:block"]]);
      case "action":
        return ae(['relative text-grey-dark before:bg-black-selection before:absolute before:inset-0 before:rounded-sm before:content-[""] before:hidden sm:hover:before:block']);
      case "dropdown":
        return ae("text-black focus:outline-none focus:bg-blue focus:text-white", "justify-start", "text-primary")
    }
  },
  Ife = t => {
    const {
      layout: e = "inline",
      size: n = "medium",
      icon: r
    } = t;
    switch (e) {
      case "block":
        return ae(["px-sm w-full"]);
      case "square":
        return ae(["flex-shrink-0", n === "medium" ? "w-button-md" : n === "smallish" ? "w-button-si" : n === "small" ? "w-button-sm" : "w-button-lg"]);
      case "inline":
        return ae(["inline-flex", "flex-shrink-0", r ? "pl-sm pr-[14px]" : "px-[14px]"])
    }
  },
  Ofe = t => {
    const {
      size: e = "medium"
    } = t;
    switch (e) {
      case "small":
        return ae(["h-button-sm"]);
      case "smallish":
        return ae(["h-button-si"]);
      case "medium":
        return ae(["h-button-md"]);
      case "large":
        return ae(["h-button-lg"])
    }
  };

function Rfe() {
  const [t, e] = g.useState(!1), n = g.useCallback(() => e(!0), []), r = g.useCallback(() => e(!1), []);
  return {
    isOpen: t,
    open: n,
    close: r
  }
}

function Afe(t) {
  const e = [t.confirmButton, t.cancelButton].filter(Boolean).length,
    [n, r] = g.useTransition();

  function o() {
    r(() => {
      var s;
      (s = t.confirmButton) == null || s.onClick()
    })
  }
  return y.jsx(zj, {
    open: t.isOpen,
    children: y.jsxs(Hj, {
      children: [y.jsx(Vj, {
        className: "z-dialog-overlay bg-grey-overlay-border fixed inset-[0]"
      }), y.jsx(Wj, {
        className: "z-dialog mb-lg fixed inset-[0] flex items-center justify-center",
        "data-id": "dialog-content",
        onClick: s => {
          var i;
          s.target instanceof HTMLElement && s.target.dataset.id === "dialog-content" && ((i = t.onDismiss) == null || i.call(t))
        },
        onEscapeKeyDown: s => {
          var a;
          s.target.role !== "option" && ((a = t.onDismiss) == null || a.call(t))
        },
        inert: n ? "" : void 0,
        children: y.jsxs("div", {
          className: "gap-md p-md shadow-dialog flex max-h-[85vh] w-[90vw] max-w-[320px] flex-col rounded bg-white pt-[30px] text-center focus:outline-none",
          children: [y.jsxs("div", {
            className: "gap-md flex flex-col",
            children: [t.icon && y.jsx("div", {
              className: "flex justify-center",
              children: y.jsx(au, {
                icon: t.icon,
                containerSize: "medium"
              })
            }), y.jsxs("div", {
              className: "gap-xs flex flex-col",
              children: [t.title && y.jsx(tie, {
                className: "text-section-title font-semibold",
                children: t.title
              }), t.description && y.jsx(nie, {
                className: "text-grey-dark text-primary",
                children: t.description
              })]
            })]
          }), y.jsxs("div", {
            className: "gap-sm flex w-full flex-col",
            children: [typeof t.children == "function" ? t.children({
              onConfirm: o
            }) : t.children, e > 0 && y.jsxs("div", {
              className: ae("gap-sm flex", e === 1 && "justify-end"),
              children: [t.cancelButton && y.jsx(R_, {
                layout: e > 1 ? "block" : "inline",
                variant: t.cancelButton.variant,
                onClick: t.cancelButton.onClick,
                children: t.cancelButton.label
              }), t.confirmButton && y.jsx(R_, {
                layout: e > 1 ? "block" : "inline",
                variant: t.confirmButton.variant,
                onClick: o,
                loading: n,
                children: t.confirmButton.label
              })]
            })]
          })]
        })
      })]
    })
  })
}
const Mfe = g.forwardRef(function({
    name: e,
    className: n,
    placeholder: r,
    maxLength: o,
    variant: s = "default",
    ...i
  }, a) {
    return y.jsx("input", {
      ref: a,
      className: ae(["text-input sm:text-primary", "placeholder-grey-input-placeholder p-sm sm:py-xs sm:py-sm rounded text-black outline-none disabled:opacity-40", s === "default" && "bg-grey-button focus:border-blue h-button-md border", s === "inline" && "h-[100%]", n]),
      name: e,
      placeholder: r,
      maxLength: o,
      ...i
    })
  }),
  jfe = g.forwardRef(function({
    value: e,
    setValue: n,
    onConfirm: r,
    placeholder: o,
    maxLength: s
  }, i) {
    const [a, c] = g.useState(null), l = g.useRef(null), {
      msg: u
    } = Fh();
    return g.useImperativeHandle(i, () => ({
      focus: () => {
        var d;
        (d = l.current) == null || d.focus()
      },
      getValue: () => {
        var d;
        return (d = l.current) == null ? void 0 : d.value
      },
      setError: d => {
        c(d)
      }
    })), g.useEffect(() => {
      e && s && e.length >= s && c(u("rename-folder-dialog.name-length-error"))
    }, [u, e, s]), y.jsxs("div", {
      className: "gap-xs flex w-full flex-col",
      children: [y.jsx(Mfe, {
        ref: l,
        placeholder: o,
        maxLength: s,
        value: e,
        autoFocus: !0,
        onKeyDown: d => {
          d.key === "Enter" && r(e)
        },
        onChange: d => {
          n(d.target.value), c(null)
        }
      }), a && y.jsx("p", {
        className: "text-red text-input-error text-left",
        children: a
      })]
    })
  });

function S$(t, [e, n]) {
  return Math.min(n, Math.max(e, t))
}
const A_ = "dismissableLayer.update",
  Dfe = "dismissableLayer.pointerDownOutside",
  Nfe = "dismissableLayer.focusOutside";
let _$;
const Lfe = g.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
  }),
  Ffe = g.forwardRef((t, e) => {
    var n;
    const {
      disableOutsidePointerEvents: r = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: s,
      onFocusOutside: i,
      onInteractOutside: a,
      onDismiss: c,
      ...l
    } = t, u = g.useContext(Lfe), [d, f] = g.useState(null), h = (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, m] = g.useState({}), p = rt(e, C => f(C)), b = Array.from(u.layers), [w] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), v = b.indexOf(w), _ = d ? b.indexOf(d) : -1, S = u.layersWithOutsidePointerEventsDisabled.size > 0, x = _ >= v, E = Bfe(C => {
      const $ = C.target,
        I = [...u.branches].some(R => R.contains($));
      !x || I || (s == null || s(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h), k = Ufe(C => {
      const $ = C.target;
      [...u.branches].some(R => R.contains($)) || (i == null || i(C), a == null || a(C), C.defaultPrevented || c == null || c())
    }, h);
    return eE(C => {
      _ === u.layers.size - 1 && (o == null || o(C), !C.defaultPrevented && c && (C.preventDefault(), c()))
    }, h), g.useEffect(() => {
      if (d) return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (_$ = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), x$(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = _$)
      }
    }, [d, h, r, u]), g.useEffect(() => () => {
      d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), x$())
    }, [d, u]), g.useEffect(() => {
      const C = () => m({});
      return document.addEventListener(A_, C), () => document.removeEventListener(A_, C)
    }, []), g.createElement(Ke.div, G({}, l, {
      ref: p,
      style: {
        pointerEvents: S ? x ? "auto" : "none" : void 0,
        ...t.style
      },
      onFocusCapture: ie(t.onFocusCapture, k.onFocusCapture),
      onBlurCapture: ie(t.onBlurCapture, k.onBlurCapture),
      onPointerDownCapture: ie(t.onPointerDownCapture, E.onPointerDownCapture)
    }))
  });

function Bfe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1),
    o = g.useRef(() => {});
  return g.useEffect(() => {
    const s = a => {
        if (a.target && !r.current) {
          let l = function() {
            m4(Dfe, n, c, {
              discrete: !0
            })
          };
          const c = {
            originalEvent: a
          };
          a.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = l, e.addEventListener("click", o.current, {
            once: !0
          })) : l()
        }
        r.current = !1
      },
      i = window.setTimeout(() => {
        e.addEventListener("pointerdown", s)
      }, 0);
    return () => {
      window.clearTimeout(i), e.removeEventListener("pointerdown", s), e.removeEventListener("click", o.current)
    }
  }, [e, n]), {
    onPointerDownCapture: () => r.current = !0
  }
}

function Ufe(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = At(t),
    r = g.useRef(!1);
  return g.useEffect(() => {
    const o = s => {
      s.target && !r.current && m4(Nfe, n, {
        originalEvent: s
      }, {
        discrete: !1
      })
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o)
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  }
}

function x$() {
  const t = new CustomEvent(A_);
  document.dispatchEvent(t)
}

function m4(t, e, n, {
  discrete: r
}) {
  const o = n.originalEvent.target,
    s = new CustomEvent(t, {
      bubbles: !1,
      cancelable: !0,
      detail: n
    });
  e && o.addEventListener(t, e, {
    once: !0
  }), r ? Rh(o, s) : o.dispatchEvent(s)
}
const Zb = "focusScope.autoFocusOnMount",
  Jb = "focusScope.autoFocusOnUnmount",
  E$ = {
    bubbles: !1,
    cancelable: !0
  },
  zfe = g.forwardRef((t, e) => {
    const {
      loop: n = !1,
      trapped: r = !1,
      onMountAutoFocus: o,
      onUnmountAutoFocus: s,
      ...i
    } = t, [a, c] = g.useState(null), l = At(o), u = At(s), d = g.useRef(null), f = rt(e, p => c(p)), h = g.useRef({
      paused: !1,
      pause() {
        this.paused = !0
      },
      resume() {
        this.paused = !1
      }
    }).current;
    g.useEffect(() => {
      if (r) {
        let p = function(_) {
            if (h.paused || !a) return;
            const S = _.target;
            a.contains(S) ? d.current = S : hi(d.current, {
              select: !0
            })
          },
          b = function(_) {
            if (h.paused || !a) return;
            const S = _.relatedTarget;
            S !== null && (a.contains(S) || hi(d.current, {
              select: !0
            }))
          },
          w = function(_) {
            const S = document.activeElement;
            for (const x of _) x.removedNodes.length > 0 && (a != null && a.contains(S) || hi(a))
          };
        document.addEventListener("focusin", p), document.addEventListener("focusout", b);
        const v = new MutationObserver(w);
        return a && v.observe(a, {
          childList: !0,
          subtree: !0
        }), () => {
          document.removeEventListener("focusin", p), document.removeEventListener("focusout", b), v.disconnect()
        }
      }
    }, [r, a, h.paused]), g.useEffect(() => {
      if (a) {
        C$.add(h);
        const p = document.activeElement;
        if (!a.contains(p)) {
          const w = new CustomEvent(Zb, E$);
          a.addEventListener(Zb, l), a.dispatchEvent(w), w.defaultPrevented || (Hfe(Yfe(y4(a)), {
            select: !0
          }), document.activeElement === p && hi(a))
        }
        return () => {
          a.removeEventListener(Zb, l), setTimeout(() => {
            const w = new CustomEvent(Jb, E$);
            a.addEventListener(Jb, u), a.dispatchEvent(w), w.defaultPrevented || hi(p ?? document.body, {
              select: !0
            }), a.removeEventListener(Jb, u), C$.remove(h)
          }, 0)
        }
      }
    }, [a, l, u, h]);
    const m = g.useCallback(p => {
      if (!n && !r || h.paused) return;
      const b = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey,
        w = document.activeElement;
      if (b && w) {
        const v = p.currentTarget,
          [_, S] = Vfe(v);
        _ && S ? !p.shiftKey && w === S ? (p.preventDefault(), n && hi(_, {
          select: !0
        })) : p.shiftKey && w === _ && (p.preventDefault(), n && hi(S, {
          select: !0
        })) : w === v && p.preventDefault()
      }
    }, [n, r, h.paused]);
    return g.createElement(Ke.div, G({
      tabIndex: -1
    }, i, {
      ref: f,
      onKeyDown: m
    }))
  });

function Hfe(t, {
  select: e = !1
} = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (hi(r, {
        select: e
      }), document.activeElement !== n) return
}

function Vfe(t) {
  const e = y4(t),
    n = k$(e, t),
    r = k$(e.reverse(), t);
  return [n, r]
}

function y4(t) {
  const e = [],
    n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
      acceptNode: r => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
      }
    });
  for (; n.nextNode();) e.push(n.currentNode);
  return e
}

function k$(t, e) {
  for (const n of t)
    if (!Wfe(n, {
        upTo: e
      })) return n
}

function Wfe(t, {
  upTo: e
}) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t;) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement
  }
  return !1
}

function Kfe(t) {
  return t instanceof HTMLInputElement && "select" in t
}

function hi(t, {
  select: e = !1
} = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({
      preventScroll: !0
    }), t !== n && Kfe(t) && e && t.select()
  }
}
const C$ = Gfe();

function Gfe() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && (n == null || n.pause()), t = P$(t, e), t.unshift(e)
    },
    remove(e) {
      var n;
      t = P$(t, e), (n = t[0]) === null || n === void 0 || n.resume()
    }
  }
}

function P$(t, e) {
  const n = [...t],
    r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n
}

function Yfe(t) {
  return t.filter(e => e.tagName !== "A")
}
const v4 = "Popper",
  [b4, w4] = Vo(v4),
  [qfe, S4] = b4(v4),
  Xfe = t => {
    const {
      __scopePopper: e,
      children: n
    } = t, [r, o] = g.useState(null);
    return g.createElement(qfe, {
      scope: e,
      anchor: r,
      onAnchorChange: o
    }, n)
  },
  Zfe = "PopperAnchor",
  Jfe = g.forwardRef((t, e) => {
    const {
      __scopePopper: n,
      virtualRef: r,
      ...o
    } = t, s = S4(Zfe, n), i = g.useRef(null), a = rt(e, i);
    return g.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || i.current)
    }), r ? null : g.createElement(Ke.div, G({}, o, {
      ref: a
    }))
  }),
  _4 = "PopperContent",
  [Qfe, Kbe] = b4(_4),
  ehe = g.forwardRef((t, e) => {
    var n, r, o, s, i, a, c, l;
    const {
      __scopePopper: u,
      side: d = "bottom",
      sideOffset: f = 0,
      align: h = "center",
      alignOffset: m = 0,
      arrowPadding: p = 0,
      collisionBoundary: b = [],
      collisionPadding: w = 0,
      sticky: v = "partial",
      hideWhenDetached: _ = !1,
      avoidCollisions: S = !0,
      onPlaced: x,
      ...E
    } = t, k = S4(_4, u), [C, $] = g.useState(null), I = rt(e, Ze => $(Ze)), [R, M] = g.useState(null), j = zD(R), A = (n = j == null ? void 0 : j.width) !== null && n !== void 0 ? n : 0, D = (r = j == null ? void 0 : j.height) !== null && r !== void 0 ? r : 0, N = d + (h !== "center" ? "-" + h : ""), q = typeof w == "number" ? w : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...w
    }, F = Array.isArray(b) ? b : [b], B = F.length > 0, V = {
      padding: q,
      boundary: F.filter(the),
      altBoundary: B
    }, {
      refs: J,
      floatingStyles: ee,
      placement: ye,
      isPositioned: ge,
      middlewareData: ce
    } = UD({
      strategy: "fixed",
      placement: N,
      whileElementsMounted: LD,
      elements: {
        reference: k.anchor
      },
      middleware: [PD({
        mainAxis: f + D,
        alignmentAxis: m
      }), S && $D({
        mainAxis: !0,
        crossAxis: !1,
        limiter: v === "partial" ? ID() : void 0,
        ...V
      }), S && kD({
        ...V
      }), OD({
        ...V,
        apply: ({
          elements: Ze,
          rects: xt,
          availableWidth: An,
          availableHeight: ln
        }) => {
          const {
            width: bn,
            height: Go
          } = xt.reference, Zn = Ze.floating.style;
          Zn.setProperty("--radix-popper-available-width", `${An}px`), Zn.setProperty("--radix-popper-available-height", `${ln}px`), Zn.setProperty("--radix-popper-anchor-width", `${bn}px`), Zn.setProperty("--radix-popper-anchor-height", `${Go}px`)
        }
      }), R && FD({
        element: R,
        padding: p
      }), nhe({
        arrowWidth: A,
        arrowHeight: D
      }), _ && CD({
        strategy: "referenceHidden"
      })]
    }), [Ce, oe] = x4(ye), pe = At(x);
    Sr(() => {
      ge && (pe == null || pe())
    }, [ge, pe]);
    const _e = (o = ce.arrow) === null || o === void 0 ? void 0 : o.x,
      xe = (s = ce.arrow) === null || s === void 0 ? void 0 : s.y,
      Me = ((i = ce.arrow) === null || i === void 0 ? void 0 : i.centerOffset) !== 0,
      [Le, gt] = g.useState();
    return Sr(() => {
      C && gt(window.getComputedStyle(C).zIndex)
    }, [C]), g.createElement("div", {
      ref: J.setFloating,
      "data-radix-popper-content-wrapper": "",
      style: {
        ...ee,
        transform: ge ? ee.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: Le,
        "--radix-popper-transform-origin": [(a = ce.transformOrigin) === null || a === void 0 ? void 0 : a.x, (c = ce.transformOrigin) === null || c === void 0 ? void 0 : c.y].join(" ")
      },
      dir: t.dir
    }, g.createElement(Qfe, {
      scope: u,
      placedSide: Ce,
      onArrowChange: M,
      arrowX: _e,
      arrowY: xe,
      shouldHideArrow: Me
    }, g.createElement(Ke.div, G({
      "data-side": Ce,
      "data-align": oe
    }, E, {
      ref: I,
      style: {
        ...E.style,
        animation: ge ? void 0 : "none",
        opacity: (l = ce.hide) !== null && l !== void 0 && l.referenceHidden ? 0 : void 0
      }
    }))))
  });

function the(t) {
  return t !== null
}
const nhe = t => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var n, r, o, s, i;
    const {
      placement: a,
      rects: c,
      middlewareData: l
    } = e, d = ((n = l.arrow) === null || n === void 0 ? void 0 : n.centerOffset) !== 0, f = d ? 0 : t.arrowWidth, h = d ? 0 : t.arrowHeight, [m, p] = x4(a), b = {
      start: "0%",
      center: "50%",
      end: "100%"
    } [p], w = ((r = (o = l.arrow) === null || o === void 0 ? void 0 : o.x) !== null && r !== void 0 ? r : 0) + f / 2, v = ((s = (i = l.arrow) === null || i === void 0 ? void 0 : i.y) !== null && s !== void 0 ? s : 0) + h / 2;
    let _ = "",
      S = "";
    return m === "bottom" ? (_ = d ? b : `${w}px`, S = `${-h}px`) : m === "top" ? (_ = d ? b : `${w}px`, S = `${c.floating.height+h}px`) : m === "right" ? (_ = `${-h}px`, S = d ? b : `${v}px`) : m === "left" && (_ = `${c.floating.width+h}px`, S = d ? b : `${v}px`), {
      data: {
        x: _,
        y: S
      }
    }
  }
});

function x4(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n]
}
const rhe = Xfe,
  ohe = Jfe,
  she = ehe;

function ihe(t) {
  const e = g.useRef({
    value: t,
    previous: t
  });
  return g.useMemo(() => (e.current.value !== t && (e.current.previous = e.current.value, e.current.value = t), e.current.previous), [t])
}
const ahe = [" ", "Enter", "ArrowUp", "ArrowDown"],
  che = [" ", "Enter"],
  Fv = "Select",
  [Bv, AE, lhe] = mv(Fv),
  [Au, Gbe] = Vo(Fv, [lhe, w4]),
  ME = w4(),
  [uhe, bc] = Au(Fv),
  [dhe, fhe] = Au(Fv),
  hhe = t => {
    const {
      __scopeSelect: e,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: s,
      value: i,
      defaultValue: a,
      onValueChange: c,
      dir: l,
      name: u,
      autoComplete: d,
      disabled: f,
      required: h
    } = t, m = ME(e), [p, b] = g.useState(null), [w, v] = g.useState(null), [_, S] = g.useState(!1), x = mE(l), [E = !1, k] = Xs({
      prop: r,
      defaultProp: o,
      onChange: s
    }), [C, $] = Xs({
      prop: i,
      defaultProp: a,
      onChange: c
    }), I = g.useRef(null), R = p ? !!p.closest("form") : !0, [M, j] = g.useState(new Set), A = Array.from(M).map(D => D.props.value).join(";");
    return g.createElement(rhe, m, g.createElement(uhe, {
      required: h,
      scope: e,
      trigger: p,
      onTriggerChange: b,
      valueNode: w,
      onValueNodeChange: v,
      valueNodeHasChildren: _,
      onValueNodeHasChildrenChange: S,
      contentId: Mo(),
      value: C,
      onValueChange: $,
      open: E,
      onOpenChange: k,
      dir: x,
      triggerPointerDownPosRef: I,
      disabled: f
    }, g.createElement(Bv.Provider, {
      scope: e
    }, g.createElement(dhe, {
      scope: t.__scopeSelect,
      onNativeOptionAdd: g.useCallback(D => {
        j(N => new Set(N).add(D))
      }, []),
      onNativeOptionRemove: g.useCallback(D => {
        j(N => {
          const q = new Set(N);
          return q.delete(D), q
        })
      }, [])
    }, n)), R ? g.createElement(C4, {
      key: A,
      "aria-hidden": !0,
      required: h,
      tabIndex: -1,
      name: u,
      autoComplete: d,
      value: C,
      onChange: D => $(D.target.value),
      disabled: f
    }, C === void 0 ? g.createElement("option", {
      value: ""
    }) : null, Array.from(M)) : null))
  },
  phe = "SelectTrigger",
  ghe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      disabled: r = !1,
      ...o
    } = t, s = ME(n), i = bc(phe, n), a = i.disabled || r, c = rt(e, i.onTriggerChange), l = AE(n), [u, d, f] = P4(m => {
      const p = l().filter(v => !v.disabled),
        b = p.find(v => v.value === i.value),
        w = T4(p, m, b);
      w !== void 0 && i.onValueChange(w.value)
    }), h = () => {
      a || (i.onOpenChange(!0), f())
    };
    return g.createElement(ohe, G({
      asChild: !0
    }, s), g.createElement(Ke.button, G({
      type: "button",
      role: "combobox",
      "aria-controls": i.contentId,
      "aria-expanded": i.open,
      "aria-required": i.required,
      "aria-autocomplete": "none",
      dir: i.dir,
      "data-state": i.open ? "open" : "closed",
      disabled: a,
      "data-disabled": a ? "" : void 0,
      "data-placeholder": i.value === void 0 ? "" : void 0
    }, o, {
      ref: c,
      onClick: ie(o.onClick, m => {
        m.currentTarget.focus()
      }),
      onPointerDown: ie(o.onPointerDown, m => {
        const p = m.target;
        p.hasPointerCapture(m.pointerId) && p.releasePointerCapture(m.pointerId), m.button === 0 && m.ctrlKey === !1 && (h(), i.triggerPointerDownPosRef.current = {
          x: Math.round(m.pageX),
          y: Math.round(m.pageY)
        }, m.preventDefault())
      }),
      onKeyDown: ie(o.onKeyDown, m => {
        const p = u.current !== "";
        !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && d(m.key), !(p && m.key === " ") && ahe.includes(m.key) && (h(), m.preventDefault())
      })
    })))
  }),
  mhe = "SelectValue",
  yhe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      className: r,
      style: o,
      children: s,
      placeholder: i,
      ...a
    } = t, c = bc(mhe, n), {
      onValueNodeHasChildrenChange: l
    } = c, u = s !== void 0, d = rt(e, c.onValueNodeChange);
    return Sr(() => {
      l(u)
    }, [l, u]), g.createElement(Ke.span, G({}, a, {
      ref: d,
      style: {
        pointerEvents: "none"
      }
    }), c.value === void 0 && i !== void 0 ? i : s)
  }),
  vhe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      children: r,
      ...o
    } = t;
    return g.createElement(Ke.span, G({
      "aria-hidden": !0
    }, o, {
      ref: e
    }), r || "")
  }),
  cu = "SelectContent",
  bhe = g.forwardRef((t, e) => {
    const n = bc(cu, t.__scopeSelect),
      [r, o] = g.useState();
    if (Sr(() => {
        o(new DocumentFragment)
      }, []), !n.open) {
      const s = r;
      return s ? ta.createPortal(g.createElement(E4, {
        scope: t.__scopeSelect
      }, g.createElement(Bv.Slot, {
        scope: t.__scopeSelect
      }, g.createElement("div", null, t.children))), s) : null
    }
    return g.createElement(whe, G({}, t, {
      ref: e
    }))
  }),
  $s = 10,
  [E4, Uv] = Au(cu),
  whe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      position: r = "item-aligned",
      onCloseAutoFocus: o,
      onEscapeKeyDown: s,
      onPointerDownOutside: i,
      side: a,
      sideOffset: c,
      align: l,
      alignOffset: u,
      arrowPadding: d,
      collisionBoundary: f,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: b,
      ...w
    } = t, v = bc(cu, n), [_, S] = g.useState(null), [x, E] = g.useState(null), k = rt(e, oe => S(oe)), [C, $] = g.useState(null), [I, R] = g.useState(null), M = AE(n), [j, A] = g.useState(!1), D = g.useRef(!1);
    g.useEffect(() => {
      if (_) return Ev(_)
    }, [_]), Sv();
    const N = g.useCallback(oe => {
        const [pe, ..._e] = M().map(Le => Le.ref.current), [xe] = _e.slice(-1), Me = document.activeElement;
        for (const Le of oe)
          if (Le === Me || (Le == null || Le.scrollIntoView({
              block: "nearest"
            }), Le === pe && x && (x.scrollTop = 0), Le === xe && x && (x.scrollTop = x.scrollHeight), Le == null || Le.focus(), document.activeElement !== Me)) return
      }, [M, x]),
      q = g.useCallback(() => N([C, _]), [N, C, _]);
    g.useEffect(() => {
      j && q()
    }, [j, q]);
    const {
      onOpenChange: F,
      triggerPointerDownPosRef: B
    } = v;
    g.useEffect(() => {
      if (_) {
        let oe = {
          x: 0,
          y: 0
        };
        const pe = xe => {
            var Me, Le, gt, Ze;
            oe = {
              x: Math.abs(Math.round(xe.pageX) - ((Me = (Le = B.current) === null || Le === void 0 ? void 0 : Le.x) !== null && Me !== void 0 ? Me : 0)),
              y: Math.abs(Math.round(xe.pageY) - ((gt = (Ze = B.current) === null || Ze === void 0 ? void 0 : Ze.y) !== null && gt !== void 0 ? gt : 0))
            }
          },
          _e = xe => {
            oe.x <= 10 && oe.y <= 10 ? xe.preventDefault() : _.contains(xe.target) || F(!1), document.removeEventListener("pointermove", pe), B.current = null
          };
        return B.current !== null && (document.addEventListener("pointermove", pe), document.addEventListener("pointerup", _e, {
          capture: !0,
          once: !0
        })), () => {
          document.removeEventListener("pointermove", pe), document.removeEventListener("pointerup", _e, {
            capture: !0
          })
        }
      }
    }, [_, F, B]), g.useEffect(() => {
      const oe = () => F(!1);
      return window.addEventListener("blur", oe), window.addEventListener("resize", oe), () => {
        window.removeEventListener("blur", oe), window.removeEventListener("resize", oe)
      }
    }, [F]);
    const [V, J] = P4(oe => {
      const pe = M().filter(Me => !Me.disabled),
        _e = pe.find(Me => Me.ref.current === document.activeElement),
        xe = T4(pe, oe, _e);
      xe && setTimeout(() => xe.ref.current.focus())
    }), ee = g.useCallback((oe, pe, _e) => {
      const xe = !D.current && !_e;
      (v.value !== void 0 && v.value === pe || xe) && ($(oe), xe && (D.current = !0))
    }, [v.value]), ye = g.useCallback(() => _ == null ? void 0 : _.focus(), [_]), ge = g.useCallback((oe, pe, _e) => {
      const xe = !D.current && !_e;
      (v.value !== void 0 && v.value === pe || xe) && R(oe)
    }, [v.value]), ce = r === "popper" ? T$ : She, Ce = ce === T$ ? {
      side: a,
      sideOffset: c,
      align: l,
      alignOffset: u,
      arrowPadding: d,
      collisionBoundary: f,
      collisionPadding: h,
      sticky: m,
      hideWhenDetached: p,
      avoidCollisions: b
    } : {};
    return g.createElement(E4, {
      scope: n,
      content: _,
      viewport: x,
      onViewportChange: E,
      itemRefCallback: ee,
      selectedItem: C,
      onItemLeave: ye,
      itemTextRefCallback: ge,
      focusSelectedItem: q,
      selectedItemText: I,
      position: r,
      isPositioned: j,
      searchRef: V
    }, g.createElement(xv, {
      as: Wi,
      allowPinchZoom: !0
    }, g.createElement(zfe, {
      asChild: !0,
      trapped: v.open,
      onMountAutoFocus: oe => {
        oe.preventDefault()
      },
      onUnmountAutoFocus: ie(o, oe => {
        var pe;
        (pe = v.trigger) === null || pe === void 0 || pe.focus({
          preventScroll: !0
        }), oe.preventDefault()
      })
    }, g.createElement(Ffe, {
      asChild: !0,
      disableOutsidePointerEvents: !0,
      onEscapeKeyDown: s,
      onPointerDownOutside: i,
      onFocusOutside: oe => oe.preventDefault(),
      onDismiss: () => v.onOpenChange(!1)
    }, g.createElement(ce, G({
      role: "listbox",
      id: v.contentId,
      "data-state": v.open ? "open" : "closed",
      dir: v.dir,
      onContextMenu: oe => oe.preventDefault()
    }, w, Ce, {
      onPlaced: () => A(!0),
      ref: k,
      style: {
        display: "flex",
        flexDirection: "column",
        outline: "none",
        ...w.style
      },
      onKeyDown: ie(w.onKeyDown, oe => {
        const pe = oe.ctrlKey || oe.altKey || oe.metaKey;
        if (oe.key === "Tab" && oe.preventDefault(), !pe && oe.key.length === 1 && J(oe.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(oe.key)) {
          let xe = M().filter(Me => !Me.disabled).map(Me => Me.ref.current);
          if (["ArrowUp", "End"].includes(oe.key) && (xe = xe.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(oe.key)) {
            const Me = oe.target,
              Le = xe.indexOf(Me);
            xe = xe.slice(Le + 1)
          }
          setTimeout(() => N(xe)), oe.preventDefault()
        }
      })
    }))))))
  }),
  She = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      onPlaced: r,
      ...o
    } = t, s = bc(cu, n), i = Uv(cu, n), [a, c] = g.useState(null), [l, u] = g.useState(null), d = rt(e, k => u(k)), f = AE(n), h = g.useRef(!1), m = g.useRef(!0), {
      viewport: p,
      selectedItem: b,
      selectedItemText: w,
      focusSelectedItem: v
    } = i, _ = g.useCallback(() => {
      if (s.trigger && s.valueNode && a && l && p && b && w) {
        const k = s.trigger.getBoundingClientRect(),
          C = l.getBoundingClientRect(),
          $ = s.valueNode.getBoundingClientRect(),
          I = w.getBoundingClientRect();
        if (s.dir !== "rtl") {
          const Me = I.left - C.left,
            Le = $.left - Me,
            gt = k.left - Le,
            Ze = k.width + gt,
            xt = Math.max(Ze, C.width),
            An = window.innerWidth - $s,
            ln = S$(Le, [$s, An - xt]);
          a.style.minWidth = Ze + "px", a.style.left = ln + "px"
        } else {
          const Me = C.right - I.right,
            Le = window.innerWidth - $.right - Me,
            gt = window.innerWidth - k.right - Le,
            Ze = k.width + gt,
            xt = Math.max(Ze, C.width),
            An = window.innerWidth - $s,
            ln = S$(Le, [$s, An - xt]);
          a.style.minWidth = Ze + "px", a.style.right = ln + "px"
        }
        const R = f(),
          M = window.innerHeight - $s * 2,
          j = p.scrollHeight,
          A = window.getComputedStyle(l),
          D = parseInt(A.borderTopWidth, 10),
          N = parseInt(A.paddingTop, 10),
          q = parseInt(A.borderBottomWidth, 10),
          F = parseInt(A.paddingBottom, 10),
          B = D + N + j + F + q,
          V = Math.min(b.offsetHeight * 5, B),
          J = window.getComputedStyle(p),
          ee = parseInt(J.paddingTop, 10),
          ye = parseInt(J.paddingBottom, 10),
          ge = k.top + k.height / 2 - $s,
          ce = M - ge,
          Ce = b.offsetHeight / 2,
          oe = b.offsetTop + Ce,
          pe = D + N + oe,
          _e = B - pe;
        if (pe <= ge) {
          const Me = b === R[R.length - 1].ref.current;
          a.style.bottom = "0px";
          const Le = l.clientHeight - p.offsetTop - p.offsetHeight,
            gt = Math.max(ce, Ce + (Me ? ye : 0) + Le + q),
            Ze = pe + gt;
          a.style.height = Ze + "px"
        } else {
          const Me = b === R[0].ref.current;
          a.style.top = "0px";
          const gt = Math.max(ge, D + p.offsetTop + (Me ? ee : 0) + Ce) + _e;
          a.style.height = gt + "px", p.scrollTop = pe - ge + p.offsetTop
        }
        a.style.margin = `${$s}px 0`, a.style.minHeight = V + "px", a.style.maxHeight = M + "px", r == null || r(), requestAnimationFrame(() => h.current = !0)
      }
    }, [f, s.trigger, s.valueNode, a, l, p, b, w, s.dir, r]);
    Sr(() => _(), [_]);
    const [S, x] = g.useState();
    Sr(() => {
      l && x(window.getComputedStyle(l).zIndex)
    }, [l]);
    const E = g.useCallback(k => {
      k && m.current === !0 && (_(), v == null || v(), m.current = !1)
    }, [_, v]);
    return g.createElement(_he, {
      scope: n,
      contentWrapper: a,
      shouldExpandOnScrollRef: h,
      onScrollButtonChange: E
    }, g.createElement("div", {
      ref: c,
      style: {
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: S
      }
    }, g.createElement(Ke.div, G({}, o, {
      ref: d,
      style: {
        boxSizing: "border-box",
        maxHeight: "100%",
        ...o.style
      }
    }))))
  }),
  T$ = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      align: r = "start",
      collisionPadding: o = $s,
      ...s
    } = t, i = ME(n);
    return g.createElement(she, G({}, i, s, {
      ref: e,
      align: r,
      collisionPadding: o,
      style: {
        boxSizing: "border-box",
        ...s.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))
  }),
  [_he, xhe] = Au(cu, {}),
  $$ = "SelectViewport",
  Ehe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      ...r
    } = t, o = Uv($$, n), s = xhe($$, n), i = rt(e, o.onViewportChange), a = g.useRef(0);
    return g.createElement(g.Fragment, null, g.createElement("style", {
      dangerouslySetInnerHTML: {
        __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
      }
    }), g.createElement(Bv.Slot, {
      scope: n
    }, g.createElement(Ke.div, G({
      "data-radix-select-viewport": "",
      role: "presentation"
    }, r, {
      ref: i,
      style: {
        position: "relative",
        flex: 1,
        overflow: "auto",
        ...r.style
      },
      onScroll: ie(r.onScroll, c => {
        const l = c.currentTarget,
          {
            contentWrapper: u,
            shouldExpandOnScrollRef: d
          } = s;
        if (d != null && d.current && u) {
          const f = Math.abs(a.current - l.scrollTop);
          if (f > 0) {
            const h = window.innerHeight - $s * 2,
              m = parseFloat(u.style.minHeight),
              p = parseFloat(u.style.height),
              b = Math.max(m, p);
            if (b < h) {
              const w = b + f,
                v = Math.min(h, w),
                _ = w - v;
              u.style.height = v + "px", u.style.bottom === "0px" && (l.scrollTop = _ > 0 ? _ : 0, u.style.justifyContent = "flex-end")
            }
          }
        }
        a.current = l.scrollTop
      })
    }))))
  }),
  khe = "SelectGroup";
Au(khe);
const M_ = "SelectItem",
  [Che, k4] = Au(M_),
  Phe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      value: r,
      disabled: o = !1,
      textValue: s,
      ...i
    } = t, a = bc(M_, n), c = Uv(M_, n), l = a.value === r, [u, d] = g.useState(s ?? ""), [f, h] = g.useState(!1), m = rt(e, w => {
      var v;
      return (v = c.itemRefCallback) === null || v === void 0 ? void 0 : v.call(c, w, r, o)
    }), p = Mo(), b = () => {
      o || (a.onValueChange(r), a.onOpenChange(!1))
    };
    return g.createElement(Che, {
      scope: n,
      value: r,
      disabled: o,
      textId: p,
      isSelected: l,
      onItemTextChange: g.useCallback(w => {
        d(v => {
          var _;
          return v || ((_ = w == null ? void 0 : w.textContent) !== null && _ !== void 0 ? _ : "").trim()
        })
      }, [])
    }, g.createElement(Bv.ItemSlot, {
      scope: n,
      value: r,
      disabled: o,
      textValue: u
    }, g.createElement(Ke.div, G({
      role: "option",
      "aria-labelledby": p,
      "data-highlighted": f ? "" : void 0,
      "aria-selected": l && f,
      "data-state": l ? "checked" : "unchecked",
      "aria-disabled": o || void 0,
      "data-disabled": o ? "" : void 0,
      tabIndex: o ? void 0 : -1
    }, i, {
      ref: m,
      onFocus: ie(i.onFocus, () => h(!0)),
      onBlur: ie(i.onBlur, () => h(!1)),
      onPointerUp: ie(i.onPointerUp, b),
      onPointerMove: ie(i.onPointerMove, w => {
        if (o) {
          var v;
          (v = c.onItemLeave) === null || v === void 0 || v.call(c)
        } else w.currentTarget.focus({
          preventScroll: !0
        })
      }),
      onPointerLeave: ie(i.onPointerLeave, w => {
        if (w.currentTarget === document.activeElement) {
          var v;
          (v = c.onItemLeave) === null || v === void 0 || v.call(c)
        }
      }),
      onKeyDown: ie(i.onKeyDown, w => {
        var v;
        ((v = c.searchRef) === null || v === void 0 ? void 0 : v.current) !== "" && w.key === " " || (che.includes(w.key) && b(), w.key === " " && w.preventDefault())
      })
    }))))
  }),
  ag = "SelectItemText",
  The = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      className: r,
      style: o,
      ...s
    } = t, i = bc(ag, n), a = Uv(ag, n), c = k4(ag, n), l = fhe(ag, n), [u, d] = g.useState(null), f = rt(e, w => d(w), c.onItemTextChange, w => {
      var v;
      return (v = a.itemTextRefCallback) === null || v === void 0 ? void 0 : v.call(a, w, c.value, c.disabled)
    }), h = u == null ? void 0 : u.textContent, m = g.useMemo(() => g.createElement("option", {
      key: c.value,
      value: c.value,
      disabled: c.disabled
    }, h), [c.disabled, c.value, h]), {
      onNativeOptionAdd: p,
      onNativeOptionRemove: b
    } = l;
    return Sr(() => (p(m), () => b(m)), [p, b, m]), g.createElement(g.Fragment, null, g.createElement(Ke.span, G({
      id: c.textId
    }, s, {
      ref: f
    })), c.isSelected && i.valueNode && !i.valueNodeHasChildren ? ta.createPortal(s.children, i.valueNode) : null)
  }),
  $he = "SelectItemIndicator",
  Ihe = g.forwardRef((t, e) => {
    const {
      __scopeSelect: n,
      ...r
    } = t;
    return k4($he, n).isSelected ? g.createElement(Ke.span, G({
      "aria-hidden": !0
    }, r, {
      ref: e
    })) : null
  }),
  C4 = g.forwardRef((t, e) => {
    const {
      value: n,
      ...r
    } = t, o = g.useRef(null), s = rt(e, o), i = ihe(n);
    return g.useEffect(() => {
      const a = o.current,
        c = window.HTMLSelectElement.prototype,
        u = Object.getOwnPropertyDescriptor(c, "value").set;
      if (i !== n && u) {
        const d = new Event("change", {
          bubbles: !0
        });
        u.call(a, n), a.dispatchEvent(d)
      }
    }, [i, n]), g.createElement(yv, {
      asChild: !0
    }, g.createElement("select", G({}, r, {
      ref: s,
      defaultValue: n
    })))
  });
C4.displayName = "BubbleSelect";

function P4(t) {
  const e = At(t),
    n = g.useRef(""),
    r = g.useRef(0),
    o = g.useCallback(i => {
      const a = n.current + i;
      e(a),
        function c(l) {
          n.current = l, window.clearTimeout(r.current), l !== "" && (r.current = window.setTimeout(() => c(""), 1e3))
        }(a)
    }, [e]),
    s = g.useCallback(() => {
      n.current = "", window.clearTimeout(r.current)
    }, []);
  return g.useEffect(() => () => window.clearTimeout(r.current), []), [n, o, s]
}

function T4(t, e, n) {
  const o = e.length > 1 && Array.from(e).every(l => l === e[0]) ? e[0] : e,
    s = n ? t.indexOf(n) : -1;
  let i = Ohe(t, Math.max(s, 0));
  o.length === 1 && (i = i.filter(l => l !== n));
  const c = i.find(l => l.textValue.toLowerCase().startsWith(o.toLowerCase()));
  return c !== n ? c : void 0
}

function Ohe(t, e) {
  return t.map((n, r) => t[(e + r) % t.length])
}
const Rhe = hhe,
  Ahe = ghe,
  Mhe = yhe,
  jhe = vhe,
  Dhe = bhe,
  Nhe = Ehe,
  Lhe = Phe,
  Fhe = The,
  Bhe = Ihe;

function Uhe({
  children: t,
  className: e,
  options: n,
  value: r,
  onValueChange: o
}) {
  const [s, i] = g.useState(!1);
  return y.jsxs(Rhe, {
    value: r,
    onValueChange: o,
    onOpenChange: i,
    open: s,
    children: [y.jsxs(Ahe, {
      autoFocus: !0,
      className: "border-grey py-xs px-sm gap-xs h-button-md bg-grey-button text-primary flex items-center justify-between rounded border",
      children: [y.jsx(Mhe, {
        asChild: !0,
        children: y.jsx(zhe, {
          children: t
        })
      }), y.jsx(jhe, {
        asChild: !0,
        children: y.jsx(au, {
          icon: s ? "chevron-up-small" : "chevron-down-small",
          containerSize: "small"
        })
      })]
    }), y.jsx(Dhe, {
      sideOffset: 5,
      side: "bottom",
      onEscapeKeyDown: () => i(!1),
      position: "popper",
      className: "text-primary border-grey z-dropdown max-h-[280px] w-full overflow-y-auto rounded-lg border bg-white drop-shadow",
      ref: a => {
        a && (a.ontouchstart = c => {
          c.preventDefault()
        })
      },
      children: y.jsx(Nhe, {
        className: ae("p-[5px]", e),
        children: n.map(a => y.jsx(Lhe, {
          className: "p-xs h-button-md hover:bg-blue text-primary flex w-full cursor-pointer select-none items-center rounded text-left text-black outline-none hover:border-none hover:text-white",
          value: a.value,
          children: y.jsxs("div", {
            className: "gap-xs flex w-full items-center",
            children: [y.jsx(Bhe, {
              children: y.jsx(au, {
                icon: "check-small",
                containerSize: "small"
              })
            }), y.jsx(Fhe, {
              asChild: !0,
              children: y.jsx(Hhe, {
                isSelected: a.value === r,
                children: a.label
              })
            })]
          })
        }, a.value))
      })
    })]
  })
}
const zhe = g.forwardRef(function(e, n) {
    return y.jsx("span", {
      ref: n,
      className: "truncate",
      ...e
    })
  }),
  Hhe = g.forwardRef(function({
    isSelected: e,
    children: n,
    ...r
  }, o) {
    return y.jsx("span", {
      ref: o,
      className: ae("text-primary truncate", !e && "pl-[22px]"),
      ...r,
      children: n
    })
  }),
  $4 = g.createContext({});

function Vhe({
  children: t
}) {
  const {
    open: e,
    close: n,
    isOpen: r
  } = Rfe(), [o, s] = g.useState(null);

  function i(u) {
    s(u), e()
  }

  function a(u) {
    s(u), e()
  }

  function c(u) {
    s(u), e()
  }

  function l() {
    s(null), n()
  }
  return y.jsxs($4.Provider, {
    value: {
      openDialog: i,
      openInputDialog: a,
      closeDialog: l,
      openSelectDialog: c
    },
    children: [t, r && o && y.jsx(Ghe, {
      ...o
    })]
  })
}

function Whe(t) {
  return t.input !== void 0
}

function Khe(t) {
  return t.options !== void 0
}

function Ghe(t) {
  return Whe(t) ? y.jsx(Yhe, {
    ...t
  }) : Khe(t) ? y.jsx(qhe, {
    ...t
  }) : y.jsx(jE, {
    ...t
  })
}

function Yhe(t) {
  const e = g.useRef(null),
    [n, r] = g.useState(t.input.value),
    o = g.useCallback(() => {
      e.current && t.confirmButton.onClick({
        setError: e.current.setError,
        getInputValue: e.current.getValue,
        focusInput: e.current.focus
      })
    }, [t.confirmButton]);
  return y.jsx(jE, {
    icon: t.icon,
    title: t.title,
    description: t.description,
    cancelButton: t.cancelButton,
    confirmButton: {
      label: t.confirmButton.label,
      variant: t.confirmButton.variant,
      onClick: o
    },
    content: ({
      onConfirm: s
    }) => y.jsx(jfe, {
      ref: e,
      placeholder: t.input.placeholder,
      maxLength: t.input.maxLength,
      value: n,
      setValue: r,
      onConfirm: s
    })
  })
}

function qhe(t) {
  const [e, n] = g.useState(t.value), r = g.useCallback(o => {
    const s = t.options.filter(i => i.value === o)[0];
    n(s)
  }, [t]);
  return y.jsx(jE, {
    icon: t.icon,
    title: t.title,
    description: t.description,
    cancelButton: t.cancelButton,
    confirmButton: {
      label: t.confirmButton.label,
      variant: t.confirmButton.variant,
      onClick: () => t.confirmButton.onClick(e)
    },
    content: () => y.jsx(Uhe, {
      className: "w-[280px]",
      value: e.value,
      options: t.options,
      onValueChange: r,
      children: e.label
    })
  })
}

function jE(t) {
  return y.jsx(Afe, {
    onDismiss: t.cancelButton.onClick,
    isOpen: !0,
    icon: t.icon,
    title: t.title,
    description: t.description,
    cancelButton: {
      label: t.cancelButton.label,
      variant: t.cancelButton.variant,
      onClick: () => t.cancelButton.onClick()
    },
    confirmButton: {
      label: t.confirmButton.label,
      variant: t.confirmButton.variant,
      onClick: () => t.confirmButton.onClick()
    },
    children: t.content
  })
}

function Ybe() {
  const t = g.useContext($4);
  if (!t) throw new Error("useToast must be used within ToastProvider");
  return t
}
var Fi = {};
Object.defineProperty(Fi, "__esModule", {
  value: !0
});
Fi.decode = Fi.verify = Fi.sign = void 0;
if (typeof crypto > "u" || !crypto.subtle) throw new Error("SubtleCrypto not supported!");

function I4(t) {
  return new Uint8Array(Array.prototype.map.call(atob(t.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")), e => e.charCodeAt(0)))
}

function Qb(t) {
  return btoa(String.fromCharCode.apply(0, t)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}
const O4 = {
  ES256: {
    name: "ECDSA",
    namedCurve: "P-256",
    hash: {
      name: "SHA-256"
    }
  },
  ES384: {
    name: "ECDSA",
    namedCurve: "P-384",
    hash: {
      name: "SHA-384"
    }
  },
  ES512: {
    name: "ECDSA",
    namedCurve: "P-521",
    hash: {
      name: "SHA-512"
    }
  },
  HS256: {
    name: "HMAC",
    hash: {
      name: "SHA-256"
    }
  },
  HS384: {
    name: "HMAC",
    hash: {
      name: "SHA-384"
    }
  },
  HS512: {
    name: "HMAC",
    hash: {
      name: "SHA-512"
    }
  },
  RS256: {
    name: "RSASSA-PKCS1-v1_5",
    hash: {
      name: "SHA-256"
    }
  },
  RS384: {
    name: "RSASSA-PKCS1-v1_5",
    hash: {
      name: "SHA-384"
    }
  },
  RS512: {
    name: "RSASSA-PKCS1-v1_5",
    hash: {
      name: "SHA-512"
    }
  }
};

function El(t) {
  return I4(btoa(unescape(encodeURIComponent(t))))
}

function R4(t) {
  t = atob(t);
  const e = new ArrayBuffer(t.length),
    n = new Uint8Array(e);
  for (let r = 0, o = t.length; r < o; r++) n[r] = t.charCodeAt(r);
  return e
}

function I$(t) {
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("Illegal base64url string!")
  }
  try {
    return JSON.parse(decodeURIComponent(escape(atob(t))))
  } catch {
    return null
  }
}
async function A4(t, e, n = {
  algorithm: "HS256",
  header: {
    typ: "JWT"
  }
}) {
  if (typeof n == "string" && (n = {
      algorithm: n,
      header: {
        typ: "JWT"
      }
    }), n = {
      algorithm: "HS256",
      header: {
        typ: "JWT"
      },
      ...n
    }, t === null || typeof t != "object") throw new Error("payload must be an object");
  if (typeof e != "string" && typeof e != "object") throw new Error("secret must be a string or a JWK object");
  if (typeof n.algorithm != "string") throw new Error("options.algorithm must be a string");
  const r = O4[n.algorithm];
  if (!r) throw new Error("algorithm not found");
  t.iat || (t.iat = Math.floor(Date.now() / 1e3));
  const o = JSON.stringify(t),
    s = `${Qb(El(JSON.stringify({...n.header,alg:n.algorithm})))}.${Qb(El(o))}`;
  let i = "raw",
    a;
  typeof e == "object" ? (i = "jwk", a = e) : typeof e == "string" && e.startsWith("-----BEGIN") ? (i = "pkcs8", a = R4(e.replace(/-----BEGIN.*?-----/g, "").replace(/-----END.*?-----/g, "").replace(/\s/g, ""))) : a = El(e);
  const c = await crypto.subtle.importKey(i, a, r, !1, ["sign"]),
    l = await crypto.subtle.sign(r, c, El(s));
  return `${s}.${Qb(new Uint8Array(l))}`
}
Fi.sign = A4;
async function M4(t, e, n = {
  algorithm: "HS256",
  skipValidation: !1,
  throwError: !1
}) {
  if (typeof n == "string" && (n = {
      algorithm: n,
      throwError: !1
    }), n = {
      algorithm: "HS256",
      skipValidation: !1,
      throwError: !1,
      ...n
    }, typeof t != "string") throw new Error("token must be a string");
  if (typeof e != "string" && typeof e != "object") throw new Error("secret must be a string or a JWK object");
  if (typeof n.algorithm != "string") throw new Error("options.algorithm must be a string");
  const r = t.split(".");
  if (r.length !== 3) throw new Error("token must consist of 3 parts");
  const o = O4[n.algorithm];
  if (!o) throw new Error("algorithm not found");
  const {
    payload: s
  } = DE(t);
  if (!n.skipValidation && !s) {
    if (n.throwError) throw "PARSE_ERROR";
    return !1
  }
  if (!n.skipValidation && s.nbf && s.nbf > Math.floor(Date.now() / 1e3)) {
    if (n.throwError) throw "NOT_YET_VALID";
    return !1
  }
  if (!n.skipValidation && s.exp && s.exp <= Math.floor(Date.now() / 1e3)) {
    if (n.throwError) throw "EXPIRED";
    return !1
  }
  let i = "raw",
    a;
  typeof e == "object" ? (i = "jwk", a = e) : typeof e == "string" && e.startsWith("-----BEGIN") ? (i = "spki", a = R4(e.replace(/-----BEGIN.*?-----/g, "").replace(/-----END.*?-----/g, "").replace(/\s/g, ""))) : a = El(e);
  const c = await crypto.subtle.importKey(i, a, o, !1, ["verify"]);
  return await crypto.subtle.verify(o, c, I4(r[2]), El(`${r[0]}.${r[1]}`))
}
Fi.verify = M4;

function DE(t) {
  return {
    header: I$(t.split(".")[0].replace(/-/g, "+").replace(/_/g, "/")),
    payload: I$(t.split(".")[1].replace(/-/g, "+").replace(/_/g, "/"))
  }
}
Fi.decode = DE;
Fi.default = {
  sign: A4,
  verify: M4,
  decode: DE
};
const Xhe = t => {
  let e;
  return t ? e = t : typeof fetch > "u" ? e = (...n) => Ie(() => Promise.resolve().then(() => Bh), void 0).then(({
    default: r
  }) => r(...n)) : e = fetch, (...n) => e(...n)
};
class NE extends Error {
  constructor(e, n = "FunctionsError", r) {
    super(e), this.name = n, this.context = r
  }
}
class Zhe extends NE {
  constructor(e) {
    super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
  }
}
class Jhe extends NE {
  constructor(e) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
  }
}
class Qhe extends NE {
  constructor(e) {
    super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
  }
}
var epe = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
class tpe {
  constructor(e, {
    headers: n = {},
    customFetch: r
  } = {}) {
    this.url = e, this.headers = n, this.fetch = Xhe(r)
  }
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`
  }
  invoke(e, n = {}) {
    var r;
    return epe(this, void 0, void 0, function*() {
      try {
        const {
          headers: o,
          method: s,
          body: i
        } = n;
        let a = {},
          c;
        i && (o && !Object.prototype.hasOwnProperty.call(o, "Content-Type") || !o) && (typeof Blob < "u" && i instanceof Blob || i instanceof ArrayBuffer ? (a["Content-Type"] = "application/octet-stream", c = i) : typeof i == "string" ? (a["Content-Type"] = "text/plain", c = i) : typeof FormData < "u" && i instanceof FormData ? c = i : (a["Content-Type"] = "application/json", c = JSON.stringify(i)));
        const l = yield this.fetch(`${this.url}/${e}`, {
          method: s || "POST",
          headers: Object.assign(Object.assign(Object.assign({}, a), this.headers), o),
          body: c
        }).catch(h => {
          throw new Zhe(h)
        }), u = l.headers.get("x-relay-error");
        if (u && u === "true") throw new Jhe(l);
        if (!l.ok) throw new Qhe(l);
        let d = ((r = l.headers.get("Content-Type")) !== null && r !== void 0 ? r : "text/plain").split(";")[0].trim(),
          f;
        return d === "application/json" ? f = yield l.json(): d === "application/octet-stream" ? f = yield l.blob(): d === "multipart/form-data" ? f = yield l.formData(): f = yield l.text(), {
          data: f,
          error: null
        }
      } catch (o) {
        return {
          data: null,
          error: o
        }
      }
    })
  }
}
var j_ = {
  exports: {}
};
(function(t, e) {
  var n = function() {
      if (typeof self < "u") return self;
      if (typeof window < "u") return window;
      if (typeof hn < "u") return hn;
      throw new Error("unable to locate global object")
    },
    r = n();
  t.exports = e = r.fetch, r.fetch && (e.default = r.fetch.bind(r)), e.Headers = r.Headers, e.Request = r.Request, e.Response = r.Response
})(j_, j_.exports);
var LE = j_.exports;
const FE = co(LE),
  Bh = J$({
    __proto__: null,
    default: FE
  }, [LE]);
class npe {
  constructor(e) {
    this.shouldThrowOnError = !1, this.method = e.method, this.url = e.url, this.headers = e.headers, this.schema = e.schema, this.body = e.body, this.shouldThrowOnError = e.shouldThrowOnError, this.signal = e.signal, this.isMaybeSingle = e.isMaybeSingle, e.fetch ? this.fetch = e.fetch : typeof fetch > "u" ? this.fetch = FE : this.fetch = fetch
  }
  throwOnError() {
    return this.shouldThrowOnError = !0, this
  }
  then(e, n) {
    this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers["Accept-Profile"] = this.schema : this.headers["Content-Profile"] = this.schema), this.method !== "GET" && this.method !== "HEAD" && (this.headers["Content-Type"] = "application/json");
    const r = this.fetch;
    let o = r(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal
    }).then(async s => {
      var i, a, c;
      let l = null,
        u = null,
        d = null,
        f = s.status,
        h = s.statusText;
      if (s.ok) {
        if (this.method !== "HEAD") {
          const w = await s.text();
          w === "" || (this.headers.Accept === "text/csv" || this.headers.Accept && this.headers.Accept.includes("application/vnd.pgrst.plan+text") ? u = w : u = JSON.parse(w))
        }
        const p = (i = this.headers.Prefer) === null || i === void 0 ? void 0 : i.match(/count=(exact|planned|estimated)/),
          b = (a = s.headers.get("content-range")) === null || a === void 0 ? void 0 : a.split("/");
        p && b && b.length > 1 && (d = parseInt(b[1])), this.isMaybeSingle && this.method === "GET" && Array.isArray(u) && (u.length > 1 ? (l = {
          code: "PGRST116",
          details: `Results contain ${u.length} rows, application/vnd.pgrst.object+json requires 1 row`,
          hint: null,
          message: "JSON object requested, multiple (or no) rows returned"
        }, u = null, d = null, f = 406, h = "Not Acceptable") : u.length === 1 ? u = u[0] : u = null)
      } else {
        const p = await s.text();
        try {
          l = JSON.parse(p), Array.isArray(l) && s.status === 404 && (u = [], l = null, f = 200, h = "OK")
        } catch {
          s.status === 404 && p === "" ? (f = 204, h = "No Content") : l = {
            message: p
          }
        }
        if (l && this.isMaybeSingle && (!((c = l == null ? void 0 : l.details) === null || c === void 0) && c.includes("0 rows")) && (l = null, f = 200, h = "OK"), l && this.shouldThrowOnError) throw l
      }
      return {
        error: l,
        data: u,
        count: d,
        status: f,
        statusText: h
      }
    });
    return this.shouldThrowOnError || (o = o.catch(s => {
      var i, a, c;
      return {
        error: {
          message: `${(i=s==null?void 0:s.name)!==null&&i!==void 0?i:"FetchError"}: ${s==null?void 0:s.message}`,
          details: `${(a=s==null?void 0:s.stack)!==null&&a!==void 0?a:""}`,
          hint: "",
          code: `${(c=s==null?void 0:s.code)!==null&&c!==void 0?c:""}`
        },
        data: null,
        count: null,
        status: 0,
        statusText: ""
      }
    })), o.then(e, n)
  }
}
class rpe extends npe {
  select(e) {
    let n = !1;
    const r = (e ?? "*").split("").map(o => /\s/.test(o) && !n ? "" : (o === '"' && (n = !n), o)).join("");
    return this.url.searchParams.set("select", r), this.headers.Prefer && (this.headers.Prefer += ","), this.headers.Prefer += "return=representation", this
  }
  order(e, {
    ascending: n = !0,
    nullsFirst: r,
    foreignTable: o
  } = {}) {
    const s = o ? `${o}.order` : "order",
      i = this.url.searchParams.get(s);
    return this.url.searchParams.set(s, `${i?`${i},`:""}${e}.${n?"asc":"desc"}${r===void 0?"":r?".nullsfirst":".nullslast"}`), this
  }
  limit(e, {
    foreignTable: n
  } = {}) {
    const r = typeof n > "u" ? "limit" : `${n}.limit`;
    return this.url.searchParams.set(r, `${e}`), this
  }
  range(e, n, {
    foreignTable: r
  } = {}) {
    const o = typeof r > "u" ? "offset" : `${r}.offset`,
      s = typeof r > "u" ? "limit" : `${r}.limit`;
    return this.url.searchParams.set(o, `${e}`), this.url.searchParams.set(s, `${n-e+1}`), this
  }
  abortSignal(e) {
    return this.signal = e, this
  }
  single() {
    return this.headers.Accept = "application/vnd.pgrst.object+json", this
  }
  maybeSingle() {
    return this.method === "GET" ? this.headers.Accept = "application/json" : this.headers.Accept = "application/vnd.pgrst.object+json", this.isMaybeSingle = !0, this
  }
  csv() {
    return this.headers.Accept = "text/csv", this
  }
  geojson() {
    return this.headers.Accept = "application/geo+json", this
  }
  explain({
    analyze: e = !1,
    verbose: n = !1,
    settings: r = !1,
    buffers: o = !1,
    wal: s = !1,
    format: i = "text"
  } = {}) {
    const a = [e ? "analyze" : null, n ? "verbose" : null, r ? "settings" : null, o ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|"),
      c = this.headers.Accept;
    return this.headers.Accept = `application/vnd.pgrst.plan+${i}; for="${c}"; options=${a};`, i === "json" ? this : this
  }
  rollback() {
    var e;
    return ((e = this.headers.Prefer) !== null && e !== void 0 ? e : "").trim().length > 0 ? this.headers.Prefer += ",tx=rollback" : this.headers.Prefer = "tx=rollback", this
  }
  returns() {
    return this
  }
}
class Jc extends rpe {
  eq(e, n) {
    return this.url.searchParams.append(e, `eq.${n}`), this
  }
  neq(e, n) {
    return this.url.searchParams.append(e, `neq.${n}`), this
  }
  gt(e, n) {
    return this.url.searchParams.append(e, `gt.${n}`), this
  }
  gte(e, n) {
    return this.url.searchParams.append(e, `gte.${n}`), this
  }
  lt(e, n) {
    return this.url.searchParams.append(e, `lt.${n}`), this
  }
  lte(e, n) {
    return this.url.searchParams.append(e, `lte.${n}`), this
  }
  like(e, n) {
    return this.url.searchParams.append(e, `like.${n}`), this
  }
  likeAllOf(e, n) {
    return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`), this
  }
  likeAnyOf(e, n) {
    return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`), this
  }
  ilike(e, n) {
    return this.url.searchParams.append(e, `ilike.${n}`), this
  }
  ilikeAllOf(e, n) {
    return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`), this
  }
  ilikeAnyOf(e, n) {
    return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`), this
  }
  is(e, n) {
    return this.url.searchParams.append(e, `is.${n}`), this
  }
  in(e, n) {
    const r = n.map(o => typeof o == "string" && new RegExp("[,()]").test(o) ? `"${o}"` : `${o}`).join(",");
    return this.url.searchParams.append(e, `in.(${r})`), this
  }
  contains(e, n) {
    return typeof n == "string" ? this.url.searchParams.append(e, `cs.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`) : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`), this
  }
  containedBy(e, n) {
    return typeof n == "string" ? this.url.searchParams.append(e, `cd.${n}`) : Array.isArray(n) ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`) : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`), this
  }
  rangeGt(e, n) {
    return this.url.searchParams.append(e, `sr.${n}`), this
  }
  rangeGte(e, n) {
    return this.url.searchParams.append(e, `nxl.${n}`), this
  }
  rangeLt(e, n) {
    return this.url.searchParams.append(e, `sl.${n}`), this
  }
  rangeLte(e, n) {
    return this.url.searchParams.append(e, `nxr.${n}`), this
  }
  rangeAdjacent(e, n) {
    return this.url.searchParams.append(e, `adj.${n}`), this
  }
  overlaps(e, n) {
    return typeof n == "string" ? this.url.searchParams.append(e, `ov.${n}`) : this.url.searchParams.append(e, `ov.{${n.join(",")}}`), this
  }
  textSearch(e, n, {
    config: r,
    type: o
  } = {}) {
    let s = "";
    o === "plain" ? s = "pl" : o === "phrase" ? s = "ph" : o === "websearch" && (s = "w");
    const i = r === void 0 ? "" : `(${r})`;
    return this.url.searchParams.append(e, `${s}fts${i}.${n}`), this
  }
  match(e) {
    return Object.entries(e).forEach(([n, r]) => {
      this.url.searchParams.append(n, `eq.${r}`)
    }), this
  }
  not(e, n, r) {
    return this.url.searchParams.append(e, `not.${n}.${r}`), this
  }
  or(e, {
    foreignTable: n
  } = {}) {
    const r = n ? `${n}.or` : "or";
    return this.url.searchParams.append(r, `(${e})`), this
  }
  filter(e, n, r) {
    return this.url.searchParams.append(e, `${n}.${r}`), this
  }
}
class ope {
  constructor(e, {
    headers: n = {},
    schema: r,
    fetch: o
  }) {
    this.url = e, this.headers = n, this.schema = r, this.fetch = o
  }
  select(e, {
    head: n = !1,
    count: r
  } = {}) {
    const o = n ? "HEAD" : "GET";
    let s = !1;
    const i = (e ?? "*").split("").map(a => /\s/.test(a) && !s ? "" : (a === '"' && (s = !s), a)).join("");
    return this.url.searchParams.set("select", i), r && (this.headers.Prefer = `count=${r}`), new Jc({
      method: o,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
  insert(e, {
    count: n,
    defaultToNull: r = !0
  } = {}) {
    const o = "POST",
      s = [];
    if (this.headers.Prefer && s.push(this.headers.Prefer), n && s.push(`count=${n}`), r || s.push("missing=default"), this.headers.Prefer = s.join(","), Array.isArray(e)) {
      const i = e.reduce((a, c) => a.concat(Object.keys(c)), []);
      if (i.length > 0) {
        const a = [...new Set(i)].map(c => `"${c}"`);
        this.url.searchParams.set("columns", a.join(","))
      }
    }
    return new Jc({
      method: o,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: e,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
  upsert(e, {
    onConflict: n,
    ignoreDuplicates: r = !1,
    count: o,
    defaultToNull: s = !0
  } = {}) {
    const i = "POST",
      a = [`resolution=${r?"ignore":"merge"}-duplicates`];
    if (n !== void 0 && this.url.searchParams.set("on_conflict", n), this.headers.Prefer && a.push(this.headers.Prefer), o && a.push(`count=${o}`), s || a.push("missing=default"), this.headers.Prefer = a.join(","), Array.isArray(e)) {
      const c = e.reduce((l, u) => l.concat(Object.keys(u)), []);
      if (c.length > 0) {
        const l = [...new Set(c)].map(u => `"${u}"`);
        this.url.searchParams.set("columns", l.join(","))
      }
    }
    return new Jc({
      method: i,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: e,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
  update(e, {
    count: n
  } = {}) {
    const r = "PATCH",
      o = [];
    return this.headers.Prefer && o.push(this.headers.Prefer), n && o.push(`count=${n}`), this.headers.Prefer = o.join(","), new Jc({
      method: r,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: e,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
  delete({
    count: e
  } = {}) {
    const n = "DELETE",
      r = [];
    return e && r.push(`count=${e}`), this.headers.Prefer && r.unshift(this.headers.Prefer), this.headers.Prefer = r.join(","), new Jc({
      method: n,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
}
const spe = "1.8.5",
  ipe = {
    "X-Client-Info": `postgrest-js/${spe}`
  };
class BE {
  constructor(e, {
    headers: n = {},
    schema: r,
    fetch: o
  } = {}) {
    this.url = e, this.headers = Object.assign(Object.assign({}, ipe), n), this.schemaName = r, this.fetch = o
  }
  from(e) {
    const n = new URL(`${this.url}/${e}`);
    return new ope(n, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch
    })
  }
  schema(e) {
    return new BE(this.url, {
      headers: this.headers,
      schema: e,
      fetch: this.fetch
    })
  }
  rpc(e, n = {}, {
    head: r = !1,
    count: o
  } = {}) {
    let s;
    const i = new URL(`${this.url}/rpc/${e}`);
    let a;
    r ? (s = "HEAD", Object.entries(n).forEach(([l, u]) => {
      i.searchParams.append(l, `${u}`)
    })) : (s = "POST", a = n);
    const c = Object.assign({}, this.headers);
    return o && (c.Prefer = `count=${o}`), new Jc({
      method: s,
      url: i,
      headers: c,
      schema: this.schemaName,
      body: a,
      fetch: this.fetch,
      allowEmpty: !1
    })
  }
}
var ew, O$;

function ape() {
  if (O$) return ew;
  O$ = 1;
  var t = function() {
    if (typeof self == "object" && self) return self;
    if (typeof window == "object" && window) return window;
    throw new Error("Unable to resolve global `this`")
  };
  return ew = function() {
    if (this) return this;
    if (typeof globalThis == "object" && globalThis) return globalThis;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this
        },
        configurable: !0
      })
    } catch {
      return t()
    }
    try {
      return __global__ || t()
    } finally {
      delete Object.prototype.__global__
    }
  }(), ew
}
const cpe = "websocket",
  lpe = "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
  upe = ["websocket", "websockets", "socket", "networking", "comet", "push", "RFC-6455", "realtime", "server", "client"],
  dpe = "Brian McKelvey <theturtle32@gmail.com> (https://github.com/theturtle32)",
  fpe = ["Iaki Baz Castillo <ibc@aliax.net> (http://dev.sipdoc.net)"],
  hpe = "1.0.34",
  ppe = {
    type: "git",
    url: "https://github.com/theturtle32/WebSocket-Node.git"
  },
  gpe = "https://github.com/theturtle32/WebSocket-Node",
  mpe = {
    node: ">=4.0.0"
  },
  ype = {
    bufferutil: "^4.0.1",
    debug: "^2.2.0",
    "es5-ext": "^0.10.50",
    "typedarray-to-buffer": "^3.1.5",
    "utf-8-validate": "^5.0.2",
    yaeti: "^0.0.6"
  },
  vpe = {
    "buffer-equal": "^1.0.0",
    gulp: "^4.0.2",
    "gulp-jshint": "^2.0.4",
    "jshint-stylish": "^2.2.1",
    jshint: "^2.0.0",
    tape: "^4.9.1"
  },
  bpe = {
    verbose: !1
  },
  wpe = {
    test: "tape test/unit/*.js",
    gulp: "gulp"
  },
  Spe = "index",
  _pe = {
    lib: "./lib"
  },
  xpe = "lib/browser.js",
  Epe = "Apache-2.0",
  kpe = {
    name: cpe,
    description: lpe,
    keywords: upe,
    author: dpe,
    contributors: fpe,
    version: hpe,
    repository: ppe,
    homepage: gpe,
    engines: mpe,
    dependencies: ype,
    devDependencies: vpe,
    config: bpe,
    scripts: wpe,
    main: Spe,
    directories: _pe,
    browser: xpe,
    license: Epe
  };
var Cpe = kpe.version,
  xa;
if (typeof globalThis == "object") xa = globalThis;
else try {
  xa = ape()
} catch {} finally {
  if (!xa && typeof window < "u" && (xa = window), !xa) throw new Error("Could not determine global this")
}
var Gf = xa.WebSocket || xa.MozWebSocket,
  Ppe = Cpe;

function j4(t, e) {
  var n;
  return e ? n = new Gf(t, e) : n = new Gf(t), n
}
Gf && ["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function(t) {
  Object.defineProperty(j4, t, {
    get: function() {
      return Gf[t]
    }
  })
});
var Tpe = {
  w3cwebsocket: Gf ? j4 : null,
  version: Ppe
};
const $pe = "2.8.1",
  Ipe = {
    "X-Client-Info": `realtime-js/${$pe}`
  },
  Ope = "1.0.0",
  D4 = 1e4,
  Rpe = 1e3;
var Qd;
(function(t) {
  t[t.connecting = 0] = "connecting", t[t.open = 1] = "open", t[t.closing = 2] = "closing", t[t.closed = 3] = "closed"
})(Qd || (Qd = {}));
var Rr;
(function(t) {
  t.closed = "closed", t.errored = "errored", t.joined = "joined", t.joining = "joining", t.leaving = "leaving"
})(Rr || (Rr = {}));
var _o;
(function(t) {
  t.close = "phx_close", t.error = "phx_error", t.join = "phx_join", t.reply = "phx_reply", t.leave = "phx_leave", t.access_token = "access_token"
})(_o || (_o = {}));
var D_;
(function(t) {
  t.websocket = "websocket"
})(D_ || (D_ = {}));
var Ea;
(function(t) {
  t.Connecting = "connecting", t.Open = "open", t.Closing = "closing", t.Closed = "closed"
})(Ea || (Ea = {}));
class N4 {
  constructor(e, n) {
    this.callback = e, this.timerCalc = n, this.timer = void 0, this.tries = 0, this.callback = e, this.timerCalc = n
  }
  reset() {
    this.tries = 0, clearTimeout(this.timer)
  }
  scheduleTimeout() {
    clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.tries = this.tries + 1, this.callback()
    }, this.timerCalc(this.tries + 1))
  }
}
class Ape {
  constructor() {
    this.HEADER_LENGTH = 1
  }
  decode(e, n) {
    return e.constructor === ArrayBuffer ? n(this._binaryDecode(e)) : n(typeof e == "string" ? JSON.parse(e) : {})
  }
  _binaryDecode(e) {
    const n = new DataView(e),
      r = new TextDecoder;
    return this._decodeBroadcast(e, n, r)
  }
  _decodeBroadcast(e, n, r) {
    const o = n.getUint8(1),
      s = n.getUint8(2);
    let i = this.HEADER_LENGTH + 2;
    const a = r.decode(e.slice(i, i + o));
    i = i + o;
    const c = r.decode(e.slice(i, i + s));
    i = i + s;
    const l = JSON.parse(r.decode(e.slice(i, e.byteLength)));
    return {
      ref: null,
      topic: a,
      event: c,
      payload: l
    }
  }
}
class tw {
  constructor(e, n, r = {}, o = D4) {
    this.channel = e, this.event = n, this.payload = r, this.timeout = o, this.sent = !1, this.timeoutTimer = void 0, this.ref = "", this.receivedResp = null, this.recHooks = [], this.refEvent = null, this.rateLimited = !1
  }
  resend(e) {
    this.timeout = e, this._cancelRefEvent(), this.ref = "", this.refEvent = null, this.receivedResp = null, this.sent = !1, this.send()
  }
  send() {
    if (this._hasReceived("timeout")) return;
    this.startTimeout(), this.sent = !0, this.channel.socket.push({
      topic: this.channel.topic,
      event: this.event,
      payload: this.payload,
      ref: this.ref,
      join_ref: this.channel._joinRef()
    }) === "rate limited" && (this.rateLimited = !0)
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e)
  }
  receive(e, n) {
    var r;
    return this._hasReceived(e) && n((r = this.receivedResp) === null || r === void 0 ? void 0 : r.response), this.recHooks.push({
      status: e,
      callback: n
    }), this
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    this.ref = this.channel.socket._makeRef(), this.refEvent = this.channel._replyEventName(this.ref);
    const e = n => {
      this._cancelRefEvent(), this._cancelTimeout(), this.receivedResp = n, this._matchReceive(n)
    };
    this.channel._on(this.refEvent, {}, e), this.timeoutTimer = setTimeout(() => {
      this.trigger("timeout", {})
    }, this.timeout)
  }
  trigger(e, n) {
    this.refEvent && this.channel._trigger(this.refEvent, {
      status: e,
      response: n
    })
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout()
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {})
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), this.timeoutTimer = void 0
  }
  _matchReceive({
    status: e,
    response: n
  }) {
    this.recHooks.filter(r => r.status === e).forEach(r => r.callback(n))
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e
  }
}
var R$;
(function(t) {
  t.SYNC = "sync", t.JOIN = "join", t.LEAVE = "leave"
})(R$ || (R$ = {}));
class ef {
  constructor(e, n) {
    this.channel = e, this.state = {}, this.pendingDiffs = [], this.joinRef = null, this.caller = {
      onJoin: () => {},
      onLeave: () => {},
      onSync: () => {}
    };
    const r = (n == null ? void 0 : n.events) || {
      state: "presence_state",
      diff: "presence_diff"
    };
    this.channel._on(r.state, {}, o => {
      const {
        onJoin: s,
        onLeave: i,
        onSync: a
      } = this.caller;
      this.joinRef = this.channel._joinRef(), this.state = ef.syncState(this.state, o, s, i), this.pendingDiffs.forEach(c => {
        this.state = ef.syncDiff(this.state, c, s, i)
      }), this.pendingDiffs = [], a()
    }), this.channel._on(r.diff, {}, o => {
      const {
        onJoin: s,
        onLeave: i,
        onSync: a
      } = this.caller;
      this.inPendingSyncState() ? this.pendingDiffs.push(o) : (this.state = ef.syncDiff(this.state, o, s, i), a())
    }), this.onJoin((o, s, i) => {
      this.channel._trigger("presence", {
        event: "join",
        key: o,
        currentPresences: s,
        newPresences: i
      })
    }), this.onLeave((o, s, i) => {
      this.channel._trigger("presence", {
        event: "leave",
        key: o,
        currentPresences: s,
        leftPresences: i
      })
    }), this.onSync(() => {
      this.channel._trigger("presence", {
        event: "sync"
      })
    })
  }
  static syncState(e, n, r, o) {
    const s = this.cloneDeep(e),
      i = this.transformState(n),
      a = {},
      c = {};
    return this.map(s, (l, u) => {
      i[l] || (c[l] = u)
    }), this.map(i, (l, u) => {
      const d = s[l];
      if (d) {
        const f = u.map(b => b.presence_ref),
          h = d.map(b => b.presence_ref),
          m = u.filter(b => h.indexOf(b.presence_ref) < 0),
          p = d.filter(b => f.indexOf(b.presence_ref) < 0);
        m.length > 0 && (a[l] = m), p.length > 0 && (c[l] = p)
      } else a[l] = u
    }), this.syncDiff(s, {
      joins: a,
      leaves: c
    }, r, o)
  }
  static syncDiff(e, n, r, o) {
    const {
      joins: s,
      leaves: i
    } = {
      joins: this.transformState(n.joins),
      leaves: this.transformState(n.leaves)
    };
    return r || (r = () => {}), o || (o = () => {}), this.map(s, (a, c) => {
      var l;
      const u = (l = e[a]) !== null && l !== void 0 ? l : [];
      if (e[a] = this.cloneDeep(c), u.length > 0) {
        const d = e[a].map(h => h.presence_ref),
          f = u.filter(h => d.indexOf(h.presence_ref) < 0);
        e[a].unshift(...f)
      }
      r(a, u, c)
    }), this.map(i, (a, c) => {
      let l = e[a];
      if (!l) return;
      const u = c.map(d => d.presence_ref);
      l = l.filter(d => u.indexOf(d.presence_ref) < 0), e[a] = l, o(a, l, c), l.length === 0 && delete e[a]
    }), e
  }
  static map(e, n) {
    return Object.getOwnPropertyNames(e).map(r => n(r, e[r]))
  }
  static transformState(e) {
    return e = this.cloneDeep(e), Object.getOwnPropertyNames(e).reduce((n, r) => {
      const o = e[r];
      return "metas" in o ? n[r] = o.metas.map(s => (s.presence_ref = s.phx_ref, delete s.phx_ref, delete s.phx_ref_prev, s)) : n[r] = o, n
    }, {})
  }
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e))
  }
  onJoin(e) {
    this.caller.onJoin = e
  }
  onLeave(e) {
    this.caller.onLeave = e
  }
  onSync(e) {
    this.caller.onSync = e
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef()
  }
}
var Et;
(function(t) {
  t.abstime = "abstime", t.bool = "bool", t.date = "date", t.daterange = "daterange", t.float4 = "float4", t.float8 = "float8", t.int2 = "int2", t.int4 = "int4", t.int4range = "int4range", t.int8 = "int8", t.int8range = "int8range", t.json = "json", t.jsonb = "jsonb", t.money = "money", t.numeric = "numeric", t.oid = "oid", t.reltime = "reltime", t.text = "text", t.time = "time", t.timestamp = "timestamp", t.timestamptz = "timestamptz", t.timetz = "timetz", t.tsrange = "tsrange", t.tstzrange = "tstzrange"
})(Et || (Et = {}));
const A$ = (t, e, n = {}) => {
    var r;
    const o = (r = n.skipTypes) !== null && r !== void 0 ? r : [];
    return Object.keys(e).reduce((s, i) => (s[i] = Mpe(i, t, e, o), s), {})
  },
  Mpe = (t, e, n, r) => {
    const o = e.find(a => a.name === t),
      s = o == null ? void 0 : o.type,
      i = n[t];
    return s && !r.includes(s) ? L4(s, i) : N_(i)
  },
  L4 = (t, e) => {
    if (t.charAt(0) === "_") {
      const n = t.slice(1, t.length);
      return Lpe(e, n)
    }
    switch (t) {
      case Et.bool:
        return jpe(e);
      case Et.float4:
      case Et.float8:
      case Et.int2:
      case Et.int4:
      case Et.int8:
      case Et.numeric:
      case Et.oid:
        return Dpe(e);
      case Et.json:
      case Et.jsonb:
        return Npe(e);
      case Et.timestamp:
        return Fpe(e);
      case Et.abstime:
      case Et.date:
      case Et.daterange:
      case Et.int4range:
      case Et.int8range:
      case Et.money:
      case Et.reltime:
      case Et.text:
      case Et.time:
      case Et.timestamptz:
      case Et.timetz:
      case Et.tsrange:
      case Et.tstzrange:
        return N_(e);
      default:
        return N_(e)
    }
  },
  N_ = t => t,
  jpe = t => {
    switch (t) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return t
    }
  },
  Dpe = t => {
    if (typeof t == "string") {
      const e = parseFloat(t);
      if (!Number.isNaN(e)) return e
    }
    return t
  },
  Npe = t => {
    if (typeof t == "string") try {
      return JSON.parse(t)
    } catch (e) {
      return console.log(`JSON parse error: ${e}`), t
    }
    return t
  },
  Lpe = (t, e) => {
    if (typeof t != "string") return t;
    const n = t.length - 1,
      r = t[n];
    if (t[0] === "{" && r === "}") {
      let s;
      const i = t.slice(1, n);
      try {
        s = JSON.parse("[" + i + "]")
      } catch {
        s = i ? i.split(",") : []
      }
      return s.map(a => L4(e, a))
    }
    return t
  },
  Fpe = t => typeof t == "string" ? t.replace(" ", "T") : t;
var M$;
(function(t) {
  t.ALL = "*", t.INSERT = "INSERT", t.UPDATE = "UPDATE", t.DELETE = "DELETE"
})(M$ || (M$ = {}));
var j$;
(function(t) {
  t.BROADCAST = "broadcast", t.PRESENCE = "presence", t.POSTGRES_CHANGES = "postgres_changes"
})(j$ || (j$ = {}));
var D$;
(function(t) {
  t.SUBSCRIBED = "SUBSCRIBED", t.TIMED_OUT = "TIMED_OUT", t.CLOSED = "CLOSED", t.CHANNEL_ERROR = "CHANNEL_ERROR"
})(D$ || (D$ = {}));
class UE {
  constructor(e, n = {
    config: {}
  }, r) {
    this.topic = e, this.params = n, this.socket = r, this.bindings = {}, this.state = Rr.closed, this.joinedOnce = !1, this.pushBuffer = [], this.subTopic = e.replace(/^realtime:/i, ""), this.params.config = Object.assign({
      broadcast: {
        ack: !1,
        self: !1
      },
      presence: {
        key: ""
      }
    }, n.config), this.timeout = this.socket.timeout, this.joinPush = new tw(this, _o.join, this.params, this.timeout), this.rejoinTimer = new N4(() => this._rejoinUntilConnected(), this.socket.reconnectAfterMs), this.joinPush.receive("ok", () => {
      this.state = Rr.joined, this.rejoinTimer.reset(), this.pushBuffer.forEach(o => o.send()), this.pushBuffer = []
    }), this._onClose(() => {
      this.rejoinTimer.reset(), this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`), this.state = Rr.closed, this.socket._remove(this)
    }), this._onError(o => {
      this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o), this.state = Rr.errored, this.rejoinTimer.scheduleTimeout())
    }), this.joinPush.receive("timeout", () => {
      this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout), this.state = Rr.errored, this.rejoinTimer.scheduleTimeout())
    }), this._on(_o.reply, {}, (o, s) => {
      this._trigger(this._replyEventName(s), o)
    }), this.presence = new ef(this), this.broadcastEndpointURL = this._broadcastEndpointURL()
  }
  subscribe(e, n = this.timeout) {
    var r, o;
    if (this.socket.isConnected() || this.socket.connect(), this.joinedOnce) throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
    {
      const {
        config: {
          broadcast: s,
          presence: i
        }
      } = this.params;
      this._onError(l => e && e("CHANNEL_ERROR", l)), this._onClose(() => e && e("CLOSED"));
      const a = {},
        c = {
          broadcast: s,
          presence: i,
          postgres_changes: (o = (r = this.bindings.postgres_changes) === null || r === void 0 ? void 0 : r.map(l => l.filter)) !== null && o !== void 0 ? o : []
        };
      this.socket.accessToken && (a.access_token = this.socket.accessToken), this.updateJoinPayload(Object.assign({
        config: c
      }, a)), this.joinedOnce = !0, this._rejoin(n), this.joinPush.receive("ok", ({
        postgres_changes: l
      }) => {
        var u;
        if (this.socket.accessToken && this.socket.setAuth(this.socket.accessToken), l === void 0) {
          e && e("SUBSCRIBED");
          return
        } else {
          const d = this.bindings.postgres_changes,
            f = (u = d == null ? void 0 : d.length) !== null && u !== void 0 ? u : 0,
            h = [];
          for (let m = 0; m < f; m++) {
            const p = d[m],
              {
                filter: {
                  event: b,
                  schema: w,
                  table: v,
                  filter: _
                }
              } = p,
              S = l && l[m];
            if (S && S.event === b && S.schema === w && S.table === v && S.filter === _) h.push(Object.assign(Object.assign({}, p), {
              id: S.id
            }));
            else {
              this.unsubscribe(), e && e("CHANNEL_ERROR", new Error("mismatch between server and client bindings for postgres changes"));
              return
            }
          }
          this.bindings.postgres_changes = h, e && e("SUBSCRIBED");
          return
        }
      }).receive("error", l => {
        e && e("CHANNEL_ERROR", new Error(JSON.stringify(Object.values(l).join(", ") || "error")))
      }).receive("timeout", () => {
        e && e("TIMED_OUT")
      })
    }
    return this
  }
  presenceState() {
    return this.presence.state
  }
  async track(e, n = {}) {
    return await this.send({
      type: "presence",
      event: "track",
      payload: e
    }, n.timeout || this.timeout)
  }
  async untrack(e = {}) {
    return await this.send({
      type: "presence",
      event: "untrack"
    }, e)
  }
  on(e, n, r) {
    return this._on(e, n, r)
  }
  async send(e, n = {}) {
    var r, o;
    if (!this._canPush() && e.type === "broadcast") {
      const {
        event: s,
        payload: i
      } = e, a = {
        method: "POST",
        headers: {
          apikey: (r = this.socket.accessToken) !== null && r !== void 0 ? r : "",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [{
            topic: this.subTopic,
            event: s,
            payload: i
          }]
        })
      };
      try {
        return (await this._fetchWithTimeout(this.broadcastEndpointURL, a, (o = n.timeout) !== null && o !== void 0 ? o : this.timeout)).ok ? "ok" : "error"
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error"
      }
    } else return new Promise(s => {
      var i, a, c;
      const l = this._push(e.type, e, n.timeout || this.timeout);
      l.rateLimited && s("rate limited"), e.type === "broadcast" && !(!((c = (a = (i = this.params) === null || i === void 0 ? void 0 : i.config) === null || a === void 0 ? void 0 : a.broadcast) === null || c === void 0) && c.ack) && s("ok"), l.receive("ok", () => s("ok")), l.receive("timeout", () => s("timed out"))
    })
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e)
  }
  unsubscribe(e = this.timeout) {
    this.state = Rr.leaving;
    const n = () => {
      this.socket.log("channel", `leave ${this.topic}`), this._trigger(_o.close, "leave", this._joinRef())
    };
    return this.rejoinTimer.reset(), this.joinPush.destroy(), new Promise(r => {
      const o = new tw(this, _o.leave, {}, e);
      o.receive("ok", () => {
        n(), r("ok")
      }).receive("timeout", () => {
        n(), r("timed out")
      }).receive("error", () => {
        r("error")
      }), o.send(), this._canPush() || o.trigger("ok", {})
    })
  }
  _broadcastEndpointURL() {
    let e = this.socket.endPoint;
    return e = e.replace(/^ws/i, "http"), e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, ""), e.replace(/\/+$/, "") + "/api/broadcast"
  }
  async _fetchWithTimeout(e, n, r) {
    const o = new AbortController,
      s = setTimeout(() => o.abort(), r),
      i = await this.socket.fetch(e, Object.assign(Object.assign({}, n), {
        signal: o.signal
      }));
    return clearTimeout(s), i
  }
  _push(e, n, r = this.timeout) {
    if (!this.joinedOnce) throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let o = new tw(this, e, n, r);
    return this._canPush() ? o.send() : (o.startTimeout(), this.pushBuffer.push(o)), o
  }
  _onMessage(e, n, r) {
    return n
  }
  _isMember(e) {
    return this.topic === e
  }
  _joinRef() {
    return this.joinPush.ref
  }
  _trigger(e, n, r) {
    var o, s;
    const i = e.toLocaleLowerCase(),
      {
        close: a,
        error: c,
        leave: l,
        join: u
      } = _o;
    if (r && [a, c, l, u].indexOf(i) >= 0 && r !== this._joinRef()) return;
    let f = this._onMessage(i, n, r);
    if (n && !f) throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(i) ? (o = this.bindings.postgres_changes) === null || o === void 0 || o.filter(h => {
      var m, p, b;
      return ((m = h.filter) === null || m === void 0 ? void 0 : m.event) === "*" || ((b = (p = h.filter) === null || p === void 0 ? void 0 : p.event) === null || b === void 0 ? void 0 : b.toLocaleLowerCase()) === i
    }).map(h => h.callback(f, r)) : (s = this.bindings[i]) === null || s === void 0 || s.filter(h => {
      var m, p, b, w, v, _;
      if (["broadcast", "presence", "postgres_changes"].includes(i))
        if ("id" in h) {
          const S = h.id,
            x = (m = h.filter) === null || m === void 0 ? void 0 : m.event;
          return S && ((p = n.ids) === null || p === void 0 ? void 0 : p.includes(S)) && (x === "*" || (x == null ? void 0 : x.toLocaleLowerCase()) === ((b = n.data) === null || b === void 0 ? void 0 : b.type.toLocaleLowerCase()))
        } else {
          const S = (v = (w = h == null ? void 0 : h.filter) === null || w === void 0 ? void 0 : w.event) === null || v === void 0 ? void 0 : v.toLocaleLowerCase();
          return S === "*" || S === ((_ = n == null ? void 0 : n.event) === null || _ === void 0 ? void 0 : _.toLocaleLowerCase())
        }
      else return h.type.toLocaleLowerCase() === i
    }).map(h => {
      if (typeof f == "object" && "ids" in f) {
        const m = f.data,
          {
            schema: p,
            table: b,
            commit_timestamp: w,
            type: v,
            errors: _
          } = m;
        f = Object.assign(Object.assign({}, {
          schema: p,
          table: b,
          commit_timestamp: w,
          eventType: v,
          new: {},
          old: {},
          errors: _
        }), this._getPayloadRecords(m))
      }
      h.callback(f, r)
    })
  }
  _isClosed() {
    return this.state === Rr.closed
  }
  _isJoined() {
    return this.state === Rr.joined
  }
  _isJoining() {
    return this.state === Rr.joining
  }
  _isLeaving() {
    return this.state === Rr.leaving
  }
  _replyEventName(e) {
    return `chan_reply_${e}`
  }
  _on(e, n, r) {
    const o = e.toLocaleLowerCase(),
      s = {
        type: o,
        filter: n,
        callback: r
      };
    return this.bindings[o] ? this.bindings[o].push(s) : this.bindings[o] = [s], this
  }
  _off(e, n) {
    const r = e.toLocaleLowerCase();
    return this.bindings[r] = this.bindings[r].filter(o => {
      var s;
      return !(((s = o.type) === null || s === void 0 ? void 0 : s.toLocaleLowerCase()) === r && UE.isEqual(o.filter, n))
    }), this
  }
  static isEqual(e, n) {
    if (Object.keys(e).length !== Object.keys(n).length) return !1;
    for (const r in e)
      if (e[r] !== n[r]) return !1;
    return !0
  }
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(), this.socket.isConnected() && this._rejoin()
  }
  _onClose(e) {
    this._on(_o.close, {}, e)
  }
  _onError(e) {
    this._on(_o.error, {}, n => e(n))
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined()
  }
  _rejoin(e = this.timeout) {
    this._isLeaving() || (this.socket._leaveOpenTopic(this.topic), this.state = Rr.joining, this.joinPush.resend(e))
  }
  _getPayloadRecords(e) {
    const n = {
      new: {},
      old: {}
    };
    return (e.type === "INSERT" || e.type === "UPDATE") && (n.new = A$(e.columns, e.record)), (e.type === "UPDATE" || e.type === "DELETE") && (n.old = A$(e.columns, e.old_record)), n
  }
}
const Bpe = () => {};
class Upe {
  constructor(e, n) {
    var r, o;
    this.accessToken = null, this.channels = [], this.endPoint = "", this.headers = Ipe, this.params = {}, this.timeout = D4, this.transport = Tpe.w3cwebsocket, this.heartbeatIntervalMs = 3e4, this.heartbeatTimer = void 0, this.pendingHeartbeatRef = null, this.ref = 0, this.logger = Bpe, this.conn = null, this.sendBuffer = [], this.serializer = new Ape, this.stateChangeCallbacks = {
      open: [],
      close: [],
      error: [],
      message: []
    }, this.eventsPerSecondLimitMs = 100, this.inThrottle = !1, this._resolveFetch = a => {
      let c;
      return a ? c = a : typeof fetch > "u" ? c = (...l) => Ie(() => Promise.resolve().then(() => Bh), void 0).then(({
        default: u
      }) => u(...l)) : c = fetch, (...l) => c(...l)
    }, this.endPoint = `${e}/${D_.websocket}`, n != null && n.params && (this.params = n.params), n != null && n.headers && (this.headers = Object.assign(Object.assign({}, this.headers), n.headers)), n != null && n.timeout && (this.timeout = n.timeout), n != null && n.logger && (this.logger = n.logger), n != null && n.transport && (this.transport = n.transport), n != null && n.heartbeatIntervalMs && (this.heartbeatIntervalMs = n.heartbeatIntervalMs);
    const s = (r = n == null ? void 0 : n.params) === null || r === void 0 ? void 0 : r.eventsPerSecond;
    s && (this.eventsPerSecondLimitMs = Math.floor(1e3 / s));
    const i = (o = n == null ? void 0 : n.params) === null || o === void 0 ? void 0 : o.apikey;
    i && (this.accessToken = i), this.reconnectAfterMs = n != null && n.reconnectAfterMs ? n.reconnectAfterMs : a => [1e3, 2e3, 5e3, 1e4][a - 1] || 1e4, this.encode = n != null && n.encode ? n.encode : (a, c) => c(JSON.stringify(a)), this.decode = n != null && n.decode ? n.decode : this.serializer.decode.bind(this.serializer), this.reconnectTimer = new N4(async () => {
      this.disconnect(), this.connect()
    }, this.reconnectAfterMs), this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch)
  }
  connect() {
    this.conn || (this.conn = new this.transport(this._endPointURL(), [], null, this.headers), this.conn && (this.conn.binaryType = "arraybuffer", this.conn.onopen = () => this._onConnOpen(), this.conn.onerror = e => this._onConnError(e), this.conn.onmessage = e => this._onConnMessage(e), this.conn.onclose = e => this._onConnClose(e)))
  }
  disconnect(e, n) {
    this.conn && (this.conn.onclose = function() {}, e ? this.conn.close(e, n ?? "") : this.conn.close(), this.conn = null, this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.reset())
  }
  getChannels() {
    return this.channels
  }
  async removeChannel(e) {
    const n = await e.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), n
  }
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map(n => n.unsubscribe()));
    return this.disconnect(), e
  }
  log(e, n, r) {
    this.logger(e, n, r)
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case Qd.connecting:
        return Ea.Connecting;
      case Qd.open:
        return Ea.Open;
      case Qd.closing:
        return Ea.Closing;
      default:
        return Ea.Closed
    }
  }
  isConnected() {
    return this.connectionState() === Ea.Open
  }
  channel(e, n = {
    config: {}
  }) {
    const r = new UE(`realtime:${e}`, n, this);
    return this.channels.push(r), r
  }
  push(e) {
    const {
      topic: n,
      event: r,
      payload: o,
      ref: s
    } = e;
    let i = () => {
      this.encode(e, a => {
        var c;
        (c = this.conn) === null || c === void 0 || c.send(a)
      })
    };
    if (this.log("push", `${n} ${r} (${s})`, o), this.isConnected())
      if (["broadcast", "presence", "postgres_changes"].includes(r)) {
        if (this._throttle(i)()) return "rate limited"
      } else i();
    else this.sendBuffer.push(i)
  }
  setAuth(e) {
    this.accessToken = e, this.channels.forEach(n => {
      e && n.updateJoinPayload({
        access_token: e
      }), n.joinedOnce && n._isJoined() && n._push(_o.access_token, {
        access_token: e
      })
    })
  }
  _makeRef() {
    let e = this.ref + 1;
    return e === this.ref ? this.ref = 0 : this.ref = e, this.ref.toString()
  }
  _leaveOpenTopic(e) {
    let n = this.channels.find(r => r.topic === e && (r._isJoined() || r._isJoining()));
    n && (this.log("transport", `leaving duplicate topic "${e}"`), n.unsubscribe())
  }
  _remove(e) {
    this.channels = this.channels.filter(n => n._joinRef() !== e._joinRef())
  }
  _endPointURL() {
    return this._appendParams(this.endPoint, Object.assign({}, this.params, {
      vsn: Ope
    }))
  }
  _onConnMessage(e) {
    this.decode(e.data, n => {
      let {
        topic: r,
        event: o,
        payload: s,
        ref: i
      } = n;
      (i && i === this.pendingHeartbeatRef || o === (s == null ? void 0 : s.type)) && (this.pendingHeartbeatRef = null), this.log("receive", `${s.status||""} ${r} ${o} ${i&&"("+i+")"||""}`, s), this.channels.filter(a => a._isMember(r)).forEach(a => a._trigger(o, s, i)), this.stateChangeCallbacks.message.forEach(a => a(n))
    })
  }
  _onConnOpen() {
    this.log("transport", `connected to ${this._endPointURL()}`), this._flushSendBuffer(), this.reconnectTimer.reset(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.heartbeatTimer = setInterval(() => this._sendHeartbeat(), this.heartbeatIntervalMs), this.stateChangeCallbacks.open.forEach(e => e())
  }
  _onConnClose(e) {
    this.log("transport", "close", e), this._triggerChanError(), this.heartbeatTimer && clearInterval(this.heartbeatTimer), this.reconnectTimer.scheduleTimeout(), this.stateChangeCallbacks.close.forEach(n => n(e))
  }
  _onConnError(e) {
    this.log("transport", e.message), this._triggerChanError(), this.stateChangeCallbacks.error.forEach(n => n(e))
  }
  _triggerChanError() {
    this.channels.forEach(e => e._trigger(_o.error))
  }
  _appendParams(e, n) {
    if (Object.keys(n).length === 0) return e;
    const r = e.match(/\?/) ? "&" : "?",
      o = new URLSearchParams(n);
    return `${e}${r}${o}`
  }
  _flushSendBuffer() {
    this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()), this.sendBuffer = [])
  }
  _sendHeartbeat() {
    var e;
    if (this.isConnected()) {
      if (this.pendingHeartbeatRef) {
        this.pendingHeartbeatRef = null, this.log("transport", "heartbeat timeout. Attempting to re-establish connection"), (e = this.conn) === null || e === void 0 || e.close(Rpe, "hearbeat timeout");
        return
      }
      this.pendingHeartbeatRef = this._makeRef(), this.push({
        topic: "phoenix",
        event: "heartbeat",
        payload: {},
        ref: this.pendingHeartbeatRef
      }), this.setAuth(this.accessToken)
    }
  }
  _throttle(e, n = this.eventsPerSecondLimitMs) {
    return () => this.inThrottle ? !0 : (e(), n > 0 && (this.inThrottle = !0, setTimeout(() => {
      this.inThrottle = !1
    }, n)), !1)
  }
}
class zE extends Error {
  constructor(e) {
    super(e), this.__isStorageError = !0, this.name = "StorageError"
  }
}

function Ln(t) {
  return typeof t == "object" && t !== null && "__isStorageError" in t
}
class zpe extends zE {
  constructor(e, n) {
    super(e), this.name = "StorageApiError", this.status = n
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    }
  }
}
class N$ extends zE {
  constructor(e, n) {
    super(e), this.name = "StorageUnknownError", this.originalError = n
  }
}
var Hpe = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
const F4 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => Ie(() => Promise.resolve().then(() => Bh), void 0).then(({
      default: r
    }) => r(...n)) : e = fetch, (...n) => e(...n)
  },
  Vpe = () => Hpe(void 0, void 0, void 0, function*() {
    return typeof Response > "u" ? (yield Ie(() => Promise.resolve().then(() => Bh), void 0)).Response : Response
  });
var Mu = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
const nw = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t),
  Wpe = (t, e) => Mu(void 0, void 0, void 0, function*() {
    const n = yield Vpe();
    t instanceof n ? t.json().then(r => {
      e(new zpe(nw(r), t.status || 500))
    }).catch(r => {
      e(new N$(nw(r), r))
    }) : e(new N$(nw(t), t))
  }),
  Kpe = (t, e, n, r) => {
    const o = {
      method: t,
      headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? o : (o.headers = Object.assign({
      "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers), o.body = JSON.stringify(r), Object.assign(Object.assign({}, o), n))
  };

function zv(t, e, n, r, o, s) {
  return Mu(this, void 0, void 0, function*() {
    return new Promise((i, a) => {
      t(n, Kpe(e, r, o, s)).then(c => {
        if (!c.ok) throw c;
        return r != null && r.noResolveJson ? c : c.json()
      }).then(c => i(c)).catch(c => Wpe(c, a))
    })
  })
}

function L_(t, e, n, r) {
  return Mu(this, void 0, void 0, function*() {
    return zv(t, "GET", e, n, r)
  })
}

function vi(t, e, n, r, o) {
  return Mu(this, void 0, void 0, function*() {
    return zv(t, "POST", e, r, o, n)
  })
}

function Gpe(t, e, n, r, o) {
  return Mu(this, void 0, void 0, function*() {
    return zv(t, "PUT", e, r, o, n)
  })
}

function B4(t, e, n, r, o) {
  return Mu(this, void 0, void 0, function*() {
    return zv(t, "DELETE", e, r, o, n)
  })
}
var Gr = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
const Ype = {
    limit: 100,
    offset: 0,
    sortBy: {
      column: "name",
      order: "asc"
    }
  },
  L$ = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
  };
class qpe {
  constructor(e, n = {}, r, o) {
    this.url = e, this.headers = n, this.bucketId = r, this.fetch = F4(o)
  }
  uploadOrUpdate(e, n, r, o) {
    return Gr(this, void 0, void 0, function*() {
      try {
        let s;
        const i = Object.assign(Object.assign({}, L$), o),
          a = Object.assign(Object.assign({}, this.headers), e === "POST" && {
            "x-upsert": String(i.upsert)
          });
        typeof Blob < "u" && r instanceof Blob ? (s = new FormData, s.append("cacheControl", i.cacheControl), s.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (s = r, s.append("cacheControl", i.cacheControl)) : (s = r, a["cache-control"] = `max-age=${i.cacheControl}`, a["content-type"] = i.contentType);
        const c = this._removeEmptyFolders(n),
          l = this._getFinalPath(c),
          u = yield this.fetch(`${this.url}/object/${l}`, Object.assign({
            method: e,
            body: s,
            headers: a
          }, i != null && i.duplex ? {
            duplex: i.duplex
          } : {}));
        return u.ok ? {
          data: {
            path: c
          },
          error: null
        } : {
          data: null,
          error: yield u.json()
        }
      } catch (s) {
        if (Ln(s)) return {
          data: null,
          error: s
        };
        throw s
      }
    })
  }
  upload(e, n, r) {
    return Gr(this, void 0, void 0, function*() {
      return this.uploadOrUpdate("POST", e, n, r)
    })
  }
  uploadToSignedUrl(e, n, r, o) {
    return Gr(this, void 0, void 0, function*() {
      const s = this._removeEmptyFolders(e),
        i = this._getFinalPath(s),
        a = new URL(this.url + `/object/upload/sign/${i}`);
      a.searchParams.set("token", n);
      try {
        let c;
        const l = Object.assign({
            upsert: L$.upsert
          }, o),
          u = Object.assign(Object.assign({}, this.headers), {
            "x-upsert": String(l.upsert)
          });
        typeof Blob < "u" && r instanceof Blob ? (c = new FormData, c.append("cacheControl", l.cacheControl), c.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (c = r, c.append("cacheControl", l.cacheControl)) : (c = r, u["cache-control"] = `max-age=${l.cacheControl}`, u["content-type"] = l.contentType);
        const d = yield this.fetch(a.toString(), {
          method: "PUT",
          body: c,
          headers: u
        });
        return d.ok ? {
          data: {
            path: s
          },
          error: null
        } : {
          data: null,
          error: yield d.json()
        }
      } catch (c) {
        if (Ln(c)) return {
          data: null,
          error: c
        };
        throw c
      }
    })
  }
  createSignedUploadUrl(e) {
    return Gr(this, void 0, void 0, function*() {
      try {
        let n = this._getFinalPath(e);
        const r = yield vi(this.fetch, `${this.url}/object/upload/sign/${n}`, {}, {
          headers: this.headers
        }), o = new URL(this.url + r.url), s = o.searchParams.get("token");
        if (!s) throw new zE("No token returned by API");
        return {
          data: {
            signedUrl: o.toString(),
            path: e,
            token: s
          },
          error: null
        }
      } catch (n) {
        if (Ln(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  update(e, n, r) {
    return Gr(this, void 0, void 0, function*() {
      return this.uploadOrUpdate("PUT", e, n, r)
    })
  }
  move(e, n) {
    return Gr(this, void 0, void 0, function*() {
      try {
        return {
          data: yield vi(this.fetch, `${this.url}/object/move`, {
            bucketId: this.bucketId,
            sourceKey: e,
            destinationKey: n
          }, {
            headers: this.headers
          }),
          error: null
        }
      } catch (r) {
        if (Ln(r)) return {
          data: null,
          error: r
        };
        throw r
      }
    })
  }
  copy(e, n) {
    return Gr(this, void 0, void 0, function*() {
      try {
        return {
          data: {
            path: (yield vi(this.fetch, `${this.url}/object/copy`, {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: n
            }, {
              headers: this.headers
            })).Key
          },
          error: null
        }
      } catch (r) {
        if (Ln(r)) return {
          data: null,
          error: r
        };
        throw r
      }
    })
  }
  createSignedUrl(e, n, r) {
    return Gr(this, void 0, void 0, function*() {
      try {
        let o = this._getFinalPath(e),
          s = yield vi(this.fetch, `${this.url}/object/sign/${o}`, Object.assign({
            expiresIn: n
          }, r != null && r.transform ? {
            transform: r.transform
          } : {}), {
            headers: this.headers
          });
        const i = r != null && r.download ? `&download=${r.download===!0?"":r.download}` : "";
        return s = {
          signedUrl: encodeURI(`${this.url}${s.signedURL}${i}`)
        }, {
          data: s,
          error: null
        }
      } catch (o) {
        if (Ln(o)) return {
          data: null,
          error: o
        };
        throw o
      }
    })
  }
  createSignedUrls(e, n, r) {
    return Gr(this, void 0, void 0, function*() {
      try {
        const o = yield vi(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {
          expiresIn: n,
          paths: e
        }, {
          headers: this.headers
        }), s = r != null && r.download ? `&download=${r.download===!0?"":r.download}` : "";
        return {
          data: o.map(i => Object.assign(Object.assign({}, i), {
            signedUrl: i.signedURL ? encodeURI(`${this.url}${i.signedURL}${s}`) : null
          })),
          error: null
        }
      } catch (o) {
        if (Ln(o)) return {
          data: null,
          error: o
        };
        throw o
      }
    })
  }
  download(e, n) {
    return Gr(this, void 0, void 0, function*() {
      const o = typeof(n == null ? void 0 : n.transform) < "u" ? "render/image/authenticated" : "object",
        s = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {}),
        i = s ? `?${s}` : "";
      try {
        const a = this._getFinalPath(e);
        return {
          data: yield(yield L_(this.fetch, `${this.url}/${o}/${a}${i}`, {
            headers: this.headers,
            noResolveJson: !0
          })).blob(),
          error: null
        }
      } catch (a) {
        if (Ln(a)) return {
          data: null,
          error: a
        };
        throw a
      }
    })
  }
  getPublicUrl(e, n) {
    const r = this._getFinalPath(e),
      o = [],
      s = n != null && n.download ? `download=${n.download===!0?"":n.download}` : "";
    s !== "" && o.push(s);
    const a = typeof(n == null ? void 0 : n.transform) < "u" ? "render/image" : "object",
      c = this.transformOptsToQueryString((n == null ? void 0 : n.transform) || {});
    c !== "" && o.push(c);
    let l = o.join("&");
    return l !== "" && (l = `?${l}`), {
      data: {
        publicUrl: encodeURI(`${this.url}/${a}/public/${r}${l}`)
      }
    }
  }
  remove(e) {
    return Gr(this, void 0, void 0, function*() {
      try {
        return {
          data: yield B4(this.fetch, `${this.url}/object/${this.bucketId}`, {
            prefixes: e
          }, {
            headers: this.headers
          }),
          error: null
        }
      } catch (n) {
        if (Ln(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  list(e, n, r) {
    return Gr(this, void 0, void 0, function*() {
      try {
        const o = Object.assign(Object.assign(Object.assign({}, Ype), n), {
          prefix: e || ""
        });
        return {
          data: yield vi(this.fetch, `${this.url}/object/list/${this.bucketId}`, o, {
            headers: this.headers
          }, r),
          error: null
        }
      } catch (o) {
        if (Ln(o)) return {
          data: null,
          error: o
        };
        throw o
      }
    })
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e}`
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
  }
  transformOptsToQueryString(e) {
    const n = [];
    return e.width && n.push(`width=${e.width}`), e.height && n.push(`height=${e.height}`), e.resize && n.push(`resize=${e.resize}`), e.format && n.push(`format=${e.format}`), e.quality && n.push(`quality=${e.quality}`), n.join("&")
  }
}
const Xpe = "2.5.4",
  Zpe = {
    "X-Client-Info": `storage-js/${Xpe}`
  };
var Wc = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
class Jpe {
  constructor(e, n = {}, r) {
    this.url = e, this.headers = Object.assign(Object.assign({}, Zpe), n), this.fetch = F4(r)
  }
  listBuckets() {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield L_(this.fetch, `${this.url}/bucket`, {
            headers: this.headers
          }),
          error: null
        }
      } catch (e) {
        if (Ln(e)) return {
          data: null,
          error: e
        };
        throw e
      }
    })
  }
  getBucket(e) {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield L_(this.fetch, `${this.url}/bucket/${e}`, {
            headers: this.headers
          }),
          error: null
        }
      } catch (n) {
        if (Ln(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  createBucket(e, n = {
    public: !1
  }) {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield vi(this.fetch, `${this.url}/bucket`, {
            id: e,
            name: e,
            public: n.public,
            file_size_limit: n.fileSizeLimit,
            allowed_mime_types: n.allowedMimeTypes
          }, {
            headers: this.headers
          }),
          error: null
        }
      } catch (r) {
        if (Ln(r)) return {
          data: null,
          error: r
        };
        throw r
      }
    })
  }
  updateBucket(e, n) {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield Gpe(this.fetch, `${this.url}/bucket/${e}`, {
            id: e,
            name: e,
            public: n.public,
            file_size_limit: n.fileSizeLimit,
            allowed_mime_types: n.allowedMimeTypes
          }, {
            headers: this.headers
          }),
          error: null
        }
      } catch (r) {
        if (Ln(r)) return {
          data: null,
          error: r
        };
        throw r
      }
    })
  }
  emptyBucket(e) {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield vi(this.fetch, `${this.url}/bucket/${e}/empty`, {}, {
            headers: this.headers
          }),
          error: null
        }
      } catch (n) {
        if (Ln(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  deleteBucket(e) {
    return Wc(this, void 0, void 0, function*() {
      try {
        return {
          data: yield B4(this.fetch, `${this.url}/bucket/${e}`, {}, {
            headers: this.headers
          }),
          error: null
        }
      } catch (n) {
        if (Ln(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
}
class Qpe extends Jpe {
  constructor(e, n = {}, r) {
    super(e, n, r)
  }
  from(e) {
    return new qpe(this.url, this.headers, e, this.fetch)
  }
}
const ege = "2.38.1";
let Od = "";
typeof Deno < "u" ? Od = "deno" : typeof document < "u" ? Od = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Od = "react-native" : Od = "node";
const tge = {
  "X-Client-Info": `supabase-js-${Od}/${ege}`
};
var nge = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
const rge = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = FE : e = fetch, (...n) => e(...n)
  },
  oge = () => typeof Headers > "u" ? LE.Headers : Headers,
  sge = (t, e, n) => {
    const r = rge(n),
      o = oge();
    return (s, i) => nge(void 0, void 0, void 0, function*() {
      var a;
      const c = (a = yield e()) !== null && a !== void 0 ? a : t;
      let l = new o(i == null ? void 0 : i.headers);
      return l.has("apikey") || l.set("apikey", t), l.has("Authorization") || l.set("Authorization", `Bearer ${c}`), r(s, Object.assign(Object.assign({}, i), {
        headers: l
      }))
    })
  };

function ige(t) {
  return t.replace(/\/$/, "")
}

function age(t, e) {
  const {
    db: n,
    auth: r,
    realtime: o,
    global: s
  } = t, {
    db: i,
    auth: a,
    realtime: c,
    global: l
  } = e;
  return {
    db: Object.assign(Object.assign({}, i), n),
    auth: Object.assign(Object.assign({}, a), r),
    realtime: Object.assign(Object.assign({}, c), o),
    global: Object.assign(Object.assign({}, l), s)
  }
}

function cge(t) {
  return Math.round(Date.now() / 1e3) + t
}

function lge() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
    const e = Math.random() * 16 | 0;
    return (t == "x" ? e : e & 3 | 8).toString(16)
  })
}
const Cs = () => typeof document < "u",
  ma = {
    tested: !1,
    writable: !1
  },
  tf = () => {
    if (!Cs()) return !1;
    try {
      if (typeof globalThis.localStorage != "object") return !1
    } catch {
      return !1
    }
    if (ma.tested) return ma.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(t, t), globalThis.localStorage.removeItem(t), ma.tested = !0, ma.writable = !0
    } catch {
      ma.tested = !0, ma.writable = !1
    }
    return ma.writable
  };

function rw(t) {
  const e = {},
    n = new URL(t);
  if (n.hash && n.hash[0] === "#") try {
    new URLSearchParams(n.hash.substring(1)).forEach((o, s) => {
      e[s] = o
    })
  } catch {}
  return n.searchParams.forEach((r, o) => {
    e[o] = r
  }), e
}
const U4 = t => {
    let e;
    return t ? e = t : typeof fetch > "u" ? e = (...n) => Ie(() => Promise.resolve().then(() => Bh), void 0).then(({
      default: r
    }) => r(...n)) : e = fetch, (...n) => e(...n)
  },
  uge = t => typeof t == "object" && t !== null && "status" in t && "ok" in t && "json" in t && typeof t.json == "function",
  Kc = async (t, e, n) => {
    await t.setItem(e, JSON.stringify(n))
  }, cg = async (t, e) => {
    const n = await t.getItem(e);
    if (!n) return null;
    try {
      return JSON.parse(n)
    } catch {
      return n
    }
  }, ow = async (t, e) => {
    await t.removeItem(e)
  };

function dge(t) {
  const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let n = "",
    r, o, s, i, a, c, l, u = 0;
  for (t = t.replace("-", "+").replace("_", "/"); u < t.length;) i = e.indexOf(t.charAt(u++)), a = e.indexOf(t.charAt(u++)), c = e.indexOf(t.charAt(u++)), l = e.indexOf(t.charAt(u++)), r = i << 2 | a >> 4, o = (a & 15) << 4 | c >> 2, s = (c & 3) << 6 | l, n = n + String.fromCharCode(r), c != 64 && o != 0 && (n = n + String.fromCharCode(o)), l != 64 && s != 0 && (n = n + String.fromCharCode(s));
  return n
}
class Hv {
  constructor() {
    this.promise = new Hv.promiseConstructor((e, n) => {
      this.resolve = e, this.reject = n
    })
  }
}
Hv.promiseConstructor = Promise;

function F$(t) {
  const e = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}=?$|[a-z0-9_-]{2}(==)?$)$/i,
    n = t.split(".");
  if (n.length !== 3) throw new Error("JWT is not valid: not a JWT structure");
  if (!e.test(n[1])) throw new Error("JWT is not valid: payload is not in base64url format");
  const r = n[1];
  return JSON.parse(dge(r))
}
async function fge(t) {
  return await new Promise(e => {
    setTimeout(() => e(null), t)
  })
}

function hge(t, e) {
  return new Promise((r, o) => {
    (async () => {
      for (let s = 0; s < 1 / 0; s++) try {
        const i = await t(s);
        if (!e(s, null, i)) {
          r(i);
          return
        }
      } catch (i) {
        if (!e(s, i)) {
          o(i);
          return
        }
      }
    })()
  })
}

function pge(t) {
  return ("0" + t.toString(16)).substr(-2)
}

function bd() {
  const e = new Uint32Array(56);
  if (typeof crypto > "u") {
    const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
      r = n.length;
    let o = "";
    for (let s = 0; s < 56; s++) o += n.charAt(Math.floor(Math.random() * r));
    return o
  }
  return crypto.getRandomValues(e), Array.from(e, pge).join("")
}
async function gge(t) {
  const n = new TextEncoder().encode(t),
    r = await crypto.subtle.digest("SHA-256", n),
    o = new Uint8Array(r);
  return Array.from(o).map(s => String.fromCharCode(s)).join("")
}

function mge(t) {
  return btoa(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function wd(t) {
  if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u")) return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."), t;
  const n = await gge(t);
  return mge(n)
}
class HE extends Error {
  constructor(e, n) {
    super(e), this.__isAuthError = !0, this.name = "AuthError", this.status = n
  }
}

function ot(t) {
  return typeof t == "object" && t !== null && "__isAuthError" in t
}
class yge extends HE {
  constructor(e, n) {
    super(e, n), this.name = "AuthApiError", this.status = n
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    }
  }
}

function vge(t) {
  return ot(t) && t.name === "AuthApiError"
}
class z4 extends HE {
  constructor(e, n) {
    super(e), this.name = "AuthUnknownError", this.originalError = n
  }
}
class ju extends HE {
  constructor(e, n, r) {
    super(e), this.name = n, this.status = r
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status
    }
  }
}
class Gc extends ju {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400)
  }
}
class sw extends ju {
  constructor() {
    super("Auth session or user missing", "AuthInvalidTokenResponseError", 500)
  }
}
class lg extends ju {
  constructor(e) {
    super(e, "AuthInvalidCredentialsError", 400)
  }
}
class ug extends ju {
  constructor(e, n = null) {
    super(e, "AuthImplicitGrantRedirectError", 500), this.details = null, this.details = n
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    }
  }
}
class B$ extends ju {
  constructor(e, n = null) {
    super(e, "AuthPKCEGrantCodeExchangeError", 500), this.details = null, this.details = n
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details
    }
  }
}
class F_ extends ju {
  constructor(e, n) {
    super(e, "AuthRetryableFetchError", n)
  }
}

function U$(t) {
  return ot(t) && t.name === "AuthRetryableFetchError"
}
var bge = globalThis && globalThis.__rest || function(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++) e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n
};
const Rd = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t),
  wge = [502, 503, 504];
async function z$(t) {
  if (!uge(t)) throw new F_(Rd(t), 0);
  if (wge.includes(t.status)) throw new F_(Rd(t), t.status);
  let e;
  try {
    e = await t.json()
  } catch (n) {
    throw new z4(Rd(n), n)
  }
  throw new yge(Rd(e), t.status || 500)
}
const Sge = (t, e, n, r) => {
  const o = {
    method: t,
    headers: (e == null ? void 0 : e.headers) || {}
  };
  return t === "GET" ? o : (o.headers = Object.assign({
    "Content-Type": "application/json;charset=UTF-8"
  }, e == null ? void 0 : e.headers), o.body = JSON.stringify(r), Object.assign(Object.assign({}, o), n))
};
async function it(t, e, n, r) {
  var o;
  const s = Object.assign({}, r == null ? void 0 : r.headers);
  r != null && r.jwt && (s.Authorization = `Bearer ${r.jwt}`);
  const i = (o = r == null ? void 0 : r.query) !== null && o !== void 0 ? o : {};
  r != null && r.redirectTo && (i.redirect_to = r.redirectTo);
  const a = Object.keys(i).length ? "?" + new URLSearchParams(i).toString() : "",
    c = await _ge(t, e, n + a, {
      headers: s,
      noResolveJson: r == null ? void 0 : r.noResolveJson
    }, {}, r == null ? void 0 : r.body);
  return r != null && r.xform ? r == null ? void 0 : r.xform(c) : {
    data: Object.assign({}, c),
    error: null
  }
}
async function _ge(t, e, n, r, o, s) {
  const i = Sge(e, r, o, s);
  let a;
  try {
    a = await t(n, i)
  } catch (c) {
    throw console.error(c), new F_(Rd(c), 0)
  }
  if (a.ok || await z$(a), r != null && r.noResolveJson) return a;
  try {
    return await a.json()
  } catch (c) {
    await z$(c)
  }
}

function di(t) {
  var e;
  let n = null;
  Cge(t) && (n = Object.assign({}, t), t.expires_at || (n.expires_at = cge(t.expires_in)));
  const r = (e = t.user) !== null && e !== void 0 ? e : t;
  return {
    data: {
      session: n,
      user: r
    },
    error: null
  }
}

function xi(t) {
  var e;
  return {
    data: {
      user: (e = t.user) !== null && e !== void 0 ? e : t
    },
    error: null
  }
}

function xge(t) {
  return {
    data: t,
    error: null
  }
}

function Ege(t) {
  const {
    action_link: e,
    email_otp: n,
    hashed_token: r,
    redirect_to: o,
    verification_type: s
  } = t, i = bge(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"]), a = {
    action_link: e,
    email_otp: n,
    hashed_token: r,
    redirect_to: o,
    verification_type: s
  }, c = Object.assign({}, i);
  return {
    data: {
      properties: a,
      user: c
    },
    error: null
  }
}

function kge(t) {
  return t
}

function Cge(t) {
  return t.access_token && t.refresh_token && t.expires_in
}
var Pge = globalThis && globalThis.__rest || function(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++) e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n
};
class Tge {
  constructor({
    url: e = "",
    headers: n = {},
    fetch: r
  }) {
    this.url = e, this.headers = n, this.fetch = U4(r), this.mfa = {
      listFactors: this._listFactors.bind(this),
      deleteFactor: this._deleteFactor.bind(this)
    }
  }
  async signOut(e, n = "global") {
    try {
      return await it(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
        headers: this.headers,
        jwt: e,
        noResolveJson: !0
      }), {
        data: null,
        error: null
      }
    } catch (r) {
      if (ot(r)) return {
        data: null,
        error: r
      };
      throw r
    }
  }
  async inviteUserByEmail(e, n = {}) {
    try {
      return await it(this.fetch, "POST", `${this.url}/invite`, {
        body: {
          email: e,
          data: n.data
        },
        headers: this.headers,
        redirectTo: n.redirectTo,
        xform: xi
      })
    } catch (r) {
      if (ot(r)) return {
        data: {
          user: null
        },
        error: r
      };
      throw r
    }
  }
  async generateLink(e) {
    try {
      const {
        options: n
      } = e, r = Pge(e, ["options"]), o = Object.assign(Object.assign({}, r), n);
      return "newEmail" in r && (o.new_email = r == null ? void 0 : r.newEmail, delete o.newEmail), await it(this.fetch, "POST", `${this.url}/admin/generate_link`, {
        body: o,
        headers: this.headers,
        xform: Ege,
        redirectTo: n == null ? void 0 : n.redirectTo
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          properties: null,
          user: null
        },
        error: n
      };
      throw n
    }
  }
  async createUser(e) {
    try {
      return await it(this.fetch, "POST", `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: xi
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null
        },
        error: n
      };
      throw n
    }
  }
  async listUsers(e) {
    var n, r, o, s, i, a, c;
    try {
      const l = {
          nextPage: null,
          lastPage: 0,
          total: 0
        },
        u = await it(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page: (r = (n = e == null ? void 0 : e.page) === null || n === void 0 ? void 0 : n.toString()) !== null && r !== void 0 ? r : "",
            per_page: (s = (o = e == null ? void 0 : e.perPage) === null || o === void 0 ? void 0 : o.toString()) !== null && s !== void 0 ? s : ""
          },
          xform: kge
        });
      if (u.error) throw u.error;
      const d = await u.json(),
        f = (i = u.headers.get("x-total-count")) !== null && i !== void 0 ? i : 0,
        h = (c = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && c !== void 0 ? c : [];
      return h.length > 0 && (h.forEach(m => {
        const p = parseInt(m.split(";")[0].split("=")[1].substring(0, 1)),
          b = JSON.parse(m.split(";")[1].split("=")[1]);
        l[`${b}Page`] = p
      }), l.total = parseInt(f)), {
        data: Object.assign(Object.assign({}, d), l),
        error: null
      }
    } catch (l) {
      if (ot(l)) return {
        data: {
          users: []
        },
        error: l
      };
      throw l
    }
  }
  async getUserById(e) {
    try {
      return await it(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: xi
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null
        },
        error: n
      };
      throw n
    }
  }
  async updateUserById(e, n) {
    try {
      return await it(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
        body: n,
        headers: this.headers,
        xform: xi
      })
    } catch (r) {
      if (ot(r)) return {
        data: {
          user: null
        },
        error: r
      };
      throw r
    }
  }
  async deleteUser(e, n = !1) {
    try {
      return await it(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: {
          should_soft_delete: n
        },
        xform: xi
      })
    } catch (r) {
      if (ot(r)) return {
        data: {
          user: null
        },
        error: r
      };
      throw r
    }
  }
  async _listFactors(e) {
    try {
      const {
        data: n,
        error: r
      } = await it(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
        headers: this.headers,
        xform: o => ({
          data: {
            factors: o
          },
          error: null
        })
      });
      return {
        data: n,
        error: r
      }
    } catch (n) {
      if (ot(n)) return {
        data: null,
        error: n
      };
      throw n
    }
  }
  async _deleteFactor(e) {
    try {
      return {
        data: await it(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
          headers: this.headers
        }),
        error: null
      }
    } catch (n) {
      if (ot(n)) return {
        data: null,
        error: n
      };
      throw n
    }
  }
}
const H4 = "2.55.0",
  $ge = "http://localhost:9999",
  Ige = "supabase.auth.token",
  Oge = {
    "X-Client-Info": `gotrue-js/${H4}`
  },
  H$ = 10,
  Rge = {
    getItem: t => tf() ? globalThis.localStorage.getItem(t) : null,
    setItem: (t, e) => {
      tf() && globalThis.localStorage.setItem(t, e)
    },
    removeItem: t => {
      tf() && globalThis.localStorage.removeItem(t)
    }
  };

function V$(t = {}) {
  return {
    getItem: e => t[e] || null,
    setItem: (e, n) => {
      t[e] = n
    },
    removeItem: e => {
      delete t[e]
    }
  }
}

function Age() {
  if (typeof globalThis != "object") try {
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this
      },
      configurable: !0
    }), __magic__.globalThis = __magic__, delete Object.prototype.__magic__
  } catch {
    typeof self < "u" && (self.globalThis = self)
  }
}
globalThis && tf() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug");
class Mge extends Error {
  constructor(e) {
    super(e), this.isAcquireTimeout = !0
  }
}
Age();
const jge = {
    url: $ge,
    storageKey: Ige,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: Oge,
    flowType: "implicit",
    debug: !1
  },
  Sd = 30 * 1e3,
  W$ = 3;
async function Dge(t, e, n) {
  return await n()
}
class Yf {
  constructor(e) {
    var n;
    this.memoryStorage = null, this.stateChangeEmitters = new Map, this.autoRefreshTicker = null, this.visibilityChangedCallback = null, this.refreshingDeferred = null, this.initializePromise = null, this.detectSessionInUrl = !0, this.lockAcquired = !1, this.pendingInLock = [], this.broadcastChannel = null, this.logger = console.log, this.instanceID = Yf.nextInstanceID, Yf.nextInstanceID += 1, this.instanceID > 0 && Cs() && console.warn("Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.");
    const r = Object.assign(Object.assign({}, jge), e);
    if (this.logDebugMessages = !!r.debug, typeof r.debug == "function" && (this.logger = r.debug), this.persistSession = r.persistSession, this.storageKey = r.storageKey, this.autoRefreshToken = r.autoRefreshToken, this.admin = new Tge({
        url: r.url,
        headers: r.headers,
        fetch: r.fetch
      }), this.url = r.url, this.headers = r.headers, this.fetch = U4(r.fetch), this.lock = r.lock || Dge, this.detectSessionInUrl = r.detectSessionInUrl, this.flowType = r.flowType, this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)
      }, this.persistSession ? r.storage ? this.storage = r.storage : tf() ? this.storage = Rge : (this.memoryStorage = {}, this.storage = V$(this.memoryStorage)) : (this.memoryStorage = {}, this.storage = V$(this.memoryStorage)), Cs() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
      } catch (o) {
        console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
      }(n = this.broadcastChannel) === null || n === void 0 || n.addEventListener("message", async o => {
        this._debug("received broadcast notification from other tab or client", o), await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
      })
    }
    this.initialize()
  }
  _debug(...e) {
    return this.logDebugMessages && this.logger(`GoTrueClient@${this.instanceID} (${H4}) ${new Date().toISOString()}`, ...e), this
  }
  async initialize() {
    return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(-1, async () => await this._initialize()))(), await this.initializePromise)
  }
  async _initialize() {
    try {
      const e = Cs() ? await this._isPKCEFlow() : !1;
      if (this._debug("#_initialize()", "begin", "is PKCE flow", e), e || this.detectSessionInUrl && this._isImplicitGrantFlow()) {
        const {
          data: n,
          error: r
        } = await this._getSessionFromURL(e);
        if (r) return this._debug("#_initialize()", "error detecting session from URL", r), await this._removeSession(), {
          error: r
        };
        const {
          session: o,
          redirectType: s
        } = n;
        return this._debug("#_initialize()", "detected session in URL", o, "redirect type", s), await this._saveSession(o), setTimeout(async () => {
          s === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
        }, 0), {
          error: null
        }
      }
      return await this._recoverAndRefresh(), {
        error: null
      }
    } catch (e) {
      return ot(e) ? {
        error: e
      } : {
        error: new z4("Unexpected error during initialization", e)
      }
    } finally {
      await this._handleVisibilityChange(), this._debug("#_initialize()", "end")
    }
  }
  async signUp(e) {
    var n, r, o;
    try {
      await this._removeSession();
      let s;
      if ("email" in e) {
        const {
          email: u,
          password: d,
          options: f
        } = e;
        let h = null,
          m = null;
        if (this.flowType === "pkce") {
          const p = bd();
          await Kc(this.storage, `${this.storageKey}-code-verifier`, p), h = await wd(p), m = p === h ? "plain" : "s256"
        }
        s = await it(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          redirectTo: f == null ? void 0 : f.emailRedirectTo,
          body: {
            email: u,
            password: d,
            data: (n = f == null ? void 0 : f.data) !== null && n !== void 0 ? n : {},
            gotrue_meta_security: {
              captcha_token: f == null ? void 0 : f.captchaToken
            },
            code_challenge: h,
            code_challenge_method: m
          },
          xform: di
        })
      } else if ("phone" in e) {
        const {
          phone: u,
          password: d,
          options: f
        } = e;
        s = await it(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: u,
            password: d,
            data: (r = f == null ? void 0 : f.data) !== null && r !== void 0 ? r : {},
            channel: (o = f == null ? void 0 : f.channel) !== null && o !== void 0 ? o : "sms",
            gotrue_meta_security: {
              captcha_token: f == null ? void 0 : f.captchaToken
            }
          },
          xform: di
        })
      } else throw new lg("You must provide either an email or phone number and a password");
      const {
        data: i,
        error: a
      } = s;
      if (a || !i) return {
        data: {
          user: null,
          session: null
        },
        error: a
      };
      const c = i.session,
        l = i.user;
      return i.session && (await this._saveSession(i.session), await this._notifyAllSubscribers("SIGNED_IN", c)), {
        data: {
          user: l,
          session: c
        },
        error: null
      }
    } catch (s) {
      if (ot(s)) return {
        data: {
          user: null,
          session: null
        },
        error: s
      };
      throw s
    }
  }
  async signInWithPassword(e) {
    try {
      await this._removeSession();
      let n;
      if ("email" in e) {
        const {
          email: s,
          password: i,
          options: a
        } = e;
        n = await it(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            email: s,
            password: i,
            gotrue_meta_security: {
              captcha_token: a == null ? void 0 : a.captchaToken
            }
          },
          xform: di
        })
      } else if ("phone" in e) {
        const {
          phone: s,
          password: i,
          options: a
        } = e;
        n = await it(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
          headers: this.headers,
          body: {
            phone: s,
            password: i,
            gotrue_meta_security: {
              captcha_token: a == null ? void 0 : a.captchaToken
            }
          },
          xform: di
        })
      } else throw new lg("You must provide either an email or phone number and a password");
      const {
        data: r,
        error: o
      } = n;
      return o ? {
        data: {
          user: null,
          session: null
        },
        error: o
      } : !r || !r.session || !r.user ? {
        data: {
          user: null,
          session: null
        },
        error: new sw
      } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), {
        data: {
          user: r.user,
          session: r.session
        },
        error: o
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null,
          session: null
        },
        error: n
      };
      throw n
    }
  }
  async signInWithOAuth(e) {
    var n, r, o, s;
    return await this._removeSession(), await this._handleProviderSignIn(e.provider, {
      redirectTo: (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
      scopes: (r = e.options) === null || r === void 0 ? void 0 : r.scopes,
      queryParams: (o = e.options) === null || o === void 0 ? void 0 : o.queryParams,
      skipBrowserRedirect: (s = e.options) === null || s === void 0 ? void 0 : s.skipBrowserRedirect
    })
  }
  async exchangeCodeForSession(e) {
    return await this.initializePromise, this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
  }
  async _exchangeCodeForSession(e) {
    const n = await cg(this.storage, `${this.storageKey}-code-verifier`),
      {
        data: r,
        error: o
      } = await it(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
        headers: this.headers,
        body: {
          auth_code: e,
          code_verifier: n
        },
        xform: di
      });
    return await ow(this.storage, `${this.storageKey}-code-verifier`), o ? {
      data: {
        user: null,
        session: null
      },
      error: o
    } : !r || !r.session || !r.user ? {
      data: {
        user: null,
        session: null
      },
      error: new sw
    } : (r.session && (await this._saveSession(r.session), await this._notifyAllSubscribers("SIGNED_IN", r.session)), {
      data: r,
      error: o
    })
  }
  async signInWithIdToken(e) {
    await this._removeSession();
    try {
      const {
        options: n,
        provider: r,
        token: o,
        access_token: s,
        nonce: i
      } = e, a = await it(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
        headers: this.headers,
        body: {
          provider: r,
          id_token: o,
          access_token: s,
          nonce: i,
          gotrue_meta_security: {
            captcha_token: n == null ? void 0 : n.captchaToken
          }
        },
        xform: di
      }), {
        data: c,
        error: l
      } = a;
      return l ? {
        data: {
          user: null,
          session: null
        },
        error: l
      } : !c || !c.session || !c.user ? {
        data: {
          user: null,
          session: null
        },
        error: new sw
      } : (c.session && (await this._saveSession(c.session), await this._notifyAllSubscribers("SIGNED_IN", c.session)), {
        data: c,
        error: l
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null,
          session: null
        },
        error: n
      };
      throw n
    }
  }
  async signInWithOtp(e) {
    var n, r, o, s, i;
    try {
      if (await this._removeSession(), "email" in e) {
        const {
          email: a,
          options: c
        } = e;
        let l = null,
          u = null;
        if (this.flowType === "pkce") {
          const f = bd();
          await Kc(this.storage, `${this.storageKey}-code-verifier`, f), l = await wd(f), u = f === l ? "plain" : "s256"
        }
        const {
          error: d
        } = await it(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: a,
            data: (n = c == null ? void 0 : c.data) !== null && n !== void 0 ? n : {},
            create_user: (r = c == null ? void 0 : c.shouldCreateUser) !== null && r !== void 0 ? r : !0,
            gotrue_meta_security: {
              captcha_token: c == null ? void 0 : c.captchaToken
            },
            code_challenge: l,
            code_challenge_method: u
          },
          redirectTo: c == null ? void 0 : c.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error: d
        }
      }
      if ("phone" in e) {
        const {
          phone: a,
          options: c
        } = e, {
          data: l,
          error: u
        } = await it(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            phone: a,
            data: (o = c == null ? void 0 : c.data) !== null && o !== void 0 ? o : {},
            create_user: (s = c == null ? void 0 : c.shouldCreateUser) !== null && s !== void 0 ? s : !0,
            gotrue_meta_security: {
              captcha_token: c == null ? void 0 : c.captchaToken
            },
            channel: (i = c == null ? void 0 : c.channel) !== null && i !== void 0 ? i : "sms"
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: l == null ? void 0 : l.message_id
          },
          error: u
        }
      }
      throw new lg("You must provide either an email or phone number.")
    } catch (a) {
      if (ot(a)) return {
        data: {
          user: null,
          session: null
        },
        error: a
      };
      throw a
    }
  }
  async verifyOtp(e) {
    var n, r;
    try {
      e.type !== "email_change" && e.type !== "phone_change" && await this._removeSession();
      let o, s;
      "options" in e && (o = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo, s = (r = e.options) === null || r === void 0 ? void 0 : r.captchaToken);
      const {
        data: i,
        error: a
      } = await it(this.fetch, "POST", `${this.url}/verify`, {
        headers: this.headers,
        body: Object.assign(Object.assign({}, e), {
          gotrue_meta_security: {
            captcha_token: s
          }
        }),
        redirectTo: o,
        xform: di
      });
      if (a) throw a;
      if (!i) throw new Error("An error occurred on token verification.");
      const c = i.session,
        l = i.user;
      return c != null && c.access_token && (await this._saveSession(c), await this._notifyAllSubscribers("SIGNED_IN", c)), {
        data: {
          user: l,
          session: c
        },
        error: null
      }
    } catch (o) {
      if (ot(o)) return {
        data: {
          user: null,
          session: null
        },
        error: o
      };
      throw o
    }
  }
  async signInWithSSO(e) {
    var n, r, o;
    try {
      return await this._removeSession(), await it(this.fetch, "POST", `${this.url}/sso`, {
        body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId" in e ? {
          provider_id: e.providerId
        } : null), "domain" in e ? {
          domain: e.domain
        } : null), {
          redirect_to: (r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo) !== null && r !== void 0 ? r : void 0
        }), !((o = e == null ? void 0 : e.options) === null || o === void 0) && o.captchaToken ? {
          gotrue_meta_security: {
            captcha_token: e.options.captchaToken
          }
        } : null), {
          skip_http_redirect: !0
        }),
        headers: this.headers,
        xform: xge
      })
    } catch (s) {
      if (ot(s)) return {
        data: null,
        error: s
      };
      throw s
    }
  }
  async reauthenticate() {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._reauthenticate())
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async e => {
        const {
          data: {
            session: n
          },
          error: r
        } = e;
        if (r) throw r;
        if (!n) throw new Gc;
        const {
          error: o
        } = await it(this.fetch, "GET", `${this.url}/reauthenticate`, {
          headers: this.headers,
          jwt: n.access_token
        });
        return {
          data: {
            user: null,
            session: null
          },
          error: o
        }
      })
    } catch (e) {
      if (ot(e)) return {
        data: {
          user: null,
          session: null
        },
        error: e
      };
      throw e
    }
  }
  async resend(e) {
    try {
      e.type != "email_change" && e.type != "phone_change" && await this._removeSession();
      const n = `${this.url}/resend`;
      if ("email" in e) {
        const {
          email: r,
          type: o,
          options: s
        } = e, {
          error: i
        } = await it(this.fetch, "POST", n, {
          headers: this.headers,
          body: {
            email: r,
            type: o,
            gotrue_meta_security: {
              captcha_token: s == null ? void 0 : s.captchaToken
            }
          },
          redirectTo: s == null ? void 0 : s.emailRedirectTo
        });
        return {
          data: {
            user: null,
            session: null
          },
          error: i
        }
      } else if ("phone" in e) {
        const {
          phone: r,
          type: o,
          options: s
        } = e, {
          data: i,
          error: a
        } = await it(this.fetch, "POST", n, {
          headers: this.headers,
          body: {
            phone: r,
            type: o,
            gotrue_meta_security: {
              captcha_token: s == null ? void 0 : s.captchaToken
            }
          }
        });
        return {
          data: {
            user: null,
            session: null,
            messageId: i == null ? void 0 : i.message_id
          },
          error: a
        }
      }
      throw new lg("You must provide either an email or phone number and a type")
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null,
          session: null
        },
        error: n
      };
      throw n
    }
  }
  async getSession() {
    return await this.initializePromise, this._acquireLock(-1, async () => this._useSession(async e => e))
  }
  async _acquireLock(e, n) {
    this._debug("#_acquireLock", "begin", e);
    try {
      if (this.lockAcquired) {
        const r = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve(),
          o = (async () => (await r, await n()))();
        return this.pendingInLock.push((async () => {
          try {
            await o
          } catch {}
        })()), o
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
        try {
          this.lockAcquired = !0;
          const r = n();
          for (this.pendingInLock.push((async () => {
              try {
                await r
              } catch {}
            })()), await r; this.pendingInLock.length;) {
            const o = [...this.pendingInLock];
            await Promise.all(o), this.pendingInLock.splice(0, o.length)
          }
          return await r
        } finally {
          this._debug("#_acquireLock", "lock released for storage key", this.storageKey), this.lockAcquired = !1
        }
      })
    } finally {
      this._debug("#_acquireLock", "end")
    }
  }
  async _useSession(e) {
    this._debug("#_useSession", "begin");
    try {
      const n = await this.__loadSession();
      return await e(n)
    } finally {
      this._debug("#_useSession", "end")
    }
  }
  async __loadSession() {
    this._debug("#__loadSession()", "begin"), this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
    try {
      let e = null;
      const n = await cg(this.storage, this.storageKey);
      if (this._debug("#getSession()", "session from storage", n), n !== null && (this._isValidSession(n) ? e = n : (this._debug("#getSession()", "session from storage is not valid"), await this._removeSession())), !e) return {
        data: {
          session: null
        },
        error: null
      };
      const r = e.expires_at ? e.expires_at <= Date.now() / 1e3 : !1;
      if (this._debug("#__loadSession()", `session has${r?"":" not"} expired`, "expires_at", e.expires_at), !r) return {
        data: {
          session: e
        },
        error: null
      };
      const {
        session: o,
        error: s
      } = await this._callRefreshToken(e.refresh_token);
      return s ? {
        data: {
          session: null
        },
        error: s
      } : {
        data: {
          session: o
        },
        error: null
      }
    } finally {
      this._debug("#__loadSession()", "end")
    }
  }
  async getUser(e) {
    return e ? await this._getUser(e) : (await this.initializePromise, this._acquireLock(-1, async () => await this._getUser()))
  }
  async _getUser(e) {
    try {
      return e ? await it(this.fetch, "GET", `${this.url}/user`, {
        headers: this.headers,
        jwt: e,
        xform: xi
      }) : await this._useSession(async n => {
        var r, o;
        const {
          data: s,
          error: i
        } = n;
        if (i) throw i;
        return await it(this.fetch, "GET", `${this.url}/user`, {
          headers: this.headers,
          jwt: (o = (r = s.session) === null || r === void 0 ? void 0 : r.access_token) !== null && o !== void 0 ? o : void 0,
          xform: xi
        })
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null
        },
        error: n
      };
      throw n
    }
  }
  async updateUser(e, n = {}) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._updateUser(e, n))
  }
  async _updateUser(e, n = {}) {
    try {
      return await this._useSession(async r => {
        const {
          data: o,
          error: s
        } = r;
        if (s) throw s;
        if (!o.session) throw new Gc;
        const i = o.session;
        let a = null,
          c = null;
        if (this.flowType === "pkce" && e.email != null) {
          const d = bd();
          await Kc(this.storage, `${this.storageKey}-code-verifier`, d), a = await wd(d), c = d === a ? "plain" : "s256"
        }
        const {
          data: l,
          error: u
        } = await it(this.fetch, "PUT", `${this.url}/user`, {
          headers: this.headers,
          redirectTo: n == null ? void 0 : n.emailRedirectTo,
          body: Object.assign(Object.assign({}, e), {
            code_challenge: a,
            code_challenge_method: c
          }),
          jwt: i.access_token,
          xform: xi
        });
        if (u) throw u;
        return i.user = l.user, await this._saveSession(i), await this._notifyAllSubscribers("USER_UPDATED", i), {
          data: {
            user: i.user
          },
          error: null
        }
      })
    } catch (r) {
      if (ot(r)) return {
        data: {
          user: null
        },
        error: r
      };
      throw r
    }
  }
  _decodeJWT(e) {
    return F$(e)
  }
  async setSession(e) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._setSession(e))
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token) throw new Gc;
      const n = Date.now() / 1e3;
      let r = n,
        o = !0,
        s = null;
      const i = F$(e.access_token);
      if (i.exp && (r = i.exp, o = r <= n), o) {
        const {
          session: a,
          error: c
        } = await this._callRefreshToken(e.refresh_token);
        if (c) return {
          data: {
            user: null,
            session: null
          },
          error: c
        };
        if (!a) return {
          data: {
            user: null,
            session: null
          },
          error: null
        };
        s = a
      } else {
        const {
          data: a,
          error: c
        } = await this._getUser(e.access_token);
        if (c) throw c;
        s = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: a.user,
          token_type: "bearer",
          expires_in: r - n,
          expires_at: r
        }, await this._saveSession(s), await this._notifyAllSubscribers("SIGNED_IN", s)
      }
      return {
        data: {
          user: s.user,
          session: s
        },
        error: null
      }
    } catch (n) {
      if (ot(n)) return {
        data: {
          session: null,
          user: null
        },
        error: n
      };
      throw n
    }
  }
  async refreshSession(e) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._refreshSession(e))
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async n => {
        var r;
        if (!e) {
          const {
            data: i,
            error: a
          } = n;
          if (a) throw a;
          e = (r = i.session) !== null && r !== void 0 ? r : void 0
        }
        if (!(e != null && e.refresh_token)) throw new Gc;
        const {
          session: o,
          error: s
        } = await this._callRefreshToken(e.refresh_token);
        return s ? {
          data: {
            user: null,
            session: null
          },
          error: s
        } : o ? {
          data: {
            user: o.user,
            session: o
          },
          error: null
        } : {
          data: {
            user: null,
            session: null
          },
          error: null
        }
      })
    } catch (n) {
      if (ot(n)) return {
        data: {
          user: null,
          session: null
        },
        error: n
      };
      throw n
    }
  }
  async _getSessionFromURL(e) {
    try {
      if (!Cs()) throw new ug("No browser detected.");
      if (this.flowType === "implicit" && !this._isImplicitGrantFlow()) throw new ug("Not a valid implicit grant flow url.");
      if (this.flowType == "pkce" && !e) throw new B$("Not a valid PKCE flow url.");
      const n = rw(window.location.href);
      if (e) {
        if (!n.code) throw new B$("No code detected.");
        const {
          data: v,
          error: _
        } = await this._exchangeCodeForSession(n.code);
        if (_) throw _;
        const S = new URL(window.location.href);
        return S.searchParams.delete("code"), window.history.replaceState(window.history.state, "", S.toString()), {
          data: {
            session: v.session,
            redirectType: null
          },
          error: null
        }
      }
      if (n.error || n.error_description || n.error_code) throw new ug(n.error_description || "Error in URL with unspecified error_description", {
        error: n.error || "unspecified_error",
        code: n.error_code || "unspecified_code"
      });
      const {
        provider_token: r,
        provider_refresh_token: o,
        access_token: s,
        refresh_token: i,
        expires_in: a,
        expires_at: c,
        token_type: l
      } = n;
      if (!s || !a || !i || !l) throw new ug("No session defined in URL");
      const u = Math.round(Date.now() / 1e3),
        d = parseInt(a);
      let f = u + d;
      c && (f = parseInt(c));
      const h = f - u;
      h * 1e3 <= Sd && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${h}s, should have been closer to ${d}s`);
      const m = f - d;
      u - m >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", m, f, u) : u - m < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clok for skew", m, f, u);
      const {
        data: p,
        error: b
      } = await this._getUser(s);
      if (b) throw b;
      const w = {
        provider_token: r,
        provider_refresh_token: o,
        access_token: s,
        expires_in: d,
        expires_at: f,
        refresh_token: i,
        token_type: l,
        user: p.user
      };
      return window.location.hash = "", this._debug("#_getSessionFromURL()", "clearing window.location.hash"), {
        data: {
          session: w,
          redirectType: n.type
        },
        error: null
      }
    } catch (n) {
      if (ot(n)) return {
        data: {
          session: null,
          redirectType: null
        },
        error: n
      };
      throw n
    }
  }
  _isImplicitGrantFlow() {
    const e = rw(window.location.href);
    return !!(Cs() && (e.access_token || e.error_description))
  }
  async _isPKCEFlow() {
    const e = rw(window.location.href),
      n = await cg(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && n)
  }
  async signOut(e = {
    scope: "global"
  }) {
    return await this.initializePromise, await this._acquireLock(-1, async () => await this._signOut(e))
  }
  async _signOut({
    scope: e
  } = {
    scope: "global"
  }) {
    return await this._useSession(async n => {
      var r;
      const {
        data: o,
        error: s
      } = n;
      if (s) return {
        error: s
      };
      const i = (r = o.session) === null || r === void 0 ? void 0 : r.access_token;
      if (i) {
        const {
          error: a
        } = await this.admin.signOut(i, e);
        if (a && !(vge(a) && (a.status === 404 || a.status === 401))) return {
          error: a
        }
      }
      return e !== "others" && (await this._removeSession(), await ow(this.storage, `${this.storageKey}-code-verifier`), await this._notifyAllSubscribers("SIGNED_OUT", null)), {
        error: null
      }
    })
  }
  onAuthStateChange(e) {
    const n = lge(),
      r = {
        id: n,
        callback: e,
        unsubscribe: () => {
          this._debug("#unsubscribe()", "state change callback with id removed", n), this.stateChangeEmitters.delete(n)
        }
      };
    return this._debug("#onAuthStateChange()", "registered callback with id", n), this.stateChangeEmitters.set(n, r), (async () => (await this.initializePromise, await this._acquireLock(-1, async () => {
      this._emitInitialSession(n)
    })))(), {
      data: {
        subscription: r
      }
    }
  }
  async _emitInitialSession(e) {
    return await this._useSession(async n => {
      var r, o;
      try {
        const {
          data: {
            session: s
          },
          error: i
        } = n;
        if (i) throw i;
        await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0 ? void 0 : r.callback("INITIAL_SESSION", s)), this._debug("INITIAL_SESSION", "callback id", e, "session", s)
      } catch (s) {
        await ((o = this.stateChangeEmitters.get(e)) === null || o === void 0 ? void 0 : o.callback("INITIAL_SESSION", null)), this._debug("INITIAL_SESSION", "callback id", e, "error", s), console.error(s)
      }
    })
  }
  async resetPasswordForEmail(e, n = {}) {
    let r = null,
      o = null;
    if (this.flowType === "pkce") {
      const s = bd();
      await Kc(this.storage, `${this.storageKey}-code-verifier`, s), r = await wd(s), o = s === r ? "plain" : "s256"
    }
    try {
      return await it(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: r,
          code_challenge_method: o,
          gotrue_meta_security: {
            captcha_token: n.captchaToken
          }
        },
        headers: this.headers,
        redirectTo: n.redirectTo
      })
    } catch (s) {
      if (ot(s)) return {
        data: null,
        error: s
      };
      throw s
    }
  }
  async _refreshAccessToken(e) {
    const n = `#_refreshAccessToken(${e.substring(0,5)}...)`;
    this._debug(n, "begin");
    try {
      const r = Date.now();
      return await hge(async o => (await fge(o * 200), this._debug(n, "refreshing attempt", o), await it(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
        body: {
          refresh_token: e
        },
        headers: this.headers,
        xform: di
      })), (o, s, i) => i && i.error && U$(i.error) && Date.now() + (o + 1) * 200 - r < Sd)
    } catch (r) {
      if (this._debug(n, "error", r), ot(r)) return {
        data: {
          session: null,
          user: null
        },
        error: r
      };
      throw r
    } finally {
      this._debug(n, "end")
    }
  }
  _isValidSession(e) {
    return typeof e == "object" && e !== null && "access_token" in e && "refresh_token" in e && "expires_at" in e
  }
  async _handleProviderSignIn(e, n) {
    const r = await this._getUrlForProvider(e, {
      redirectTo: n.redirectTo,
      scopes: n.scopes,
      queryParams: n.queryParams
    });
    return this._debug("#_handleProviderSignIn()", "provider", e, "options", n, "url", r), Cs() && !n.skipBrowserRedirect && window.location.assign(r), {
      data: {
        provider: e,
        url: r
      },
      error: null
    }
  }
  async _recoverAndRefresh() {
    var e;
    const n = "#_recoverAndRefresh()";
    this._debug(n, "begin");
    try {
      const r = await cg(this.storage, this.storageKey);
      if (this._debug(n, "session from storage", r), !this._isValidSession(r)) {
        this._debug(n, "session is not valid"), r !== null && await this._removeSession();
        return
      }
      const o = Math.round(Date.now() / 1e3),
        s = ((e = r.expires_at) !== null && e !== void 0 ? e : 1 / 0) < o + H$;
      if (this._debug(n, `session has${s?"":" not"} expired with margin of ${H$}s`), s) {
        if (this.autoRefreshToken && r.refresh_token) {
          const {
            error: i
          } = await this._callRefreshToken(r.refresh_token);
          i && (console.error(i), U$(i) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", i), await this._removeSession()))
        }
      } else await this._notifyAllSubscribers("SIGNED_IN", r)
    } catch (r) {
      this._debug(n, "error", r), console.error(r);
      return
    } finally {
      this._debug(n, "end")
    }
  }
  async _callRefreshToken(e) {
    var n, r;
    if (!e) throw new Gc;
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const o = `#_callRefreshToken(${e.substring(0,5)}...)`;
    this._debug(o, "begin");
    try {
      this.refreshingDeferred = new Hv;
      const {
        data: s,
        error: i
      } = await this._refreshAccessToken(e);
      if (i) throw i;
      if (!s.session) throw new Gc;
      await this._saveSession(s.session), await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
      const a = {
        session: s.session,
        error: null
      };
      return this.refreshingDeferred.resolve(a), a
    } catch (s) {
      if (this._debug(o, "error", s), ot(s)) {
        const i = {
          session: null,
          error: s
        };
        return (n = this.refreshingDeferred) === null || n === void 0 || n.resolve(i), i
      }
      throw (r = this.refreshingDeferred) === null || r === void 0 || r.reject(s), s
    } finally {
      this.refreshingDeferred = null, this._debug(o, "end")
    }
  }
  async _notifyAllSubscribers(e, n, r = !0) {
    const o = `#_notifyAllSubscribers(${e})`;
    this._debug(o, "begin", n, `broadcast = ${r}`);
    try {
      this.broadcastChannel && r && this.broadcastChannel.postMessage({
        event: e,
        session: n
      });
      const s = [],
        i = Array.from(this.stateChangeEmitters.values()).map(async a => {
          try {
            await a.callback(e, n)
          } catch (c) {
            s.push(c)
          }
        });
      if (await Promise.all(i), s.length > 0) {
        for (let a = 0; a < s.length; a += 1) console.error(s[a]);
        throw s[0]
      }
    } finally {
      this._debug(o, "end")
    }
  }
  async _saveSession(e) {
    this._debug("#_saveSession()", e), await this._persistSession(e)
  }
  _persistSession(e) {
    return this._debug("#_persistSession()", e), Kc(this.storage, this.storageKey, e)
  }
  async _removeSession() {
    this._debug("#_removeSession()"), await ow(this.storage, this.storageKey)
  }
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e && Cs() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
    } catch (n) {
      console.error("removing visibilitychange callback failed", n)
    }
  }
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const e = setInterval(() => this._autoRefreshTokenTick(), Sd);
    this.autoRefreshTicker = e, e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e), setTimeout(async () => {
      await this.initializePromise, await this._autoRefreshTokenTick()
    }, 0)
  }
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const e = this.autoRefreshTicker;
    this.autoRefreshTicker = null, e && clearInterval(e)
  }
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh()
  }
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh()
  }
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async n => {
              const {
                data: {
                  session: r
                }
              } = n;
              if (!r || !r.refresh_token || !r.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return
              }
              const o = Math.floor((r.expires_at * 1e3 - e) / Sd);
              this._debug("#_autoRefreshTokenTick()", `access token expires in ${o} ticks, a tick lasts ${Sd}ms, refresh threshold is ${W$} ticks`), o <= W$ && await this._callRefreshToken(r.refresh_token)
            })
          } catch (n) {
            console.error("Auto refresh tick failed with error. This is likely a transient error.", n)
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end")
        }
      })
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof Mge) this._debug("auto refresh token tick lock not available");
      else throw e
    }
  }
  async _handleVisibilityChange() {
    if (this._debug("#_handleVisibilityChange()"), !Cs() || !(window != null && window.addEventListener)) return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1), window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback), await this._onVisibilityChanged(!0)
    } catch (e) {
      console.error("_handleVisibilityChange", e)
    }
  }
  async _onVisibilityChanged(e) {
    const n = `#_onVisibilityChanged(${e})`;
    this._debug(n, "visibilityState", document.visibilityState), document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(), e || (await this.initializePromise, await this._acquireLock(-1, async () => {
      if (document.visibilityState !== "visible") {
        this._debug(n, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
        return
      }
      await this._recoverAndRefresh()
    }))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
  }
  async _getUrlForProvider(e, n) {
    const r = [`provider=${encodeURIComponent(e)}`];
    if (n != null && n.redirectTo && r.push(`redirect_to=${encodeURIComponent(n.redirectTo)}`), n != null && n.scopes && r.push(`scopes=${encodeURIComponent(n.scopes)}`), this.flowType === "pkce") {
      const o = bd();
      await Kc(this.storage, `${this.storageKey}-code-verifier`, o);
      const s = await wd(o),
        i = o === s ? "plain" : "s256";
      this._debug("PKCE", "code verifier", `${o.substring(0,5)}...`, "code challenge", s, "method", i);
      const a = new URLSearchParams({
        code_challenge: `${encodeURIComponent(s)}`,
        code_challenge_method: `${encodeURIComponent(i)}`
      });
      r.push(a.toString())
    }
    if (n != null && n.queryParams) {
      const o = new URLSearchParams(n.queryParams);
      r.push(o.toString())
    }
    return `${this.url}/authorize?${r.join("&")}`
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async n => {
        var r;
        const {
          data: o,
          error: s
        } = n;
        return s ? {
          data: null,
          error: s
        } : await it(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
          headers: this.headers,
          jwt: (r = o == null ? void 0 : o.session) === null || r === void 0 ? void 0 : r.access_token
        })
      })
    } catch (n) {
      if (ot(n)) return {
        data: null,
        error: n
      };
      throw n
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async n => {
        var r, o;
        const {
          data: s,
          error: i
        } = n;
        if (i) return {
          data: null,
          error: i
        };
        const {
          data: a,
          error: c
        } = await it(this.fetch, "POST", `${this.url}/factors`, {
          body: {
            friendly_name: e.friendlyName,
            factor_type: e.factorType,
            issuer: e.issuer
          },
          headers: this.headers,
          jwt: (r = s == null ? void 0 : s.session) === null || r === void 0 ? void 0 : r.access_token
        });
        return c ? {
          data: null,
          error: c
        } : (!((o = a == null ? void 0 : a.totp) === null || o === void 0) && o.qr_code && (a.totp.qr_code = `data:image/svg+xml;utf-8,${a.totp.qr_code}`), {
          data: a,
          error: null
        })
      })
    } catch (n) {
      if (ot(n)) return {
        data: null,
        error: n
      };
      throw n
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async n => {
          var r;
          const {
            data: o,
            error: s
          } = n;
          if (s) return {
            data: null,
            error: s
          };
          const {
            data: i,
            error: a
          } = await it(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
            body: {
              code: e.code,
              challenge_id: e.challengeId
            },
            headers: this.headers,
            jwt: (r = o == null ? void 0 : o.session) === null || r === void 0 ? void 0 : r.access_token
          });
          return a ? {
            data: null,
            error: a
          } : (await this._saveSession(Object.assign({
            expires_at: Math.round(Date.now() / 1e3) + i.expires_in
          }, i)), await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", i), {
            data: i,
            error: a
          })
        })
      } catch (n) {
        if (ot(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async n => {
          var r;
          const {
            data: o,
            error: s
          } = n;
          return s ? {
            data: null,
            error: s
          } : await it(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
            headers: this.headers,
            jwt: (r = o == null ? void 0 : o.session) === null || r === void 0 ? void 0 : r.access_token
          })
        })
      } catch (n) {
        if (ot(n)) return {
          data: null,
          error: n
        };
        throw n
      }
    })
  }
  async _challengeAndVerify(e) {
    const {
      data: n,
      error: r
    } = await this._challenge({
      factorId: e.factorId
    });
    return r ? {
      data: null,
      error: r
    } : await this._verify({
      factorId: e.factorId,
      challengeId: n.id,
      code: e.code
    })
  }
  async _listFactors() {
    const {
      data: {
        user: e
      },
      error: n
    } = await this.getUser();
    if (n) return {
      data: null,
      error: n
    };
    const r = (e == null ? void 0 : e.factors) || [],
      o = r.filter(s => s.factor_type === "totp" && s.status === "verified");
    return {
      data: {
        all: r,
        totp: o
      },
      error: null
    }
  }
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(-1, async () => await this._useSession(async e => {
      var n, r;
      const {
        data: {
          session: o
        },
        error: s
      } = e;
      if (s) return {
        data: null,
        error: s
      };
      if (!o) return {
        data: {
          currentLevel: null,
          nextLevel: null,
          currentAuthenticationMethods: []
        },
        error: null
      };
      const i = this._decodeJWT(o.access_token);
      let a = null;
      i.aal && (a = i.aal);
      let c = a;
      ((r = (n = o.user.factors) === null || n === void 0 ? void 0 : n.filter(d => d.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (c = "aal2");
      const u = i.amr || [];
      return {
        data: {
          currentLevel: a,
          nextLevel: c,
          currentAuthenticationMethods: u
        },
        error: null
      }
    }))
  }
}
Yf.nextInstanceID = 0;
class Nge extends Yf {
  constructor(e) {
    super(e)
  }
}
var Lge = globalThis && globalThis.__awaiter || function(t, e, n, r) {
  function o(s) {
    return s instanceof n ? s : new n(function(i) {
      i(s)
    })
  }
  return new(n || (n = Promise))(function(s, i) {
    function a(u) {
      try {
        l(r.next(u))
      } catch (d) {
        i(d)
      }
    }

    function c(u) {
      try {
        l(r.throw(u))
      } catch (d) {
        i(d)
      }
    }

    function l(u) {
      u.done ? s(u.value) : o(u.value).then(a, c)
    }
    l((r = r.apply(t, e || [])).next())
  })
};
const Fge = {
    headers: tge
  },
  Bge = {
    schema: "public"
  },
  Uge = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
  },
  zge = {};
class Hge {
  constructor(e, n, r) {
    var o, s, i, a, c, l, u, d;
    if (this.supabaseUrl = e, this.supabaseKey = n, !e) throw new Error("supabaseUrl is required.");
    if (!n) throw new Error("supabaseKey is required.");
    const f = ige(e);
    this.realtimeUrl = `${f}/realtime/v1`.replace(/^http/i, "ws"), this.authUrl = `${f}/auth/v1`, this.storageUrl = `${f}/storage/v1`, this.functionsUrl = `${f}/functions/v1`;
    const h = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`,
      m = {
        db: Bge,
        realtime: zge,
        auth: Object.assign(Object.assign({}, Uge), {
          storageKey: h
        }),
        global: Fge
      },
      p = age(r ?? {}, m);
    this.storageKey = (s = (o = p.auth) === null || o === void 0 ? void 0 : o.storageKey) !== null && s !== void 0 ? s : "", this.headers = (a = (i = p.global) === null || i === void 0 ? void 0 : i.headers) !== null && a !== void 0 ? a : {}, this.auth = this._initSupabaseAuthClient((c = p.auth) !== null && c !== void 0 ? c : {}, this.headers, (l = p.global) === null || l === void 0 ? void 0 : l.fetch), this.fetch = sge(n, this._getAccessToken.bind(this), (u = p.global) === null || u === void 0 ? void 0 : u.fetch), this.realtime = this._initRealtimeClient(Object.assign({
      headers: this.headers
    }, p.realtime)), this.rest = new BE(`${f}/rest/v1`, {
      headers: this.headers,
      schema: (d = p.db) === null || d === void 0 ? void 0 : d.schema,
      fetch: this.fetch
    }), this._listenForAuthEvents()
  }
  get functions() {
    return new tpe(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch
    })
  }
  get storage() {
    return new Qpe(this.storageUrl, this.headers, this.fetch)
  }
  from(e) {
    return this.rest.from(e)
  }
  schema(e) {
    return this.rest.schema(e)
  }
  rpc(e, n = {}, r) {
    return this.rest.rpc(e, n, r)
  }
  channel(e, n = {
    config: {}
  }) {
    return this.realtime.channel(e, n)
  }
  getChannels() {
    return this.realtime.getChannels()
  }
  removeChannel(e) {
    return this.realtime.removeChannel(e)
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels()
  }
  _getAccessToken() {
    var e, n;
    return Lge(this, void 0, void 0, function*() {
      const {
        data: r
      } = yield this.auth.getSession();
      return (n = (e = r.session) === null || e === void 0 ? void 0 : e.access_token) !== null && n !== void 0 ? n : null
    })
  }
  _initSupabaseAuthClient({
    autoRefreshToken: e,
    persistSession: n,
    detectSessionInUrl: r,
    storage: o,
    storageKey: s,
    flowType: i,
    debug: a
  }, c, l) {
    const u = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`
    };
    return new Nge({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, u), c),
      storageKey: s,
      autoRefreshToken: e,
      persistSession: n,
      detectSessionInUrl: r,
      storage: o,
      flowType: i,
      debug: a,
      fetch: l
    })
  }
  _initRealtimeClient(e) {
    return new Upe(this.realtimeUrl, Object.assign(Object.assign({}, e), {
      params: Object.assign({
        apikey: this.supabaseKey
      }, e == null ? void 0 : e.params)
    }))
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((n, r) => {
      this._handleTokenChanged(n, "CLIENT", r == null ? void 0 : r.access_token)
    })
  }
  _handleTokenChanged(e, n, r) {
    (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") && this.changedAccessToken !== r ? (this.realtime.setAuth(r ?? null), this.changedAccessToken = r) : e === "SIGNED_OUT" && (this.realtime.setAuth(this.supabaseKey), n == "STORAGE" && this.auth.signOut(), this.changedAccessToken = void 0)
  }
}
const Vge = (t, e, n) => new Hge(t, e, n);

function V4(t) {
  const e = t.headers.get("x-forwarded-host"),
    n = t.headers.get("x-forwarded-proto");
  return (e && n ? `${n}://${e}` : null) ?? t.headers.get("origin") ?? new URL(t.url).origin
}
var ct;
(function(t) {
  t.assertEqual = o => o;

  function e(o) {}
  t.assertIs = e;

  function n(o) {
    throw new Error
  }
  t.assertNever = n, t.arrayToEnum = o => {
    const s = {};
    for (const i of o) s[i] = i;
    return s
  }, t.getValidEnumValues = o => {
    const s = t.objectKeys(o).filter(a => typeof o[o[a]] != "number"),
      i = {};
    for (const a of s) i[a] = o[a];
    return t.objectValues(i)
  }, t.objectValues = o => t.objectKeys(o).map(function(s) {
    return o[s]
  }), t.objectKeys = typeof Object.keys == "function" ? o => Object.keys(o) : o => {
    const s = [];
    for (const i in o) Object.prototype.hasOwnProperty.call(o, i) && s.push(i);
    return s
  }, t.find = (o, s) => {
    for (const i of o)
      if (s(i)) return i
  }, t.isInteger = typeof Number.isInteger == "function" ? o => Number.isInteger(o) : o => typeof o == "number" && isFinite(o) && Math.floor(o) === o;

  function r(o, s = " | ") {
    return o.map(i => typeof i == "string" ? `'${i}'` : i).join(s)
  }
  t.joinValues = r, t.jsonStringifyReplacer = (o, s) => typeof s == "bigint" ? s.toString() : s
})(ct || (ct = {}));
var B_;
(function(t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n
  })
})(B_ || (B_ = {}));
const ue = ct.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
  Ei = t => {
    switch (typeof t) {
      case "undefined":
        return ue.undefined;
      case "string":
        return ue.string;
      case "number":
        return isNaN(t) ? ue.nan : ue.number;
      case "boolean":
        return ue.boolean;
      case "function":
        return ue.function;
      case "bigint":
        return ue.bigint;
      case "symbol":
        return ue.symbol;
      case "object":
        return Array.isArray(t) ? ue.array : t === null ? ue.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? ue.promise : typeof Map < "u" && t instanceof Map ? ue.map : typeof Set < "u" && t instanceof Set ? ue.set : typeof Date < "u" && t instanceof Date ? ue.date : ue.object;
      default:
        return ue.unknown
    }
  },
  re = ct.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
  Wge = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Do extends Error {
  constructor(e) {
    super(), this.issues = [], this.addIssue = r => {
      this.issues = [...this.issues, r]
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r]
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = e
  }
  get errors() {
    return this.issues
  }
  format(e) {
    const n = e || function(s) {
        return s.message
      },
      r = {
        _errors: []
      },
      o = s => {
        for (const i of s.issues)
          if (i.code === "invalid_union") i.unionErrors.map(o);
          else if (i.code === "invalid_return_type") o(i.returnTypeError);
        else if (i.code === "invalid_arguments") o(i.argumentsError);
        else if (i.path.length === 0) r._errors.push(n(i));
        else {
          let a = r,
            c = 0;
          for (; c < i.path.length;) {
            const l = i.path[c];
            c === i.path.length - 1 ? (a[l] = a[l] || {
              _errors: []
            }, a[l]._errors.push(n(i))) : a[l] = a[l] || {
              _errors: []
            }, a = a[l], c++
          }
        }
      };
    return o(this), r
  }
  toString() {
    return this.message
  }
  get message() {
    return JSON.stringify(this.issues, ct.jsonStringifyReplacer, 2)
  }
  get isEmpty() {
    return this.issues.length === 0
  }
  flatten(e = n => n.message) {
    const n = {},
      r = [];
    for (const o of this.issues) o.path.length > 0 ? (n[o.path[0]] = n[o.path[0]] || [], n[o.path[0]].push(e(o))) : r.push(e(o));
    return {
      formErrors: r,
      fieldErrors: n
    }
  }
  get formErrors() {
    return this.flatten()
  }
}
Do.create = t => new Do(t);
const qf = (t, e) => {
  let n;
  switch (t.code) {
    case re.invalid_type:
      t.received === ue.undefined ? n = "Required" : n = `Expected ${t.expected}, received ${t.received}`;
      break;
    case re.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(t.expected,ct.jsonStringifyReplacer)}`;
      break;
    case re.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${ct.joinValues(t.keys,", ")}`;
      break;
    case re.invalid_union:
      n = "Invalid input";
      break;
    case re.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${ct.joinValues(t.options)}`;
      break;
    case re.invalid_enum_value:
      n = `Invalid enum value. Expected ${ct.joinValues(t.options)}, received '${t.received}'`;
      break;
    case re.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case re.invalid_return_type:
      n = "Invalid function return type";
      break;
    case re.invalid_date:
      n = "Invalid date";
      break;
    case re.invalid_string:
      typeof t.validation == "object" ? "includes" in t.validation ? (n = `Invalid input: must include "${t.validation.includes}"`, typeof t.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? n = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? n = `Invalid input: must end with "${t.validation.endsWith}"` : ct.assertNever(t.validation) : t.validation !== "regex" ? n = `Invalid ${t.validation}` : n = "Invalid";
      break;
    case re.too_small:
      t.type === "array" ? n = `Array must contain ${t.exact?"exactly":t.inclusive?"at least":"more than"} ${t.minimum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact?"exactly":t.inclusive?"at least":"over"} ${t.minimum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${t.minimum}` : t.type === "date" ? n = `Date must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${new Date(Number(t.minimum))}` : n = "Invalid input";
      break;
    case re.too_big:
      t.type === "array" ? n = `Array must contain ${t.exact?"exactly":t.inclusive?"at most":"less than"} ${t.maximum} element(s)` : t.type === "string" ? n = `String must contain ${t.exact?"exactly":t.inclusive?"at most":"under"} ${t.maximum} character(s)` : t.type === "number" ? n = `Number must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : t.type === "bigint" ? n = `BigInt must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : t.type === "date" ? n = `Date must be ${t.exact?"exactly":t.inclusive?"smaller than or equal to":"smaller than"} ${new Date(Number(t.maximum))}` : n = "Invalid input";
      break;
    case re.custom:
      n = "Invalid input";
      break;
    case re.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case re.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case re.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = e.defaultError, ct.assertNever(t)
  }
  return {
    message: n
  }
};
let W4 = qf;

function Kge(t) {
  W4 = t
}

function ny() {
  return W4
}
const ry = t => {
    const {
      data: e,
      path: n,
      errorMaps: r,
      issueData: o
    } = t, s = [...n, ...o.path || []], i = {
      ...o,
      path: s
    };
    let a = "";
    const c = r.filter(l => !!l).slice().reverse();
    for (const l of c) a = l(i, {
      data: e,
      defaultError: a
    }).message;
    return {
      ...o,
      path: s,
      message: o.message || a
    }
  },
  Gge = [];

function de(t, e) {
  const n = ry({
    issueData: e,
    data: t.data,
    path: t.path,
    errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, ny(), qf].filter(r => !!r)
  });
  t.common.issues.push(n)
}
class Yn {
  constructor() {
    this.value = "valid"
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty")
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted")
  }
  static mergeArray(e, n) {
    const r = [];
    for (const o of n) {
      if (o.status === "aborted") return Ue;
      o.status === "dirty" && e.dirty(), r.push(o.value)
    }
    return {
      status: e.value,
      value: r
    }
  }
  static async mergeObjectAsync(e, n) {
    const r = [];
    for (const o of n) r.push({
      key: await o.key,
      value: await o.value
    });
    return Yn.mergeObjectSync(e, r)
  }
  static mergeObjectSync(e, n) {
    const r = {};
    for (const o of n) {
      const {
        key: s,
        value: i
      } = o;
      if (s.status === "aborted" || i.status === "aborted") return Ue;
      s.status === "dirty" && e.dirty(), i.status === "dirty" && e.dirty(), s.value !== "__proto__" && (typeof i.value < "u" || o.alwaysSet) && (r[s.value] = i.value)
    }
    return {
      status: e.value,
      value: r
    }
  }
}
const Ue = Object.freeze({
    status: "aborted"
  }),
  K4 = t => ({
    status: "dirty",
    value: t
  }),
  sr = t => ({
    status: "valid",
    value: t
  }),
  U_ = t => t.status === "aborted",
  z_ = t => t.status === "dirty",
  Xf = t => t.status === "valid",
  oy = t => typeof Promise < "u" && t instanceof Promise;
var ke;
(function(t) {
  t.errToObj = e => typeof e == "string" ? {
    message: e
  } : e || {}, t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
})(ke || (ke = {}));
class gs {
  constructor(e, n, r, o) {
    this._cachedPath = [], this.parent = e, this.data = n, this._path = r, this._key = o
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath
  }
}
const K$ = (t, e) => {
  if (Xf(e)) return {
    success: !0,
    data: e.value
  };
  if (!t.common.issues.length) throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const n = new Do(t.common.issues);
      return this._error = n, this._error
    }
  }
};

function ze(t) {
  if (!t) return {};
  const {
    errorMap: e,
    invalid_type_error: n,
    required_error: r,
    description: o
  } = t;
  if (e && (n || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return e ? {
    errorMap: e,
    description: o
  } : {
    errorMap: (i, a) => i.code !== "invalid_type" ? {
      message: a.defaultError
    } : typeof a.data > "u" ? {
      message: r ?? a.defaultError
    } : {
      message: n ?? a.defaultError
    },
    description: o
  }
}
class Xe {
  constructor(e) {
    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this)
  }
  get description() {
    return this._def.description
  }
  _getType(e) {
    return Ei(e.data)
  }
  _getOrReturnCtx(e, n) {
    return n || {
      common: e.parent.common,
      data: e.data,
      parsedType: Ei(e.data),
      schemaErrorMap: this._def.errorMap,
      path: e.path,
      parent: e.parent
    }
  }
  _processInputParams(e) {
    return {
      status: new Yn,
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: Ei(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent
      }
    }
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (oy(n)) throw new Error("Synchronous parse encountered promise.");
    return n
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n)
  }
  parse(e, n) {
    const r = this.safeParse(e, n);
    if (r.success) return r.data;
    throw r.error
  }
  safeParse(e, n) {
    var r;
    const o = {
        common: {
          issues: [],
          async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Ei(e)
      },
      s = this._parseSync({
        data: e,
        path: o.path,
        parent: o
      });
    return K$(o, s)
  }
  async parseAsync(e, n) {
    const r = await this.safeParseAsync(e, n);
    if (r.success) return r.data;
    throw r.error
  }
  async safeParseAsync(e, n) {
    const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: Ei(e)
      },
      o = this._parse({
        data: e,
        path: r.path,
        parent: r
      }),
      s = await (oy(o) ? o : Promise.resolve(o));
    return K$(r, s)
  }
  refine(e, n) {
    const r = o => typeof n == "string" || typeof n > "u" ? {
      message: n
    } : typeof n == "function" ? n(o) : n;
    return this._refinement((o, s) => {
      const i = e(o),
        a = () => s.addIssue({
          code: re.custom,
          ...r(o)
        });
      return typeof Promise < "u" && i instanceof Promise ? i.then(c => c ? !0 : (a(), !1)) : i ? !0 : (a(), !1)
    })
  }
  refinement(e, n) {
    return this._refinement((r, o) => e(r) ? !0 : (o.addIssue(typeof n == "function" ? n(r, o) : n), !1))
  }
  _refinement(e) {
    return new Bo({
      schema: this,
      typeName: Re.ZodEffects,
      effect: {
        type: "refinement",
        refinement: e
      }
    })
  }
  superRefine(e) {
    return this._refinement(e)
  }
  optional() {
    return Hs.create(this, this._def)
  }
  nullable() {
    return sc.create(this, this._def)
  }
  nullish() {
    return this.nullable().optional()
  }
  array() {
    return No.create(this, this._def)
  }
  promise() {
    return uu.create(this, this._def)
  }
  or(e) {
    return eh.create([this, e], this._def)
  }
  and(e) {
    return th.create(this, e, this._def)
  }
  transform(e) {
    return new Bo({
      ...ze(this._def),
      schema: this,
      typeName: Re.ZodEffects,
      effect: {
        type: "transform",
        transform: e
      }
    })
  }
  default (e) {
    const n = typeof e == "function" ? e : () => e;
    return new ih({
      ...ze(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Re.ZodDefault
    })
  }
  brand() {
    return new Y4({
      typeName: Re.ZodBranded,
      type: this,
      ...ze(this._def)
    })
  } catch (e) {
    const n = typeof e == "function" ? e : () => e;
    return new cy({
      ...ze(this._def),
      innerType: this,
      catchValue: n,
      typeName: Re.ZodCatch
    })
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e
    })
  }
  pipe(e) {
    return Uh.create(this, e)
  }
  readonly() {
    return uy.create(this)
  }
  isOptional() {
    return this.safeParse(void 0).success
  }
  isNullable() {
    return this.safeParse(null).success
  }
}
const Yge = /^c[^\s-]{8,}$/i,
  qge = /^[a-z][a-z0-9]*$/,
  Xge = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  Zge = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  Jge = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  Qge = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let iw;
const eme = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  tme = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  nme = t => t.precision ? t.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${t.precision}}Z$`) : t.precision === 0 ? t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : t.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");

function rme(t, e) {
  return !!((e === "v4" || !e) && eme.test(t) || (e === "v6" || !e) && tme.test(t))
}
class $o extends Xe {
  _parse(e) {
    if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== ue.string) {
      const s = this._getOrReturnCtx(e);
      return de(s, {
        code: re.invalid_type,
        expected: ue.string,
        received: s.parsedType
      }), Ue
    }
    const r = new Yn;
    let o;
    for (const s of this._def.checks)
      if (s.kind === "min") e.data.length < s.value && (o = this._getOrReturnCtx(e, o), de(o, {
        code: re.too_small,
        minimum: s.value,
        type: "string",
        inclusive: !0,
        exact: !1,
        message: s.message
      }), r.dirty());
      else if (s.kind === "max") e.data.length > s.value && (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.too_big,
      maximum: s.value,
      type: "string",
      inclusive: !0,
      exact: !1,
      message: s.message
    }), r.dirty());
    else if (s.kind === "length") {
      const i = e.data.length > s.value,
        a = e.data.length < s.value;
      (i || a) && (o = this._getOrReturnCtx(e, o), i ? de(o, {
        code: re.too_big,
        maximum: s.value,
        type: "string",
        inclusive: !0,
        exact: !0,
        message: s.message
      }) : a && de(o, {
        code: re.too_small,
        minimum: s.value,
        type: "string",
        inclusive: !0,
        exact: !0,
        message: s.message
      }), r.dirty())
    } else if (s.kind === "email") Jge.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "email",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "emoji") iw || (iw = new RegExp(Qge, "u")), iw.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "emoji",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "uuid") Zge.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "uuid",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "cuid") Yge.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "cuid",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "cuid2") qge.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "cuid2",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "ulid") Xge.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "ulid",
      code: re.invalid_string,
      message: s.message
    }), r.dirty());
    else if (s.kind === "url") try {
      new URL(e.data)
    } catch {
      o = this._getOrReturnCtx(e, o), de(o, {
        validation: "url",
        code: re.invalid_string,
        message: s.message
      }), r.dirty()
    } else s.kind === "regex" ? (s.regex.lastIndex = 0, s.regex.test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "regex",
      code: re.invalid_string,
      message: s.message
    }), r.dirty())) : s.kind === "trim" ? e.data = e.data.trim() : s.kind === "includes" ? e.data.includes(s.value, s.position) || (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.invalid_string,
      validation: {
        includes: s.value,
        position: s.position
      },
      message: s.message
    }), r.dirty()) : s.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : s.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : s.kind === "startsWith" ? e.data.startsWith(s.value) || (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.invalid_string,
      validation: {
        startsWith: s.value
      },
      message: s.message
    }), r.dirty()) : s.kind === "endsWith" ? e.data.endsWith(s.value) || (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.invalid_string,
      validation: {
        endsWith: s.value
      },
      message: s.message
    }), r.dirty()) : s.kind === "datetime" ? nme(s).test(e.data) || (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.invalid_string,
      validation: "datetime",
      message: s.message
    }), r.dirty()) : s.kind === "ip" ? rme(e.data, s.version) || (o = this._getOrReturnCtx(e, o), de(o, {
      validation: "ip",
      code: re.invalid_string,
      message: s.message
    }), r.dirty()) : ct.assertNever(s);
    return {
      status: r.value,
      value: e.data
    }
  }
  _regex(e, n, r) {
    return this.refinement(o => e.test(o), {
      validation: n,
      code: re.invalid_string,
      ...ke.errToObj(r)
    })
  }
  _addCheck(e) {
    return new $o({
      ...this._def,
      checks: [...this._def.checks, e]
    })
  }
  email(e) {
    return this._addCheck({
      kind: "email",
      ...ke.errToObj(e)
    })
  }
  url(e) {
    return this._addCheck({
      kind: "url",
      ...ke.errToObj(e)
    })
  }
  emoji(e) {
    return this._addCheck({
      kind: "emoji",
      ...ke.errToObj(e)
    })
  }
  uuid(e) {
    return this._addCheck({
      kind: "uuid",
      ...ke.errToObj(e)
    })
  }
  cuid(e) {
    return this._addCheck({
      kind: "cuid",
      ...ke.errToObj(e)
    })
  }
  cuid2(e) {
    return this._addCheck({
      kind: "cuid2",
      ...ke.errToObj(e)
    })
  }
  ulid(e) {
    return this._addCheck({
      kind: "ulid",
      ...ke.errToObj(e)
    })
  }
  ip(e) {
    return this._addCheck({
      kind: "ip",
      ...ke.errToObj(e)
    })
  }
  datetime(e) {
    var n;
    return typeof e == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: e
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof(e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
      offset: (n = e == null ? void 0 : e.offset) !== null && n !== void 0 ? n : !1,
      ...ke.errToObj(e == null ? void 0 : e.message)
    })
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ke.errToObj(n)
    })
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ...ke.errToObj(n == null ? void 0 : n.message)
    })
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ke.errToObj(n)
    })
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ke.errToObj(n)
    })
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ke.errToObj(n)
    })
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ke.errToObj(n)
    })
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ke.errToObj(n)
    })
  }
  nonempty(e) {
    return this.min(1, ke.errToObj(e))
  }
  trim() {
    return new $o({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "trim"
      }]
    })
  }
  toLowerCase() {
    return new $o({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "toLowerCase"
      }]
    })
  }
  toUpperCase() {
    return new $o({
      ...this._def,
      checks: [...this._def.checks, {
        kind: "toUpperCase"
      }]
    })
  }
  get isDatetime() {
    return !!this._def.checks.find(e => e.kind === "datetime")
  }
  get isEmail() {
    return !!this._def.checks.find(e => e.kind === "email")
  }
  get isURL() {
    return !!this._def.checks.find(e => e.kind === "url")
  }
  get isEmoji() {
    return !!this._def.checks.find(e => e.kind === "emoji")
  }
  get isUUID() {
    return !!this._def.checks.find(e => e.kind === "uuid")
  }
  get isCUID() {
    return !!this._def.checks.find(e => e.kind === "cuid")
  }
  get isCUID2() {
    return !!this._def.checks.find(e => e.kind === "cuid2")
  }
  get isULID() {
    return !!this._def.checks.find(e => e.kind === "ulid")
  }
  get isIP() {
    return !!this._def.checks.find(e => e.kind === "ip")
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e
  }
}
$o.create = t => {
  var e;
  return new $o({
    checks: [],
    typeName: Re.ZodString,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ze(t)
  })
};

function ome(t, e) {
  const n = (t.toString().split(".")[1] || "").length,
    r = (e.toString().split(".")[1] || "").length,
    o = n > r ? n : r,
    s = parseInt(t.toFixed(o).replace(".", "")),
    i = parseInt(e.toFixed(o).replace(".", ""));
  return s % i / Math.pow(10, o)
}
class qi extends Xe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
  }
  _parse(e) {
    if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== ue.number) {
      const s = this._getOrReturnCtx(e);
      return de(s, {
        code: re.invalid_type,
        expected: ue.number,
        received: s.parsedType
      }), Ue
    }
    let r;
    const o = new Yn;
    for (const s of this._def.checks) s.kind === "int" ? ct.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.invalid_type,
      expected: "integer",
      received: "float",
      message: s.message
    }), o.dirty()) : s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.too_small,
      minimum: s.value,
      type: "number",
      inclusive: s.inclusive,
      exact: !1,
      message: s.message
    }), o.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.too_big,
      maximum: s.value,
      type: "number",
      inclusive: s.inclusive,
      exact: !1,
      message: s.message
    }), o.dirty()) : s.kind === "multipleOf" ? ome(e.data, s.value) !== 0 && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.not_multiple_of,
      multipleOf: s.value,
      message: s.message
    }), o.dirty()) : s.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.not_finite,
      message: s.message
    }), o.dirty()) : ct.assertNever(s);
    return {
      status: o.value,
      value: e.data
    }
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ke.toString(n))
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ke.toString(n))
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ke.toString(n))
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ke.toString(n))
  }
  setLimit(e, n, r, o) {
    return new qi({
      ...this._def,
      checks: [...this._def.checks, {
        kind: e,
        value: n,
        inclusive: r,
        message: ke.toString(o)
      }]
    })
  }
  _addCheck(e) {
    return new qi({
      ...this._def,
      checks: [...this._def.checks, e]
    })
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ke.toString(e)
    })
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ke.toString(e)
    })
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ke.toString(e)
    })
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ke.toString(e)
    })
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ke.toString(e)
    })
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ke.toString(n)
    })
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ke.toString(e)
    })
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ke.toString(e)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ke.toString(e)
    })
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e
  }
  get isInt() {
    return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && ct.isInteger(e.value))
  }
  get isFinite() {
    let e = null,
      n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
    }
    return Number.isFinite(n) && Number.isFinite(e)
  }
}
qi.create = t => new qi({
  checks: [],
  typeName: Re.ZodNumber,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ze(t)
});
class Xi extends Xe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte
  }
  _parse(e) {
    if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== ue.bigint) {
      const s = this._getOrReturnCtx(e);
      return de(s, {
        code: re.invalid_type,
        expected: ue.bigint,
        received: s.parsedType
      }), Ue
    }
    let r;
    const o = new Yn;
    for (const s of this._def.checks) s.kind === "min" ? (s.inclusive ? e.data < s.value : e.data <= s.value) && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.too_small,
      type: "bigint",
      minimum: s.value,
      inclusive: s.inclusive,
      message: s.message
    }), o.dirty()) : s.kind === "max" ? (s.inclusive ? e.data > s.value : e.data >= s.value) && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.too_big,
      type: "bigint",
      maximum: s.value,
      inclusive: s.inclusive,
      message: s.message
    }), o.dirty()) : s.kind === "multipleOf" ? e.data % s.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), de(r, {
      code: re.not_multiple_of,
      multipleOf: s.value,
      message: s.message
    }), o.dirty()) : ct.assertNever(s);
    return {
      status: o.value,
      value: e.data
    }
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ke.toString(n))
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ke.toString(n))
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ke.toString(n))
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ke.toString(n))
  }
  setLimit(e, n, r, o) {
    return new Xi({
      ...this._def,
      checks: [...this._def.checks, {
        kind: e,
        value: n,
        inclusive: r,
        message: ke.toString(o)
      }]
    })
  }
  _addCheck(e) {
    return new Xi({
      ...this._def,
      checks: [...this._def.checks, e]
    })
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ke.toString(e)
    })
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ke.toString(e)
    })
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ke.toString(e)
    })
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ke.toString(e)
    })
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ke.toString(n)
    })
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e
  }
}
Xi.create = t => {
  var e;
  return new Xi({
    checks: [],
    typeName: Re.ZodBigInt,
    coerce: (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...ze(t)
  })
};
class Zf extends Xe {
  _parse(e) {
    if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== ue.boolean) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.boolean,
        received: r.parsedType
      }), Ue
    }
    return sr(e.data)
  }
}
Zf.create = t => new Zf({
  typeName: Re.ZodBoolean,
  coerce: (t == null ? void 0 : t.coerce) || !1,
  ...ze(t)
});
class rc extends Xe {
  _parse(e) {
    if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== ue.date) {
      const s = this._getOrReturnCtx(e);
      return de(s, {
        code: re.invalid_type,
        expected: ue.date,
        received: s.parsedType
      }), Ue
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return de(s, {
        code: re.invalid_date
      }), Ue
    }
    const r = new Yn;
    let o;
    for (const s of this._def.checks) s.kind === "min" ? e.data.getTime() < s.value && (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.too_small,
      message: s.message,
      inclusive: !0,
      exact: !1,
      minimum: s.value,
      type: "date"
    }), r.dirty()) : s.kind === "max" ? e.data.getTime() > s.value && (o = this._getOrReturnCtx(e, o), de(o, {
      code: re.too_big,
      message: s.message,
      inclusive: !0,
      exact: !1,
      maximum: s.value,
      type: "date"
    }), r.dirty()) : ct.assertNever(s);
    return {
      status: r.value,
      value: new Date(e.data.getTime())
    }
  }
  _addCheck(e) {
    return new rc({
      ...this._def,
      checks: [...this._def.checks, e]
    })
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ke.toString(n)
    })
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ke.toString(n)
    })
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks) n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks) n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null
  }
}
rc.create = t => new rc({
  checks: [],
  coerce: (t == null ? void 0 : t.coerce) || !1,
  typeName: Re.ZodDate,
  ...ze(t)
});
class sy extends Xe {
  _parse(e) {
    if (this._getType(e) !== ue.symbol) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.symbol,
        received: r.parsedType
      }), Ue
    }
    return sr(e.data)
  }
}
sy.create = t => new sy({
  typeName: Re.ZodSymbol,
  ...ze(t)
});
class Jf extends Xe {
  _parse(e) {
    if (this._getType(e) !== ue.undefined) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.undefined,
        received: r.parsedType
      }), Ue
    }
    return sr(e.data)
  }
}
Jf.create = t => new Jf({
  typeName: Re.ZodUndefined,
  ...ze(t)
});
class Qf extends Xe {
  _parse(e) {
    if (this._getType(e) !== ue.null) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.null,
        received: r.parsedType
      }), Ue
    }
    return sr(e.data)
  }
}
Qf.create = t => new Qf({
  typeName: Re.ZodNull,
  ...ze(t)
});
class lu extends Xe {
  constructor() {
    super(...arguments), this._any = !0
  }
  _parse(e) {
    return sr(e.data)
  }
}
lu.create = t => new lu({
  typeName: Re.ZodAny,
  ...ze(t)
});
class La extends Xe {
  constructor() {
    super(...arguments), this._unknown = !0
  }
  _parse(e) {
    return sr(e.data)
  }
}
La.create = t => new La({
  typeName: Re.ZodUnknown,
  ...ze(t)
});
class ei extends Xe {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return de(n, {
      code: re.invalid_type,
      expected: ue.never,
      received: n.parsedType
    }), Ue
  }
}
ei.create = t => new ei({
  typeName: Re.ZodNever,
  ...ze(t)
});
class iy extends Xe {
  _parse(e) {
    if (this._getType(e) !== ue.undefined) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.void,
        received: r.parsedType
      }), Ue
    }
    return sr(e.data)
  }
}
iy.create = t => new iy({
  typeName: Re.ZodVoid,
  ...ze(t)
});
class No extends Xe {
  _parse(e) {
    const {
      ctx: n,
      status: r
    } = this._processInputParams(e), o = this._def;
    if (n.parsedType !== ue.array) return de(n, {
      code: re.invalid_type,
      expected: ue.array,
      received: n.parsedType
    }), Ue;
    if (o.exactLength !== null) {
      const i = n.data.length > o.exactLength.value,
        a = n.data.length < o.exactLength.value;
      (i || a) && (de(n, {
        code: i ? re.too_big : re.too_small,
        minimum: a ? o.exactLength.value : void 0,
        maximum: i ? o.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: o.exactLength.message
      }), r.dirty())
    }
    if (o.minLength !== null && n.data.length < o.minLength.value && (de(n, {
        code: re.too_small,
        minimum: o.minLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: o.minLength.message
      }), r.dirty()), o.maxLength !== null && n.data.length > o.maxLength.value && (de(n, {
        code: re.too_big,
        maximum: o.maxLength.value,
        type: "array",
        inclusive: !0,
        exact: !1,
        message: o.maxLength.message
      }), r.dirty()), n.common.async) return Promise.all([...n.data].map((i, a) => o.type._parseAsync(new gs(n, i, n.path, a)))).then(i => Yn.mergeArray(r, i));
    const s = [...n.data].map((i, a) => o.type._parseSync(new gs(n, i, n.path, a)));
    return Yn.mergeArray(r, s)
  }
  get element() {
    return this._def.type
  }
  min(e, n) {
    return new No({
      ...this._def,
      minLength: {
        value: e,
        message: ke.toString(n)
      }
    })
  }
  max(e, n) {
    return new No({
      ...this._def,
      maxLength: {
        value: e,
        message: ke.toString(n)
      }
    })
  }
  length(e, n) {
    return new No({
      ...this._def,
      exactLength: {
        value: e,
        message: ke.toString(n)
      }
    })
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
No.create = (t, e) => new No({
  type: t,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Re.ZodArray,
  ...ze(e)
});

function Qc(t) {
  if (t instanceof Ut) {
    const e = {};
    for (const n in t.shape) {
      const r = t.shape[n];
      e[n] = Hs.create(Qc(r))
    }
    return new Ut({
      ...t._def,
      shape: () => e
    })
  } else return t instanceof No ? new No({
    ...t._def,
    type: Qc(t.element)
  }) : t instanceof Hs ? Hs.create(Qc(t.unwrap())) : t instanceof sc ? sc.create(Qc(t.unwrap())) : t instanceof ms ? ms.create(t.items.map(e => Qc(e))) : t
}
class Ut extends Xe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const e = this._def.shape(),
      n = ct.objectKeys(e);
    return this._cached = {
      shape: e,
      keys: n
    }
  }
  _parse(e) {
    if (this._getType(e) !== ue.object) {
      const l = this._getOrReturnCtx(e);
      return de(l, {
        code: re.invalid_type,
        expected: ue.object,
        received: l.parsedType
      }), Ue
    }
    const {
      status: r,
      ctx: o
    } = this._processInputParams(e), {
      shape: s,
      keys: i
    } = this._getCached(), a = [];
    if (!(this._def.catchall instanceof ei && this._def.unknownKeys === "strip"))
      for (const l in o.data) i.includes(l) || a.push(l);
    const c = [];
    for (const l of i) {
      const u = s[l],
        d = o.data[l];
      c.push({
        key: {
          status: "valid",
          value: l
        },
        value: u._parse(new gs(o, d, o.path, l)),
        alwaysSet: l in o.data
      })
    }
    if (this._def.catchall instanceof ei) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of a) c.push({
          key: {
            status: "valid",
            value: u
          },
          value: {
            status: "valid",
            value: o.data[u]
          }
        });
      else if (l === "strict") a.length > 0 && (de(o, {
        code: re.unrecognized_keys,
        keys: a
      }), r.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.")
    } else {
      const l = this._def.catchall;
      for (const u of a) {
        const d = o.data[u];
        c.push({
          key: {
            status: "valid",
            value: u
          },
          value: l._parse(new gs(o, d, o.path, u)),
          alwaysSet: u in o.data
        })
      }
    }
    return o.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const d = await u.key;
        l.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        })
      }
      return l
    }).then(l => Yn.mergeObjectSync(r, l)) : Yn.mergeObjectSync(r, c)
  }
  get shape() {
    return this._def.shape()
  }
  strict(e) {
    return ke.errToObj, new Ut({
      ...this._def,
      unknownKeys: "strict",
      ...e !== void 0 ? {
        errorMap: (n, r) => {
          var o, s, i, a;
          const c = (i = (s = (o = this._def).errorMap) === null || s === void 0 ? void 0 : s.call(o, n, r).message) !== null && i !== void 0 ? i : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (a = ke.errToObj(e).message) !== null && a !== void 0 ? a : c
          } : {
            message: c
          }
        }
      } : {}
    })
  }
  strip() {
    return new Ut({
      ...this._def,
      unknownKeys: "strip"
    })
  }
  passthrough() {
    return new Ut({
      ...this._def,
      unknownKeys: "passthrough"
    })
  }
  extend(e) {
    return new Ut({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e
      })
    })
  }
  merge(e) {
    return new Ut({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape()
      }),
      typeName: Re.ZodObject
    })
  }
  setKey(e, n) {
    return this.augment({
      [e]: n
    })
  }
  catchall(e) {
    return new Ut({
      ...this._def,
      catchall: e
    })
  }
  pick(e) {
    const n = {};
    return ct.objectKeys(e).forEach(r => {
      e[r] && this.shape[r] && (n[r] = this.shape[r])
    }), new Ut({
      ...this._def,
      shape: () => n
    })
  }
  omit(e) {
    const n = {};
    return ct.objectKeys(this.shape).forEach(r => {
      e[r] || (n[r] = this.shape[r])
    }), new Ut({
      ...this._def,
      shape: () => n
    })
  }
  deepPartial() {
    return Qc(this)
  }
  partial(e) {
    const n = {};
    return ct.objectKeys(this.shape).forEach(r => {
      const o = this.shape[r];
      e && !e[r] ? n[r] = o : n[r] = o.optional()
    }), new Ut({
      ...this._def,
      shape: () => n
    })
  }
  required(e) {
    const n = {};
    return ct.objectKeys(this.shape).forEach(r => {
      if (e && !e[r]) n[r] = this.shape[r];
      else {
        let s = this.shape[r];
        for (; s instanceof Hs;) s = s._def.innerType;
        n[r] = s
      }
    }), new Ut({
      ...this._def,
      shape: () => n
    })
  }
  keyof() {
    return G4(ct.objectKeys(this.shape))
  }
}
Ut.create = (t, e) => new Ut({
  shape: () => t,
  unknownKeys: "strip",
  catchall: ei.create(),
  typeName: Re.ZodObject,
  ...ze(e)
});
Ut.strictCreate = (t, e) => new Ut({
  shape: () => t,
  unknownKeys: "strict",
  catchall: ei.create(),
  typeName: Re.ZodObject,
  ...ze(e)
});
Ut.lazycreate = (t, e) => new Ut({
  shape: t,
  unknownKeys: "strip",
  catchall: ei.create(),
  typeName: Re.ZodObject,
  ...ze(e)
});
class eh extends Xe {
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e), r = this._def.options;

    function o(s) {
      for (const a of s)
        if (a.result.status === "valid") return a.result;
      for (const a of s)
        if (a.result.status === "dirty") return n.common.issues.push(...a.ctx.common.issues), a.result;
      const i = s.map(a => new Do(a.ctx.common.issues));
      return de(n, {
        code: re.invalid_union,
        unionErrors: i
      }), Ue
    }
    if (n.common.async) return Promise.all(r.map(async s => {
      const i = {
        ...n,
        common: {
          ...n.common,
          issues: []
        },
        parent: null
      };
      return {
        result: await s._parseAsync({
          data: n.data,
          path: n.path,
          parent: i
        }),
        ctx: i
      }
    })).then(o);
    {
      let s;
      const i = [];
      for (const c of r) {
        const l = {
            ...n,
            common: {
              ...n.common,
              issues: []
            },
            parent: null
          },
          u = c._parseSync({
            data: n.data,
            path: n.path,
            parent: l
          });
        if (u.status === "valid") return u;
        u.status === "dirty" && !s && (s = {
          result: u,
          ctx: l
        }), l.common.issues.length && i.push(l.common.issues)
      }
      if (s) return n.common.issues.push(...s.ctx.common.issues), s.result;
      const a = i.map(c => new Do(c));
      return de(n, {
        code: re.invalid_union,
        unionErrors: a
      }), Ue
    }
  }
  get options() {
    return this._def.options
  }
}
eh.create = (t, e) => new eh({
  options: t,
  typeName: Re.ZodUnion,
  ...ze(e)
});
const zg = t => t instanceof rh ? zg(t.schema) : t instanceof Bo ? zg(t.innerType()) : t instanceof oh ? [t.value] : t instanceof Zi ? t.options : t instanceof sh ? Object.keys(t.enum) : t instanceof ih ? zg(t._def.innerType) : t instanceof Jf ? [void 0] : t instanceof Qf ? [null] : null;
class Vv extends Xe {
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e);
    if (n.parsedType !== ue.object) return de(n, {
      code: re.invalid_type,
      expected: ue.object,
      received: n.parsedType
    }), Ue;
    const r = this.discriminator,
      o = n.data[r],
      s = this.optionsMap.get(o);
    return s ? n.common.async ? s._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : s._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (de(n, {
      code: re.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Ue)
  }
  get discriminator() {
    return this._def.discriminator
  }
  get options() {
    return this._def.options
  }
  get optionsMap() {
    return this._def.optionsMap
  }
  static create(e, n, r) {
    const o = new Map;
    for (const s of n) {
      const i = zg(s.shape[e]);
      if (!i) throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
      for (const a of i) {
        if (o.has(a)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);
        o.set(a, s)
      }
    }
    return new Vv({
      typeName: Re.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: o,
      ...ze(r)
    })
  }
}

function H_(t, e) {
  const n = Ei(t),
    r = Ei(e);
  if (t === e) return {
    valid: !0,
    data: t
  };
  if (n === ue.object && r === ue.object) {
    const o = ct.objectKeys(e),
      s = ct.objectKeys(t).filter(a => o.indexOf(a) !== -1),
      i = {
        ...t,
        ...e
      };
    for (const a of s) {
      const c = H_(t[a], e[a]);
      if (!c.valid) return {
        valid: !1
      };
      i[a] = c.data
    }
    return {
      valid: !0,
      data: i
    }
  } else if (n === ue.array && r === ue.array) {
    if (t.length !== e.length) return {
      valid: !1
    };
    const o = [];
    for (let s = 0; s < t.length; s++) {
      const i = t[s],
        a = e[s],
        c = H_(i, a);
      if (!c.valid) return {
        valid: !1
      };
      o.push(c.data)
    }
    return {
      valid: !0,
      data: o
    }
  } else return n === ue.date && r === ue.date && +t == +e ? {
    valid: !0,
    data: t
  } : {
    valid: !1
  }
}
class th extends Xe {
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e), o = (s, i) => {
      if (U_(s) || U_(i)) return Ue;
      const a = H_(s.value, i.value);
      return a.valid ? ((z_(s) || z_(i)) && n.dirty(), {
        status: n.value,
        value: a.data
      }) : (de(r, {
        code: re.invalid_intersection_types
      }), Ue)
    };
    return r.common.async ? Promise.all([this._def.left._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseAsync({
      data: r.data,
      path: r.path,
      parent: r
    })]).then(([s, i]) => o(s, i)) : o(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }))
  }
}
th.create = (t, e, n) => new th({
  left: t,
  right: e,
  typeName: Re.ZodIntersection,
  ...ze(n)
});
class ms extends Xe {
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e);
    if (r.parsedType !== ue.array) return de(r, {
      code: re.invalid_type,
      expected: ue.array,
      received: r.parsedType
    }), Ue;
    if (r.data.length < this._def.items.length) return de(r, {
      code: re.too_small,
      minimum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), Ue;
    !this._def.rest && r.data.length > this._def.items.length && (de(r, {
      code: re.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const s = [...r.data].map((i, a) => {
      const c = this._def.items[a] || this._def.rest;
      return c ? c._parse(new gs(r, i, r.path, a)) : null
    }).filter(i => !!i);
    return r.common.async ? Promise.all(s).then(i => Yn.mergeArray(n, i)) : Yn.mergeArray(n, s)
  }
  get items() {
    return this._def.items
  }
  rest(e) {
    return new ms({
      ...this._def,
      rest: e
    })
  }
}
ms.create = (t, e) => {
  if (!Array.isArray(t)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ms({
    items: t,
    typeName: Re.ZodTuple,
    rest: null,
    ...ze(e)
  })
};
class nh extends Xe {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e);
    if (r.parsedType !== ue.object) return de(r, {
      code: re.invalid_type,
      expected: ue.object,
      received: r.parsedType
    }), Ue;
    const o = [],
      s = this._def.keyType,
      i = this._def.valueType;
    for (const a in r.data) o.push({
      key: s._parse(new gs(r, a, r.path, a)),
      value: i._parse(new gs(r, r.data[a], r.path, a))
    });
    return r.common.async ? Yn.mergeObjectAsync(n, o) : Yn.mergeObjectSync(n, o)
  }
  get element() {
    return this._def.valueType
  }
  static create(e, n, r) {
    return n instanceof Xe ? new nh({
      keyType: e,
      valueType: n,
      typeName: Re.ZodRecord,
      ...ze(r)
    }) : new nh({
      keyType: $o.create(),
      valueType: e,
      typeName: Re.ZodRecord,
      ...ze(n)
    })
  }
}
class ay extends Xe {
  get keySchema() {
    return this._def.keyType
  }
  get valueSchema() {
    return this._def.valueType
  }
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e);
    if (r.parsedType !== ue.map) return de(r, {
      code: re.invalid_type,
      expected: ue.map,
      received: r.parsedType
    }), Ue;
    const o = this._def.keyType,
      s = this._def.valueType,
      i = [...r.data.entries()].map(([a, c], l) => ({
        key: o._parse(new gs(r, a, r.path, [l, "key"])),
        value: s._parse(new gs(r, c, r.path, [l, "value"]))
      }));
    if (r.common.async) {
      const a = new Map;
      return Promise.resolve().then(async () => {
        for (const c of i) {
          const l = await c.key,
            u = await c.value;
          if (l.status === "aborted" || u.status === "aborted") return Ue;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(l.value, u.value)
        }
        return {
          status: n.value,
          value: a
        }
      })
    } else {
      const a = new Map;
      for (const c of i) {
        const l = c.key,
          u = c.value;
        if (l.status === "aborted" || u.status === "aborted") return Ue;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), a.set(l.value, u.value)
      }
      return {
        status: n.value,
        value: a
      }
    }
  }
}
ay.create = (t, e, n) => new ay({
  valueType: e,
  keyType: t,
  typeName: Re.ZodMap,
  ...ze(n)
});
class oc extends Xe {
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e);
    if (r.parsedType !== ue.set) return de(r, {
      code: re.invalid_type,
      expected: ue.set,
      received: r.parsedType
    }), Ue;
    const o = this._def;
    o.minSize !== null && r.data.size < o.minSize.value && (de(r, {
      code: re.too_small,
      minimum: o.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.minSize.message
    }), n.dirty()), o.maxSize !== null && r.data.size > o.maxSize.value && (de(r, {
      code: re.too_big,
      maximum: o.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: o.maxSize.message
    }), n.dirty());
    const s = this._def.valueType;

    function i(c) {
      const l = new Set;
      for (const u of c) {
        if (u.status === "aborted") return Ue;
        u.status === "dirty" && n.dirty(), l.add(u.value)
      }
      return {
        status: n.value,
        value: l
      }
    }
    const a = [...r.data.values()].map((c, l) => s._parse(new gs(r, c, r.path, l)));
    return r.common.async ? Promise.all(a).then(c => i(c)) : i(a)
  }
  min(e, n) {
    return new oc({
      ...this._def,
      minSize: {
        value: e,
        message: ke.toString(n)
      }
    })
  }
  max(e, n) {
    return new oc({
      ...this._def,
      maxSize: {
        value: e,
        message: ke.toString(n)
      }
    })
  }
  size(e, n) {
    return this.min(e, n).max(e, n)
  }
  nonempty(e) {
    return this.min(1, e)
  }
}
oc.create = (t, e) => new oc({
  valueType: t,
  minSize: null,
  maxSize: null,
  typeName: Re.ZodSet,
  ...ze(e)
});
class zl extends Xe {
  constructor() {
    super(...arguments), this.validate = this.implement
  }
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e);
    if (n.parsedType !== ue.function) return de(n, {
      code: re.invalid_type,
      expected: ue.function,
      received: n.parsedType
    }), Ue;

    function r(a, c) {
      return ry({
        data: a,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, ny(), qf].filter(l => !!l),
        issueData: {
          code: re.invalid_arguments,
          argumentsError: c
        }
      })
    }

    function o(a, c) {
      return ry({
        data: a,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, ny(), qf].filter(l => !!l),
        issueData: {
          code: re.invalid_return_type,
          returnTypeError: c
        }
      })
    }
    const s = {
        errorMap: n.common.contextualErrorMap
      },
      i = n.data;
    if (this._def.returns instanceof uu) {
      const a = this;
      return sr(async function(...c) {
        const l = new Do([]),
          u = await a._def.args.parseAsync(c, s).catch(h => {
            throw l.addIssue(r(c, h)), l
          }),
          d = await Reflect.apply(i, this, u);
        return await a._def.returns._def.type.parseAsync(d, s).catch(h => {
          throw l.addIssue(o(d, h)), l
        })
      })
    } else {
      const a = this;
      return sr(function(...c) {
        const l = a._def.args.safeParse(c, s);
        if (!l.success) throw new Do([r(c, l.error)]);
        const u = Reflect.apply(i, this, l.data),
          d = a._def.returns.safeParse(u, s);
        if (!d.success) throw new Do([o(u, d.error)]);
        return d.data
      })
    }
  }
  parameters() {
    return this._def.args
  }
  returnType() {
    return this._def.returns
  }
  args(...e) {
    return new zl({
      ...this._def,
      args: ms.create(e).rest(La.create())
    })
  }
  returns(e) {
    return new zl({
      ...this._def,
      returns: e
    })
  }
  implement(e) {
    return this.parse(e)
  }
  strictImplement(e) {
    return this.parse(e)
  }
  static create(e, n, r) {
    return new zl({
      args: e || ms.create([]).rest(La.create()),
      returns: n || La.create(),
      typeName: Re.ZodFunction,
      ...ze(r)
    })
  }
}
class rh extends Xe {
  get schema() {
    return this._def.getter()
  }
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e);
    return this._def.getter()._parse({
      data: n.data,
      path: n.path,
      parent: n
    })
  }
}
rh.create = (t, e) => new rh({
  getter: t,
  typeName: Re.ZodLazy,
  ...ze(e)
});
class oh extends Xe {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return de(n, {
        received: n.data,
        code: re.invalid_literal,
        expected: this._def.value
      }), Ue
    }
    return {
      status: "valid",
      value: e.data
    }
  }
  get value() {
    return this._def.value
  }
}
oh.create = (t, e) => new oh({
  value: t,
  typeName: Re.ZodLiteral,
  ...ze(e)
});

function G4(t, e) {
  return new Zi({
    values: t,
    typeName: Re.ZodEnum,
    ...ze(e)
  })
}
class Zi extends Xe {
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e),
        r = this._def.values;
      return de(n, {
        expected: ct.joinValues(r),
        received: n.parsedType,
        code: re.invalid_type
      }), Ue
    }
    if (this._def.values.indexOf(e.data) === -1) {
      const n = this._getOrReturnCtx(e),
        r = this._def.values;
      return de(n, {
        received: n.data,
        code: re.invalid_enum_value,
        options: r
      }), Ue
    }
    return sr(e.data)
  }
  get options() {
    return this._def.values
  }
  get enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e
  }
  get Values() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e
  }
  extract(e) {
    return Zi.create(e)
  }
  exclude(e) {
    return Zi.create(this.options.filter(n => !e.includes(n)))
  }
}
Zi.create = G4;
class sh extends Xe {
  _parse(e) {
    const n = ct.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(e);
    if (r.parsedType !== ue.string && r.parsedType !== ue.number) {
      const o = ct.objectValues(n);
      return de(r, {
        expected: ct.joinValues(o),
        received: r.parsedType,
        code: re.invalid_type
      }), Ue
    }
    if (n.indexOf(e.data) === -1) {
      const o = ct.objectValues(n);
      return de(r, {
        received: r.data,
        code: re.invalid_enum_value,
        options: o
      }), Ue
    }
    return sr(e.data)
  }
  get enum() {
    return this._def.values
  }
}
sh.create = (t, e) => new sh({
  values: t,
  typeName: Re.ZodNativeEnum,
  ...ze(e)
});
class uu extends Xe {
  unwrap() {
    return this._def.type
  }
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e);
    if (n.parsedType !== ue.promise && n.common.async === !1) return de(n, {
      code: re.invalid_type,
      expected: ue.promise,
      received: n.parsedType
    }), Ue;
    const r = n.parsedType === ue.promise ? n.data : Promise.resolve(n.data);
    return sr(r.then(o => this._def.type.parseAsync(o, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })))
  }
}
uu.create = (t, e) => new uu({
  type: t,
  typeName: Re.ZodPromise,
  ...ze(e)
});
class Bo extends Xe {
  innerType() {
    return this._def.schema
  }
  sourceType() {
    return this._def.schema._def.typeName === Re.ZodEffects ? this._def.schema.sourceType() : this._def.schema
  }
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e), o = this._def.effect || null, s = {
      addIssue: i => {
        de(r, i), i.fatal ? n.abort() : n.dirty()
      },
      get path() {
        return r.path
      }
    };
    if (s.addIssue = s.addIssue.bind(s), o.type === "preprocess") {
      const i = o.transform(r.data, s);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(i).then(a => this._def.schema._parseAsync({
        data: a,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: i,
        path: r.path,
        parent: r
      })
    }
    if (o.type === "refinement") {
      const i = a => {
        const c = o.refinement(a, s);
        if (r.common.async) return Promise.resolve(c);
        if (c instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return a
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Ue : (a.status === "dirty" && n.dirty(), i(a.value), {
          status: n.value,
          value: a.value
        })
      } else return this._def.schema._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }).then(a => a.status === "aborted" ? Ue : (a.status === "dirty" && n.dirty(), i(a.value).then(() => ({
        status: n.value,
        value: a.value
      }))))
    }
    if (o.type === "transform")
      if (r.common.async === !1) {
        const i = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Xf(i)) return i;
        const a = o.transform(i.value, s);
        if (a instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return {
          status: n.value,
          value: a
        }
      } else return this._def.schema._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }).then(i => Xf(i) ? Promise.resolve(o.transform(i.value, s)).then(a => ({
        status: n.value,
        value: a
      })) : i);
    ct.assertNever(o)
  }
}
Bo.create = (t, e, n) => new Bo({
  schema: t,
  typeName: Re.ZodEffects,
  effect: e,
  ...ze(n)
});
Bo.createWithPreprocess = (t, e, n) => new Bo({
  schema: e,
  effect: {
    type: "preprocess",
    transform: t
  },
  typeName: Re.ZodEffects,
  ...ze(n)
});
class Hs extends Xe {
  _parse(e) {
    return this._getType(e) === ue.undefined ? sr(void 0) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
Hs.create = (t, e) => new Hs({
  innerType: t,
  typeName: Re.ZodOptional,
  ...ze(e)
});
class sc extends Xe {
  _parse(e) {
    return this._getType(e) === ue.null ? sr(null) : this._def.innerType._parse(e)
  }
  unwrap() {
    return this._def.innerType
  }
}
sc.create = (t, e) => new sc({
  innerType: t,
  typeName: Re.ZodNullable,
  ...ze(e)
});
class ih extends Xe {
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e);
    let r = n.data;
    return n.parsedType === ue.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    })
  }
  removeDefault() {
    return this._def.innerType
  }
}
ih.create = (t, e) => new ih({
  innerType: t,
  typeName: Re.ZodDefault,
  defaultValue: typeof e.default == "function" ? e.default : () => e.default,
  ...ze(e)
});
class cy extends Xe {
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, o = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return oy(o) ? o.then(s => ({
      status: "valid",
      value: s.status === "valid" ? s.value : this._def.catchValue({
        get error() {
          return new Do(r.common.issues)
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: o.status === "valid" ? o.value : this._def.catchValue({
        get error() {
          return new Do(r.common.issues)
        },
        input: r.data
      })
    }
  }
  removeCatch() {
    return this._def.innerType
  }
}
cy.create = (t, e) => new cy({
  innerType: t,
  typeName: Re.ZodCatch,
  catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
  ...ze(e)
});
class ly extends Xe {
  _parse(e) {
    if (this._getType(e) !== ue.nan) {
      const r = this._getOrReturnCtx(e);
      return de(r, {
        code: re.invalid_type,
        expected: ue.nan,
        received: r.parsedType
      }), Ue
    }
    return {
      status: "valid",
      value: e.data
    }
  }
}
ly.create = t => new ly({
  typeName: Re.ZodNaN,
  ...ze(t)
});
const sme = Symbol("zod_brand");
class Y4 extends Xe {
  _parse(e) {
    const {
      ctx: n
    } = this._processInputParams(e), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    })
  }
  unwrap() {
    return this._def.type
  }
}
class Uh extends Xe {
  _parse(e) {
    const {
      status: n,
      ctx: r
    } = this._processInputParams(e);
    if (r.common.async) return (async () => {
      const s = await this._def.in._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return s.status === "aborted" ? Ue : s.status === "dirty" ? (n.dirty(), K4(s.value)) : this._def.out._parseAsync({
        data: s.value,
        path: r.path,
        parent: r
      })
    })();
    {
      const o = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return o.status === "aborted" ? Ue : o.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: o.value
      }) : this._def.out._parseSync({
        data: o.value,
        path: r.path,
        parent: r
      })
    }
  }
  static create(e, n) {
    return new Uh({
      in: e,
      out: n,
      typeName: Re.ZodPipeline
    })
  }
}
class uy extends Xe {
  _parse(e) {
    const n = this._def.innerType._parse(e);
    return Xf(n) && (n.value = Object.freeze(n.value)), n
  }
}
uy.create = (t, e) => new uy({
  innerType: t,
  typeName: Re.ZodReadonly,
  ...ze(e)
});
const q4 = (t, e = {}, n) => t ? lu.create().superRefine((r, o) => {
    var s, i;
    if (!t(r)) {
      const a = typeof e == "function" ? e(r) : typeof e == "string" ? {
          message: e
        } : e,
        c = (i = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null && i !== void 0 ? i : !0,
        l = typeof a == "string" ? {
          message: a
        } : a;
      o.addIssue({
        code: "custom",
        ...l,
        fatal: c
      })
    }
  }) : lu.create(),
  ime = {
    object: Ut.lazycreate
  };
var Re;
(function(t) {
  t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly"
})(Re || (Re = {}));
const ame = (t, e = {
    message: `Input not instance of ${t.name}`
  }) => q4(n => n instanceof t, e),
  X4 = $o.create,
  Z4 = qi.create,
  cme = ly.create,
  lme = Xi.create,
  J4 = Zf.create,
  ume = rc.create,
  dme = sy.create,
  fme = Jf.create,
  hme = Qf.create,
  pme = lu.create,
  gme = La.create,
  mme = ei.create,
  yme = iy.create,
  vme = No.create,
  bme = Ut.create,
  wme = Ut.strictCreate,
  Sme = eh.create,
  _me = Vv.create,
  xme = th.create,
  Eme = ms.create,
  kme = nh.create,
  Cme = ay.create,
  Pme = oc.create,
  Tme = zl.create,
  $me = rh.create,
  Ime = oh.create,
  Ome = Zi.create,
  Rme = sh.create,
  Ame = uu.create,
  G$ = Bo.create,
  Mme = Hs.create,
  jme = sc.create,
  Dme = Bo.createWithPreprocess,
  Nme = Uh.create,
  Lme = () => X4().optional(),
  Fme = () => Z4().optional(),
  Bme = () => J4().optional(),
  Ume = {
    string: t => $o.create({
      ...t,
      coerce: !0
    }),
    number: t => qi.create({
      ...t,
      coerce: !0
    }),
    boolean: t => Zf.create({
      ...t,
      coerce: !0
    }),
    bigint: t => Xi.create({
      ...t,
      coerce: !0
    }),
    date: t => rc.create({
      ...t,
      coerce: !0
    })
  },
  zme = Ue;
var K = Object.freeze({
  __proto__: null,
  defaultErrorMap: qf,
  setErrorMap: Kge,
  getErrorMap: ny,
  makeIssue: ry,
  EMPTY_PATH: Gge,
  addIssueToContext: de,
  ParseStatus: Yn,
  INVALID: Ue,
  DIRTY: K4,
  OK: sr,
  isAborted: U_,
  isDirty: z_,
  isValid: Xf,
  isAsync: oy,
  get util() {
    return ct
  },
  get objectUtil() {
    return B_
  },
  ZodParsedType: ue,
  getParsedType: Ei,
  ZodType: Xe,
  ZodString: $o,
  ZodNumber: qi,
  ZodBigInt: Xi,
  ZodBoolean: Zf,
  ZodDate: rc,
  ZodSymbol: sy,
  ZodUndefined: Jf,
  ZodNull: Qf,
  ZodAny: lu,
  ZodUnknown: La,
  ZodNever: ei,
  ZodVoid: iy,
  ZodArray: No,
  ZodObject: Ut,
  ZodUnion: eh,
  ZodDiscriminatedUnion: Vv,
  ZodIntersection: th,
  ZodTuple: ms,
  ZodRecord: nh,
  ZodMap: ay,
  ZodSet: oc,
  ZodFunction: zl,
  ZodLazy: rh,
  ZodLiteral: oh,
  ZodEnum: Zi,
  ZodNativeEnum: sh,
  ZodPromise: uu,
  ZodEffects: Bo,
  ZodTransformer: Bo,
  ZodOptional: Hs,
  ZodNullable: sc,
  ZodDefault: ih,
  ZodCatch: cy,
  ZodNaN: ly,
  BRAND: sme,
  ZodBranded: Y4,
  ZodPipeline: Uh,
  ZodReadonly: uy,
  custom: q4,
  Schema: Xe,
  ZodSchema: Xe,
  late: ime,
  get ZodFirstPartyTypeKind() {
    return Re
  },
  coerce: Ume,
  any: pme,
  array: vme,
  bigint: lme,
  boolean: J4,
  date: ume,
  discriminatedUnion: _me,
  effect: G$,
  enum: Ome,
  function: Tme,
  instanceof: ame,
  intersection: xme,
  lazy: $me,
  literal: Ime,
  map: Cme,
  nan: cme,
  nativeEnum: Rme,
  never: mme,
  null: hme,
  nullable: jme,
  number: Z4,
  object: bme,
  oboolean: Bme,
  onumber: Fme,
  optional: Mme,
  ostring: Lme,
  pipeline: Nme,
  preprocess: Dme,
  promise: Ame,
  record: kme,
  set: Pme,
  strictObject: wme,
  string: X4,
  symbol: dme,
  transformer: G$,
  tuple: Eme,
  undefined: fme,
  union: Sme,
  unknown: gme,
  void: yme,
  NEVER: zme,
  ZodIssueCode: re,
  quotelessJson: Wge,
  ZodError: Do
});
class ic extends Error {
  constructor(e, n) {
    super(n), this.status = e
  }
}

function Hme(t) {
  return Object.fromEntries(t.map(e => [e.name, e]))
}
const Vme = {
    name: "sendOtpCodeForSignIn",
    requireLogin: !1,
    getModifiedWorkspaceIds: null,
    input: K.object({
      email: K.string().nonempty("Email is required").email({
        message: "Invalid email"
      }),
      redirect: K.string().regex(/^\/team\?join=\w{20}$/).optional()
    }).strict(),
    output: K.null(),
    execute: async (t, {
      supabase: e,
      request: n,
      adminSupabase: r
    }) => {
      const o = V4(n);
      let s = t.redirect;
      const i = r.from("profiles").select("id").eq("email", t.email).single(),
        a = r.from("waitlist").select("email").eq("email", t.email).eq("enabled", !0).single(),
        [{
          error: c
        }, {
          data: l
        }] = await Promise.all([i, a]);
      if (s) {
        const d = s.replace("/team?join=", "");
        if (d) {
          const {
            data: f
          } = await r.from("workspaces").select("id").eq("invite_code", d).eq("is_inviting_enabled", !0).single();
          f ? c && (s = `/create-account?redirect=${s}`) : s = void 0
        } else s = void 0
      } else c && l && (s = "/create-account");
      const u = await e.auth.signInWithOtp({
        email: t.email,
        options: {
          shouldCreateUser: !0,
          emailRedirectTo: `${o}/api/auth/callback` + (s ? `?redirect=${s}` : "")
        }
      });
      return u.error ? (console.error(u.error), qe.err(new ic(500, "There was a problem sending the sign-in link."))) : qe.ok(null)
    }
  },
  Wme = {
    name: "signInWithOauth",
    requireLogin: !1,
    getModifiedWorkspaceIds: null,
    input: K.object({
      redirect: K.string().regex(/^\/team\?join=\w{20}$/).optional()
    }).strict(),
    output: K.string().url(),
    execute: async (t, {
      supabase: e,
      request: n,
      adminSupabase: r
    }) => {
      const o = V4(n);
      let s = t == null ? void 0 : t.redirect;
      if (s) {
        const a = s.replace("/team?join=", "");
        if (a) {
          const {
            data: c
          } = await r.from("workspaces").select("id").eq("invite_code", a).eq("is_inviting_enabled", !0).single();
          c || (s = void 0)
        } else s = void 0
      }
      const i = await e.auth.signInWithOAuth({
        provider: "google",
        options: {
          redirectTo: `${o}/api/auth/callback` + (s ? `?redirect=${s}` : "")
        }
      });
      return i.error ? (console.error(i.error), qe.err(new ic(500, "There was a problem sending the sign-in link."))) : qe.ok(i.data.url)
    }
  },
  Kme = {
    name: "signOut",
    requireLogin: !0,
    getModifiedWorkspaceIds: null,
    input: K.null(),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const n = await e.auth.signOut();
      return n.error ? qe.err(n.error) : qe.ok(null)
    }
  },
  qt = K.string().uuid().brand("uuid"),
  VE = K.object({
    id: qt,
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    }),
    username: K.string().min(3, "Username must be at least 3 characters long").max(20, "Username cannot be longer than 20 characters").nullable().refine(t => t ? /^[a-z0-9]+$/.test(t) : !0, "Lowercase alphanumeric characters only"),
    name: K.string().min(1, "Name must be at least 1 character long").max(20, "Name cannot be longer than 20 characters").nullable(),
    last_active_workspace_id: qt.nullable(),
    avatar_object_name: K.string().nullable(),
    oauth_avatar_url: K.string().url().nullable(),
    oauth_name: K.string().nullable(),
    email: K.string().email().nullable(),
    locale: K.string().min(2, "Locale cannot be shorter than two characters").max(10, "Locale cannot be longer than 10 characters").nullable(),
    color: K.string().min(4, "Color must be at least 4 characters long").max(9, "Color cannot be longer than 9 characters").refine(t => t === null ? !0 : /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/i.test(t), "Must be a valid hex string").nullable(),
    is_dark_mode: K.boolean().nullable(),
    is_snap_mode: K.boolean().nullable(),
    animation_speed: K.number().nonnegative().nullable()
  }).strict(),
  ah = K.object({
    id: qt,
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    }),
    is_deleted: K.boolean(),
    invite_code: K.string().length(20),
    is_inviting_enabled: K.boolean(),
    name: K.string().nonempty("Workspace name is required").max(60, "Workspace name cannot be longer than 60 characters"),
    icon_object_name: K.string().nullable()
  }).strict(),
  ac = K.object({
    id: qt,
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    }),
    is_deleted: K.boolean(),
    is_archived: K.boolean(),
    name: K.string().nonempty("Folder name needs to have at least 1 character").max(60, "Folder name cannot be longer than 60 characters"),
    workspace_id: qt
  }).strict(),
  ch = K.object({
    id: qt,
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    }),
    last_viewed_at: K.string().datetime({
      offset: !0
    }).nullable(),
    is_deleted: K.boolean(),
    is_archived: K.boolean(),
    name: K.string().nonempty("Name can't be empty"),
    clock: K.number().int().nonnegative().nullable(),
    thumbnail_last_enqueued_clock: K.number().int().nonnegative().nullable(),
    workspace_id: qt,
    folder_id: qt.nullable(),
    private_to_profile_id: qt.nullable()
  }).strict(),
  Gme = K.object({
    board_id: qt,
    thumbnail_id: qt,
    clock: K.number().int().nonnegative(),
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    })
  }).strict(),
  zh = K.object({
    profile_id: qt,
    workspace_id: qt,
    created_at: K.string().datetime({
      offset: !0
    }),
    updated_at: K.string().datetime({
      offset: !0
    }),
    role: K.literal("admin").or(K.literal("member"))
  }),
  Hg = 0;
K.object({
  version: K.literal(Hg),
  boardPresenceInfo: K.record(K.record(K.number().int().nonnegative()))
});
async function Yme(t, e, n) {
  const r = await t.from("memberships").select().eq("workspace_id", n).eq("profile_id", e).maybeSingle();
  return r.error ? qe.err(r.error) : qe.ok(!!r.data)
}
const qme = {
    name: "createBoard",
    requireLogin: !0,
    getModifiedWorkspaceIds: ({
      workspace_id: t
    }) => [t],
    input: K.object({
      name: K.string().nonempty(),
      workspace_id: qt,
      view: K.discriminatedUnion("type", [K.object({
        type: K.literal("workspace")
      }), K.object({
        type: K.literal("folder"),
        folderId: qt
      }), K.object({
        type: K.literal("private")
      })])
    }),
    output: ch.pick({
      id: !0
    }),
    execute: async (t, {
      supabase: e,
      session: n,
      adminSupabase: r
    }) => {
      const o = await Yme(e, n.user.id, t.workspace_id);
      if (!o.ok) return o;
      if (!o.value) return qe.err(new ic(400, "Not a member of this workspace"));
      const s = await r.from("boards").insert({
        name: t.name,
        workspace_id: t.workspace_id,
        folder_id: t.view.type === "folder" ? t.view.folderId : void 0,
        private_to_profile_id: t.view.type === "private" ? n.user.id : void 0
      }).select().single();
      if (s.error) return s;
      const i = s.data;
      return qe.ok({
        id: i.id
      })
    }
  },
  Xme = {
    name: "updateBoard",
    requireLogin: !0,
    getModifiedWorkspaceIds: (t, {
      workspace_id: e
    }) => [e],
    input: ch.pick({
      id: !0,
      name: !0,
      is_deleted: !0,
      is_archived: !0,
      folder_id: !0,
      private_to_profile_id: !0
    }).partial().required({
      id: !0
    }),
    output: ch.omit({
      last_viewed_at: !0
    }),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        id: n,
        ...r
      } = t;
      if (r.folder_id) {
        const s = await e.rpc("update_boards_folder", {
          b_id: n,
          f_id: r.folder_id
        });
        if (s.error) return console.error(s.error), qe.err(new ic(500, "Something went wrong"))
      }
      const o = await e.from("boards").update(r).eq("id", n).select().single();
      return o.error ? (console.error(o.error), o) : qe.ok(o.data)
    }
  },
  Zme = {
    name: "updateBoardSessionState",
    requireLogin: !0,
    getModifiedWorkspaceIds: null,
    input: K.object({
      profile_id: qt,
      board_id: qt,
      board_state: K.object({
        version: K.number()
      }).catchall(K.any())
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const n = await e.from("profile_board_session_states").upsert({
        profile_id: t.profile_id,
        board_id: t.board_id,
        board_state: t.board_state
      });
      return n.error ? n : qe.ok(null)
    }
  },
  Jme = {
    name: "duplicateBoard",
    requireLogin: !0,
    getModifiedWorkspaceIds: (t, {
      workspace_id: e
    }) => [e],
    input: K.object({
      id: qt,
      name: K.string().nonempty()
    }),
    output: ch.omit({
      last_viewed_at: !0
    }),
    execute: async (t, {
      supabase: e,
      session: n,
      adminSupabase: r,
      triggerLiveBoardDuplication: o
    }) => {
      if (!n) return qe.err(new ic(401, "Unauthorized"));
      const s = await e.from("boards").select("workspace_id,folder_id,private_to_profile_id").eq("id", t.id).single();
      if (s.error) return s;
      const i = await r.from("boards").insert({
        name: t.name,
        ...s.data
      }).select().single();
      if (i.error) return i;
      const a = await o({
        fromId: t.id,
        toId: i.data.id
      });
      return a.ok ? qe.ok(i.data) : a
    }
  },
  Qme = {
    name: "updateBoardViews",
    getModifiedWorkspaceIds: null,
    requireLogin: !0,
    input: K.object({
      profile_id: qt,
      board_id: qt
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e,
      announceWorkspaceUpdate: n
    }) => {
      var o, s;
      const r = await e.from("board_views").upsert(t).select("boards(workspace_id)").single();
      return r.error ? r : ((o = r.data.boards) != null && o.workspace_id && n((s = r.data.boards) == null ? void 0 : s.workspace_id), qe.ok(null))
    }
  },
  eye = {
    name: "createFolder",
    requireLogin: !0,
    input: ac.pick({
      name: !0,
      workspace_id: !0
    }),
    output: ac,
    getModifiedWorkspaceIds: ({
      workspace_id: t
    }) => [t],
    execute: async (t, {
      supabase: e
    }) => {
      const n = await e.from("folders").insert({
        name: t.name,
        workspace_id: t.workspace_id
      }).select().single();
      return n.error ? n : qe.ok(n.data)
    }
  },
  tye = {
    name: "updateFolder",
    requireLogin: !0,
    getModifiedWorkspaceIds: (t, {
      workspace_id: e
    }) => [e],
    input: ac.pick({
      id: !0,
      name: !0,
      is_deleted: !0
    }).partial().required({
      id: !0
    }),
    output: ac,
    execute: async (t, {
      supabase: e
    }) => {
      const {
        id: n,
        ...r
      } = t, o = await e.from("folders").update(r).eq("id", n).select().single();
      return o.error ? o : qe.ok(o.data)
    }
  },
  nye = {
    name: "archiveFolder",
    requireLogin: !0,
    getModifiedWorkspaceIds: (t, {
      workspace_id: e
    }) => [e],
    input: ac.pick({
      id: !0
    }).partial().required({
      id: !0
    }),
    output: ac,
    execute: async (t, {
      supabase: e
    }) => {
      const {
        id: n
      } = t, r = await e.rpc("archive_folder", {
        folder_id_to_archive: n
      });
      if (r.error) return r;
      const o = await e.from("folders").select().eq("id", n).single();
      return o.error ? o : qe.ok(o.data)
    }
  },
  rye = {
    name: "joinWorkspace",
    requireLogin: !0,
    getModifiedWorkspaceIds: ({
      workspace_id: t
    }) => [t],
    input: zh.extend({
      code: K.string().nonempty().length(20)
    }).pick({
      workspace_id: !0,
      code: !0
    }).required({
      workspace_id: !0,
      code: !0
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        workspace_id: n,
        code: r
      } = t, o = await e.rpc("join_workspace", {
        code: r,
        w_id: n
      });
      return o.error ? o : qe.ok(null)
    }
  },
  oye = {
    name: "updateMembership",
    requireLogin: !0,
    getModifiedWorkspaceIds: ({
      workspace_id: t
    }) => [t],
    input: zh.pick({
      profile_id: !0,
      workspace_id: !0,
      role: !0
    }).required({
      profile_id: !0,
      workspace_id: !0,
      role: !0
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        role: n,
        profile_id: r,
        workspace_id: o
      } = t, s = await e.from("memberships").update({
        role: n
      }).eq("profile_id", r).eq("workspace_id", o);
      return s.error ? s : qe.ok(null)
    }
  },
  sye = {
    name: "deleteMembership",
    requireLogin: !0,
    getModifiedWorkspaceIds: ({
      workspace_id: t
    }) => [t],
    input: zh.pick({
      profile_id: !0,
      workspace_id: !0
    }).required({
      profile_id: !0,
      workspace_id: !0
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        profile_id: n,
        workspace_id: r
      } = t, o = await e.from("memberships").delete().eq("profile_id", n).eq("workspace_id", r);
      return o.error ? o : qe.ok(null)
    }
  },
  iye = {
    name: "updateCurrentUserProfile",
    requireLogin: !0,
    getModifiedWorkspaceIds: null,
    input: VE.pick({
      username: !0,
      name: !0,
      last_active_workspace_id: !0,
      avatar_object_name: !0,
      is_dark_mode: !0,
      is_snap_mode: !0,
      animation_speed: !0,
      locale: !0,
      color: !0
    }).partial(),
    output: K.null(),
    postgresErrorMessagesForColumn: {
      key: "username",
      postgrestErrorMap: {
        23505: "Username already exists"
      }
    },
    execute: async (t, {
      supabase: e,
      session: n,
      announceWorkspaceUpdate: r
    }) => {
      const o = await e.from("profiles").update(t).eq("id", n.user.id).select("memberships(workspace_id)").single();
      return o.error ? o : (o.data.memberships.forEach(({
        workspace_id: s
      }) => {
        r(s)
      }), qe.ok(null))
    }
  },
  aye = {
    profilePicture: "avatars",
    workspaceIcon: "avatars"
  },
  cye = {
    name: "createStorageUpload",
    getModifiedWorkspaceIds: null,
    requireLogin: !0,
    input: K.discriminatedUnion("purpose", [K.object({
      purpose: K.literal("profilePicture"),
      fileSize: K.number().int().positive().max(10 * 1024 * 1024, {
        message: "Profile pictures must be less than 10mb"
      }),
      fileType: K.string().refine(t => ["image/png", "image/jpeg"].includes(t), {
        message: "Profile pictures must be either png or jpeg"
      })
    }), K.object({
      purpose: K.literal("workspaceIcon"),
      fileSize: K.number().int().positive().max(10 * 1024 * 1024, {
        message: "Workspace icons must be less than 10mb"
      }),
      fileType: K.string().refine(t => ["image/png", "image/jpeg"].includes(t), {
        message: "Workspace icons must be either png or jpeg"
      })
    })]),
    output: K.object({
      objectName: K.string(),
      bucketId: K.string(),
      uploadUrl: K.string()
    }),
    execute: async (t, {
      supabase: e
    }) => {
      const n = crypto.randomUUID(),
        r = aye[t.purpose],
        o = await e.storage.from(r).createSignedUploadUrl(n);
      if (o.error) throw o.error;
      return qe.ok({
        objectName: n,
        bucketId: r,
        uploadUrl: o.data.signedUrl
      })
    }
  },
  lye = {
    name: "addToWaitlist",
    requireLogin: !1,
    getModifiedWorkspaceIds: null,
    input: K.object({
      email: K.string().email({
        message: "Invalid email"
      }).optional(),
      inviteCode: K.string().optional()
    }).strict(),
    output: K.null(),
    execute: async (t, {
      supabase: e,
      adminSupabase: n
    }) => {
      var a;
      const {
        data: r
      } = await e.auth.getUser(), o = ((a = r == null ? void 0 : r.user) == null ? void 0 : a.email) || (t == null ? void 0 : t.email);
      if (!o) return qe.err(new ic(500, "Something went wrong"));
      const s = t.inviteCode ? !!(await n.from("workspaces").select("id").eq("invite_code", t.inviteCode).single()).data : !1,
        {
          error: i
        } = await n.from("waitlist").upsert({
          email: o,
          enabled: s
        });
      return i ? qe.err(new ic(500, "Something went wrong")) : qe.ok(null)
    }
  },
  uye = {
    name: "getWaitlistStatus",
    requireLogin: !1,
    getModifiedWorkspaceIds: null,
    input: K.object({
      email: K.string().email({
        message: "Invalid email"
      })
    }).strict(),
    output: K.object({
      isOnWaitlist: K.boolean(),
      isApprovedForSignup: K.boolean()
    }),
    execute: async (t, {
      adminSupabase: e
    }) => {
      const {
        data: n
      } = await e.from("waitlist").select("email, enabled").eq("email", t.email).single();
      return qe.ok({
        isOnWaitlist: !!n,
        isApprovedForSignup: (n == null ? void 0 : n.enabled) || !1
      })
    }
  },
  dye = {
    name: "createWorkspace",
    requireLogin: !0,
    getModifiedWorkspaceIds: null,
    input: ah.pick({
      name: !0,
      icon_object_name: !0
    }).extend({
      id: qt.optional()
    }),
    output: ah.pick({
      id: !0
    }),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        data: n,
        error: r
      } = await e.rpc("create_workspace", {
        name: t.name,
        icon_object_name: t.icon_object_name ?? void 0,
        id_override: t.id ?? void 0
      });
      return r ? qe.err(r) : qe.ok({
        id: n
      })
    }
  },
  fye = {
    name: "updateWorkspace",
    requireLogin: !0,
    getModifiedWorkspaceIds: ({
      id: t
    }) => [t],
    input: ah.pick({
      id: !0,
      name: !0,
      icon_object_name: !0,
      is_inviting_enabled: !0
    }).partial().required({
      id: !0
    }),
    output: K.null(),
    execute: async (t, {
      supabase: e
    }) => {
      const {
        id: n,
        ...r
      } = t, o = await e.from("workspaces").update(r).eq("id", n);
      return o.error ? o : qe.ok(null)
    }
  },
  hye = {
    name: "getWorkspaceDataForInvitedUser",
    requireLogin: !1,
    getModifiedWorkspaceIds: null,
    input: K.object({
      inviteCode: K.string()
    }),
    output: ah.extend({
      memberships: K.array(zh.extend({
        profiles: VE
      }))
    }),
    execute: async (t, {
      adminSupabase: e
    }) => {
      const n = await e.from("workspaces").select("*,memberships(*,profiles(*,email))").eq("invite_code", t.inviteCode).eq("is_inviting_enabled", !0).single();
      return n.error ? qe.err(n.error) : qe.ok(n.data)
    }
  };
Hme([Vme, Wme, Kme, qme, Xme, Jme, Zme, Qme, eye, tye, nye, rye, oye, sye, iye, lye, uye, dye, fye, hye, cye]);

function dg(t, e) {
  return t.startsWith(e) ? t.slice(e.length) : null
}

function En(t) {
  const e = dg(t, "profile:") ?? dg(t, "workspace:") ?? dg(t, "folder:") ?? dg(t, "board:") ?? t;
  return qt.parse(e)
}
new TextEncoder;
const pye = new TextDecoder,
  gye = t => {
    const e = atob(t),
      n = new Uint8Array(e.length);
    for (let r = 0; r < e.length; r++) n[r] = e.charCodeAt(r);
    return n
  },
  mye = t => {
    let e = t;
    e instanceof Uint8Array && (e = pye.decode(e)), e = e.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
    try {
      return gye(e)
    } catch {
      throw new TypeError("The input to be decoded is not correctly encoded.")
    }
  },
  yye = mye;
var vye = Object.create,
  Q4 = Object.defineProperty,
  bye = Object.getOwnPropertyDescriptor,
  eN = Object.getOwnPropertyNames,
  wye = Object.getPrototypeOf,
  Sye = Object.prototype.hasOwnProperty,
  _ye = (t, e) => function() {
    return e || (0, t[eN(t)[0]])((e = {
      exports: {}
    }).exports, e), e.exports
  },
  xye = (t, e, n, r) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let o of eN(e)) !Sye.call(t, o) && o !== n && Q4(t, o, {
        get: () => e[o],
        enumerable: !(r = bye(e, o)) || r.enumerable
      });
    return t
  },
  tN = (t, e, n) => (n = t != null ? vye(wye(t)) : {}, xye(e || !t || !t.__esModule ? Q4(n, "default", {
    value: t,
    enumerable: !0
  }) : n, t)),
  nN = _ye({
    "../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js"(t) {
      t.parse = r, t.serialize = o;
      var e = Object.prototype.toString,
        n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

      function r(l, u) {
        if (typeof l != "string") throw new TypeError("argument str must be a string");
        for (var d = {}, f = u || {}, h = f.decode || s, m = 0; m < l.length;) {
          var p = l.indexOf("=", m);
          if (p === -1) break;
          var b = l.indexOf(";", m);
          if (b === -1) b = l.length;
          else if (b < p) {
            m = l.lastIndexOf(";", p - 1) + 1;
            continue
          }
          var w = l.slice(m, p).trim();
          if (d[w] === void 0) {
            var v = l.slice(p + 1, b).trim();
            v.charCodeAt(0) === 34 && (v = v.slice(1, -1)), d[w] = c(v, h)
          }
          m = b + 1
        }
        return d
      }

      function o(l, u, d) {
        var f = d || {},
          h = f.encode || i;
        if (typeof h != "function") throw new TypeError("option encode is invalid");
        if (!n.test(l)) throw new TypeError("argument name is invalid");
        var m = h(u);
        if (m && !n.test(m)) throw new TypeError("argument val is invalid");
        var p = l + "=" + m;
        if (f.maxAge != null) {
          var b = f.maxAge - 0;
          if (isNaN(b) || !isFinite(b)) throw new TypeError("option maxAge is invalid");
          p += "; Max-Age=" + Math.floor(b)
        }
        if (f.domain) {
          if (!n.test(f.domain)) throw new TypeError("option domain is invalid");
          p += "; Domain=" + f.domain
        }
        if (f.path) {
          if (!n.test(f.path)) throw new TypeError("option path is invalid");
          p += "; Path=" + f.path
        }
        if (f.expires) {
          var w = f.expires;
          if (!a(w) || isNaN(w.valueOf())) throw new TypeError("option expires is invalid");
          p += "; Expires=" + w.toUTCString()
        }
        if (f.httpOnly && (p += "; HttpOnly"), f.secure && (p += "; Secure"), f.priority) {
          var v = typeof f.priority == "string" ? f.priority.toLowerCase() : f.priority;
          switch (v) {
            case "low":
              p += "; Priority=Low";
              break;
            case "medium":
              p += "; Priority=Medium";
              break;
            case "high":
              p += "; Priority=High";
              break;
            default:
              throw new TypeError("option priority is invalid")
          }
        }
        if (f.sameSite) {
          var _ = typeof f.sameSite == "string" ? f.sameSite.toLowerCase() : f.sameSite;
          switch (_) {
            case !0:
              p += "; SameSite=Strict";
              break;
            case "lax":
              p += "; SameSite=Lax";
              break;
            case "strict":
              p += "; SameSite=Strict";
              break;
            case "none":
              p += "; SameSite=None";
              break;
            default:
              throw new TypeError("option sameSite is invalid")
          }
        }
        return p
      }

      function s(l) {
        return l.indexOf("%") !== -1 ? decodeURIComponent(l) : l
      }

      function i(l) {
        return encodeURIComponent(l)
      }

      function a(l) {
        return e.call(l) === "[object Date]" || l instanceof Date
      }

      function c(l, u) {
        try {
          return u(l)
        } catch {
          return l
        }
      }
    }
  }),
  aw = tN(nN()),
  rN = tN(nN());

function oN(t) {
  if (!t) return null;
  try {
    const e = JSON.parse(t);
    if (!e) return null;
    if (e.constructor.name === "Object") return e;
    if (e.constructor.name !== "Array") throw new Error(`Unexpected format: ${e.constructor.name}`);
    const [n, r, o] = e[0].split("."), s = yye(r), i = new TextDecoder, {
      exp: a,
      sub: c,
      ...l
    } = JSON.parse(i.decode(s));
    return {
      expires_at: a,
      expires_in: a - Math.round(Date.now() / 1e3),
      token_type: "bearer",
      access_token: e[0],
      refresh_token: e[1],
      provider_token: e[2],
      provider_refresh_token: e[3],
      user: {
        id: c,
        factors: e[4],
        ...l
      }
    }
  } catch (e) {
    return console.warn("Failed to parse cookie string:", e), null
  }
}

function sN(t) {
  var e;
  return JSON.stringify([t.access_token, t.refresh_token, t.provider_token, t.provider_refresh_token, ((e = t.user) == null ? void 0 : e.factors) ?? null])
}

function nf() {
  return typeof window < "u" && typeof window.document < "u"
}
var iN = {
    path: "/",
    maxAge: 60 * 60 * 24 * 365 * 1e3
  },
  aN = class {
    constructor(t) {
      this.cookieOptions = {
        ...iN,
        ...t
      }
    }
    getItem(t) {
      const e = this.getCookie(t);
      return e ? t.endsWith("-code-verifier") ? e : JSON.stringify(oN(e)) : null
    }
    setItem(t, e) {
      if (t.endsWith("-code-verifier")) {
        this.setCookie(t, e);
        return
      }
      let n = JSON.parse(e);
      const r = sN(n);
      this.setCookie(t, r)
    }
    removeItem(t) {
      this.deleteCookie(t)
    }
  },
  Eye = class extends aN {
    constructor(t) {
      super(t)
    }
    getCookie(t) {
      return nf() ? (0, aw.parse)(document.cookie)[t] : null
    }
    setCookie(t, e) {
      if (!nf()) return null;
      document.cookie = (0, aw.serialize)(t, e, {
        ...this.cookieOptions,
        httpOnly: !1
      })
    }
    deleteCookie(t) {
      if (!nf()) return null;
      document.cookie = (0, aw.serialize)(t, "", {
        ...this.cookieOptions,
        maxAge: 0,
        httpOnly: !1
      })
    }
  };

function kye(t, e, n) {
  var r;
  const o = nf();
  return Vge(t, e, {
    ...n,
    auth: {
      flowType: "pkce",
      autoRefreshToken: o,
      detectSessionInUrl: o,
      persistSession: !0,
      storage: n.auth.storage,
      ...(r = n.auth) != null && r.storageKey ? {
        storageKey: n.auth.storageKey
      } : {}
    }
  })
}
var Cye = rN.parse,
  Pye = rN.serialize;
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
const Tye = Object.freeze(Object.defineProperty({
    __proto__: null,
    BrowserCookieAuthStorageAdapter: Eye,
    CookieAuthStorageAdapter: aN,
    DEFAULT_COOKIE_OPTIONS: iN,
    createSupabaseClient: kye,
    isBrowser: nf,
    parseCookies: Cye,
    parseSupabaseCookie: oN,
    serializeCookie: Pye,
    stringifySupabaseSession: sN
  }, Symbol.toStringTag, {
    value: "Module"
  })),
  Hh = a6(Tye);
var Vh = {
    exports: {}
  },
  kl = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };

function V_(t) {
  return typeof t == "string" && !!t.trim()
}

function W_(t, e) {
  var n = t.split(";").filter(V_),
    r = n.shift(),
    o = $ye(r),
    s = o.name,
    i = o.value;
  e = e ? Object.assign({}, kl, e) : kl;
  try {
    i = e.decodeValues ? decodeURIComponent(i) : i
  } catch (c) {
    console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + i + "'. Set options.decodeValues to false to disable this feature.", c)
  }
  var a = {
    name: s,
    value: i
  };
  return n.forEach(function(c) {
    var l = c.split("="),
      u = l.shift().trimLeft().toLowerCase(),
      d = l.join("=");
    u === "expires" ? a.expires = new Date(d) : u === "max-age" ? a.maxAge = parseInt(d, 10) : u === "secure" ? a.secure = !0 : u === "httponly" ? a.httpOnly = !0 : u === "samesite" ? a.sameSite = d : a[u] = d
  }), a
}

function $ye(t) {
  var e = "",
    n = "",
    r = t.split("=");
  return r.length > 1 ? (e = r.shift(), n = r.join("=")) : n = t, {
    name: e,
    value: n
  }
}

function cN(t, e) {
  if (e = e ? Object.assign({}, kl, e) : kl, !t) return e.map ? {} : [];
  if (t.headers)
    if (typeof t.headers.getSetCookie == "function") t = t.headers.getSetCookie();
    else if (t.headers["set-cookie"]) t = t.headers["set-cookie"];
  else {
    var n = t.headers[Object.keys(t.headers).find(function(o) {
      return o.toLowerCase() === "set-cookie"
    })];
    !n && t.headers.cookie && !e.silent && console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."), t = n
  }
  if (Array.isArray(t) || (t = [t]), e = e ? Object.assign({}, kl, e) : kl, e.map) {
    var r = {};
    return t.filter(V_).reduce(function(o, s) {
      var i = W_(s, e);
      return o[i.name] = i, o
    }, r)
  } else return t.filter(V_).map(function(o) {
    return W_(o, e)
  })
}

function Iye(t) {
  if (Array.isArray(t)) return t;
  if (typeof t != "string") return [];
  var e = [],
    n = 0,
    r, o, s, i, a;

  function c() {
    for (; n < t.length && /\s/.test(t.charAt(n));) n += 1;
    return n < t.length
  }

  function l() {
    return o = t.charAt(n), o !== "=" && o !== ";" && o !== ","
  }
  for (; n < t.length;) {
    for (r = n, a = !1; c();)
      if (o = t.charAt(n), o === ",") {
        for (s = n, n += 1, c(), i = n; n < t.length && l();) n += 1;
        n < t.length && t.charAt(n) === "=" ? (a = !0, n = i, e.push(t.substring(r, s)), r = n) : n = s + 1
      } else n += 1;
    (!a || n >= t.length) && e.push(t.substring(r, t.length))
  }
  return e
}
Vh.exports = cN;
Vh.exports.parse = cN;
Vh.exports.parseString = W_;
Vh.exports.splitCookiesString = Iye;
var lN = Vh.exports,
  WE = Object.defineProperty,
  Oye = Object.getOwnPropertyDescriptor,
  Rye = Object.getOwnPropertyNames,
  Aye = Object.prototype.hasOwnProperty,
  Mye = (t, e) => {
    for (var n in e) WE(t, n, {
      get: e[n],
      enumerable: !0
    })
  },
  jye = (t, e, n, r) => {
    if (e && typeof e == "object" || typeof e == "function")
      for (let o of Rye(e)) !Aye.call(t, o) && o !== n && WE(t, o, {
        get: () => e[o],
        enumerable: !(r = Oye(e, o)) || r.enumerable
      });
    return t
  },
  Dye = t => jye(WE({}, "__esModule", {
    value: !0
  }), t),
  uN = {};
Mye(uN, {
  createBrowserSupabaseClient: () => Wye,
  createClientComponentClient: () => dN,
  createMiddlewareClient: () => pN,
  createMiddlewareSupabaseClient: () => Gye,
  createPagesBrowserClient: () => fN,
  createPagesServerClient: () => hN,
  createRouteHandlerClient: () => yN,
  createServerActionClient: () => Vye,
  createServerComponentClient: () => zye,
  createServerSupabaseClient: () => Kye
});
var Nye = Dye(uN),
  Y$ = Hh,
  fg;

function dN({
  supabaseUrl: t = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: e = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: n,
  cookieOptions: r,
  isSingleton: o = !0
} = {}) {
  if (!t || !e) throw new Error("either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!");
  const s = () => {
    var i;
    return (0, Y$.createSupabaseClient)(t, e, {
      ...n,
      global: {
        ...n == null ? void 0 : n.global,
        headers: {
          ...(i = n == null ? void 0 : n.global) == null ? void 0 : i.headers,
          "X-Client-Info": "@supabase/auth-helpers-nextjs@0.7.4"
        }
      },
      auth: {
        storageKey: r == null ? void 0 : r.name,
        storage: new Y$.BrowserCookieAuthStorageAdapter(r)
      }
    })
  };
  if (o) {
    const i = fg ?? s();
    return typeof window > "u" ? i : (fg || (fg = i), fg)
  }
  return s()
}
var fN = dN,
  Ad = Hh,
  q$ = lN,
  Lye = class extends Ad.CookieAuthStorageAdapter {
    constructor(t, e) {
      super(e), this.context = t
    }
    getCookie(t) {
      var e;
      return (0, q$.splitCookiesString)(((e = this.context.res.getHeader("set-cookie")) == null ? void 0 : e.toString()) ?? "").map(o => (0, Ad.parseCookies)(o)[t]).find(o => !!o) ?? this.context.req.cookies[t]
    }
    setCookie(t, e) {
      this._setCookie(t, e)
    }
    deleteCookie(t) {
      this._setCookie(t, "", {
        maxAge: 0
      })
    }
    _setCookie(t, e, n) {
      var r;
      const o = (0, q$.splitCookiesString)(((r = this.context.res.getHeader("set-cookie")) == null ? void 0 : r.toString()) ?? "").filter(i => !(t in (0, Ad.parseCookies)(i))),
        s = (0, Ad.serializeCookie)(t, e, {
          ...this.cookieOptions,
          ...n,
          httpOnly: !1
        });
      this.context.res.setHeader("set-cookie", [...o, s])
    }
  };

function hN(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  var s;
  if (!e || !n) throw new Error("either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!");
  return (0, Ad.createSupabaseClient)(e, n, {
    ...r,
    global: {
      ...r == null ? void 0 : r.global,
      headers: {
        ...(s = r == null ? void 0 : r.global) == null ? void 0 : s.headers,
        "X-Client-Info": "@supabase/auth-helpers-nextjs@0.7.4"
      }
    },
    auth: {
      storageKey: o == null ? void 0 : o.name,
      storage: new Lye(t, o)
    }
  })
}
var Md = Hh,
  Fye = lN,
  Bye = class extends Md.CookieAuthStorageAdapter {
    constructor(t, e) {
      super(e), this.context = t
    }
    getCookie(t) {
      var e;
      const n = (0, Fye.splitCookiesString)(((e = this.context.res.headers.get("set-cookie")) == null ? void 0 : e.toString()) ?? "").map(o => (0, Md.parseCookies)(o)[t]).find(o => !!o);
      return n || (0, Md.parseCookies)(this.context.req.headers.get("cookie") ?? "")[t]
    }
    setCookie(t, e) {
      this._setCookie(t, e)
    }
    deleteCookie(t) {
      this._setCookie(t, "", {
        maxAge: 0
      })
    }
    _setCookie(t, e, n) {
      const r = (0, Md.serializeCookie)(t, e, {
        ...this.cookieOptions,
        ...n,
        httpOnly: !1
      });
      this.context.res.headers && (this.context.res.headers.append("set-cookie", r), this.context.res.headers.append("cookie", r))
    }
  };

function pN(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  var s;
  if (!e || !n) throw new Error("either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!");
  return (0, Md.createSupabaseClient)(e, n, {
    ...r,
    global: {
      ...r == null ? void 0 : r.global,
      headers: {
        ...(s = r == null ? void 0 : r.global) == null ? void 0 : s.headers,
        "X-Client-Info": "@supabase/auth-helpers-nextjs@0.7.4"
      }
    },
    auth: {
      storageKey: o == null ? void 0 : o.name,
      storage: new Bye(t, o)
    }
  })
}
var gN = Hh,
  Uye = class extends gN.CookieAuthStorageAdapter {
    constructor(t, e) {
      super(e), this.context = t
    }
    getCookie(t) {
      var e;
      return (e = this.context.cookies().get(t)) == null ? void 0 : e.value
    }
    setCookie(t, e) {}
    deleteCookie(t) {}
  };

function zye(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  var s;
  if (!e || !n) throw new Error("either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!");
  return (0, gN.createSupabaseClient)(e, n, {
    ...r,
    global: {
      ...r == null ? void 0 : r.global,
      headers: {
        ...(s = r == null ? void 0 : r.global) == null ? void 0 : s.headers,
        "X-Client-Info": "@supabase/auth-helpers-nextjs@0.7.4"
      }
    },
    auth: {
      storageKey: o == null ? void 0 : o.name,
      storage: new Uye(t, o)
    }
  })
}
var mN = Hh,
  Hye = class extends mN.CookieAuthStorageAdapter {
    constructor(t, e) {
      super(e), this.context = t
    }
    getCookie(t) {
      var e;
      return (e = this.context.cookies().get(t)) == null ? void 0 : e.value
    }
    setCookie(t, e) {
      this.context.cookies().set(t, e, this.cookieOptions)
    }
    deleteCookie(t) {
      this.context.cookies().set(t, "", {
        maxAge: 0
      })
    }
  };

function yN(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  var s;
  if (!e || !n) throw new Error("either NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY env variables or supabaseUrl and supabaseKey are required!");
  return (0, mN.createSupabaseClient)(e, n, {
    ...r,
    global: {
      ...r == null ? void 0 : r.global,
      headers: {
        ...(s = r == null ? void 0 : r.global) == null ? void 0 : s.headers,
        "X-Client-Info": "@supabase/auth-helpers-nextjs@0.7.4"
      }
    },
    auth: {
      storageKey: o == null ? void 0 : o.name,
      storage: new Hye(t, o)
    }
  })
}
var Vye = yN;

function Wye({
  supabaseUrl: t = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: e = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: n,
  cookieOptions: r
} = {}) {
  return console.warn("Please utilize the `createPagesBrowserClient` function instead of the deprecated `createBrowserSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages"), fN({
    supabaseUrl: t,
    supabaseKey: e,
    options: n,
    cookieOptions: r
  })
}

function Kye(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  return console.warn("Please utilize the `createPagesServerClient` function instead of the deprecated `createServerSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs-pages"), hN(t, {
    supabaseUrl: e,
    supabaseKey: n,
    options: r,
    cookieOptions: o
  })
}

function Gye(t, {
  supabaseUrl: e = {}.NEXT_PUBLIC_SUPABASE_URL,
  supabaseKey: n = {}.NEXT_PUBLIC_SUPABASE_ANON_KEY,
  options: r,
  cookieOptions: o
} = {}) {
  return console.warn("Please utilize the `createMiddlewareClient` function instead of the deprecated `createMiddlewareSupabaseClient` function. Learn more: https://supabase.com/docs/guides/auth/auth-helpers/nextjs#middleware"), pN(t, {
    supabaseUrl: e,
    supabaseKey: n,
    options: r,
    cookieOptions: o
  })
}

function Yye() {
  const t = "https://db.tldraw.com",
    e = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5qaG5qaGNla3FsanJqZmxna3R3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2OTY1ODkzOTMsImV4cCI6MjAxMjE2NTM5M30.J9z9jA34Op7UrZS1UH3ieF2XlKs0J82C-lzKNluXop4";
  return Nye.createClientComponentClient({
    supabaseUrl: t,
    supabaseKey: e
  })
}

function X$(t, e) {
  return t.name.localeCompare(e.name)
}

function ya(t, e) {
  return t.id < e.id ? -1 : t.id > e.id ? 1 : 0
}
async function qye(t, e) {
  const n = await t.from("profiles").select(`
            *,
            email,
            userMemberships:memberships(
                *,
                workspace:workspaces(
                    *,
                    folders(*),
                    boards(
                        *,
                        last_viewed_at,
                        thumbnail:board_thumbnails(*)
                    ),
                    workspaceMemberships:memberships(
                        *,
                        profile:profiles(*, email)
                    )
                )
            )
        `).eq("id", e).single();
  if (n.error) throw n.error;
  return n.data
}
const Xye = VE.omit({
    id: !0
  }).extend({
    id: K.string().refine(t => Hl.isId(t)),
    typeName: K.literal("profile")
  }),
  Hl = _r("profile", {
    scope: "document",
    validator: {
      validate: t => Xye.parse(t)
    }
  }),
  Zye = ah.omit({
    id: !0
  }).extend({
    id: K.string().refine(t => xo.isId(t)),
    typeName: K.literal("workspace")
  }),
  xo = _r("workspace", {
    scope: "document",
    validator: {
      validate: t => Zye.parse(t)
    }
  }),
  Jye = ac.omit({
    id: !0
  }).extend({
    id: K.string().refine(t => lh.isId(t)),
    typeName: K.literal("folder")
  }),
  lh = _r("folder", {
    scope: "document",
    validator: {
      validate: t => Jye.parse(t)
    }
  }),
  Qye = ch.omit({
    id: !0
  }).extend({
    id: K.string().refine(t => Wv.isId(t)),
    typeName: K.literal("board"),
    thumbnail: Gme.nullable()
  }),
  Wv = _r("board", {
    scope: "document",
    validator: {
      validate: t => Qye.parse(t)
    }
  }),
  eve = zh.extend({
    id: K.string().refine(t => KE.isId(t)),
    typeName: K.literal("membership")
  }),
  KE = _r("membership", {
    scope: "document",
    validator: {
      validate: t => eve.parse(t)
    }
  }),
  tve = Yy.create({
    profile: Hl,
    workspace: xo,
    folder: lh,
    board: Wv,
    membership: KE
  });

function nve(t) {
  switch (t.typeName) {
    case "profile":
      return {
        ...t.row, id: Hl.createId(t.row.id), typeName: "profile"
      };
    case "workspace":
      return {
        ...t.row, id: xo.createId(t.row.id), typeName: "workspace"
      };
    case "folder":
      return {
        ...t.row, id: lh.createId(t.row.id), typeName: "folder"
      };
    case "board":
      return {
        ...t.row, id: Wv.createId(t.row.id), typeName: "board"
      };
    case "membership":
      return {
        ...t.row, id: KE.createId(`${t.row.profile_id}_${t.row.workspace_id}`), typeName: "membership"
      };
    default:
      bu(t, "typeName")
  }
}

function ur(t, e) {
  return t.isId(e) ? e : t.createId(e)
}

function rve(t) {
  const e = {},
    n = s => {
      const i = nve(s);
      e[i.id] = i
    },
    {
      userMemberships: r,
      ...o
    } = t;
  n({
    typeName: "profile",
    row: o
  });
  for (const {
      workspace: s,
      ...i
    }
    of r) {
    Xa(s, "workspace must exist"), n({
      typeName: "membership",
      row: i
    });
    const {
      folders: a,
      boards: c,
      workspaceMemberships: l,
      ...u
    } = s;
    n({
      typeName: "workspace",
      row: u
    });
    for (const d of a) n({
      typeName: "folder",
      row: d
    });
    for (const d of c) n({
      typeName: "board",
      row: d
    });
    for (const {
        profile: d,
        ...f
      }
      of l) Xa(d, "profile must exist"), n({
      typeName: "membership",
      row: f
    }), n({
      typeName: "profile",
      row: d
    })
  }
  return e
}
var ove = Object.defineProperty,
  sve = Object.getOwnPropertyDescriptor,
  vN = (t, e, n, r) => {
    for (var o = r > 1 ? void 0 : r ? sve(e, n) : e, s = t.length - 1, i; s >= 0; s--)(i = t[s]) && (o = (r ? i(e, n, o) : i(o)) || o);
    return r && o && ove(e, n, o), o
  };
const GE = class bN extends l1 {
  constructor(n, r, o, s) {
    super({
      initialData: rve(n),
      schema: tve,
      props: void 0
    });
    P(this, "supabase");
    P(this, "workspaceFolders", this.createSelectedComputedCache("workspaceFolders", n => En(n.id), n => {
      const r = this.query.records("folder", () => ({
        workspace_id: {
          eq: n
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !1
        }
      }));
      return Q("workspaceFolders", () => r.value.sort(X$))
    }));
    P(this, "folderBoards", this.createSelectedComputedCache("folderBoards", n => En(n.id), n => {
      const r = this.query.records("board", () => ({
        folder_id: {
          eq: n
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !1
        }
      }));
      return Q("folderBoards", () => r.value.sort(ya))
    }));
    P(this, "workspaceBoards", this.createSelectedComputedCache("workspaceBoards", n => En(n.id), n => {
      const r = this.query.records("board", () => ({
        workspace_id: {
          eq: n
        },
        private_to_profile_id: {
          eq: null
        },
        folder_id: {
          eq: null
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !1
        }
      }));
      return Q("workspaceBoards", () => r.value.sort(ya))
    }));
    P(this, "myPrivateBoards", this.createSelectedComputedCache("myPrivateBoards", n => En(n.id), n => {
      const r = this.query.records("board", () => ({
        workspace_id: {
          eq: n
        },
        private_to_profile_id: {
          eq: this.profileId
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !1
        }
      }));
      return Q("myPrivateBoards", () => r.value.sort(ya))
    }));
    P(this, "dashboardBoards", this.createSelectedComputedCache("dashboardBoards", n => En(n.id), n => {
      const r = this.query.records("board", () => ({
        workspace_id: {
          eq: n
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !1
        }
      }));
      return Q("dashboardBoards", () => r.value.sort(ya))
    }));
    P(this, "archivedBoards", this.createSelectedComputedCache("archivedBoards", n => En(n.id), n => {
      const r = this.query.records("board", () => ({
        workspace_id: {
          eq: n
        },
        is_deleted: {
          eq: !1
        },
        is_archived: {
          eq: !0
        }
      }));
      return Q("archivedBoards", () => r.value.sort(ya))
    }));
    P(this, "profileMemberships", this.createSelectedComputedCache("profileMemberships", n => En(n.id), n => {
      const r = this.query.records("membership", () => ({
        profile_id: {
          eq: n
        }
      }));
      return Q("profileMemberships", () => r.value.sort(ya))
    }));
    P(this, "workspaceMemberships", this.createSelectedComputedCache("workspaceMemberships", n => En(n.id), n => {
      const r = this.query.records("membership", () => ({
        workspace_id: {
          eq: n
        }
      }));
      return Q("workspaceMemberships", () => r.value.sort(ya))
    }));
    P(this, "presenceInfoSnapshot", tr("presenceInfoSnapshot", {
      version: Hg,
      boardPresenceInfo: {}
    }));
    this.profileId = r, this.scheduleReplaceStore = o, s && this.updatePresenceInfo(s), this.supabase = Yye()
  }
  async refreshData() {
    const n = await qye(this.supabase, this.profileId);
    this.scheduleReplaceStore(new bN(n, this.profileId, this.scheduleReplaceStore, this.presenceInfoSnapshot.value))
  }
  applyScheduledUpdate(n) {
    this.mergeRemoteChanges(() => {
      this.clear(), this.put(Object.values(n.snapshot))
    })
  }
  get profile() {
    return Nl(this.get(ur(Hl, this.profileId)), "profile must exist")
  }
  getWorkspace(n) {
    return this.get(ur(xo, n))
  }
  getBoard(n) {
    return this.get(ur(Wv, n))
  }
  getFolder(n) {
    return this.get(ur(lh, n))
  }
  getProfile(n) {
    return this.get(ur(Hl, n))
  }
  get workspacesQuery() {
    const n = this.query.records("workspace");
    return Q("workspacesQuery", () => n.value.sort(X$))
  }
  getAllWorkspaces() {
    return this.workspacesQuery.value
  }
  getWorkspaceFolders(n) {
    var r;
    return ((r = this.workspaceFolders.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getFolderBoards(n) {
    var r;
    return ((r = this.folderBoards.get(ur(lh, n))) == null ? void 0 : r.value) ?? []
  }
  getWorkspaceBoards(n) {
    var r;
    return ((r = this.workspaceBoards.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getMyPrivateBoards(n) {
    var r;
    return ((r = this.myPrivateBoards.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getDashboardBoards(n) {
    var r;
    return ((r = this.dashboardBoards.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getArchivedBoards(n) {
    var r;
    return ((r = this.archivedBoards.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getProfileMemberships(n) {
    var r;
    return ((r = this.profileMemberships.get(ur(Hl, n))) == null ? void 0 : r.value) ?? []
  }
  getWorkspaceMemberships(n) {
    var r;
    return ((r = this.workspaceMemberships.get(ur(xo, n))) == null ? void 0 : r.value) ?? []
  }
  getBoardLocation(n) {
    return n.folder_id ? Nl(this.getFolder(n.folder_id), "folder must exist") : n.private_to_profile_id ? (Xa(n.private_to_profile_id === this.profileId, "board must be private to profile"), this.profile) : Nl(this.getWorkspace(n.workspace_id), "workspace must exist")
  }
  updatePresenceInfo(n) {
    n.version === Hg && this.presenceInfoSnapshot.set(n)
  }
  clearPresenceInfo() {
    this.presenceInfoSnapshot.set({
      version: Hg,
      boardPresenceInfo: {}
    })
  }
  getBoardPresenceInfo(n, {
    includeCurrentUser: r = !1
  } = {}) {
    const o = Object.keys(this.presenceInfoSnapshot.value.boardPresenceInfo[En(n)] ?? {}).filter(s => r || s !== this.profileId);
    return Fe(o.map(s => this.getProfile(s)))
  }
};
vN([Q], GE.prototype, "profile", 1);
vN([Q], GE.prototype, "workspacesQuery", 1);
let ive = GE;
const qbe = "https://bookmark-extractor.tldraw.com/api/bookmark",
  Xbe = "https://assets.tldraw.xyz",
  ave = "https://tldraw-multiplayer.tldraw.workers.dev".replace(/^http/, "ws"),
  wN = Ui();
async function cve(t, e) {
  return await (await fetch(`/api/rpc/${t}`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": wN
    },
    body: JSON.stringify(e)
  })).json()
}
class lve {
  constructor(e) {
    P(this, "stateByWorkspaceId", new Map);
    this.storeRef = e
  }
  get store() {
    return this.storeRef.current
  }
  getRefCount(e) {
    var n;
    return ((n = this.stateByWorkspaceId.get(e)) == null ? void 0 : n.referenceCount) ?? 0
  }
  createWebsocket(e) {
    return new WebSocket(e)
  }
  async getAccessToken() {
    var e;
    return (e = (await this.store.supabase.auth.getSession()).data.session) == null ? void 0 : e.access_token
  }
  addWorkspaceSubscription(e) {
    const n = this.stateByWorkspaceId.get(e);
    if (n) {
      n.referenceCount++;
      return
    }
    const r = a => {
      try {
        const c = JSON.parse(a.data ?? "{type: null}");
        c.type === "workspace_did_update" && c.originClientId !== wN ? this.store.refreshData() : c.type === "presence_change" && this.store.updatePresenceInfo(c.data)
      } catch (c) {
        console.error(c)
      }
    };
    let o = () => {};
    const s = {
      referenceCount: 1,
      close: () => o()
    };
    this.stateByWorkspaceId.set(e, s), (async () => {
      const a = await this.getAccessToken();
      if (!a) {
        console.error("no access token for connecting to workspace socket");
        return
      }
      if (this.stateByWorkspaceId.get(e) !== s) return;
      const c = this.createWebsocket(`${ave}/w/${En(e)}?${new URLSearchParams({accessToken:a}).toString()}`);
      c.addEventListener("message", r);
      let l = !1;
      const u = () => {
          l ? this.store.refreshData() : l = !0
        },
        d = () => {
          this.store.clearPresenceInfo()
        };
      c.addEventListener("open", u), c.addEventListener("close", d), o = () => {
        c.removeEventListener("message", r), c.removeEventListener("open", u), c.removeEventListener("close", d), c.close()
      }
    })()
  }
  removeWorkspaceSubscription(e) {
    const n = this.stateByWorkspaceId.get(e);
    n && (n.referenceCount--, n.referenceCount === 0 && (n.close(), this.stateByWorkspaceId.delete(e)))
  }
}
const Kv = g.createContext(null);

function Zbe({
  queryData: t,
  profileId: e,
  children: n
}) {
  const [r, o] = g.useState(() => new ive(t, e, a => {
    g.startTransition(() => {
      o(a)
    })
  })), s = g.useRef(r);
  g.useLayoutEffect(() => {
    s.current = r
  }, [r]);
  const [i] = g.useState(() => new lve(s));
  return y.jsx(Kv.Provider, {
    value: {
      store: r,
      realtime: i
    },
    children: n
  })
}

function Jbe(t) {
  const e = Nl(g.useContext(Kv), "useProStore must be used within a ProStoreProvider").realtime;
  g.useEffect(() => {
    const n = ur(xo, t);
    try {
      return e.addWorkspaceSubscription(n), () => {
        setTimeout(() => e.removeWorkspaceSubscription(n), 1e3)
      }
    } catch (r) {
      console.error(r)
    }
  }, [e, t])
}

function uve() {
  return Nl(g.useContext(Kv), "useProStore must be used within a ProStoreProvider").store
}

function Qbe() {
  var t;
  return (t = g.useContext(Kv)) == null ? void 0 : t.store
}
const Gv = g.createContext(null),
  dve = pt(function() {
    const e = uve(),
      n = gU(),
      r = n == null ? void 0 : n.workspaceId,
      o = e.profile.last_active_workspace_id,
      s = r ? e.getWorkspace(r) ?? null : null,
      i = s == null ? void 0 : s.id;
    return g.useEffect(() => {
      i && En(i) !== o && (async () => await cve("updateCurrentUserProfile", {
        last_active_workspace_id: En(i)
      }))()
    }, [i, o]), y.jsx(Gv.Provider, {
      value: s,
      children: y.jsx(Tg, {})
    })
  }),
  fve = Object.freeze(Object.defineProperty({
    __proto__: null,
    ActiveWorkspaceContext: Gv,
    Component: dve
  }, Symbol.toStringTag, {
    value: "Module"
  }));

function ewe() {
  const t = g.useContext(Gv);
  if (!t) throw new Error("Workspace not found");
  return t
}

function hve() {
  return g.useContext(Gv)
}
const SN = {
  workspace: t => `/w/${En(t)}`,
  private: t => `/w/${En(t)}/private`,
  folder: (t, e) => `${SN.workspace(t)}/f/${En(e)}`,
  board: t => `/b/${En(t)}`,
  waitlist: () => "/waitlist",
  workspaceSettingsOverview: t => "/w/" + En(t) + "/settings/overview"
};

function pve(t) {
  const e = hve();
  return t || (e ? SN.workspace(e.id) : "/dashboard")
}

function gve({
  icon: t,
  messages: e,
  redirectTo: n
}) {
  const {
    msg: r
  } = Fh(), o = pve(n);
  return y.jsx("div", {
    className: "flex h-full flex-1 flex-col items-center justify-center",
    children: y.jsxs("div", {
      className: "flex flex-col items-center justify-center gap-[30px]",
      children: [t && y.jsx("img", {
        width: 36,
        height: 36,
        alt: r("not-found.icon-alt"),
        src: "/404-Sad-tldraw.svg",
        loading: "lazy"
      }), y.jsxs("div", {
        className: "flex flex-col items-center justify-center text-center",
        children: [y.jsx("h1", {
          className: "text-header mb-sm",
          children: e.header
        }), y.jsx("p", {
          className: "text-primary-bold text-grey",
          children: e.para1
        }), e.para2 && y.jsx("p", {
          className: "text-primary-bold text-grey",
          children: e.para2
        })]
      }), y.jsx(Tfe, {
        to: o,
        variant: "primary",
        children: r("not-found.button")
      })]
    })
  })
}

function mve() {
  return y.jsxs(Pg, {
    children: [y.jsx("link", {
      rel: "icon",
      type: "image/png",
      sizes: "32x32",
      href: "/favicon-32x32.png"
    }), y.jsx("link", {
      rel: "icon",
      type: "image/png",
      sizes: "16x16",
      href: "/favicon-16x16.png"
    }), y.jsx("link", {
      rel: "shortcut icon",
      href: "/favicon.svg"
    })]
  })
}

function yve({
  message: t,
  isOpen: e,
  icon: n,
  duration: r = 3e3,
  onClose: o,
  action: s,
  _key: i
}) {
  const a = g.useRef(null),
    c = !!s,
    l = !!n,
    {
      _removeToastByKey: u
    } = wve(),
    [d, f] = g.useState(e),
    h = g.useCallback(m => {
      m || (f(!1), setTimeout(() => {
        o == null || o(), u(i)
      }, 150))
    }, [o, u, i]);
  return y.jsxs(bj, {
    className: ae("shadow-toast", "py-sm flex h-fit w-fit rounded-lg pl-[15px]", "pointer-events-auto", "gap-sm items-center", "bg-black text-white", l ? "pl-[15px]" : "pl-md", c ? "pr-sm" : "pr-md"),
    ref: a,
    open: d,
    duration: r,
    onOpenChange: h,
    children: [n && y.jsx(au, {
      icon: n,
      containerSize: "medium"
    }), y.jsx(wj, {
      className: "text-primary h-button-md flex items-center self-center",
      children: t
    }), s && y.jsx(R_, {
      onClick: s.onClick,
      variant: s.variant,
      children: s.label
    })]
  })
}
const _N = g.createContext({}),
  vve = 5;

function bve({
  children: t
}) {
  const {
    msg: e
  } = Fh(), [n, r] = g.useState([]), o = g.useCallback(l => {
    const u = l.id ?? Ui();
    return r(d => [...d.filter(f => f.id !== u).slice(-vve + 1), {
      ...l,
      id: u,
      _key: Ui()
    }]), u
  }, []), s = g.useCallback(l => (r(u => u.filter(d => d.id !== l)), l), []), i = g.useCallback(l => {
    setTimeout(() => {
      r(u => u.filter(d => d._key !== l))
    }, 150)
  }, []), a = g.useCallback(() => {
    r(() => [])
  }, []), c = g.useCallback(() => {
    o({
      id: "unimplemented",
      message: e("toast.unimplemented"),
      icon: "warning"
    })
  }, [o, e]);
  return y.jsx(_N.Provider, {
    value: {
      addToast: o,
      removeToast: s,
      clearToasts: a,
      unimplemented: c,
      _removeToastByKey: i
    },
    children: y.jsxs(Aoe, {
      swipeDirection: "down",
      children: [t, n.map(l => g.createElement(yve, {
        ...l,
        key: l._key
      })), y.jsx(Moe, {
        className: "bottom-md left-md right-md gap-xs z-toast pointer-events-none fixed flex flex-col-reverse items-center justify-center"
      })]
    })
  })
}

function wve() {
  const t = g.useContext(_N);
  if (!t) throw new Error("useToast must be used within ToastProvider");
  return t
}
const xN = g.createContext(null);

function Sve({
  children: t
}) {
  const e = uc().pathname,
    [n, r] = g.useState(null),
    o = g.useRef(e);
  return o.current !== e && n !== o.current && r(o.current), g.useEffect(() => {
    o.current = e
  }, [e]), y.jsx(xN.Provider, {
    value: {
      pathname: n
    },
    children: t
  })
}

function twe() {
  const t = g.useContext(xN);
  if (!t) throw new Error("usePreviousPathname must be used within a PreviousRouteProvider");
  return t.pathname
}
const _ve = OU(xS(y.jsxs(Ae, {
  element: y.jsx(Sve, {
    children: y.jsx(Tg, {})
  }),
  ErrorBoundary: () => {
    const t = r1(),
      {
        msg: e
      } = Fh();
    return g.useEffect(() => {
      nx(t)
    }, [t]), y.jsx(gve, {
      messages: {
        header: e("generic.error"),
        para1: e("generic.error-description")
      }
    })
  },
  children: [y.jsxs(Ae, {
    errorElement: y.jsx(jde, {}),
    children: [y.jsx(Ae, {
      path: "/",
      lazy: () => Ie(() => import("./root-191a269d.js"), ["assets/root-191a269d.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/Tldraw-1c8dee11.js", "assets/SneakyOnDropOverride-407892da.js", "assets/useFileSystem-b6952672.js", "assets/DebugMenuItems-53fa1755.js", "assets/auth-7bbcf3cb.js", "assets/defineLoader-f9d74e57.js"])
    }), y.jsx(Ae, {
      path: "/r",
      loader: () => {
        const t = "v2" + Ui();
        return VB(`/r/${t}`)
      }
    }), y.jsx(Ae, {
      path: "/r/:roomId",
      lazy: () => Ie(() => import("./public-multiplayer-c3472f67.js"), ["assets/public-multiplayer-c3472f67.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/MultiplayerEditor-8a238fd2.js", "assets/Tldraw-1c8dee11.js", "assets/OfflineIndicator-b2dc5c4a.js", "assets/requestAnimationFrame.polyfill-057527f1.js", "assets/useFileSystem-b6952672.js", "assets/SneakyOnDropOverride-407892da.js"])
    }), y.jsx(Ae, {
      path: "/r/:boardId/history",
      lazy: () => Ie(() => import("./history-2b7923a2.js"), ["assets/history-2b7923a2.js", "assets/defineLoader-f9d74e57.js"])
    }), y.jsx(Ae, {
      path: "/r/:boardId/history/:timestamp",
      lazy: () => Ie(() => import("./history-snapshot-693d17b6.js"), ["assets/history-snapshot-693d17b6.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/Tldraw-1c8dee11.js", "assets/useFileSystem-b6952672.js", "assets/defineLoader-f9d74e57.js"])
    }), y.jsx(Ae, {
      path: "/s/:roomId",
      lazy: () => Ie(() => import("./public-snapshot-19e9a6e0.js"), ["assets/public-snapshot-19e9a6e0.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/Tldraw-1c8dee11.js", "assets/requestAnimationFrame.polyfill-057527f1.js", "assets/SneakyOnDropOverride-407892da.js", "assets/useFileSystem-b6952672.js", "assets/DebugMenuItems-53fa1755.js", "assets/MultiplayerEditor-8a238fd2.js", "assets/OfflineIndicator-b2dc5c4a.js", "assets/defineLoader-f9d74e57.js"])
    }), y.jsx(Ae, {
      path: "/v/:roomId",
      lazy: () => Ie(() => import("./public-readonly-00a549c3.js"), ["assets/public-readonly-00a549c3.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/MultiplayerEditor-8a238fd2.js", "assets/Tldraw-1c8dee11.js", "assets/OfflineIndicator-b2dc5c4a.js", "assets/requestAnimationFrame.polyfill-057527f1.js", "assets/useFileSystem-b6952672.js", "assets/SneakyOnDropOverride-407892da.js"])
    })]
  }), y.jsx(Ae, {
    path: "/stats",
    lazy: () => Ie(() => import("./stats-f7590c2c.js"), [])
  }), y.jsx(Ae, {
    path: "/stats/rooms-create-day",
    lazy: () => Ie(() => import("./stats-rooms-created-day-08b3e1dc.js"), [])
  }), y.jsx(Ae, {
    path: "/stats/rooms-create-month",
    lazy: () => Ie(() => import("./stats-rooms-created-month-ba417230.js"), [])
  }), y.jsx(Ae, {
    path: "/playground",
    lazy: () => Ie(() => import("./playground-c96e51be.js"), ["assets/playground-c96e51be.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/misc-b13a21ed.js", "assets/recordHelpers-471baafb.js", "assets/AvatarActionButton-5ff57f28.js", "assets/Dropdown-c7e15b44.js", "assets/Toggle-fbc19507.js", "assets/ToggleGroup-4767f835.js"])
  }), y.jsx(Ae, {
    path: "/internal/screenshot",
    lazy: () => Ie(() => import("./screenshot-026cd869.js"), ["assets/screenshot-026cd869.js", "assets/requestAnimationFrame.polyfill-057527f1.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css"])
  }), y.jsx(Ae, {
    path: "/sign-out",
    lazy: () => Ie(() => import("./sign-out-8c5f44e5.js"), ["assets/sign-out-8c5f44e5.js", "assets/auth-7bbcf3cb.js", "assets/defineLoader-f9d74e57.js"])
  }), y.jsx(Ae, {
    path: "/team",
    lazy: () => Ie(() => import("./team-1ec72bcc.js"), ["assets/team-1ec72bcc.js", "assets/useMutation-c799a007.js", "assets/misc-b13a21ed.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/recordHelpers-471baafb.js", "assets/CenteredPage-510e52b2.js", "assets/ModalTopBar-96eac7fa.js", "assets/defineLoader-f9d74e57.js"])
  }), y.jsxs(Ae, {
    lazy: async () => {
      const t = (await Ie(() => import("./useSession-812b55f9.js"), [])).ProvideSession;
      return {
        Component: () => y.jsx(t, {
          children: y.jsx(Tg, {})
        })
      }
    },
    children: [y.jsx(Ae, {
      path: "pro-waitlist",
      lazy: () => Ie(() => import("./pro-waitlist-a97cb304.js"), ["assets/pro-waitlist-a97cb304.js", "assets/useMutation-c799a007.js"])
    }), y.jsx(Ae, {
      path: "pro-waitlist/success",
      lazy: () => Ie(() => import("./pro-waitlist-success-2ad8a93a.js"), ["assets/pro-waitlist-success-2ad8a93a.js", "assets/WaitlistJoined-61f20d41.js", "assets/CenteredPage-510e52b2.js", "assets/ModalTopBar-96eac7fa.js"])
    }), y.jsx(Ae, {
      path: "sign-in",
      lazy: () => Ie(() => import("./sign-in-2d4aaf5f.js"), ["assets/sign-in-2d4aaf5f.js", "assets/Separator-ff5bb57e.js", "assets/useMutation-c799a007.js", "assets/Title-eba2be6f.js", "assets/useSession-812b55f9.js"])
    }), y.jsx(Ae, {
      path: "sign-in/success",
      lazy: () => Ie(() => import("./sign-in-success-f4641938.js"), [])
    })]
  }), y.jsxs(Ae, {
    lazy: async () => {
      const t = (await Ie(() => import("./useSession-812b55f9.js"), [])).ProvideSession,
        e = (await Ie(() => import("./private-68b1a6a7.js"), ["assets/private-68b1a6a7.js", "assets/auth-7bbcf3cb.js", "assets/defineLoader-f9d74e57.js"])).PrivateLayout,
        n = (await Ie(() => import("./private-68b1a6a7.js"), ["assets/private-68b1a6a7.js", "assets/auth-7bbcf3cb.js", "assets/defineLoader-f9d74e57.js"])).loader;
      return {
        Component: () => y.jsx(e, {
          children: y.jsx(t, {
            children: y.jsx(Tg, {})
          })
        }),
        loader: n
      }
    },
    children: [y.jsx(Ae, {
      path: "waitlist",
      lazy: async () => Ie(() => import("./waitlist-498ca3a4.js"), ["assets/waitlist-498ca3a4.js", "assets/useMutation-c799a007.js", "assets/CenteredPage-510e52b2.js", "assets/ModalTopBar-96eac7fa.js", "assets/WaitlistJoined-61f20d41.js", "assets/defineLoader-f9d74e57.js"])
    }), y.jsxs(Ae, {
      lazy: async () => Ie(() => import("./alpha-layout-2f860bae.js"), ["assets/alpha-layout-2f860bae.js", "assets/defineLoader-f9d74e57.js"]),
      children: [y.jsx(Ae, {
        path: "create-account",
        lazy: () => Ie(() => import("./create-account-986eaf82.js"), ["assets/create-account-986eaf82.js", "assets/EditAvatarButton-640c91a9.js", "assets/useMutation-c799a007.js", "assets/ProfileAvatar-733f3c84.js", "assets/misc-b13a21ed.js", "assets/recordHelpers-471baafb.js", "assets/Avatar-c3b16c48.js", "assets/CenteredPage-510e52b2.js", "assets/ModalTopBar-96eac7fa.js"])
      }), y.jsx(Ae, {
        path: "dashboard",
        lazy: () => Ie(() => import("./dashboard-4349dbec.js"), [])
      }), y.jsx(Ae, {
        path: "create-workspace",
        lazy: () => Ie(() => import("./create-workspace-aaff4808.js"), ["assets/create-workspace-aaff4808.js", "assets/Avatar-c3b16c48.js", "assets/EditAvatarButton-640c91a9.js", "assets/useMutation-c799a007.js", "assets/CenteredPage-510e52b2.js", "assets/ModalTopBar-96eac7fa.js", "assets/defineLoader-f9d74e57.js", "assets/misc-b13a21ed.js"])
      }), y.jsx(Ae, {
        path: "/b/:boardId",
        lazy: () => Ie(() => import("./board-700cdfa4.js"), ["assets/board-700cdfa4.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/Tldraw-1c8dee11.js", "assets/useMutation-c799a007.js", "assets/MultiplayerEditor-8a238fd2.js", "assets/OfflineIndicator-b2dc5c4a.js", "assets/requestAnimationFrame.polyfill-057527f1.js", "assets/useFileSystem-b6952672.js", "assets/SneakyOnDropOverride-407892da.js", "assets/recordHelpers-471baafb.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/misc-b13a21ed.js", "assets/defineLoader-f9d74e57.js"])
      }), y.jsx(Ae, {
        path: "/b/:boardId/history",
        lazy: () => Ie(() => import("./history-2b7923a2.js"), ["assets/history-2b7923a2.js", "assets/defineLoader-f9d74e57.js"])
      }), y.jsx(Ae, {
        path: "/b/:boardId/history/:timestamp",
        lazy: () => Ie(() => import("./history-snapshot-693d17b6.js"), ["assets/history-snapshot-693d17b6.js", "assets/assetUrls-dc196c17.js", "assets/assetUrls-ae77267a.css", "assets/Tldraw-1c8dee11.js", "assets/useFileSystem-b6952672.js", "assets/defineLoader-f9d74e57.js"])
      }), y.jsx(Ae, {
        lazy: () => Ie(() => Promise.resolve().then(() => fve), void 0),
        children: y.jsxs(Ae, {
          lazy: () => Ie(() => import("./workspace-2fbf2cb5.js"), []),
          children: [y.jsxs(Ae, {
            lazy: () => Ie(() => import("./workspace-view-860f06b5.js"), ["assets/workspace-view-860f06b5.js", "assets/ProfileAvatar-733f3c84.js", "assets/misc-b13a21ed.js", "assets/recordHelpers-471baafb.js", "assets/Avatar-c3b16c48.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/AvatarActionButton-5ff57f28.js", "assets/Dropdown-c7e15b44.js", "assets/useMutation-c799a007.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/Separator-ff5bb57e.js", "assets/WorkspaceFolderDropdown-4e6b8802.js", "assets/ToggleGroup-4767f835.js"]),
            children: [y.jsx(Ae, {
              path: "w/:workspaceId/",
              lazy: () => Ie(() => import("./dashboard-view-e27fd7f7.js"), ["assets/dashboard-view-e27fd7f7.js", "assets/WorkspaceFolderDropdown-4e6b8802.js", "assets/useMutation-c799a007.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/misc-b13a21ed.js", "assets/Dropdown-c7e15b44.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/recordHelpers-471baafb.js", "assets/ToggleGroup-4767f835.js"])
            }), y.jsx(Ae, {
              path: "w/:workspaceId/private",
              lazy: () => Ie(() => import("./private-9e4e5d8c.js"), ["assets/private-9e4e5d8c.js", "assets/WorkspaceFolderDropdown-4e6b8802.js", "assets/useMutation-c799a007.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/misc-b13a21ed.js", "assets/Dropdown-c7e15b44.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/recordHelpers-471baafb.js", "assets/ToggleGroup-4767f835.js", "assets/Title-eba2be6f.js"])
            }), y.jsx(Ae, {
              path: "w/:workspaceId/archive",
              lazy: () => Ie(() => import("./archive-591eb4b6.js"), ["assets/archive-591eb4b6.js", "assets/WorkspaceFolderDropdown-4e6b8802.js", "assets/useMutation-c799a007.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/misc-b13a21ed.js", "assets/Dropdown-c7e15b44.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/recordHelpers-471baafb.js", "assets/ToggleGroup-4767f835.js", "assets/Title-eba2be6f.js"])
            }), y.jsx(Ae, {
              path: "w/:workspaceId/f/:folderId",
              lazy: () => Ie(() => import("./folder-b329b085.js"), ["assets/folder-b329b085.js", "assets/WorkspaceFolderDropdown-4e6b8802.js", "assets/useMutation-c799a007.js", "assets/useRenameBoardDialog-184eb3c4.js", "assets/misc-b13a21ed.js", "assets/Dropdown-c7e15b44.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/Avatar-c3b16c48.js", "assets/ProfileAvatar-733f3c84.js", "assets/recordHelpers-471baafb.js", "assets/ToggleGroup-4767f835.js", "assets/Title-eba2be6f.js"])
            })]
          }), y.jsxs(Ae, {
            lazy: () => Ie(() => import("./settings-15ce3907.js"), ["assets/settings-15ce3907.js", "assets/SettingsLayout-2e2812fe.js", "assets/ModalTopBar-96eac7fa.js", "assets/Title-eba2be6f.js"]),
            children: [y.jsx(Ae, {
              path: "w/:workspaceId/settings",
              element: y.jsx(lP, {
                replace: !0,
                to: "./overview"
              })
            }), y.jsx(Ae, {
              path: "w/:workspaceId/settings/overview",
              lazy: () => Ie(() => import("./settings-overview-8dc3224b.js"), ["assets/settings-overview-8dc3224b.js", "assets/EditAvatarButton-640c91a9.js", "assets/useMutation-c799a007.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/misc-b13a21ed.js", "assets/Avatar-c3b16c48.js", "assets/WorkspaceSettingsSidebar-bf52849d.js", "assets/SettingsWrapper-0766cec4.js", "assets/SettingsInputSection-1cdc5567.js", "assets/SettingsSectionTitle-47df1ed7.js", "assets/SettingsSeparator-adcc4883.js"])
            }), y.jsx(Ae, {
              path: "w/:workspaceId/settings/members",
              lazy: () => Ie(() => import("./settings-members-71b586e7.js"), ["assets/settings-members-71b586e7.js", "assets/ProfileAvatar-733f3c84.js", "assets/misc-b13a21ed.js", "assets/recordHelpers-471baafb.js", "assets/Avatar-c3b16c48.js", "assets/WorkspaceSettingsSidebar-bf52849d.js", "assets/SettingsWrapper-0766cec4.js", "assets/useMutation-c799a007.js", "assets/Dropdown-c7e15b44.js", "assets/Toggle-fbc19507.js", "assets/SettingsSeparator-adcc4883.js"])
            }), y.jsx(Ae, {
              path: "w/:workspaceId/settings/subscription",
              lazy: () => Ie(() => import("./settings-subscriptions-adaf79f5.js"), ["assets/settings-subscriptions-adaf79f5.js", "assets/WorkspaceSettingsSidebar-bf52849d.js", "assets/SettingsWrapper-0766cec4.js", "assets/SettingsSectionTitle-47df1ed7.js", "assets/SettingsSeparator-adcc4883.js"])
            })]
          })]
        })
      }), y.jsxs(Ae, {
        lazy: () => Ie(() => import("./accounts-7c899e60.js"), ["assets/accounts-7c899e60.js", "assets/SettingsLayout-2e2812fe.js", "assets/ModalTopBar-96eac7fa.js", "assets/Title-eba2be6f.js"]),
        children: [y.jsx(Ae, {
          path: "account",
          element: y.jsx(lP, {
            replace: !0,
            to: "./overview"
          })
        }), y.jsx(Ae, {
          path: "account/overview",
          lazy: () => Ie(() => import("./account-overivew-48a90a5e.js"), ["assets/account-overivew-48a90a5e.js", "assets/AccountSettingsSidebar-228743af.js", "assets/SettingsWrapper-0766cec4.js", "assets/EditAvatarButton-640c91a9.js", "assets/useMutation-c799a007.js", "assets/ProfileAvatar-733f3c84.js", "assets/misc-b13a21ed.js", "assets/recordHelpers-471baafb.js", "assets/Avatar-c3b16c48.js", "assets/SettingsInputSection-1cdc5567.js", "assets/SettingsSectionTitle-47df1ed7.js", "assets/SettingsSeparator-adcc4883.js"])
        }), y.jsx(Ae, {
          path: "account/workspaces",
          lazy: () => Ie(() => import("./account-workspaces-f119541b.js"), ["assets/account-workspaces-f119541b.js", "assets/AccountSettingsSidebar-228743af.js", "assets/SettingsWrapper-0766cec4.js", "assets/WorkspaceAvatar-494c6a53.js", "assets/misc-b13a21ed.js", "assets/Avatar-c3b16c48.js"])
        })]
      })]
    })]
  }), y.jsx(Ae, {
    path: "*",
    lazy: () => Ie(() => import("./not-found-d02e3342.js"), ["assets/not-found-d02e3342.js", "assets/defineLoader-f9d74e57.js"])
  })]
})));
GR(document.getElementById("root")).render(y.jsxs(fl, {
  children: [y.jsx(mve, {}), y.jsx(Cfe, {
    children: y.jsx(bve, {
      children: y.jsx(Vhe, {
        children: y.jsx(LU, {
          router: _ve
        })
      })
    })
  }), y.jsx(U7, {
    debug: !1
  })]
}));
export {
  uve as $, Ybe as A, me as B, Rve as C, Afe as D, eo as E, cd as F, ls as G, cve as H, fr as I, Qx as J, SN as K, Tfe as L, qc as M, lP as N, En as O, zU as P, bu as Q, qe as R, gve as S, Pve as T, Pfe as U, uc as V, Eve as W, Zbe as X, Tg as Y, qye as Z, Ie as _, te as a, Qie as a$, tr as a0, pt as a1, Js as a2, Ou as a3, Qs as a4, Ye as a5, ns as a6, H as a7, ave as a8, yq as a9, at as aA, h3 as aB, $u as aC, wr as aD, hT as aE, cE as aF, yG as aG, vc as aH, U0e as aI, Mve as aJ, qbe as aK, Pb as aL, xle as aM, Ah as aN, Mh as aO, jh as aP, su as aQ, kv as aR, Ibe as aS, Xa as aT, Ia as aU, G as aV, ta as aW, cI as aX, KR as aY, Ev as aZ, xv as a_, Qbe as aa, Q as ab, nY as ac, CA as ad, x3 as ae, QG as af, Nl as ag, Jbe as ah, twe as ai, mq as aj, bh as ak, Oz as al, Ls as am, Gt as an, Ui as ao, Zr as ap, Uve as aq, Dve as ar, Gy as as, Wq as at, ko as au, Fm as av, It as aw, $f as ax, PA as ay, Xbe as az, mde as b, G0e as b$, Vbe as b0, Je as b1, zbe as b2, Hbe as b3, PH as b4, RH as b5, AH as b6, l0e as b7, u0e as b8, TH as b9, Hj as bA, Wj as bB, hve as bC, kve as bD, xz as bE, Sa as bF, T as bG, A0e as bH, Hn as bI, hr as bJ, Xd as bK, is as bL, k1 as bM, C3 as bN, v1 as bO, Rt as bP, Be as bQ, T3 as bR, mT as bS, ev as bT, Qne as bU, rre as bV, nre as bW, Vi as bX, ZA as bY, DV as bZ, wre as b_, $H as ba, Yve as bb, qve as bc, Qve as bd, e0e as be, a0e as bf, c0e as bg, s0e as bh, i0e as bi, IH as bj, OH as bk, Kve as bl, Gve as bm, t0e as bn, n0e as bo, Zve as bp, Jve as bq, r0e as br, o0e as bs, NH as bt, LH as bu, qt as bv, ewe as bw, zj as bx, Tbe as by, Vj as bz, gc as c, aj as c$, Fe as c0, q0e as c1, c_ as c2, K0e as c3, W0e as c4, Q1 as c5, Y0e as c6, bz as c7, Ee as c8, I0e as c9, k3 as cA, U as cB, Uo as cC, X0e as cD, W3 as cE, wh as cF, Are as cG, zo as cH, p0e as cI, $3 as cJ, a1 as cK, Lre as cL, R1 as cM, Cre as cN, V3 as cO, Xve as cP, jre as cQ, C2 as cR, Z0e as cS, S0e as cT, ebe as cU, J0e as cV, XM as cW, Wm as cX, Vm as cY, pv as cZ, cj as c_, y0e as ca, LS as cb, V0e as cc, ec as cd, _0e as ce, ts as cf, yi as cg, Na as ch, OV as ci, Qa as cj, Wve as ck, FS as cl, Nt as cm, AP as cn, Yd as co, P2 as cp, T1 as cq, C1 as cr, _a as cs, Ni as ct, Hr as cu, N0e as cv, F0e as cw, ds as cx, D0e as cy, L0e as cz, bs as d, Zc as d$, cbe as d0, Sbe as d1, hbe as d2, nbe as d3, gbe as d4, ube as d5, ibe as d6, bbe as d7, obe as d8, ybe as d9, wY as dA, SY as dB, h0e as dC, b0e as dD, lV as dE, oY as dF, $r as dG, Ys as dH, H0e as dI, kbe as dJ, eX as dK, B0e as dL, Fbe as dM, Ube as dN, y3 as dO, er as dP, Un as dQ, Bn as dR, Cm as dS, lH as dT, E5 as dU, Hf as dV, CE as dW, k5 as dX, Abe as dY, jbe as dZ, Mbe as d_, dbe as da, wbe as db, abe as dc, fbe as dd, vbe as de, sbe as df, mbe as dg, rbe as dh, pbe as di, tbe as dj, lbe as dk, Wre as dl, Ag as dm, Q0e as dn, uY as dp, qM as dq, Wn as dr, Tb as ds, $b as dt, Ib as du, ru as dv, V0 as dw, M0e as dx, yo as dy, dV as dz, Yye as e, Ns as e$, Vo as e0, rt as e1, Xs as e2, Ke as e3, ie as e4, ihe as e5, zD as e6, ZD as e7, mE as e8, Nae as e9, Cbe as eA, Hoe as eB, Cv as eC, dE as eD, Bie as eE, Foe as eF, rE as eG, Lie as eH, vD as eI, bD as eJ, xie as eK, Eie as eL, hD as eM, Pie as eN, gie as eO, Oie as eP, Yie as eQ, Wue as eR, Wie as eS, Xie as eT, lo as eU, wt as eV, Jie as eW, gE as eX, Ebe as eY, $de as eZ, Ide as e_, Lae as ea, hn as eb, Ove as ec, Pg as ed, eE as ee, At as ef, Rh as eg, UD as eh, LD as ei, PD as ej, $D as ek, ID as el, kD as em, OD as en, FD as eo, CD as ep, Sr as eq, Mo as er, Wo as es, Xre as et, _be as eu, vh as ev, $be as ew, Dbe as ex, ore as ey, rae as ez, VB as f, x0e as f$, dz as f0, EA as f1, ja as f2, Tve as f3, GA as f4, Rf as f5, z0e as f6, rV as f7, H0 as f8, hV as f9, Rg as fA, nX as fB, VY as fC, Ir as fD, sv as fE, Kq as fF, es as fG, _u as fH, f0e as fI, d0e as fJ, sY as fK, zS as fL, P3 as fM, Gd as fN, Qr as fO, br as fP, DS as fQ, tv as fR, w0e as fS, YA as fT, uV as fU, v0e as fV, VP as fW, m0e as fX, g0e as fY, Af as fZ, C0e as f_, WP as fa, b1 as fb, RV as fc, AV as fd, MV as fe, jV as ff, YP as fg, NV as fh, zV as fi, HV as fj, VV as fk, vq as fl, Mp as fm, I3 as fn, Os as fo, R0e as fp, CV as fq, xV as fr, KP as fs, Rm as ft, Qo as fu, EV as fv, kV as fw, Ic as fx, ve as fy, na as fz, gU as g, Pm as g$, E0e as g0, P0e as g1, k0e as g2, $0e as g3, T0e as g4, Jr as g5, fV as g6, So as g7, Rp as g8, lY as g9, Yy as gA, Lz as gB, Bve as gC, gl as gD, Hve as gE, ht as gF, zve as gG, u1 as gH, Ip as gI, Qy as gJ, p1 as gK, Yz as gL, qz as gM, LA as gN, FA as gO, Kd as gP, Pf as gQ, Ao as gR, xH as gS, _H as gT, m1 as gU, jS as gV, Tf as gW, g1 as gX, BA as gY, F0 as gZ, Tm as g_, HS as ga, dY as gb, HH as gc, Om as gd, _h as ge, Sh as gf, fY as gg, gr as gh, qA as gi, i3 as gj, gV as gk, gY as gl, j3 as gm, q0 as gn, j0e as go, ou as gp, nv as gq, O0e as gr, rX as gs, f3 as gt, oX as gu, Ig as gv, c1 as gw, Fve as gx, _r as gy, l1 as gz, Fh as h, nH as h0, tH as h1, wo as h2, nu as h3, Im as h4, EH as h5, qn as h6, ao as h7, Ja as h8, tu as h9, $z as hA, Lve as hB, Vve as hC, OA as hD, RA as hE, kf as hF, qy as hG, mn as hH, If as ha, us as hb, $m as hc, Of as hd, FH as he, xm as hf, wz as hg, Sz as hh, $ve as hi, i1 as hj, _z as hk, kA as hl, Ive as hm, Ave as hn, jve as ho, Em as hp, M0 as hq, Da as hr, Ky as hs, EP as ht, TA as hu, xP as hv, Cz as hw, Pz as hx, AS as hy, Nve as hz, KS as i, y as j, R_ as k, se as l, Xn as m, Rn as n, $q as o, nt as p, uo as q, g as r, Ade as s, wve as t, Y as u, Mfe as v, jfe as w, Wbe as x, au as y, ae as z
};
//# sourceMappingURL=index-1040c914.js.map

//# debugId=68c3aa7a-a503-5fe3-b256-4537170f3e7b
